var MZ = Object.defineProperty;
var KI = (n) => {
  throw TypeError(n);
};
var DZ = (n, e, t) => e in n ? MZ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var Vn = (n, e, t) => DZ(n, typeof e != "symbol" ? e + "" : e, t), OZ = (n, e, t) => e.has(n) || KI("Cannot " + t);
var Ih = (n, e, t) => (OZ(n, e, "read from private field"), t ? t.call(n) : e.get(n)), XI = (n, e, t) => e.has(n) ? KI("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t);
import * as rp from "vue";
import { defineComponent as ve, computed as K, createElementBlock as W, openBlock as L, createElementVNode as G, normalizeClass as _e, createCommentVNode as ge, toDisplayString as ke, renderSlot as ue, unref as O, shallowRef as Bd, watch as et, triggerRef as ZI, onScopeDispose as xg, ref as Z, onUnmounted as Nn, watchEffect as Cn, onMounted as kt, cloneVNode as kA, h as qt, Fragment as Ke, provide as zn, inject as Xt, nextTick as Wt, toRaw as li, reactive as Sr, getCurrentInstance as ro, Teleport as wg, readonly as fp, toValue as Ir, getCurrentScope as V_, effectScope as fF, onBeforeUnmount as Io, customRef as pF, isRef as al, toRefs as fi, toHandlerKey as IZ, camelize as hF, toRef as j1, Comment as vF, mergeProps as He, createBlock as re, withCtx as ee, normalizeStyle as An, createVNode as se, normalizeProps as Bt, guardReactiveProps as Jt, markRaw as cn, renderList as _t, watchPostEffect as mF, shallowReadonly as cf, mergeDefaults as gF, withKeys as ci, withModifiers as xt, watchSyncEffect as LZ, withMemo as NZ, resolveDynamicComponent as bn, createTextVNode as gn, onBeforeMount as AA, useSlots as Xp, toHandlers as yF, withDirectives as ta, vShow as hs, useAttrs as $d, resolveComponent as ol, createSlots as Zc, mergeModels as MA, useModel as DA, render as JI, vModelText as mT, useTemplateRef as t1, Transition as H_, createApp as bF, vModelSelect as RZ, onBeforeUpdate as PZ, createStaticVNode as Zp, defineAsyncComponent as my, useCssVars as jZ } from "vue";
const BZ = { class: "block w-full" }, $Z = { class: "ml-2 w-full" }, zZ = { class: "flex flex-col md:flex-row md:items-baseline" }, FZ = {
  key: 0,
  class: "text-lg font-medium text-ink-gray-9"
}, VZ = { class: "mt-1 md:ml-2 md:mt-0" }, HZ = { class: "mt-3 md:ml-auto md:mt-0" }, rUe = /* @__PURE__ */ ve({
  __name: "Alert",
  props: {
    title: {},
    type: { default: "warning" }
  },
  setup(n) {
    const e = n, t = K(() => ({
      warning: "text-ink-gray-7 bg-surface-blue-1"
    })[e.type]);
    return (r, i) => (L(), W("div", BZ, [
      G("div", {
        class: _e(["flex items-start rounded-md px-4 py-3.5 text-base md:px-5", t.value])
      }, [
        i[0] || (i[0] = G("svg", {
          width: "24",
          height: "24",
          viewBox: "0 0 24 24",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, [
          G("path", {
            opacity: "0.8",
            "fill-rule": "evenodd",
            "clip-rule": "evenodd",
            d: "M12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C17.5 22 22 17.5 22 12C22 6.5 17.5 2 12 2ZM12 10.5C12.5523 10.5 13 10.9477 13 11.5V17C13 17.5523 12.5523 18 12 18C11.4477 18 11 17.5523 11 17V11.5C11 10.9477 11.4477 10.5 12 10.5ZM13 7.99976C13 7.44747 12.5523 6.99976 12 6.99976C11.4477 6.99976 11 7.44747 11 7.99976V8.1C11 8.65228 11.4477 9.1 12 9.1C12.5523 9.1 13 8.65228 13 8.1V7.99976Z",
            fill: "#318AD8"
          })
        ], -1)),
        G("div", $Z, [
          G("div", zZ, [
            r.title ? (L(), W("h3", FZ, ke(r.title), 1)) : ge("", !0),
            G("div", VZ, [
              ue(r.$slots, "default")
            ]),
            G("div", HZ, [
              ue(r.$slots, "actions")
            ])
          ])
        ])
      ], 2)
    ]));
  }
});
function df(n, e, t) {
  let r = t.initialDeps ?? [], i;
  function a() {
    var o, s, l, u;
    let c;
    t.key && ((o = t.debug) != null && o.call(t)) && (c = Date.now());
    const d = n();
    if (!(d.length !== r.length || d.some((h, v) => r[v] !== h)))
      return i;
    r = d;
    let p;
    if (t.key && ((s = t.debug) != null && s.call(t)) && (p = Date.now()), i = e(...d), t.key && ((l = t.debug) != null && l.call(t))) {
      const h = Math.round((Date.now() - c) * 100) / 100, v = Math.round((Date.now() - p) * 100) / 100, m = v / 16, g = (y, b) => {
        for (y = String(y); y.length < b; )
          y = " " + y;
        return y;
      };
      console.info(
        `%c⏱ ${g(v, 5)} /${g(h, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * m, 120)
        )}deg 100% 31%);`,
        t == null ? void 0 : t.key
      );
    }
    return (u = t == null ? void 0 : t.onChange) == null || u.call(t, i), i;
  }
  return a.updateDeps = (o) => {
    r = o;
  }, a;
}
function QI(n, e) {
  if (n === void 0)
    throw new Error("Unexpected undefined");
  return n;
}
const GZ = (n, e) => Math.abs(n - e) < 1.01, UZ = (n, e, t) => {
  let r;
  return function(...i) {
    n.clearTimeout(r), r = n.setTimeout(() => e.apply(this, i), t);
  };
}, eL = (n) => {
  const { offsetWidth: e, offsetHeight: t } = n;
  return { width: e, height: t };
}, WZ = (n) => n, qZ = (n) => {
  const e = Math.max(n.startIndex - n.overscan, 0), t = Math.min(n.endIndex + n.overscan, n.count - 1), r = [];
  for (let i = e; i <= t; i++)
    r.push(i);
  return r;
}, YZ = (n, e) => {
  const t = n.scrollElement;
  if (!t)
    return;
  const r = n.targetWindow;
  if (!r)
    return;
  const i = (o) => {
    const { width: s, height: l } = o;
    e({ width: Math.round(s), height: Math.round(l) });
  };
  if (i(eL(t)), !r.ResizeObserver)
    return () => {
    };
  const a = new r.ResizeObserver((o) => {
    const s = () => {
      const l = o[0];
      if (l != null && l.borderBoxSize) {
        const u = l.borderBoxSize[0];
        if (u) {
          i({ width: u.inlineSize, height: u.blockSize });
          return;
        }
      }
      i(eL(t));
    };
    n.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(s) : s();
  });
  return a.observe(t, { box: "border-box" }), () => {
    a.unobserve(t);
  };
}, tL = {
  passive: !0
}, nL = typeof window > "u" ? !0 : "onscrollend" in window, KZ = (n, e) => {
  const t = n.scrollElement;
  if (!t)
    return;
  const r = n.targetWindow;
  if (!r)
    return;
  let i = 0;
  const a = n.options.useScrollendEvent && nL ? () => {
  } : UZ(
    r,
    () => {
      e(i, !1);
    },
    n.options.isScrollingResetDelay
  ), o = (c) => () => {
    const { horizontal: d, isRtl: f } = n.options;
    i = d ? t.scrollLeft * (f && -1 || 1) : t.scrollTop, a(), e(i, c);
  }, s = o(!0), l = o(!1);
  l(), t.addEventListener("scroll", s, tL);
  const u = n.options.useScrollendEvent && nL;
  return u && t.addEventListener("scrollend", l, tL), () => {
    t.removeEventListener("scroll", s), u && t.removeEventListener("scrollend", l);
  };
}, XZ = (n, e, t) => {
  if (e != null && e.borderBoxSize) {
    const r = e.borderBoxSize[0];
    if (r)
      return Math.round(
        r[t.options.horizontal ? "inlineSize" : "blockSize"]
      );
  }
  return n[t.options.horizontal ? "offsetWidth" : "offsetHeight"];
}, ZZ = (n, {
  adjustments: e = 0,
  behavior: t
}, r) => {
  var i, a;
  const o = n + e;
  (a = (i = r.scrollElement) == null ? void 0 : i.scrollTo) == null || a.call(i, {
    [r.options.horizontal ? "left" : "top"]: o,
    behavior: t
  });
};
class JZ {
  constructor(e) {
    this.unsubs = [], this.scrollElement = null, this.targetWindow = null, this.isScrolling = !1, this.measurementsCache = [], this.itemSizeCache = /* @__PURE__ */ new Map(), this.pendingMeasuredCacheIndexes = [], this.scrollRect = null, this.scrollOffset = null, this.scrollDirection = null, this.scrollAdjustments = 0, this.elementsCache = /* @__PURE__ */ new Map(), this.observer = /* @__PURE__ */ (() => {
      let t = null;
      const r = () => t || (!this.targetWindow || !this.targetWindow.ResizeObserver ? null : t = new this.targetWindow.ResizeObserver((i) => {
        i.forEach((a) => {
          const o = () => {
            this._measureElement(a.target, a);
          };
          this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(o) : o();
        });
      }));
      return {
        disconnect: () => {
          var i;
          (i = r()) == null || i.disconnect(), t = null;
        },
        observe: (i) => {
          var a;
          return (a = r()) == null ? void 0 : a.observe(i, { box: "border-box" });
        },
        unobserve: (i) => {
          var a;
          return (a = r()) == null ? void 0 : a.unobserve(i);
        }
      };
    })(), this.range = null, this.setOptions = (t) => {
      Object.entries(t).forEach(([r, i]) => {
        typeof i > "u" && delete t[r];
      }), this.options = {
        debug: !1,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: !1,
        getItemKey: WZ,
        rangeExtractor: qZ,
        onChange: () => {
        },
        measureElement: XZ,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: !0,
        isRtl: !1,
        useScrollendEvent: !1,
        useAnimationFrameWithResizeObserver: !1,
        ...t
      };
    }, this.notify = (t) => {
      var r, i;
      (i = (r = this.options).onChange) == null || i.call(r, this, t);
    }, this.maybeNotify = df(
      () => (this.calculateRange(), [
        this.isScrolling,
        this.range ? this.range.startIndex : null,
        this.range ? this.range.endIndex : null
      ]),
      (t) => {
        this.notify(t);
      },
      {
        key: process.env.NODE_ENV !== "production" && "maybeNotify",
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    ), this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((t) => t()), this.unsubs = [], this.observer.disconnect(), this.scrollElement = null, this.targetWindow = null;
    }, this._didMount = () => () => {
      this.cleanup();
    }, this._willUpdate = () => {
      var t;
      const r = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== r) {
        if (this.cleanup(), !r) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = r, this.scrollElement && "ownerDocument" in this.scrollElement ? this.targetWindow = this.scrollElement.ownerDocument.defaultView : this.targetWindow = ((t = this.scrollElement) == null ? void 0 : t.window) ?? null, this.elementsCache.forEach((i) => {
          this.observer.observe(i);
        }), this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        }), this.unsubs.push(
          this.options.observeElementRect(this, (i) => {
            this.scrollRect = i, this.maybeNotify();
          })
        ), this.unsubs.push(
          this.options.observeElementOffset(this, (i, a) => {
            this.scrollAdjustments = 0, this.scrollDirection = a ? this.getScrollOffset() < i ? "forward" : "backward" : null, this.scrollOffset = i, this.isScrolling = a, this.maybeNotify();
          })
        );
      }
    }, this.getSize = () => this.options.enabled ? (this.scrollRect = this.scrollRect ?? this.options.initialRect, this.scrollRect[this.options.horizontal ? "width" : "height"]) : (this.scrollRect = null, 0), this.getScrollOffset = () => this.options.enabled ? (this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset == "function" ? this.options.initialOffset() : this.options.initialOffset), this.scrollOffset) : (this.scrollOffset = null, 0), this.getFurthestMeasurement = (t, r) => {
      const i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
      for (let o = r - 1; o >= 0; o--) {
        const s = t[o];
        if (i.has(s.lane))
          continue;
        const l = a.get(
          s.lane
        );
        if (l == null || s.end > l.end ? a.set(s.lane, s) : s.end < l.end && i.set(s.lane, !0), i.size === this.options.lanes)
          break;
      }
      return a.size === this.options.lanes ? Array.from(a.values()).sort((o, s) => o.end === s.end ? o.index - s.index : o.end - s.end)[0] : void 0;
    }, this.getMeasurementOptions = df(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled
      ],
      (t, r, i, a, o) => (this.pendingMeasuredCacheIndexes = [], {
        count: t,
        paddingStart: r,
        scrollMargin: i,
        getItemKey: a,
        enabled: o
      }),
      {
        key: !1
      }
    ), this.getMeasurements = df(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count: t, paddingStart: r, scrollMargin: i, getItemKey: a, enabled: o }, s) => {
        if (!o)
          return this.measurementsCache = [], this.itemSizeCache.clear(), [];
        this.measurementsCache.length === 0 && (this.measurementsCache = this.options.initialMeasurementsCache, this.measurementsCache.forEach((c) => {
          this.itemSizeCache.set(c.key, c.size);
        }));
        const l = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const u = this.measurementsCache.slice(0, l);
        for (let c = l; c < t; c++) {
          const d = a(c), f = this.options.lanes === 1 ? u[c - 1] : this.getFurthestMeasurement(u, c), p = f ? f.end + this.options.gap : r + i, h = s.get(d), v = typeof h == "number" ? h : this.options.estimateSize(c), m = p + v, g = f ? f.lane : c % this.options.lanes;
          u[c] = {
            index: c,
            start: p,
            size: v,
            end: m,
            key: d,
            lane: g
          };
        }
        return this.measurementsCache = u, u;
      },
      {
        key: process.env.NODE_ENV !== "production" && "getMeasurements",
        debug: () => this.options.debug
      }
    ), this.calculateRange = df(
      () => [
        this.getMeasurements(),
        this.getSize(),
        this.getScrollOffset(),
        this.options.lanes
      ],
      (t, r, i, a) => this.range = t.length > 0 && r > 0 ? QZ({
        measurements: t,
        outerSize: r,
        scrollOffset: i,
        lanes: a
      }) : null,
      {
        key: process.env.NODE_ENV !== "production" && "calculateRange",
        debug: () => this.options.debug
      }
    ), this.getVirtualIndexes = df(
      () => {
        let t = null, r = null;
        const i = this.calculateRange();
        return i && (t = i.startIndex, r = i.endIndex), this.maybeNotify.updateDeps([this.isScrolling, t, r]), [
          this.options.rangeExtractor,
          this.options.overscan,
          this.options.count,
          t,
          r
        ];
      },
      (t, r, i, a, o) => a === null || o === null ? [] : t({
        startIndex: a,
        endIndex: o,
        overscan: r,
        count: i
      }),
      {
        key: process.env.NODE_ENV !== "production" && "getVirtualIndexes",
        debug: () => this.options.debug
      }
    ), this.indexFromElement = (t) => {
      const r = this.options.indexAttribute, i = t.getAttribute(r);
      return i ? parseInt(i, 10) : (console.warn(
        `Missing attribute name '${r}={index}' on measured element.`
      ), -1);
    }, this._measureElement = (t, r) => {
      const i = this.indexFromElement(t), a = this.measurementsCache[i];
      if (!a)
        return;
      const o = a.key, s = this.elementsCache.get(o);
      s !== t && (s && this.observer.unobserve(s), this.observer.observe(t), this.elementsCache.set(o, t)), t.isConnected && this.resizeItem(i, this.options.measureElement(t, r, this));
    }, this.resizeItem = (t, r) => {
      const i = this.measurementsCache[t];
      if (!i)
        return;
      const a = this.itemSizeCache.get(i.key) ?? i.size, o = r - a;
      o !== 0 && ((this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(i, o, this) : i.start < this.getScrollOffset() + this.scrollAdjustments) && (process.env.NODE_ENV !== "production" && this.options.debug && console.info("correction", o), this._scrollToOffset(this.getScrollOffset(), {
        adjustments: this.scrollAdjustments += o,
        behavior: void 0
      })), this.pendingMeasuredCacheIndexes.push(i.index), this.itemSizeCache = new Map(this.itemSizeCache.set(i.key, r)), this.notify(!1));
    }, this.measureElement = (t) => {
      if (!t) {
        this.elementsCache.forEach((r, i) => {
          r.isConnected || (this.observer.unobserve(r), this.elementsCache.delete(i));
        });
        return;
      }
      this._measureElement(t, void 0);
    }, this.getVirtualItems = df(
      () => [this.getVirtualIndexes(), this.getMeasurements()],
      (t, r) => {
        const i = [];
        for (let a = 0, o = t.length; a < o; a++) {
          const s = t[a], l = r[s];
          i.push(l);
        }
        return i;
      },
      {
        key: process.env.NODE_ENV !== "production" && "getVirtualItems",
        debug: () => this.options.debug
      }
    ), this.getVirtualItemForOffset = (t) => {
      const r = this.getMeasurements();
      if (r.length !== 0)
        return QI(
          r[_F(
            0,
            r.length - 1,
            (i) => QI(r[i]).start,
            t
          )]
        );
    }, this.getOffsetForAlignment = (t, r, i = 0) => {
      const a = this.getSize(), o = this.getScrollOffset();
      r === "auto" && (r = t >= o + a ? "end" : "start"), r === "center" ? t += (i - a) / 2 : r === "end" && (t -= a);
      const s = this.getTotalSize() + this.options.scrollMargin - a;
      return Math.max(Math.min(s, t), 0);
    }, this.getOffsetForIndex = (t, r = "auto") => {
      t = Math.max(0, Math.min(t, this.options.count - 1));
      const i = this.measurementsCache[t];
      if (!i)
        return;
      const a = this.getSize(), o = this.getScrollOffset();
      if (r === "auto")
        if (i.end >= o + a - this.options.scrollPaddingEnd)
          r = "end";
        else if (i.start <= o + this.options.scrollPaddingStart)
          r = "start";
        else
          return [o, r];
      const s = r === "end" ? i.end + this.options.scrollPaddingEnd : i.start - this.options.scrollPaddingStart;
      return [
        this.getOffsetForAlignment(s, r, i.size),
        r
      ];
    }, this.isDynamicMode = () => this.elementsCache.size > 0, this.scrollToOffset = (t, { align: r = "start", behavior: i } = {}) => {
      i === "smooth" && this.isDynamicMode() && console.warn(
        "The `smooth` scroll behavior is not fully supported with dynamic size."
      ), this._scrollToOffset(this.getOffsetForAlignment(t, r), {
        adjustments: void 0,
        behavior: i
      });
    }, this.scrollToIndex = (t, { align: r = "auto", behavior: i } = {}) => {
      i === "smooth" && this.isDynamicMode() && console.warn(
        "The `smooth` scroll behavior is not fully supported with dynamic size."
      ), t = Math.max(0, Math.min(t, this.options.count - 1));
      let a = 0;
      const o = 10, s = (u) => {
        if (!this.targetWindow) return;
        const c = this.getOffsetForIndex(t, u);
        if (!c) {
          console.warn("Failed to get offset for index:", t);
          return;
        }
        const [d, f] = c;
        this._scrollToOffset(d, { adjustments: void 0, behavior: i }), this.targetWindow.requestAnimationFrame(() => {
          const p = this.getScrollOffset(), h = this.getOffsetForIndex(t, f);
          if (!h) {
            console.warn("Failed to get offset for index:", t);
            return;
          }
          GZ(h[0], p) || l(f);
        });
      }, l = (u) => {
        this.targetWindow && (a++, a < o ? (process.env.NODE_ENV !== "production" && this.options.debug && console.info("Schedule retry", a, o), this.targetWindow.requestAnimationFrame(() => s(u))) : console.warn(
          `Failed to scroll to index ${t} after ${o} attempts.`
        ));
      };
      s(r);
    }, this.scrollBy = (t, { behavior: r } = {}) => {
      r === "smooth" && this.isDynamicMode() && console.warn(
        "The `smooth` scroll behavior is not fully supported with dynamic size."
      ), this._scrollToOffset(this.getScrollOffset() + t, {
        adjustments: void 0,
        behavior: r
      });
    }, this.getTotalSize = () => {
      var t;
      const r = this.getMeasurements();
      let i;
      if (r.length === 0)
        i = this.options.paddingStart;
      else if (this.options.lanes === 1)
        i = ((t = r[r.length - 1]) == null ? void 0 : t.end) ?? 0;
      else {
        const a = Array(this.options.lanes).fill(null);
        let o = r.length - 1;
        for (; o >= 0 && a.some((s) => s === null); ) {
          const s = r[o];
          a[s.lane] === null && (a[s.lane] = s.end), o--;
        }
        i = Math.max(...a.filter((s) => s !== null));
      }
      return Math.max(
        i - this.options.scrollMargin + this.options.paddingEnd,
        0
      );
    }, this._scrollToOffset = (t, {
      adjustments: r,
      behavior: i
    }) => {
      this.options.scrollToFn(t, { behavior: i, adjustments: r }, this);
    }, this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map(), this.notify(!1);
    }, this.setOptions(e);
  }
}
const _F = (n, e, t, r) => {
  for (; n <= e; ) {
    const i = (n + e) / 2 | 0, a = t(i);
    if (a < r)
      n = i + 1;
    else if (a > r)
      e = i - 1;
    else
      return i;
  }
  return n > 0 ? n - 1 : 0;
};
function QZ({
  measurements: n,
  outerSize: e,
  scrollOffset: t,
  lanes: r
}) {
  const i = n.length - 1, a = (l) => n[l].start;
  if (n.length <= r)
    return {
      startIndex: 0,
      endIndex: i
    };
  let o = _F(
    0,
    i,
    a,
    t
  ), s = o;
  if (r === 1)
    for (; s < i && n[s].end < t + e; )
      s++;
  else if (r > 1) {
    const l = Array(r).fill(0);
    for (; s < i && l.some((c) => c < t + e); ) {
      const c = n[s];
      l[c.lane] = c.end, s++;
    }
    const u = Array(r).fill(t + e);
    for (; o >= 0 && u.some((c) => c >= t); ) {
      const c = n[o];
      u[c.lane] = c.start, o--;
    }
    o = Math.max(0, o - o % r), s = Math.min(i, s + (r - 1 - s % r));
  }
  return { startIndex: o, endIndex: s };
}
function eJ(n) {
  const e = new JZ(O(n)), t = Bd(e), r = e._didMount();
  return et(
    () => O(n).getScrollElement(),
    (i) => {
      i && e._willUpdate();
    },
    {
      immediate: !0
    }
  ), et(
    () => O(n),
    (i) => {
      e.setOptions({
        ...i,
        onChange: (a, o) => {
          var s;
          ZI(t), (s = i.onChange) == null || s.call(i, a, o);
        }
      }), e._willUpdate(), ZI(t);
    },
    {
      immediate: !0
    }
  ), xg(r), t;
}
function tJ(n) {
  return eJ(
    K(() => ({
      observeElementRect: YZ,
      observeElementOffset: KZ,
      scrollToFn: ZZ,
      ...O(n)
    }))
  );
}
function OA(n, e, t) {
  let r = Z(t == null ? void 0 : t.value), i = K(() => n.value !== void 0);
  return [K(() => i.value ? n.value : r.value), function(a) {
    return i.value || (r.value = a), e == null ? void 0 : e(a);
  }];
}
function xF(n) {
  typeof queueMicrotask == "function" ? queueMicrotask(n) : Promise.resolve().then(n).catch((e) => setTimeout(() => {
    throw e;
  }));
}
function B1() {
  let n = [], e = { addEventListener(t, r, i, a) {
    return t.addEventListener(r, i, a), e.add(() => t.removeEventListener(r, i, a));
  }, requestAnimationFrame(...t) {
    let r = requestAnimationFrame(...t);
    e.add(() => cancelAnimationFrame(r));
  }, nextFrame(...t) {
    e.requestAnimationFrame(() => {
      e.requestAnimationFrame(...t);
    });
  }, setTimeout(...t) {
    let r = setTimeout(...t);
    e.add(() => clearTimeout(r));
  }, microTask(...t) {
    let r = { current: !0 };
    return xF(() => {
      r.current && t[0]();
    }), e.add(() => {
      r.current = !1;
    });
  }, style(t, r, i) {
    let a = t.style.getPropertyValue(r);
    return Object.assign(t.style, { [r]: i }), this.add(() => {
      Object.assign(t.style, { [r]: a });
    });
  }, group(t) {
    let r = B1();
    return t(r), this.add(() => r.dispose());
  }, add(t) {
    return n.push(t), () => {
      let r = n.indexOf(t);
      if (r >= 0) for (let i of n.splice(r, 1)) i();
    };
  }, dispose() {
    for (let t of n.splice(0)) t();
  } };
  return e;
}
function nJ() {
  let n = B1();
  return Nn(() => n.dispose()), n;
}
function rJ() {
  let n = nJ();
  return (e) => {
    n.dispose(), n.nextFrame(e);
  };
}
var rL;
let iJ = Symbol("headlessui.useid"), aJ = 0;
const Fr = (rL = rp.useId) != null ? rL : function() {
  return rp.inject(iJ, () => `${++aJ}`)();
};
function Ue(n) {
  var e;
  if (n == null || n.value == null) return null;
  let t = (e = n.value.$el) != null ? e : n.value;
  return t instanceof Node ? t : null;
}
function Mr(n, e, ...t) {
  if (n in e) {
    let i = e[n];
    return typeof i == "function" ? i(...t) : i;
  }
  let r = new Error(`Tried to handle "${n}" but there is no handler defined. Only defined handlers are: ${Object.keys(e).map((i) => `"${i}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(r, Mr), r;
}
var oJ = Object.defineProperty, sJ = (n, e, t) => e in n ? oJ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, iL = (n, e, t) => (sJ(n, typeof e != "symbol" ? e + "" : e, t), t);
let lJ = class {
  constructor() {
    iL(this, "current", this.detect()), iL(this, "currentId", 0);
  }
  set(e) {
    this.current !== e && (this.currentId = 0, this.current = e);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
}, G_ = new lJ();
function Zi(n) {
  if (G_.isServer) return null;
  if (n instanceof Node) return n.ownerDocument;
  if (n != null && n.hasOwnProperty("value")) {
    let e = Ue(n);
    if (e) return e.ownerDocument;
  }
  return document;
}
let gT = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((n) => `${n}:not([tabindex='-1'])`).join(",");
var rr = ((n) => (n[n.First = 1] = "First", n[n.Previous = 2] = "Previous", n[n.Next = 4] = "Next", n[n.Last = 8] = "Last", n[n.WrapAround = 16] = "WrapAround", n[n.NoScroll = 32] = "NoScroll", n))(rr || {}), ns = ((n) => (n[n.Error = 0] = "Error", n[n.Overflow = 1] = "Overflow", n[n.Success = 2] = "Success", n[n.Underflow = 3] = "Underflow", n))(ns || {}), uJ = ((n) => (n[n.Previous = -1] = "Previous", n[n.Next = 1] = "Next", n))(uJ || {});
function U_(n = document.body) {
  return n == null ? [] : Array.from(n.querySelectorAll(gT)).sort((e, t) => Math.sign((e.tabIndex || Number.MAX_SAFE_INTEGER) - (t.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var IA = ((n) => (n[n.Strict = 0] = "Strict", n[n.Loose = 1] = "Loose", n))(IA || {});
function wF(n, e = 0) {
  var t;
  return n === ((t = Zi(n)) == null ? void 0 : t.body) ? !1 : Mr(e, { 0() {
    return n.matches(gT);
  }, 1() {
    let r = n;
    for (; r !== null; ) {
      if (r.matches(gT)) return !0;
      r = r.parentElement;
    }
    return !1;
  } });
}
var cJ = ((n) => (n[n.Keyboard = 0] = "Keyboard", n[n.Mouse = 1] = "Mouse", n))(cJ || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (n) => {
  n.metaKey || n.altKey || n.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (n) => {
  n.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : n.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
let dJ = ["textarea", "input"].join(",");
function fJ(n) {
  var e, t;
  return (t = (e = n == null ? void 0 : n.matches) == null ? void 0 : e.call(n, dJ)) != null ? t : !1;
}
function nu(n, e = (t) => t) {
  return n.slice().sort((t, r) => {
    let i = e(t), a = e(r);
    if (i === null || a === null) return 0;
    let o = i.compareDocumentPosition(a);
    return o & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : o & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function ki(n, e, { sorted: t = !0, relativeTo: r = null, skipElements: i = [] } = {}) {
  var a;
  let o = (a = Array.isArray(n) ? n.length > 0 ? n[0].ownerDocument : document : n == null ? void 0 : n.ownerDocument) != null ? a : document, s = Array.isArray(n) ? t ? nu(n) : n : U_(n);
  i.length > 0 && s.length > 1 && (s = s.filter((h) => !i.includes(h))), r = r ?? o.activeElement;
  let l = (() => {
    if (e & 5) return 1;
    if (e & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), u = (() => {
    if (e & 1) return 0;
    if (e & 2) return Math.max(0, s.indexOf(r)) - 1;
    if (e & 4) return Math.max(0, s.indexOf(r)) + 1;
    if (e & 8) return s.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), c = e & 32 ? { preventScroll: !0 } : {}, d = 0, f = s.length, p;
  do {
    if (d >= f || d + f <= 0) return 0;
    let h = u + d;
    if (e & 16) h = (h + f) % f;
    else {
      if (h < 0) return 3;
      if (h >= f) return 1;
    }
    p = s[h], p == null || p.focus(c), d += l;
  } while (p !== o.activeElement);
  return e & 6 && fJ(p) && p.select(), 2;
}
function pJ() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function hJ() {
  return /Android/gi.test(window.navigator.userAgent);
}
function SF() {
  return pJ() || hJ();
}
function gy(n, e, t) {
  G_.isServer || Cn((r) => {
    document.addEventListener(n, e, t), r(() => document.removeEventListener(n, e, t));
  });
}
function EF(n, e, t) {
  G_.isServer || Cn((r) => {
    window.addEventListener(n, e, t), r(() => window.removeEventListener(n, e, t));
  });
}
function TF(n, e, t = K(() => !0)) {
  function r(a, o) {
    if (!t.value || a.defaultPrevented) return;
    let s = o(a);
    if (s === null || !s.getRootNode().contains(s)) return;
    let l = function u(c) {
      return typeof c == "function" ? u(c()) : Array.isArray(c) || c instanceof Set ? c : [c];
    }(n);
    for (let u of l) {
      if (u === null) continue;
      let c = u instanceof HTMLElement ? u : Ue(u);
      if (c != null && c.contains(s) || a.composed && a.composedPath().includes(c)) return;
    }
    return !wF(s, IA.Loose) && s.tabIndex !== -1 && a.preventDefault(), e(a, s);
  }
  let i = Z(null);
  gy("pointerdown", (a) => {
    var o, s;
    t.value && (i.value = ((s = (o = a.composedPath) == null ? void 0 : o.call(a)) == null ? void 0 : s[0]) || a.target);
  }, !0), gy("mousedown", (a) => {
    var o, s;
    t.value && (i.value = ((s = (o = a.composedPath) == null ? void 0 : o.call(a)) == null ? void 0 : s[0]) || a.target);
  }, !0), gy("click", (a) => {
    SF() || i.value && (r(a, () => i.value), i.value = null);
  }, !0), gy("touchend", (a) => r(a, () => a.target instanceof HTMLElement ? a.target : null), !0), EF("blur", (a) => r(a, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function aL(n, e) {
  if (n) return n;
  let t = e ?? "button";
  if (typeof t == "string" && t.toLowerCase() === "button") return "button";
}
function W_(n, e) {
  let t = Z(aL(n.value.type, n.value.as));
  return kt(() => {
    t.value = aL(n.value.type, n.value.as);
  }), Cn(() => {
    var r;
    t.value || Ue(e) && Ue(e) instanceof HTMLButtonElement && !((r = Ue(e)) != null && r.hasAttribute("type")) && (t.value = "button");
  }), t;
}
function oL(n) {
  return [n.screenX, n.screenY];
}
function vJ() {
  let n = Z([-1, -1]);
  return { wasMoved(e) {
    let t = oL(e);
    return n.value[0] === t[0] && n.value[1] === t[1] ? !1 : (n.value = t, !0);
  }, update(e) {
    n.value = oL(e);
  } };
}
function CF({ container: n, accept: e, walk: t, enabled: r }) {
  Cn(() => {
    let i = n.value;
    if (!i || r !== void 0 && !r.value) return;
    let a = Zi(n);
    if (!a) return;
    let o = Object.assign((l) => e(l), { acceptNode: e }), s = a.createTreeWalker(i, NodeFilter.SHOW_ELEMENT, o, !1);
    for (; s.nextNode(); ) t(s.currentNode);
  });
}
var So = ((n) => (n[n.None = 0] = "None", n[n.RenderStrategy = 1] = "RenderStrategy", n[n.Static = 2] = "Static", n))(So || {}), mJ = ((n) => (n[n.Unmount = 0] = "Unmount", n[n.Hidden = 1] = "Hidden", n))(mJ || {});
function Kn({ visible: n = !0, features: e = 0, ourProps: t, theirProps: r, ...i }) {
  var a;
  let o = AF(r, t), s = Object.assign(i, { props: o });
  if (n || e & 2 && o.static) return Uw(s);
  if (e & 1) {
    let l = (a = o.unmount) == null || a ? 0 : 1;
    return Mr(l, { 0() {
      return null;
    }, 1() {
      return Uw({ ...i, props: { ...o, hidden: !0, style: { display: "none" } } });
    } });
  }
  return Uw(s);
}
function Uw({ props: n, attrs: e, slots: t, slot: r, name: i }) {
  var a, o;
  let { as: s, ...l } = zd(n, ["unmount", "static"]), u = (a = t.default) == null ? void 0 : a.call(t, r), c = {};
  if (r) {
    let d = !1, f = [];
    for (let [p, h] of Object.entries(r)) typeof h == "boolean" && (d = !0), h === !0 && f.push(p);
    d && (c["data-headlessui-state"] = f.join(" "));
  }
  if (s === "template") {
    if (u = kF(u ?? []), Object.keys(l).length > 0 || Object.keys(e).length > 0) {
      let [d, ...f] = u ?? [];
      if (!gJ(d) || f.length > 0) throw new Error(['Passing props on "template"!', "", `The current component <${i} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(l).concat(Object.keys(e)).map((v) => v.trim()).filter((v, m, g) => g.indexOf(v) === m).sort((v, m) => v.localeCompare(m)).map((v) => `  - ${v}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map((v) => `  - ${v}`).join(`
`)].join(`
`));
      let p = AF((o = d.props) != null ? o : {}, l, c), h = kA(d, p, !0);
      for (let v in p) v.startsWith("on") && (h.props || (h.props = {}), h.props[v] = p[v]);
      return h;
    }
    return Array.isArray(u) && u.length === 1 ? u[0] : u;
  }
  return qt(s, Object.assign({}, l, c), { default: () => u });
}
function kF(n) {
  return n.flatMap((e) => e.type === Ke ? kF(e.children) : [e]);
}
function AF(...n) {
  if (n.length === 0) return {};
  if (n.length === 1) return n[0];
  let e = {}, t = {};
  for (let r of n) for (let i in r) i.startsWith("on") && typeof r[i] == "function" ? (t[i] != null || (t[i] = []), t[i].push(r[i])) : e[i] = r[i];
  if (e.disabled || e["aria-disabled"]) return Object.assign(e, Object.fromEntries(Object.keys(t).map((r) => [r, void 0])));
  for (let r in t) Object.assign(e, { [r](i, ...a) {
    let o = t[r];
    for (let s of o) {
      if (i instanceof Event && i.defaultPrevented) return;
      s(i, ...a);
    }
  } });
  return e;
}
function LA(n) {
  let e = Object.assign({}, n);
  for (let t in e) e[t] === void 0 && delete e[t];
  return e;
}
function zd(n, e = []) {
  let t = Object.assign({}, n);
  for (let r of e) r in t && delete t[r];
  return t;
}
function gJ(n) {
  return n == null ? !1 : typeof n.type == "string" || typeof n.type == "object" || typeof n.type == "function";
}
var vs = ((n) => (n[n.None = 1] = "None", n[n.Focusable = 2] = "Focusable", n[n.Hidden = 4] = "Hidden", n))(vs || {});
let ms = ve({ name: "Hidden", props: { as: { type: [Object, String], default: "div" }, features: { type: Number, default: 1 } }, setup(n, { slots: e, attrs: t }) {
  return () => {
    var r;
    let { features: i, ...a } = n, o = { "aria-hidden": (i & 2) === 2 ? !0 : (r = a["aria-hidden"]) != null ? r : void 0, hidden: (i & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(i & 4) === 4 && (i & 2) !== 2 && { display: "none" } } };
    return Kn({ ourProps: o, theirProps: a, slot: {}, attrs: t, slots: e, name: "Hidden" });
  };
} }), MF = Symbol("Context");
var Eo = ((n) => (n[n.Open = 1] = "Open", n[n.Closed = 2] = "Closed", n[n.Closing = 4] = "Closing", n[n.Opening = 8] = "Opening", n))(Eo || {});
function NA() {
  return Xt(MF, null);
}
function DF(n) {
  zn(MF, n);
}
var un = ((n) => (n.Space = " ", n.Enter = "Enter", n.Escape = "Escape", n.Backspace = "Backspace", n.Delete = "Delete", n.ArrowLeft = "ArrowLeft", n.ArrowUp = "ArrowUp", n.ArrowRight = "ArrowRight", n.ArrowDown = "ArrowDown", n.Home = "Home", n.End = "End", n.PageUp = "PageUp", n.PageDown = "PageDown", n.Tab = "Tab", n))(un || {}), OF = ((n) => (n[n.Left = 0] = "Left", n[n.Right = 2] = "Right", n))(OF || {});
function yJ(n) {
  function e() {
    document.readyState !== "loading" && (n(), document.removeEventListener("DOMContentLoaded", e));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", e), e());
}
let Dc = [];
yJ(() => {
  function n(e) {
    e.target instanceof HTMLElement && e.target !== document.body && Dc[0] !== e.target && (Dc.unshift(e.target), Dc = Dc.filter((t) => t != null && t.isConnected), Dc.splice(10));
  }
  window.addEventListener("click", n, { capture: !0 }), window.addEventListener("mousedown", n, { capture: !0 }), window.addEventListener("focus", n, { capture: !0 }), document.body.addEventListener("click", n, { capture: !0 }), document.body.addEventListener("mousedown", n, { capture: !0 }), document.body.addEventListener("focus", n, { capture: !0 });
});
function bJ(n) {
  throw new Error("Unexpected object: " + n);
}
var Yr = ((n) => (n[n.First = 0] = "First", n[n.Previous = 1] = "Previous", n[n.Next = 2] = "Next", n[n.Last = 3] = "Last", n[n.Specific = 4] = "Specific", n[n.Nothing = 5] = "Nothing", n))(Yr || {});
function sL(n, e) {
  let t = e.resolveItems();
  if (t.length <= 0) return null;
  let r = e.resolveActiveIndex(), i = r ?? -1;
  switch (n.focus) {
    case 0: {
      for (let a = 0; a < t.length; ++a) if (!e.resolveDisabled(t[a], a, t)) return a;
      return r;
    }
    case 1: {
      i === -1 && (i = t.length);
      for (let a = i - 1; a >= 0; --a) if (!e.resolveDisabled(t[a], a, t)) return a;
      return r;
    }
    case 2: {
      for (let a = i + 1; a < t.length; ++a) if (!e.resolveDisabled(t[a], a, t)) return a;
      return r;
    }
    case 3: {
      for (let a = t.length - 1; a >= 0; --a) if (!e.resolveDisabled(t[a], a, t)) return a;
      return r;
    }
    case 4: {
      for (let a = 0; a < t.length; ++a) if (e.resolveId(t[a], a, t) === n.id) return a;
      return r;
    }
    case 5:
      return null;
    default:
      bJ(n);
  }
}
function RA(n = {}, e = null, t = []) {
  for (let [r, i] of Object.entries(n)) LF(t, IF(e, r), i);
  return t;
}
function IF(n, e) {
  return n ? n + "[" + e + "]" : e;
}
function LF(n, e, t) {
  if (Array.isArray(t)) for (let [r, i] of t.entries()) LF(n, IF(e, r.toString()), i);
  else t instanceof Date ? n.push([e, t.toISOString()]) : typeof t == "boolean" ? n.push([e, t ? "1" : "0"]) : typeof t == "string" ? n.push([e, t]) : typeof t == "number" ? n.push([e, `${t}`]) : t == null ? n.push([e, ""]) : RA(t, e, n);
}
function NF(n) {
  var e, t;
  let r = (e = n == null ? void 0 : n.form) != null ? e : n.closest("form");
  if (r) {
    for (let i of r.elements) if (i !== n && (i.tagName === "INPUT" && i.type === "submit" || i.tagName === "BUTTON" && i.type === "submit" || i.nodeName === "INPUT" && i.type === "image")) {
      i.click();
      return;
    }
    (t = r.requestSubmit) == null || t.call(r);
  }
}
function _J(n, e) {
  return n === e;
}
var xJ = ((n) => (n[n.Open = 0] = "Open", n[n.Closed = 1] = "Closed", n))(xJ || {}), wJ = ((n) => (n[n.Single = 0] = "Single", n[n.Multi = 1] = "Multi", n))(wJ || {}), SJ = ((n) => (n[n.Pointer = 0] = "Pointer", n[n.Focus = 1] = "Focus", n[n.Other = 2] = "Other", n))(SJ || {});
let RF = Symbol("ComboboxContext");
function Fd(n) {
  let e = Xt(RF, null);
  if (e === null) {
    let t = new Error(`<${n} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t, Fd), t;
  }
  return e;
}
let PF = Symbol("VirtualContext"), EJ = ve({ name: "VirtualProvider", setup(n, { slots: e }) {
  let t = Fd("VirtualProvider"), r = K(() => {
    let s = Ue(t.optionsRef);
    if (!s) return { start: 0, end: 0 };
    let l = window.getComputedStyle(s);
    return { start: parseFloat(l.paddingBlockStart || l.paddingTop), end: parseFloat(l.paddingBlockEnd || l.paddingBottom) };
  }), i = tJ(K(() => ({ scrollPaddingStart: r.value.start, scrollPaddingEnd: r.value.end, count: t.virtual.value.options.length, estimateSize() {
    return 40;
  }, getScrollElement() {
    return Ue(t.optionsRef);
  }, overscan: 12 }))), a = K(() => {
    var s;
    return (s = t.virtual.value) == null ? void 0 : s.options;
  }), o = Z(0);
  return et([a], () => {
    o.value += 1;
  }), zn(PF, t.virtual.value ? i : null), () => [qt("div", { style: { position: "relative", width: "100%", height: `${i.value.getTotalSize()}px` }, ref: (s) => {
    if (s) {
      if (typeof process < "u" && process.env.JEST_WORKER_ID !== void 0 || t.activationTrigger.value === 0) return;
      t.activeOptionIndex.value !== null && t.virtual.value.options.length > t.activeOptionIndex.value && i.value.scrollToIndex(t.activeOptionIndex.value);
    }
  } }, i.value.getVirtualItems().map((s) => kA(e.default({ option: t.virtual.value.options[s.index], open: t.comboboxState.value === 0 })[0], { key: `${o.value}-${s.index}`, "data-index": s.index, "aria-setsize": t.virtual.value.options.length, "aria-posinset": s.index + 1, style: { position: "absolute", top: 0, left: 0, transform: `translateY(${s.start}px)`, overflowAnchor: "none" } })))];
} }), jF = ve({ name: "Combobox", emits: { "update:modelValue": (n) => !0 }, props: { as: { type: [Object, String], default: "template" }, disabled: { type: [Boolean], default: !1 }, by: { type: [String, Function], nullable: !0, default: null }, modelValue: { type: [Object, String, Number, Boolean], default: void 0 }, defaultValue: { type: [Object, String, Number, Boolean], default: void 0 }, form: { type: String, optional: !0 }, name: { type: String, optional: !0 }, nullable: { type: Boolean, default: !1 }, multiple: { type: [Boolean], default: !1 }, immediate: { type: [Boolean], default: !1 }, virtual: { type: Object, default: null } }, inheritAttrs: !1, setup(n, { slots: e, attrs: t, emit: r }) {
  let i = Z(1), a = Z(null), o = Z(null), s = Z(null), l = Z(null), u = Z({ static: !1, hold: !1 }), c = Z([]), d = Z(null), f = Z(2), p = Z(!1);
  function h(M = (D) => D) {
    let D = d.value !== null ? c.value[d.value] : null, N = M(c.value.slice()), R = N.length > 0 && N[0].dataRef.order.value !== null ? N.sort((z, F) => z.dataRef.order.value - F.dataRef.order.value) : nu(N, (z) => Ue(z.dataRef.domRef)), j = D ? R.indexOf(D) : null;
    return j === -1 && (j = null), { options: R, activeOptionIndex: j };
  }
  let v = K(() => n.multiple ? 1 : 0), m = K(() => n.nullable), [g, y] = OA(K(() => n.modelValue), (M) => r("update:modelValue", M), K(() => n.defaultValue)), b = K(() => g.value === void 0 ? Mr(v.value, { 1: [], 0: void 0 }) : g.value), _ = null, x = null;
  function w(M) {
    return Mr(v.value, { 0() {
      return y == null ? void 0 : y(M);
    }, 1: () => {
      let D = li(C.value.value).slice(), N = li(M), R = D.findIndex((j) => C.compare(N, li(j)));
      return R === -1 ? D.push(N) : D.splice(R, 1), y == null ? void 0 : y(D);
    } });
  }
  let S = K(() => {
  });
  et([S], ([M], [D]) => {
    if (C.virtual.value && M && D && d.value !== null) {
      let N = M.indexOf(D[d.value]);
      N !== -1 ? d.value = N : d.value = null;
    }
  });
  let C = { comboboxState: i, value: b, mode: v, compare(M, D) {
    if (typeof n.by == "string") {
      let N = n.by;
      return (M == null ? void 0 : M[N]) === (D == null ? void 0 : D[N]);
    }
    return n.by === null ? _J(M, D) : n.by(M, D);
  }, calculateIndex(M) {
    return C.virtual.value ? n.by === null ? C.virtual.value.options.indexOf(M) : C.virtual.value.options.findIndex((D) => C.compare(D, M)) : c.value.findIndex((D) => C.compare(D.dataRef.value, M));
  }, defaultValue: K(() => n.defaultValue), nullable: m, immediate: K(() => !1), virtual: K(() => null), inputRef: o, labelRef: a, buttonRef: s, optionsRef: l, disabled: K(() => n.disabled), options: c, change(M) {
    y(M);
  }, activeOptionIndex: K(() => {
    if (p.value && d.value === null && (C.virtual.value ? C.virtual.value.options.length > 0 : c.value.length > 0)) {
      if (C.virtual.value) {
        let D = C.virtual.value.options.findIndex((N) => {
          var R;
          return !((R = C.virtual.value) != null && R.disabled(N));
        });
        if (D !== -1) return D;
      }
      let M = c.value.findIndex((D) => !D.dataRef.disabled);
      if (M !== -1) return M;
    }
    return d.value;
  }), activationTrigger: f, optionsPropsRef: u, closeCombobox() {
    p.value = !1, !n.disabled && i.value !== 1 && (i.value = 1, d.value = null);
  }, openCombobox() {
    if (p.value = !0, !n.disabled && i.value !== 0) {
      if (C.value.value) {
        let M = C.calculateIndex(C.value.value);
        M !== -1 && (d.value = M);
      }
      i.value = 0;
    }
  }, setActivationTrigger(M) {
    f.value = M;
  }, goToOption(M, D, N) {
    p.value = !1, _ !== null && cancelAnimationFrame(_), _ = requestAnimationFrame(() => {
      if (n.disabled || l.value && !u.value.static && i.value === 1) return;
      if (C.virtual.value) {
        d.value = M === Yr.Specific ? D : sL({ focus: M }, { resolveItems: () => C.virtual.value.options, resolveActiveIndex: () => {
          var z, F;
          return (F = (z = C.activeOptionIndex.value) != null ? z : C.virtual.value.options.findIndex((B) => {
            var H;
            return !((H = C.virtual.value) != null && H.disabled(B));
          })) != null ? F : null;
        }, resolveDisabled: (z) => C.virtual.value.disabled(z), resolveId() {
          throw new Error("Function not implemented.");
        } }), f.value = N ?? 2;
        return;
      }
      let R = h();
      if (R.activeOptionIndex === null) {
        let z = R.options.findIndex((F) => !F.dataRef.disabled);
        z !== -1 && (R.activeOptionIndex = z);
      }
      let j = M === Yr.Specific ? D : sL({ focus: M }, { resolveItems: () => R.options, resolveActiveIndex: () => R.activeOptionIndex, resolveId: (z) => z.id, resolveDisabled: (z) => z.dataRef.disabled });
      d.value = j, f.value = N ?? 2, c.value = R.options;
    });
  }, selectOption(M) {
    let D = c.value.find((R) => R.id === M);
    if (!D) return;
    let { dataRef: N } = D;
    w(N.value);
  }, selectActiveOption() {
    if (C.activeOptionIndex.value !== null) {
      if (C.virtual.value) w(C.virtual.value.options[C.activeOptionIndex.value]);
      else {
        let { dataRef: M } = c.value[C.activeOptionIndex.value];
        w(M.value);
      }
      C.goToOption(Yr.Specific, C.activeOptionIndex.value);
    }
  }, registerOption(M, D) {
    let N = Sr({ id: M, dataRef: D });
    if (C.virtual.value) {
      c.value.push(N);
      return;
    }
    x && cancelAnimationFrame(x);
    let R = h((j) => (j.push(N), j));
    d.value === null && C.isSelected(D.value.value) && (R.activeOptionIndex = R.options.indexOf(N)), c.value = R.options, d.value = R.activeOptionIndex, f.value = 2, R.options.some((j) => !Ue(j.dataRef.domRef)) && (x = requestAnimationFrame(() => {
      let j = h();
      c.value = j.options, d.value = j.activeOptionIndex;
    }));
  }, unregisterOption(M, D) {
    if (_ !== null && cancelAnimationFrame(_), D && (p.value = !0), C.virtual.value) {
      c.value = c.value.filter((R) => R.id !== M);
      return;
    }
    let N = h((R) => {
      let j = R.findIndex((z) => z.id === M);
      return j !== -1 && R.splice(j, 1), R;
    });
    c.value = N.options, d.value = N.activeOptionIndex, f.value = 2;
  }, isSelected(M) {
    return Mr(v.value, { 0: () => C.compare(li(C.value.value), li(M)), 1: () => li(C.value.value).some((D) => C.compare(li(D), li(M))) });
  }, isActive(M) {
    return d.value === C.calculateIndex(M);
  } };
  TF([o, s, l], () => C.closeCombobox(), K(() => i.value === 0)), zn(RF, C), DF(K(() => Mr(i.value, { 0: Eo.Open, 1: Eo.Closed })));
  let k = K(() => {
    var M;
    return (M = Ue(o)) == null ? void 0 : M.closest("form");
  });
  return kt(() => {
    et([k], () => {
      if (!k.value || n.defaultValue === void 0) return;
      function M() {
        C.change(n.defaultValue);
      }
      return k.value.addEventListener("reset", M), () => {
        var D;
        (D = k.value) == null || D.removeEventListener("reset", M);
      };
    }, { immediate: !0 });
  }), () => {
    var M, D, N;
    let { name: R, disabled: j, form: z, ...F } = n, B = { open: i.value === 0, disabled: j, activeIndex: C.activeOptionIndex.value, activeOption: C.activeOptionIndex.value === null ? null : C.virtual.value ? C.virtual.value.options[(M = C.activeOptionIndex.value) != null ? M : 0] : (N = (D = C.options.value[C.activeOptionIndex.value]) == null ? void 0 : D.dataRef.value) != null ? N : null, value: b.value };
    return qt(Ke, [...R != null && b.value != null ? RA({ [R]: b.value }).map(([H, Y]) => qt(ms, LA({ features: vs.Hidden, key: H, as: "input", type: "hidden", hidden: !0, readOnly: !0, form: z, disabled: j, name: H, value: Y }))) : [], Kn({ theirProps: { ...t, ...zd(F, ["by", "defaultValue", "immediate", "modelValue", "multiple", "nullable", "onUpdate:modelValue", "virtual"]) }, ourProps: {}, slot: B, slots: e, attrs: t, name: "Combobox" })]);
  };
} });
ve({ name: "ComboboxLabel", props: { as: { type: [Object, String], default: "label" }, id: { type: String, default: null } }, setup(n, { attrs: e, slots: t }) {
  var r;
  let i = (r = n.id) != null ? r : `headlessui-combobox-label-${Fr()}`, a = Fd("ComboboxLabel");
  function o() {
    var s;
    (s = Ue(a.inputRef)) == null || s.focus({ preventScroll: !0 });
  }
  return () => {
    let s = { open: a.comboboxState.value === 0, disabled: a.disabled.value }, { ...l } = n, u = { id: i, ref: a.labelRef, onClick: o };
    return Kn({ ourProps: u, theirProps: l, slot: s, attrs: e, slots: t, name: "ComboboxLabel" });
  };
} });
ve({ name: "ComboboxButton", props: { as: { type: [Object, String], default: "button" }, id: { type: String, default: null } }, setup(n, { attrs: e, slots: t, expose: r }) {
  var i;
  let a = (i = n.id) != null ? i : `headlessui-combobox-button-${Fr()}`, o = Fd("ComboboxButton");
  r({ el: o.buttonRef, $el: o.buttonRef });
  function s(c) {
    o.disabled.value || (o.comboboxState.value === 0 ? o.closeCombobox() : (c.preventDefault(), o.openCombobox()), Wt(() => {
      var d;
      return (d = Ue(o.inputRef)) == null ? void 0 : d.focus({ preventScroll: !0 });
    }));
  }
  function l(c) {
    switch (c.key) {
      case un.ArrowDown:
        c.preventDefault(), c.stopPropagation(), o.comboboxState.value === 1 && o.openCombobox(), Wt(() => {
          var d;
          return (d = o.inputRef.value) == null ? void 0 : d.focus({ preventScroll: !0 });
        });
        return;
      case un.ArrowUp:
        c.preventDefault(), c.stopPropagation(), o.comboboxState.value === 1 && (o.openCombobox(), Wt(() => {
          o.value.value || o.goToOption(Yr.Last);
        })), Wt(() => {
          var d;
          return (d = o.inputRef.value) == null ? void 0 : d.focus({ preventScroll: !0 });
        });
        return;
      case un.Escape:
        if (o.comboboxState.value !== 0) return;
        c.preventDefault(), o.optionsRef.value && !o.optionsPropsRef.value.static && c.stopPropagation(), o.closeCombobox(), Wt(() => {
          var d;
          return (d = o.inputRef.value) == null ? void 0 : d.focus({ preventScroll: !0 });
        });
        return;
    }
  }
  let u = W_(K(() => ({ as: n.as, type: e.type })), o.buttonRef);
  return () => {
    var c, d;
    let f = { open: o.comboboxState.value === 0, disabled: o.disabled.value, value: o.value.value }, { ...p } = n, h = { ref: o.buttonRef, id: a, type: u.value, tabindex: "-1", "aria-haspopup": "listbox", "aria-controls": (c = Ue(o.optionsRef)) == null ? void 0 : c.id, "aria-expanded": o.comboboxState.value === 0, "aria-labelledby": o.labelRef.value ? [(d = Ue(o.labelRef)) == null ? void 0 : d.id, a].join(" ") : void 0, disabled: o.disabled.value === !0 ? !0 : void 0, onKeydown: l, onClick: s };
    return Kn({ ourProps: h, theirProps: p, slot: f, attrs: e, slots: t, name: "ComboboxButton" });
  };
} });
let BF = ve({ name: "ComboboxInput", props: { as: { type: [Object, String], default: "input" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, displayValue: { type: Function }, defaultValue: { type: String, default: void 0 }, id: { type: String, default: null } }, emits: { change: (n) => !0 }, setup(n, { emit: e, attrs: t, slots: r, expose: i }) {
  var a;
  let o = (a = n.id) != null ? a : `headlessui-combobox-input-${Fr()}`, s = Fd("ComboboxInput"), l = K(() => Zi(Ue(s.inputRef))), u = { value: !1 };
  i({ el: s.inputRef, $el: s.inputRef });
  function c() {
    s.change(null);
    let x = Ue(s.optionsRef);
    x && (x.scrollTop = 0), s.goToOption(Yr.Nothing);
  }
  let d = K(() => {
    var x;
    let w = s.value.value;
    return Ue(s.inputRef) ? typeof n.displayValue < "u" && w !== void 0 ? (x = n.displayValue(w)) != null ? x : "" : typeof w == "string" ? w : "" : "";
  });
  kt(() => {
    et([d, s.comboboxState, l], ([x, w], [S, C]) => {
      if (u.value) return;
      let k = Ue(s.inputRef);
      k && ((C === 0 && w === 1 || x !== S) && (k.value = x), requestAnimationFrame(() => {
        var M;
        if (u.value || !k || ((M = l.value) == null ? void 0 : M.activeElement) !== k) return;
        let { selectionStart: D, selectionEnd: N } = k;
        Math.abs((N ?? 0) - (D ?? 0)) === 0 && D === 0 && k.setSelectionRange(k.value.length, k.value.length);
      }));
    }, { immediate: !0 }), et([s.comboboxState], ([x], [w]) => {
      if (x === 0 && w === 1) {
        if (u.value) return;
        let S = Ue(s.inputRef);
        if (!S) return;
        let C = S.value, { selectionStart: k, selectionEnd: M, selectionDirection: D } = S;
        S.value = "", S.value = C, D !== null ? S.setSelectionRange(k, M, D) : S.setSelectionRange(k, M);
      }
    });
  });
  let f = Z(!1);
  function p() {
    f.value = !0;
  }
  function h() {
    B1().nextFrame(() => {
      f.value = !1;
    });
  }
  let v = rJ();
  function m(x) {
    switch (u.value = !0, v(() => {
      u.value = !1;
    }), x.key) {
      case un.Enter:
        if (u.value = !1, s.comboboxState.value !== 0 || f.value) return;
        if (x.preventDefault(), x.stopPropagation(), s.activeOptionIndex.value === null) {
          s.closeCombobox();
          return;
        }
        s.selectActiveOption(), s.mode.value === 0 && s.closeCombobox();
        break;
      case un.ArrowDown:
        return u.value = !1, x.preventDefault(), x.stopPropagation(), Mr(s.comboboxState.value, { 0: () => s.goToOption(Yr.Next), 1: () => s.openCombobox() });
      case un.ArrowUp:
        return u.value = !1, x.preventDefault(), x.stopPropagation(), Mr(s.comboboxState.value, { 0: () => s.goToOption(Yr.Previous), 1: () => {
          s.openCombobox(), Wt(() => {
            s.value.value || s.goToOption(Yr.Last);
          });
        } });
      case un.Home:
        if (x.shiftKey) break;
        return u.value = !1, x.preventDefault(), x.stopPropagation(), s.goToOption(Yr.First);
      case un.PageUp:
        return u.value = !1, x.preventDefault(), x.stopPropagation(), s.goToOption(Yr.First);
      case un.End:
        if (x.shiftKey) break;
        return u.value = !1, x.preventDefault(), x.stopPropagation(), s.goToOption(Yr.Last);
      case un.PageDown:
        return u.value = !1, x.preventDefault(), x.stopPropagation(), s.goToOption(Yr.Last);
      case un.Escape:
        if (u.value = !1, s.comboboxState.value !== 0) return;
        x.preventDefault(), s.optionsRef.value && !s.optionsPropsRef.value.static && x.stopPropagation(), s.nullable.value && s.mode.value === 0 && s.value.value === null && c(), s.closeCombobox();
        break;
      case un.Tab:
        if (u.value = !1, s.comboboxState.value !== 0) return;
        s.mode.value === 0 && s.activationTrigger.value !== 1 && s.selectActiveOption(), s.closeCombobox();
        break;
    }
  }
  function g(x) {
    e("change", x), s.nullable.value && s.mode.value === 0 && x.target.value === "" && c(), s.openCombobox();
  }
  function y(x) {
    var w, S, C;
    let k = (w = x.relatedTarget) != null ? w : Dc.find((M) => M !== x.currentTarget);
    if (u.value = !1, !((S = Ue(s.optionsRef)) != null && S.contains(k)) && !((C = Ue(s.buttonRef)) != null && C.contains(k)) && s.comboboxState.value === 0) return x.preventDefault(), s.mode.value === 0 && (s.nullable.value && s.value.value === null ? c() : s.activationTrigger.value !== 1 && s.selectActiveOption()), s.closeCombobox();
  }
  function b(x) {
    var w, S, C;
    let k = (w = x.relatedTarget) != null ? w : Dc.find((M) => M !== x.currentTarget);
    (S = Ue(s.buttonRef)) != null && S.contains(k) || (C = Ue(s.optionsRef)) != null && C.contains(k) || s.disabled.value || s.immediate.value && s.comboboxState.value !== 0 && (s.openCombobox(), B1().nextFrame(() => {
      s.setActivationTrigger(1);
    }));
  }
  let _ = K(() => {
    var x, w, S, C;
    return (C = (S = (w = n.defaultValue) != null ? w : s.defaultValue.value !== void 0 ? (x = n.displayValue) == null ? void 0 : x.call(n, s.defaultValue.value) : null) != null ? S : s.defaultValue.value) != null ? C : "";
  });
  return () => {
    var x, w, S, C, k, M, D;
    let N = { open: s.comboboxState.value === 0 }, { displayValue: R, onChange: j, ...z } = n, F = { "aria-controls": (x = s.optionsRef.value) == null ? void 0 : x.id, "aria-expanded": s.comboboxState.value === 0, "aria-activedescendant": s.activeOptionIndex.value === null ? void 0 : s.virtual.value ? (w = s.options.value.find((B) => !s.virtual.value.disabled(B.dataRef.value) && s.compare(B.dataRef.value, s.virtual.value.options[s.activeOptionIndex.value]))) == null ? void 0 : w.id : (S = s.options.value[s.activeOptionIndex.value]) == null ? void 0 : S.id, "aria-labelledby": (M = (C = Ue(s.labelRef)) == null ? void 0 : C.id) != null ? M : (k = Ue(s.buttonRef)) == null ? void 0 : k.id, "aria-autocomplete": "list", id: o, onCompositionstart: p, onCompositionend: h, onKeydown: m, onInput: g, onFocus: b, onBlur: y, role: "combobox", type: (D = t.type) != null ? D : "text", tabIndex: 0, ref: s.inputRef, defaultValue: _.value, disabled: s.disabled.value === !0 ? !0 : void 0 };
    return Kn({ ourProps: F, theirProps: z, slot: N, attrs: t, slots: r, features: So.RenderStrategy | So.Static, name: "ComboboxInput" });
  };
} }), $F = ve({ name: "ComboboxOptions", props: { as: { type: [Object, String], default: "ul" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, hold: { type: [Boolean], default: !1 } }, setup(n, { attrs: e, slots: t, expose: r }) {
  let i = Fd("ComboboxOptions"), a = `headlessui-combobox-options-${Fr()}`;
  r({ el: i.optionsRef, $el: i.optionsRef }), Cn(() => {
    i.optionsPropsRef.value.static = n.static;
  }), Cn(() => {
    i.optionsPropsRef.value.hold = n.hold;
  });
  let o = NA(), s = K(() => o !== null ? (o.value & Eo.Open) === Eo.Open : i.comboboxState.value === 0);
  CF({ container: K(() => Ue(i.optionsRef)), enabled: K(() => i.comboboxState.value === 0), accept(u) {
    return u.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : u.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(u) {
    u.setAttribute("role", "none");
  } });
  function l(u) {
    u.preventDefault();
  }
  return () => {
    var u, c, d;
    let f = { open: i.comboboxState.value === 0 }, p = { "aria-labelledby": (d = (u = Ue(i.labelRef)) == null ? void 0 : u.id) != null ? d : (c = Ue(i.buttonRef)) == null ? void 0 : c.id, id: a, ref: i.optionsRef, role: "listbox", "aria-multiselectable": i.mode.value === 1 ? !0 : void 0, onMousedown: l }, h = zd(n, ["hold"]);
    return Kn({ ourProps: p, theirProps: h, slot: f, attrs: e, slots: i.virtual.value && i.comboboxState.value === 0 ? { ...t, default: () => [qt(EJ, {}, t.default)] } : t, features: So.RenderStrategy | So.Static, visible: s.value, name: "ComboboxOptions" });
  };
} }), zF = ve({ name: "ComboboxOption", props: { as: { type: [Object, String], default: "li" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: !1 }, order: { type: [Number], default: null } }, setup(n, { slots: e, attrs: t, expose: r }) {
  let i = Fd("ComboboxOption"), a = `headlessui-combobox-option-${Fr()}`, o = Z(null), s = K(() => n.disabled);
  r({ el: o, $el: o });
  let l = K(() => {
    var y;
    return i.virtual.value ? i.activeOptionIndex.value === i.calculateIndex(n.value) : i.activeOptionIndex.value === null ? !1 : ((y = i.options.value[i.activeOptionIndex.value]) == null ? void 0 : y.id) === a;
  }), u = K(() => i.isSelected(n.value)), c = Xt(PF, null), d = K(() => ({ disabled: n.disabled, value: n.value, domRef: o, order: K(() => n.order) }));
  kt(() => i.registerOption(a, d)), Nn(() => i.unregisterOption(a, l.value)), Cn(() => {
    let y = Ue(o);
    y && (c == null || c.value.measureElement(y));
  }), Cn(() => {
    i.comboboxState.value === 0 && l.value && (i.virtual.value || i.activationTrigger.value !== 0 && Wt(() => {
      var y, b;
      return (b = (y = Ue(o)) == null ? void 0 : y.scrollIntoView) == null ? void 0 : b.call(y, { block: "nearest" });
    }));
  });
  function f(y) {
    y.preventDefault(), y.button === OF.Left && (s.value || (i.selectOption(a), SF() || requestAnimationFrame(() => {
      var b;
      return (b = Ue(i.inputRef)) == null ? void 0 : b.focus({ preventScroll: !0 });
    }), i.mode.value === 0 && i.closeCombobox()));
  }
  function p() {
    var y;
    if (n.disabled || (y = i.virtual.value) != null && y.disabled(n.value)) return i.goToOption(Yr.Nothing);
    let b = i.calculateIndex(n.value);
    i.goToOption(Yr.Specific, b);
  }
  let h = vJ();
  function v(y) {
    h.update(y);
  }
  function m(y) {
    var b;
    if (!h.wasMoved(y) || n.disabled || (b = i.virtual.value) != null && b.disabled(n.value) || l.value) return;
    let _ = i.calculateIndex(n.value);
    i.goToOption(Yr.Specific, _, 0);
  }
  function g(y) {
    var b;
    h.wasMoved(y) && (n.disabled || (b = i.virtual.value) != null && b.disabled(n.value) || l.value && (i.optionsPropsRef.value.hold || i.goToOption(Yr.Nothing)));
  }
  return () => {
    let { disabled: y } = n, b = { active: l.value, selected: u.value, disabled: y }, _ = { id: a, ref: o, role: "option", tabIndex: y === !0 ? void 0 : -1, "aria-disabled": y === !0 ? !0 : void 0, "aria-selected": u.value, disabled: void 0, onMousedown: f, onFocus: p, onPointerenter: v, onMouseenter: v, onPointermove: m, onMousemove: m, onPointerleave: g, onMouseleave: g }, x = zd(n, ["order", "value"]);
    return Kn({ ourProps: _, theirProps: x, slot: b, attrs: t, slots: e, name: "ComboboxOption" });
  };
} });
function TJ(n, e, t, r) {
  G_.isServer || Cn((i) => {
    n = n ?? window, n.addEventListener(e, t, r), i(() => n.removeEventListener(e, t, r));
  });
}
var Zs = ((n) => (n[n.Forwards = 0] = "Forwards", n[n.Backwards = 1] = "Backwards", n))(Zs || {});
function FF() {
  let n = Z(0);
  return EF("keydown", (e) => {
    e.key === "Tab" && (n.value = e.shiftKey ? 1 : 0);
  }), n;
}
function CJ({ defaultContainers: n = [], portals: e, mainTreeNodeRef: t } = {}) {
  let r = Z(null), i = Zi(r);
  function a() {
    var o, s, l;
    let u = [];
    for (let c of n) c !== null && (c instanceof HTMLElement ? u.push(c) : "value" in c && c.value instanceof HTMLElement && u.push(c.value));
    if (e != null && e.value) for (let c of e.value) u.push(c);
    for (let c of (o = i == null ? void 0 : i.querySelectorAll("html > *, body > *")) != null ? o : []) c !== document.body && c !== document.head && c instanceof HTMLElement && c.id !== "headlessui-portal-root" && (c.contains(Ue(r)) || c.contains((l = (s = Ue(r)) == null ? void 0 : s.getRootNode()) == null ? void 0 : l.host) || u.some((d) => c.contains(d)) || u.push(c));
    return u;
  }
  return { resolveContainers: a, contains(o) {
    return a().some((s) => s.contains(o));
  }, mainTreeNodeRef: r, MainTreeNode() {
    return t != null ? null : qt(ms, { features: vs.Hidden, ref: r });
  } };
}
function kJ() {
  let n = Z(null);
  return { mainTreeNodeRef: n, MainTreeNode() {
    return qt(ms, { features: vs.Hidden, ref: n });
  } };
}
let VF = Symbol("ForcePortalRootContext");
function AJ() {
  return Xt(VF, !1);
}
ve({ name: "ForcePortalRoot", props: { as: { type: [Object, String], default: "template" }, force: { type: Boolean, default: !1 } }, setup(n, { slots: e, attrs: t }) {
  return zn(VF, n.force), () => {
    let { force: r, ...i } = n;
    return Kn({ theirProps: i, ourProps: {}, slot: {}, slots: e, attrs: t, name: "ForcePortalRoot" });
  };
} });
let HF = Symbol("DescriptionContext");
function MJ() {
  let n = Xt(HF, null);
  if (n === null) throw new Error("Missing parent");
  return n;
}
function PA({ slot: n = Z({}), name: e = "Description", props: t = {} } = {}) {
  let r = Z([]);
  function i(a) {
    return r.value.push(a), () => {
      let o = r.value.indexOf(a);
      o !== -1 && r.value.splice(o, 1);
    };
  }
  return zn(HF, { register: i, slot: n, name: e, props: t }), K(() => r.value.length > 0 ? r.value.join(" ") : void 0);
}
let DJ = ve({ name: "Description", props: { as: { type: [Object, String], default: "p" }, id: { type: String, default: null } }, setup(n, { attrs: e, slots: t }) {
  var r;
  let i = (r = n.id) != null ? r : `headlessui-description-${Fr()}`, a = MJ();
  return kt(() => Nn(a.register(i))), () => {
    let { name: o = "Description", slot: s = Z({}), props: l = {} } = a, { ...u } = n, c = { ...Object.entries(l).reduce((d, [f, p]) => Object.assign(d, { [f]: O(p) }), {}), id: i };
    return Kn({ ourProps: c, theirProps: u, slot: s.value, attrs: e, slots: t, name: o });
  };
} });
function OJ(n) {
  let e = Zi(n);
  if (!e) {
    if (n === null) return null;
    throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${n}`);
  }
  let t = e.getElementById("headlessui-portal-root");
  if (t) return t;
  let r = e.createElement("div");
  return r.setAttribute("id", "headlessui-portal-root"), e.body.appendChild(r);
}
const yT = /* @__PURE__ */ new WeakMap();
function IJ(n) {
  var e;
  return (e = yT.get(n)) != null ? e : 0;
}
function lL(n, e) {
  let t = e(IJ(n));
  return t <= 0 ? yT.delete(n) : yT.set(n, t), t;
}
ve({ name: "Portal", props: { as: { type: [Object, String], default: "div" } }, setup(n, { slots: e, attrs: t }) {
  let r = Z(null), i = K(() => Zi(r)), a = AJ(), o = Xt(GF, null), s = Z(a === !0 || o == null ? OJ(r.value) : o.resolveTarget());
  s.value && lL(s.value, (f) => f + 1);
  let l = Z(!1);
  kt(() => {
    l.value = !0;
  }), Cn(() => {
    a || o != null && (s.value = o.resolveTarget());
  });
  let u = Xt(bT, null), c = !1, d = ro();
  return et(r, () => {
    if (c || !u) return;
    let f = Ue(r);
    f && (Nn(u.register(f), d), c = !0);
  }), Nn(() => {
    var f, p;
    let h = (f = i.value) == null ? void 0 : f.getElementById("headlessui-portal-root");
    !h || s.value !== h || lL(s.value, (v) => v - 1) || s.value.children.length > 0 || (p = s.value.parentElement) == null || p.removeChild(s.value);
  }), () => {
    if (!l.value || s.value === null) return null;
    let f = { ref: r, "data-headlessui-portal": "" };
    return qt(wg, { to: s.value }, Kn({ ourProps: f, theirProps: n, slot: {}, attrs: t, slots: e, name: "Portal" }));
  };
} });
let bT = Symbol("PortalParentContext");
function LJ() {
  let n = Xt(bT, null), e = Z([]);
  function t(a) {
    return e.value.push(a), n && n.register(a), () => r(a);
  }
  function r(a) {
    let o = e.value.indexOf(a);
    o !== -1 && e.value.splice(o, 1), n && n.unregister(a);
  }
  let i = { register: t, unregister: r, portals: e };
  return [e, ve({ name: "PortalWrapper", setup(a, { slots: o }) {
    return zn(bT, i), () => {
      var s;
      return (s = o.default) == null ? void 0 : s.call(o);
    };
  } })];
}
let GF = Symbol("PortalGroupContext");
ve({ name: "PortalGroup", props: { as: { type: [Object, String], default: "template" }, target: { type: Object, default: null } }, setup(n, { attrs: e, slots: t }) {
  let r = Sr({ resolveTarget() {
    return n.target;
  } });
  return zn(GF, r), () => {
    let { target: i, ...a } = n;
    return Kn({ theirProps: a, ourProps: {}, slot: {}, attrs: e, slots: t, name: "PortalGroup" });
  };
} });
var NJ = ((n) => (n[n.Open = 0] = "Open", n[n.Closed = 1] = "Closed", n))(NJ || {});
let UF = Symbol("PopoverContext");
function q_(n) {
  let e = Xt(UF, null);
  if (e === null) {
    let t = new Error(`<${n} /> is missing a parent <${KF.name} /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t, q_), t;
  }
  return e;
}
let WF = Symbol("PopoverGroupContext");
function qF() {
  return Xt(WF, null);
}
let YF = Symbol("PopoverPanelContext");
function RJ() {
  return Xt(YF, null);
}
let KF = ve({ name: "Popover", inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" } }, setup(n, { slots: e, attrs: t, expose: r }) {
  var i;
  let a = Z(null);
  r({ el: a, $el: a });
  let o = Z(1), s = Z(null), l = Z(null), u = Z(null), c = Z(null), d = K(() => Zi(a)), f = K(() => {
    var x, w;
    if (!Ue(s) || !Ue(c)) return !1;
    for (let R of document.querySelectorAll("body > *")) if (Number(R == null ? void 0 : R.contains(Ue(s))) ^ Number(R == null ? void 0 : R.contains(Ue(c)))) return !0;
    let S = U_(), C = S.indexOf(Ue(s)), k = (C + S.length - 1) % S.length, M = (C + 1) % S.length, D = S[k], N = S[M];
    return !((x = Ue(c)) != null && x.contains(D)) && !((w = Ue(c)) != null && w.contains(N));
  }), p = { popoverState: o, buttonId: Z(null), panelId: Z(null), panel: c, button: s, isPortalled: f, beforePanelSentinel: l, afterPanelSentinel: u, togglePopover() {
    o.value = Mr(o.value, { 0: 1, 1: 0 });
  }, closePopover() {
    o.value !== 1 && (o.value = 1);
  }, close(x) {
    p.closePopover();
    let w = x ? x instanceof HTMLElement ? x : x.value instanceof HTMLElement ? Ue(x) : Ue(p.button) : Ue(p.button);
    w == null || w.focus();
  } };
  zn(UF, p), DF(K(() => Mr(o.value, { 0: Eo.Open, 1: Eo.Closed })));
  let h = { buttonId: p.buttonId, panelId: p.panelId, close() {
    p.closePopover();
  } }, v = qF(), m = v == null ? void 0 : v.registerPopover, [g, y] = LJ(), b = CJ({ mainTreeNodeRef: v == null ? void 0 : v.mainTreeNodeRef, portals: g, defaultContainers: [s, c] });
  function _() {
    var x, w, S, C;
    return (C = v == null ? void 0 : v.isFocusWithinPopoverGroup()) != null ? C : ((x = d.value) == null ? void 0 : x.activeElement) && (((w = Ue(s)) == null ? void 0 : w.contains(d.value.activeElement)) || ((S = Ue(c)) == null ? void 0 : S.contains(d.value.activeElement)));
  }
  return Cn(() => m == null ? void 0 : m(h)), TJ((i = d.value) == null ? void 0 : i.defaultView, "focus", (x) => {
    var w, S;
    x.target !== window && x.target instanceof HTMLElement && o.value === 0 && (_() || s && c && (b.contains(x.target) || (w = Ue(p.beforePanelSentinel)) != null && w.contains(x.target) || (S = Ue(p.afterPanelSentinel)) != null && S.contains(x.target) || p.closePopover()));
  }, !0), TF(b.resolveContainers, (x, w) => {
    var S;
    p.closePopover(), wF(w, IA.Loose) || (x.preventDefault(), (S = Ue(s)) == null || S.focus());
  }, K(() => o.value === 0)), () => {
    let x = { open: o.value === 0, close: p.close };
    return qt(Ke, [qt(y, {}, () => Kn({ theirProps: { ...n, ...t }, ourProps: { ref: a }, slot: x, slots: e, attrs: t, name: "Popover" })), qt(b.MainTreeNode)]);
  };
} }), PJ = ve({ name: "PopoverButton", props: { as: { type: [Object, String], default: "button" }, disabled: { type: [Boolean], default: !1 }, id: { type: String, default: null } }, inheritAttrs: !1, setup(n, { attrs: e, slots: t, expose: r }) {
  var i;
  let a = (i = n.id) != null ? i : `headlessui-popover-button-${Fr()}`, o = q_("PopoverButton"), s = K(() => Zi(o.button));
  r({ el: o.button, $el: o.button }), kt(() => {
    o.buttonId.value = a;
  }), Nn(() => {
    o.buttonId.value = null;
  });
  let l = qF(), u = l == null ? void 0 : l.closeOthers, c = RJ(), d = K(() => c === null ? !1 : c.value === o.panelId.value), f = Z(null), p = `headlessui-focus-sentinel-${Fr()}`;
  d.value || Cn(() => {
    o.button.value = Ue(f);
  });
  let h = W_(K(() => ({ as: n.as, type: e.type })), f);
  function v(x) {
    var w, S, C, k, M;
    if (d.value) {
      if (o.popoverState.value === 1) return;
      switch (x.key) {
        case un.Space:
        case un.Enter:
          x.preventDefault(), (S = (w = x.target).click) == null || S.call(w), o.closePopover(), (C = Ue(o.button)) == null || C.focus();
          break;
      }
    } else switch (x.key) {
      case un.Space:
      case un.Enter:
        x.preventDefault(), x.stopPropagation(), o.popoverState.value === 1 && (u == null || u(o.buttonId.value)), o.togglePopover();
        break;
      case un.Escape:
        if (o.popoverState.value !== 0) return u == null ? void 0 : u(o.buttonId.value);
        if (!Ue(o.button) || (k = s.value) != null && k.activeElement && !((M = Ue(o.button)) != null && M.contains(s.value.activeElement))) return;
        x.preventDefault(), x.stopPropagation(), o.closePopover();
        break;
    }
  }
  function m(x) {
    d.value || x.key === un.Space && x.preventDefault();
  }
  function g(x) {
    var w, S;
    n.disabled || (d.value ? (o.closePopover(), (w = Ue(o.button)) == null || w.focus()) : (x.preventDefault(), x.stopPropagation(), o.popoverState.value === 1 && (u == null || u(o.buttonId.value)), o.togglePopover(), (S = Ue(o.button)) == null || S.focus()));
  }
  function y(x) {
    x.preventDefault(), x.stopPropagation();
  }
  let b = FF();
  function _() {
    let x = Ue(o.panel);
    if (!x) return;
    function w() {
      Mr(b.value, { [Zs.Forwards]: () => ki(x, rr.First), [Zs.Backwards]: () => ki(x, rr.Last) }) === ns.Error && ki(U_().filter((S) => S.dataset.headlessuiFocusGuard !== "true"), Mr(b.value, { [Zs.Forwards]: rr.Next, [Zs.Backwards]: rr.Previous }), { relativeTo: Ue(o.button) });
    }
    w();
  }
  return () => {
    let x = o.popoverState.value === 0, w = { open: x }, { ...S } = n, C = d.value ? { ref: f, type: h.value, onKeydown: v, onClick: g } : { ref: f, id: a, type: h.value, "aria-expanded": o.popoverState.value === 0, "aria-controls": Ue(o.panel) ? o.panelId.value : void 0, disabled: n.disabled ? !0 : void 0, onKeydown: v, onKeyup: m, onClick: g, onMousedown: y };
    return qt(Ke, [Kn({ ourProps: C, theirProps: { ...e, ...S }, slot: w, attrs: e, slots: t, name: "PopoverButton" }), x && !d.value && o.isPortalled.value && qt(ms, { id: p, features: vs.Focusable, "data-headlessui-focus-guard": !0, as: "button", type: "button", onFocus: _ })]);
  };
} });
ve({ name: "PopoverOverlay", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 } }, setup(n, { attrs: e, slots: t }) {
  let r = q_("PopoverOverlay"), i = `headlessui-popover-overlay-${Fr()}`, a = NA(), o = K(() => a !== null ? (a.value & Eo.Open) === Eo.Open : r.popoverState.value === 0);
  function s() {
    r.closePopover();
  }
  return () => {
    let l = { open: r.popoverState.value === 0 };
    return Kn({ ourProps: { id: i, "aria-hidden": !0, onClick: s }, theirProps: n, slot: l, attrs: e, slots: t, features: So.RenderStrategy | So.Static, visible: o.value, name: "PopoverOverlay" });
  };
} });
let jJ = ve({ name: "PopoverPanel", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, focus: { type: Boolean, default: !1 }, id: { type: String, default: null } }, inheritAttrs: !1, setup(n, { attrs: e, slots: t, expose: r }) {
  var i;
  let a = (i = n.id) != null ? i : `headlessui-popover-panel-${Fr()}`, { focus: o } = n, s = q_("PopoverPanel"), l = K(() => Zi(s.panel)), u = `headlessui-focus-sentinel-before-${Fr()}`, c = `headlessui-focus-sentinel-after-${Fr()}`;
  r({ el: s.panel, $el: s.panel }), kt(() => {
    s.panelId.value = a;
  }), Nn(() => {
    s.panelId.value = null;
  }), zn(YF, s.panelId), Cn(() => {
    var y, b;
    if (!o || s.popoverState.value !== 0 || !s.panel) return;
    let _ = (y = l.value) == null ? void 0 : y.activeElement;
    (b = Ue(s.panel)) != null && b.contains(_) || ki(Ue(s.panel), rr.First);
  });
  let d = NA(), f = K(() => d !== null ? (d.value & Eo.Open) === Eo.Open : s.popoverState.value === 0);
  function p(y) {
    var b, _;
    switch (y.key) {
      case un.Escape:
        if (s.popoverState.value !== 0 || !Ue(s.panel) || l.value && !((b = Ue(s.panel)) != null && b.contains(l.value.activeElement))) return;
        y.preventDefault(), y.stopPropagation(), s.closePopover(), (_ = Ue(s.button)) == null || _.focus();
        break;
    }
  }
  function h(y) {
    var b, _, x, w, S;
    let C = y.relatedTarget;
    C && Ue(s.panel) && ((b = Ue(s.panel)) != null && b.contains(C) || (s.closePopover(), ((x = (_ = Ue(s.beforePanelSentinel)) == null ? void 0 : _.contains) != null && x.call(_, C) || (S = (w = Ue(s.afterPanelSentinel)) == null ? void 0 : w.contains) != null && S.call(w, C)) && C.focus({ preventScroll: !0 })));
  }
  let v = FF();
  function m() {
    let y = Ue(s.panel);
    if (!y) return;
    function b() {
      Mr(v.value, { [Zs.Forwards]: () => {
        var _;
        ki(y, rr.First) === ns.Error && ((_ = Ue(s.afterPanelSentinel)) == null || _.focus());
      }, [Zs.Backwards]: () => {
        var _;
        (_ = Ue(s.button)) == null || _.focus({ preventScroll: !0 });
      } });
    }
    b();
  }
  function g() {
    let y = Ue(s.panel);
    if (!y) return;
    function b() {
      Mr(v.value, { [Zs.Forwards]: () => {
        let _ = Ue(s.button), x = Ue(s.panel);
        if (!_) return;
        let w = U_(), S = w.indexOf(_), C = w.slice(0, S + 1), k = [...w.slice(S + 1), ...C];
        for (let M of k.slice()) if (M.dataset.headlessuiFocusGuard === "true" || x != null && x.contains(M)) {
          let D = k.indexOf(M);
          D !== -1 && k.splice(D, 1);
        }
        ki(k, rr.First, { sorted: !1 });
      }, [Zs.Backwards]: () => {
        var _;
        ki(y, rr.Previous) === ns.Error && ((_ = Ue(s.button)) == null || _.focus());
      } });
    }
    b();
  }
  return () => {
    let y = { open: s.popoverState.value === 0, close: s.close }, { focus: b, ..._ } = n, x = { ref: s.panel, id: a, onKeydown: p, onFocusout: o && s.popoverState.value === 0 ? h : void 0, tabIndex: -1 };
    return Kn({ ourProps: x, theirProps: { ...e, ..._ }, attrs: e, slot: y, slots: { ...t, default: (...w) => {
      var S;
      return [qt(Ke, [f.value && s.isPortalled.value && qt(ms, { id: u, ref: s.beforePanelSentinel, features: vs.Focusable, "data-headlessui-focus-guard": !0, as: "button", type: "button", onFocus: m }), (S = t.default) == null ? void 0 : S.call(t, ...w), f.value && s.isPortalled.value && qt(ms, { id: c, ref: s.afterPanelSentinel, features: vs.Focusable, "data-headlessui-focus-guard": !0, as: "button", type: "button", onFocus: g })])];
    } }, features: So.RenderStrategy | So.Static, visible: f.value, name: "PopoverPanel" });
  };
} });
ve({ name: "PopoverGroup", inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" } }, setup(n, { attrs: e, slots: t, expose: r }) {
  let i = Z(null), a = Bd([]), o = K(() => Zi(i)), s = kJ();
  r({ el: i, $el: i });
  function l(f) {
    let p = a.value.indexOf(f);
    p !== -1 && a.value.splice(p, 1);
  }
  function u(f) {
    return a.value.push(f), () => {
      l(f);
    };
  }
  function c() {
    var f;
    let p = o.value;
    if (!p) return !1;
    let h = p.activeElement;
    return (f = Ue(i)) != null && f.contains(h) ? !0 : a.value.some((v) => {
      var m, g;
      return ((m = p.getElementById(v.buttonId.value)) == null ? void 0 : m.contains(h)) || ((g = p.getElementById(v.panelId.value)) == null ? void 0 : g.contains(h));
    });
  }
  function d(f) {
    for (let p of a.value) p.buttonId.value !== f && p.close();
  }
  return zn(WF, { registerPopover: u, unregisterPopover: l, isFocusWithinPopoverGroup: c, closeOthers: d, mainTreeNodeRef: s.mainTreeNodeRef }), () => qt(Ke, [Kn({ ourProps: { ref: i }, theirProps: { ...n, ...e }, slot: {}, attrs: e, slots: t, name: "PopoverGroup" }), qt(s.MainTreeNode)]);
} });
let XF = Symbol("LabelContext");
function ZF() {
  let n = Xt(XF, null);
  if (n === null) {
    let e = new Error("You used a <Label /> component, but it is not inside a parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(e, ZF), e;
  }
  return n;
}
function jA({ slot: n = {}, name: e = "Label", props: t = {} } = {}) {
  let r = Z([]);
  function i(a) {
    return r.value.push(a), () => {
      let o = r.value.indexOf(a);
      o !== -1 && r.value.splice(o, 1);
    };
  }
  return zn(XF, { register: i, slot: n, name: e, props: t }), K(() => r.value.length > 0 ? r.value.join(" ") : void 0);
}
let JF = ve({ name: "Label", props: { as: { type: [Object, String], default: "label" }, passive: { type: [Boolean], default: !1 }, id: { type: String, default: null } }, setup(n, { slots: e, attrs: t }) {
  var r;
  let i = (r = n.id) != null ? r : `headlessui-label-${Fr()}`, a = ZF();
  return kt(() => Nn(a.register(i))), () => {
    let { name: o = "Label", slot: s = {}, props: l = {} } = a, { passive: u, ...c } = n, d = { ...Object.entries(l).reduce((f, [p, h]) => Object.assign(f, { [p]: O(h) }), {}), id: i };
    return u && (delete d.onClick, delete d.htmlFor, delete c.onClick), Kn({ ourProps: d, theirProps: c, slot: s, attrs: t, slots: e, name: o });
  };
} });
function BJ(n, e) {
  return n === e;
}
let QF = Symbol("RadioGroupContext");
function eV(n) {
  let e = Xt(QF, null);
  if (e === null) {
    let t = new Error(`<${n} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t, eV), t;
  }
  return e;
}
let $J = ve({ name: "RadioGroup", emits: { "update:modelValue": (n) => !0 }, props: { as: { type: [Object, String], default: "div" }, disabled: { type: [Boolean], default: !1 }, by: { type: [String, Function], default: () => BJ }, modelValue: { type: [Object, String, Number, Boolean], default: void 0 }, defaultValue: { type: [Object, String, Number, Boolean], default: void 0 }, form: { type: String, optional: !0 }, name: { type: String, optional: !0 }, id: { type: String, default: null } }, inheritAttrs: !1, setup(n, { emit: e, attrs: t, slots: r, expose: i }) {
  var a;
  let o = (a = n.id) != null ? a : `headlessui-radiogroup-${Fr()}`, s = Z(null), l = Z([]), u = jA({ name: "RadioGroupLabel" }), c = PA({ name: "RadioGroupDescription" });
  i({ el: s, $el: s });
  let [d, f] = OA(K(() => n.modelValue), (m) => e("update:modelValue", m), K(() => n.defaultValue)), p = { options: l, value: d, disabled: K(() => n.disabled), firstOption: K(() => l.value.find((m) => !m.propsRef.disabled)), containsCheckedOption: K(() => l.value.some((m) => p.compare(li(m.propsRef.value), li(n.modelValue)))), compare(m, g) {
    if (typeof n.by == "string") {
      let y = n.by;
      return (m == null ? void 0 : m[y]) === (g == null ? void 0 : g[y]);
    }
    return n.by(m, g);
  }, change(m) {
    var g;
    if (n.disabled || p.compare(li(d.value), li(m))) return !1;
    let y = (g = l.value.find((b) => p.compare(li(b.propsRef.value), li(m)))) == null ? void 0 : g.propsRef;
    return y != null && y.disabled ? !1 : (f(m), !0);
  }, registerOption(m) {
    l.value.push(m), l.value = nu(l.value, (g) => g.element);
  }, unregisterOption(m) {
    let g = l.value.findIndex((y) => y.id === m);
    g !== -1 && l.value.splice(g, 1);
  } };
  zn(QF, p), CF({ container: K(() => Ue(s)), accept(m) {
    return m.getAttribute("role") === "radio" ? NodeFilter.FILTER_REJECT : m.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(m) {
    m.setAttribute("role", "none");
  } });
  function h(m) {
    if (!s.value || !s.value.contains(m.target)) return;
    let g = l.value.filter((y) => y.propsRef.disabled === !1).map((y) => y.element);
    switch (m.key) {
      case un.Enter:
        NF(m.currentTarget);
        break;
      case un.ArrowLeft:
      case un.ArrowUp:
        if (m.preventDefault(), m.stopPropagation(), ki(g, rr.Previous | rr.WrapAround) === ns.Success) {
          let y = l.value.find((b) => {
            var _;
            return b.element === ((_ = Zi(s)) == null ? void 0 : _.activeElement);
          });
          y && p.change(y.propsRef.value);
        }
        break;
      case un.ArrowRight:
      case un.ArrowDown:
        if (m.preventDefault(), m.stopPropagation(), ki(g, rr.Next | rr.WrapAround) === ns.Success) {
          let y = l.value.find((b) => {
            var _;
            return b.element === ((_ = Zi(b.element)) == null ? void 0 : _.activeElement);
          });
          y && p.change(y.propsRef.value);
        }
        break;
      case un.Space:
        {
          m.preventDefault(), m.stopPropagation();
          let y = l.value.find((b) => {
            var _;
            return b.element === ((_ = Zi(b.element)) == null ? void 0 : _.activeElement);
          });
          y && p.change(y.propsRef.value);
        }
        break;
    }
  }
  let v = K(() => {
    var m;
    return (m = Ue(s)) == null ? void 0 : m.closest("form");
  });
  return kt(() => {
    et([v], () => {
      if (!v.value || n.defaultValue === void 0) return;
      function m() {
        p.change(n.defaultValue);
      }
      return v.value.addEventListener("reset", m), () => {
        var g;
        (g = v.value) == null || g.removeEventListener("reset", m);
      };
    }, { immediate: !0 });
  }), () => {
    let { disabled: m, name: g, form: y, ...b } = n, _ = { ref: s, id: o, role: "radiogroup", "aria-labelledby": u.value, "aria-describedby": c.value, onKeydown: h };
    return qt(Ke, [...g != null && d.value != null ? RA({ [g]: d.value }).map(([x, w]) => qt(ms, LA({ features: vs.Hidden, key: x, as: "input", type: "hidden", hidden: !0, readOnly: !0, form: y, disabled: m, name: x, value: w }))) : [], Kn({ ourProps: _, theirProps: { ...t, ...zd(b, ["modelValue", "defaultValue", "by"]) }, slot: {}, attrs: t, slots: r, name: "RadioGroup" })]);
  };
} });
var zJ = ((n) => (n[n.Empty = 1] = "Empty", n[n.Active = 2] = "Active", n))(zJ || {});
let FJ = ve({ name: "RadioGroupOption", props: { as: { type: [Object, String], default: "div" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: !1 }, id: { type: String, default: null } }, setup(n, { attrs: e, slots: t, expose: r }) {
  var i;
  let a = (i = n.id) != null ? i : `headlessui-radiogroup-option-${Fr()}`, o = eV("RadioGroupOption"), s = jA({ name: "RadioGroupLabel" }), l = PA({ name: "RadioGroupDescription" }), u = Z(null), c = K(() => ({ value: n.value, disabled: n.disabled })), d = Z(1);
  r({ el: u, $el: u });
  let f = K(() => Ue(u));
  kt(() => o.registerOption({ id: a, element: f, propsRef: c })), Nn(() => o.unregisterOption(a));
  let p = K(() => {
    var _;
    return ((_ = o.firstOption.value) == null ? void 0 : _.id) === a;
  }), h = K(() => o.disabled.value || n.disabled), v = K(() => o.compare(li(o.value.value), li(n.value))), m = K(() => h.value ? -1 : v.value || !o.containsCheckedOption.value && p.value ? 0 : -1);
  function g() {
    var _;
    o.change(n.value) && (d.value |= 2, (_ = Ue(u)) == null || _.focus());
  }
  function y() {
    d.value |= 2;
  }
  function b() {
    d.value &= -3;
  }
  return () => {
    let { value: _, disabled: x, ...w } = n, S = { checked: v.value, disabled: h.value, active: !!(d.value & 2) }, C = { id: a, ref: u, role: "radio", "aria-checked": v.value ? "true" : "false", "aria-labelledby": s.value, "aria-describedby": l.value, "aria-disabled": h.value ? !0 : void 0, tabIndex: m.value, onClick: h.value ? void 0 : g, onFocus: h.value ? void 0 : y, onBlur: h.value ? void 0 : b };
    return Kn({ ourProps: C, theirProps: w, slot: S, attrs: e, slots: t, name: "RadioGroupOption" });
  };
} }), VJ = JF, tV = Symbol("GroupContext"), HJ = ve({ name: "SwitchGroup", props: { as: { type: [Object, String], default: "template" } }, setup(n, { slots: e, attrs: t }) {
  let r = Z(null), i = jA({ name: "SwitchLabel", props: { htmlFor: K(() => {
    var o;
    return (o = r.value) == null ? void 0 : o.id;
  }), onClick(o) {
    r.value && (o.currentTarget.tagName === "LABEL" && o.preventDefault(), r.value.click(), r.value.focus({ preventScroll: !0 }));
  } } }), a = PA({ name: "SwitchDescription" });
  return zn(tV, { switchRef: r, labelledby: i, describedby: a }), () => Kn({ theirProps: n, ourProps: {}, slot: {}, slots: e, attrs: t, name: "SwitchGroup" });
} }), GJ = ve({ name: "Switch", emits: { "update:modelValue": (n) => !0 }, props: { as: { type: [Object, String], default: "button" }, modelValue: { type: Boolean, default: void 0 }, defaultChecked: { type: Boolean, optional: !0 }, form: { type: String, optional: !0 }, name: { type: String, optional: !0 }, value: { type: String, optional: !0 }, id: { type: String, default: null }, disabled: { type: Boolean, default: !1 }, tabIndex: { type: Number, default: 0 } }, inheritAttrs: !1, setup(n, { emit: e, attrs: t, slots: r, expose: i }) {
  var a;
  let o = (a = n.id) != null ? a : `headlessui-switch-${Fr()}`, s = Xt(tV, null), [l, u] = OA(K(() => n.modelValue), (y) => e("update:modelValue", y), K(() => n.defaultChecked));
  function c() {
    u(!l.value);
  }
  let d = Z(null), f = s === null ? d : s.switchRef, p = W_(K(() => ({ as: n.as, type: t.type })), f);
  i({ el: f, $el: f });
  function h(y) {
    y.preventDefault(), c();
  }
  function v(y) {
    y.key === un.Space ? (y.preventDefault(), c()) : y.key === un.Enter && NF(y.currentTarget);
  }
  function m(y) {
    y.preventDefault();
  }
  let g = K(() => {
    var y, b;
    return (b = (y = Ue(f)) == null ? void 0 : y.closest) == null ? void 0 : b.call(y, "form");
  });
  return kt(() => {
    et([g], () => {
      if (!g.value || n.defaultChecked === void 0) return;
      function y() {
        u(n.defaultChecked);
      }
      return g.value.addEventListener("reset", y), () => {
        var b;
        (b = g.value) == null || b.removeEventListener("reset", y);
      };
    }, { immediate: !0 });
  }), () => {
    let { name: y, value: b, form: _, tabIndex: x, ...w } = n, S = { checked: l.value }, C = { id: o, ref: f, role: "switch", type: p.value, tabIndex: x === -1 ? 0 : x, "aria-checked": l.value, "aria-labelledby": s == null ? void 0 : s.labelledby.value, "aria-describedby": s == null ? void 0 : s.describedby.value, onClick: h, onKeyup: v, onKeypress: m };
    return qt(Ke, [y != null && l.value != null ? qt(ms, LA({ features: vs.Hidden, as: "input", type: "checkbox", hidden: !0, readOnly: !0, checked: l.value, form: _, disabled: w.disabled, name: y, value: b })) : null, Kn({ ourProps: C, theirProps: { ...t, ...zd(w, ["modelValue", "defaultChecked"]) }, slot: S, attrs: t, slots: r, name: "Switch" })]);
  };
} }), UJ = JF, WJ = DJ, qJ = ve({ props: { onFocus: { type: Function, required: !0 } }, setup(n) {
  let e = Z(!0);
  return () => e.value ? qt(ms, { as: "button", type: "button", features: vs.Focusable, onFocus(t) {
    t.preventDefault();
    let r, i = 50;
    function a() {
      var o;
      if (i-- <= 0) {
        r && cancelAnimationFrame(r);
        return;
      }
      if ((o = n.onFocus) != null && o.call(n)) {
        e.value = !1, cancelAnimationFrame(r);
        return;
      }
      r = requestAnimationFrame(a);
    }
    r = requestAnimationFrame(a);
  } }) : null;
} });
var YJ = ((n) => (n[n.Forwards = 0] = "Forwards", n[n.Backwards = 1] = "Backwards", n))(YJ || {}), KJ = ((n) => (n[n.Less = -1] = "Less", n[n.Equal = 0] = "Equal", n[n.Greater = 1] = "Greater", n))(KJ || {});
let nV = Symbol("TabsContext");
function Sg(n) {
  let e = Xt(nV, null);
  if (e === null) {
    let t = new Error(`<${n} /> is missing a parent <TabGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t, Sg), t;
  }
  return e;
}
let BA = Symbol("TabsSSRContext"), XJ = ve({ name: "TabGroup", emits: { change: (n) => !0 }, props: { as: { type: [Object, String], default: "template" }, selectedIndex: { type: [Number], default: null }, defaultIndex: { type: [Number], default: 0 }, vertical: { type: [Boolean], default: !1 }, manual: { type: [Boolean], default: !1 } }, inheritAttrs: !1, setup(n, { slots: e, attrs: t, emit: r }) {
  var i;
  let a = Z((i = n.selectedIndex) != null ? i : n.defaultIndex), o = Z([]), s = Z([]), l = K(() => n.selectedIndex !== null), u = K(() => l.value ? n.selectedIndex : a.value);
  function c(v) {
    var m;
    let g = nu(d.tabs.value, Ue), y = nu(d.panels.value, Ue), b = g.filter((_) => {
      var x;
      return !((x = Ue(_)) != null && x.hasAttribute("disabled"));
    });
    if (v < 0 || v > g.length - 1) {
      let _ = Mr(a.value === null ? 0 : Math.sign(v - a.value), { [-1]: () => 1, 0: () => Mr(Math.sign(v), { [-1]: () => 0, 0: () => 0, 1: () => 1 }), 1: () => 0 }), x = Mr(_, { 0: () => g.indexOf(b[0]), 1: () => g.indexOf(b[b.length - 1]) });
      x !== -1 && (a.value = x), d.tabs.value = g, d.panels.value = y;
    } else {
      let _ = g.slice(0, v), x = [...g.slice(v), ..._].find((S) => b.includes(S));
      if (!x) return;
      let w = (m = g.indexOf(x)) != null ? m : d.selectedIndex.value;
      w === -1 && (w = d.selectedIndex.value), a.value = w, d.tabs.value = g, d.panels.value = y;
    }
  }
  let d = { selectedIndex: K(() => {
    var v, m;
    return (m = (v = a.value) != null ? v : n.defaultIndex) != null ? m : null;
  }), orientation: K(() => n.vertical ? "vertical" : "horizontal"), activation: K(() => n.manual ? "manual" : "auto"), tabs: o, panels: s, setSelectedIndex(v) {
    u.value !== v && r("change", v), l.value || c(v);
  }, registerTab(v) {
    var m;
    if (o.value.includes(v)) return;
    let g = o.value[a.value];
    if (o.value.push(v), o.value = nu(o.value, Ue), !l.value) {
      let y = (m = o.value.indexOf(g)) != null ? m : a.value;
      y !== -1 && (a.value = y);
    }
  }, unregisterTab(v) {
    let m = o.value.indexOf(v);
    m !== -1 && o.value.splice(m, 1);
  }, registerPanel(v) {
    s.value.includes(v) || (s.value.push(v), s.value = nu(s.value, Ue));
  }, unregisterPanel(v) {
    let m = s.value.indexOf(v);
    m !== -1 && s.value.splice(m, 1);
  } };
  zn(nV, d);
  let f = Z({ tabs: [], panels: [] }), p = Z(!1);
  kt(() => {
    p.value = !0;
  }), zn(BA, K(() => p.value ? null : f.value));
  let h = K(() => n.selectedIndex);
  return kt(() => {
    et([h], () => {
      var v;
      return c((v = n.selectedIndex) != null ? v : n.defaultIndex);
    }, { immediate: !0 });
  }), Cn(() => {
    if (!l.value || u.value == null || d.tabs.value.length <= 0) return;
    let v = nu(d.tabs.value, Ue);
    v.some((m, g) => Ue(d.tabs.value[g]) !== Ue(m)) && d.setSelectedIndex(v.findIndex((m) => Ue(m) === Ue(d.tabs.value[u.value])));
  }), () => {
    let v = { selectedIndex: a.value };
    return qt(Ke, [o.value.length <= 0 && qt(qJ, { onFocus: () => {
      for (let m of o.value) {
        let g = Ue(m);
        if ((g == null ? void 0 : g.tabIndex) === 0) return g.focus(), !0;
      }
      return !1;
    } }), Kn({ theirProps: { ...t, ...zd(n, ["selectedIndex", "defaultIndex", "manual", "vertical", "onChange"]) }, ourProps: {}, slot: v, slots: e, attrs: t, name: "TabGroup" })]);
  };
} }), ZJ = ve({ name: "TabList", props: { as: { type: [Object, String], default: "div" } }, setup(n, { attrs: e, slots: t }) {
  let r = Sg("TabList");
  return () => {
    let i = { selectedIndex: r.selectedIndex.value }, a = { role: "tablist", "aria-orientation": r.orientation.value };
    return Kn({ ourProps: a, theirProps: n, slot: i, attrs: e, slots: t, name: "TabList" });
  };
} }), JJ = ve({ name: "Tab", props: { as: { type: [Object, String], default: "button" }, disabled: { type: [Boolean], default: !1 }, id: { type: String, default: null } }, setup(n, { attrs: e, slots: t, expose: r }) {
  var i;
  let a = (i = n.id) != null ? i : `headlessui-tabs-tab-${Fr()}`, o = Sg("Tab"), s = Z(null);
  r({ el: s, $el: s }), kt(() => o.registerTab(s)), Nn(() => o.unregisterTab(s));
  let l = Xt(BA), u = K(() => {
    if (l.value) {
      let y = l.value.tabs.indexOf(a);
      return y === -1 ? l.value.tabs.push(a) - 1 : y;
    }
    return -1;
  }), c = K(() => {
    let y = o.tabs.value.indexOf(s);
    return y === -1 ? u.value : y;
  }), d = K(() => c.value === o.selectedIndex.value);
  function f(y) {
    var b;
    let _ = y();
    if (_ === ns.Success && o.activation.value === "auto") {
      let x = (b = Zi(s)) == null ? void 0 : b.activeElement, w = o.tabs.value.findIndex((S) => Ue(S) === x);
      w !== -1 && o.setSelectedIndex(w);
    }
    return _;
  }
  function p(y) {
    let b = o.tabs.value.map((_) => Ue(_)).filter(Boolean);
    if (y.key === un.Space || y.key === un.Enter) {
      y.preventDefault(), y.stopPropagation(), o.setSelectedIndex(c.value);
      return;
    }
    switch (y.key) {
      case un.Home:
      case un.PageUp:
        return y.preventDefault(), y.stopPropagation(), f(() => ki(b, rr.First));
      case un.End:
      case un.PageDown:
        return y.preventDefault(), y.stopPropagation(), f(() => ki(b, rr.Last));
    }
    if (f(() => Mr(o.orientation.value, { vertical() {
      return y.key === un.ArrowUp ? ki(b, rr.Previous | rr.WrapAround) : y.key === un.ArrowDown ? ki(b, rr.Next | rr.WrapAround) : ns.Error;
    }, horizontal() {
      return y.key === un.ArrowLeft ? ki(b, rr.Previous | rr.WrapAround) : y.key === un.ArrowRight ? ki(b, rr.Next | rr.WrapAround) : ns.Error;
    } })) === ns.Success) return y.preventDefault();
  }
  let h = Z(!1);
  function v() {
    var y;
    h.value || (h.value = !0, !n.disabled && ((y = Ue(s)) == null || y.focus({ preventScroll: !0 }), o.setSelectedIndex(c.value), xF(() => {
      h.value = !1;
    })));
  }
  function m(y) {
    y.preventDefault();
  }
  let g = W_(K(() => ({ as: n.as, type: e.type })), s);
  return () => {
    var y, b;
    let _ = { selected: d.value, disabled: (y = n.disabled) != null ? y : !1 }, { ...x } = n, w = { ref: s, onKeydown: p, onMousedown: m, onClick: v, id: a, role: "tab", type: g.value, "aria-controls": (b = Ue(o.panels.value[c.value])) == null ? void 0 : b.id, "aria-selected": d.value, tabIndex: d.value ? 0 : -1, disabled: n.disabled ? !0 : void 0 };
    return Kn({ ourProps: w, theirProps: x, slot: _, attrs: e, slots: t, name: "Tab" });
  };
} }), QJ = ve({ name: "TabPanels", props: { as: { type: [Object, String], default: "div" } }, setup(n, { slots: e, attrs: t }) {
  let r = Sg("TabPanels");
  return () => {
    let i = { selectedIndex: r.selectedIndex.value };
    return Kn({ theirProps: n, ourProps: {}, slot: i, attrs: t, slots: e, name: "TabPanels" });
  };
} }), eQ = ve({ name: "TabPanel", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, id: { type: String, default: null }, tabIndex: { type: Number, default: 0 } }, setup(n, { attrs: e, slots: t, expose: r }) {
  var i;
  let a = (i = n.id) != null ? i : `headlessui-tabs-panel-${Fr()}`, o = Sg("TabPanel"), s = Z(null);
  r({ el: s, $el: s }), kt(() => o.registerPanel(s)), Nn(() => o.unregisterPanel(s));
  let l = Xt(BA), u = K(() => {
    if (l.value) {
      let f = l.value.panels.indexOf(a);
      return f === -1 ? l.value.panels.push(a) - 1 : f;
    }
    return -1;
  }), c = K(() => {
    let f = o.panels.value.indexOf(s);
    return f === -1 ? u.value : f;
  }), d = K(() => c.value === o.selectedIndex.value);
  return () => {
    var f;
    let p = { selected: d.value }, { tabIndex: h, ...v } = n, m = { ref: s, id: a, role: "tabpanel", "aria-labelledby": (f = Ue(o.tabs.value[c.value])) == null ? void 0 : f.id, tabIndex: d.value ? h : -1 };
    return !d.value && n.unmount && !n.static ? qt(ms, { as: "span", "aria-hidden": !0, ...m }) : Kn({ ourProps: m, theirProps: v, slot: p, attrs: e, slots: t, features: So.Static | So.RenderStrategy, visible: d.value, name: "TabPanel" });
  };
} });
function uL(n) {
  return typeof n == "string" ? `'${n}'` : new tQ().serialize(n);
}
const tQ = /* @__PURE__ */ function() {
  var e;
  class n {
    constructor() {
      XI(this, e, /* @__PURE__ */ new Map());
    }
    compare(r, i) {
      const a = typeof r, o = typeof i;
      return a === "string" && o === "string" ? r.localeCompare(i) : a === "number" && o === "number" ? r - i : String.prototype.localeCompare.call(this.serialize(r, !0), this.serialize(i, !0));
    }
    serialize(r, i) {
      if (r === null) return "null";
      switch (typeof r) {
        case "string":
          return i ? r : `'${r}'`;
        case "bigint":
          return `${r}n`;
        case "object":
          return this.$object(r);
        case "function":
          return this.$function(r);
      }
      return String(r);
    }
    serializeObject(r) {
      const i = Object.prototype.toString.call(r);
      if (i !== "[object Object]") return this.serializeBuiltInType(i.length < 10 ? `unknown:${i}` : i.slice(8, -1), r);
      const a = r.constructor, o = a === Object || a === void 0 ? "" : a.name;
      if (o !== "" && globalThis[o] === a) return this.serializeBuiltInType(o, r);
      if (typeof r.toJSON == "function") {
        const s = r.toJSON();
        return o + (s !== null && typeof s == "object" ? this.$object(s) : `(${this.serialize(s)})`);
      }
      return this.serializeObjectEntries(o, Object.entries(r));
    }
    serializeBuiltInType(r, i) {
      const a = this["$" + r];
      if (a) return a.call(this, i);
      if (typeof (i == null ? void 0 : i.entries) == "function") return this.serializeObjectEntries(r, i.entries());
      throw new Error(`Cannot serialize ${r}`);
    }
    serializeObjectEntries(r, i) {
      const a = Array.from(i).sort((s, l) => this.compare(s[0], l[0]));
      let o = `${r}{`;
      for (let s = 0; s < a.length; s++) {
        const [l, u] = a[s];
        o += `${this.serialize(l, !0)}:${this.serialize(u)}`, s < a.length - 1 && (o += ",");
      }
      return o + "}";
    }
    $object(r) {
      let i = Ih(this, e).get(r);
      return i === void 0 && (Ih(this, e).set(r, `#${Ih(this, e).size}`), i = this.serializeObject(r), Ih(this, e).set(r, i)), i;
    }
    $function(r) {
      const i = Function.prototype.toString.call(r);
      return i.slice(-15) === "[native code] }" ? `${r.name || ""}()[native]` : `${r.name}(${r.length})${i.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(r) {
      let i = "[";
      for (let a = 0; a < r.length; a++) i += this.serialize(r[a]), a < r.length - 1 && (i += ",");
      return i + "]";
    }
    $Date(r) {
      try {
        return `Date(${r.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(r) {
      return `ArrayBuffer[${new Uint8Array(r).join(",")}]`;
    }
    $Set(r) {
      return `Set${this.$Array(Array.from(r).sort((i, a) => this.compare(i, a)))}`;
    }
    $Map(r) {
      return this.serializeObjectEntries("Map", r.entries());
    }
  }
  e = new WeakMap();
  for (const t of ["Error", "RegExp", "URL"]) n.prototype["$" + t] = function(r) {
    return `${t}(${r})`;
  };
  for (const t of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) n.prototype["$" + t] = function(r) {
    return `${t}[${r.join(",")}]`;
  };
  for (const t of ["BigInt64Array", "BigUint64Array"]) n.prototype["$" + t] = function(r) {
    return `${t}[${r.join("n,")}${r.length > 0 ? "n" : ""}]`;
  };
  return n;
}();
function _T(n, e) {
  return n === e || uL(n) === uL(e);
}
function nQ(n, e, t) {
  const r = n.findIndex((s) => _T(s, e)), i = n.findIndex((s) => _T(s, t));
  if (r === -1 || i === -1) return [];
  const [a, o] = [r, i].sort((s, l) => s - l);
  return n.slice(a, o + 1);
}
function br(n, e) {
  const t = typeof n == "string" && !e ? `${n}Context` : e, r = Symbol(t);
  return [(o) => {
    const s = Xt(r, o);
    if (s || s === null) return s;
    throw new Error(`Injection \`${r.toString()}\` not found. Component must be used within ${Array.isArray(n) ? `one of the following components: ${n.join(", ")}` : `\`${n}\``}`);
  }, (o) => (zn(r, o), o)];
}
function Di() {
  let n = document.activeElement;
  if (n == null) return null;
  for (; n != null && n.shadowRoot != null && n.shadowRoot.activeElement != null; ) n = n.shadowRoot.activeElement;
  return n;
}
function $A(n, e, t) {
  const r = t.originalEvent.target, i = new CustomEvent(n, {
    bubbles: !1,
    cancelable: !0,
    detail: t
  });
  e && r.addEventListener(n, e, { once: !0 }), r.dispatchEvent(i);
}
function zA(n) {
  return n ? n.flatMap((e) => e.type === Ke ? zA(e.children) : [e]) : [];
}
const rQ = ["INPUT", "TEXTAREA"];
function iQ(n, e, t, r = {}) {
  if (!e || r.enableIgnoredElement && rQ.includes(e.nodeName)) return null;
  const { arrowKeyOptions: i = "both", attributeName: a = "[data-reka-collection-item]", itemsArray: o = [], loop: s = !0, dir: l = "ltr", preventScroll: u = !0, focus: c = !1 } = r, [d, f, p, h, v, m] = [
    n.key === "ArrowRight",
    n.key === "ArrowLeft",
    n.key === "ArrowUp",
    n.key === "ArrowDown",
    n.key === "Home",
    n.key === "End"
  ], g = p || h, y = d || f;
  if (!v && !m && (!g && !y || i === "vertical" && y || i === "horizontal" && g)) return null;
  const b = t ? Array.from(t.querySelectorAll(a)) : o;
  if (!b.length) return null;
  u && n.preventDefault();
  let _ = null;
  return y || g ? _ = rV(b, e, {
    goForward: g ? h : l === "ltr" ? d : f,
    loop: s
  }) : v ? _ = b.at(0) || null : m && (_ = b.at(-1) || null), c && (_ == null || _.focus()), _;
}
function rV(n, e, t, r = n.length) {
  if (--r === 0) return null;
  const i = n.indexOf(e), a = t.goForward ? i + 1 : i - 1;
  if (!t.loop && (a < 0 || a >= n.length)) return null;
  const o = (a + n.length) % n.length, s = n[o];
  return s ? s.hasAttribute("disabled") && s.getAttribute("disabled") !== "false" ? rV(n, s, t, r) : s : null;
}
const [Y_, aUe] = br("ConfigProvider");
function aQ(n, e) {
  var t;
  const r = Bd();
  return Cn(() => {
    r.value = n();
  }, {
    ...e,
    flush: (t = void 0) != null ? t : "sync"
  }), fp(r);
}
function Jp(n) {
  return V_() ? (xg(n), !0) : !1;
}
function $v() {
  const n = /* @__PURE__ */ new Set(), e = (a) => {
    n.delete(a);
  };
  return {
    on: (a) => {
      n.add(a);
      const o = () => e(a);
      return Jp(o), {
        off: o
      };
    },
    off: e,
    trigger: (...a) => Promise.all(Array.from(n).map((o) => o(...a))),
    clear: () => {
      n.clear();
    }
  };
}
function oQ(n) {
  let e = !1, t;
  const r = fF(!0);
  return (...i) => (e || (t = r.run(() => n(...i)), e = !0), t);
}
function iV(n) {
  let e = 0, t, r;
  const i = () => {
    e -= 1, r && e <= 0 && (r.stop(), t = void 0, r = void 0);
  };
  return (...a) => (e += 1, r || (r = fF(!0), t = r.run(() => n(...a))), Jp(i), t);
}
function sQ(n) {
  if (!al(n))
    return Sr(n);
  const e = new Proxy({}, {
    get(t, r, i) {
      return O(Reflect.get(n.value, r, i));
    },
    set(t, r, i) {
      return al(n.value[r]) && !al(i) ? n.value[r].value = i : n.value[r] = i, !0;
    },
    deleteProperty(t, r) {
      return Reflect.deleteProperty(n.value, r);
    },
    has(t, r) {
      return Reflect.has(n.value, r);
    },
    ownKeys() {
      return Object.keys(n.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return Sr(e);
}
function lQ(n) {
  return sQ(K(n));
}
function uQ(n, ...e) {
  const t = e.flat(), r = t[0];
  return lQ(() => Object.fromEntries(typeof r == "function" ? Object.entries(fi(n)).filter(([i, a]) => !r(Ir(a), i)) : Object.entries(fi(n)).filter((i) => !t.includes(i[0]))));
}
const Cs = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const cQ = (n) => typeof n < "u", dQ = Object.prototype.toString, fQ = (n) => dQ.call(n) === "[object Object]", pQ = () => {
}, cL = /* @__PURE__ */ hQ();
function hQ() {
  var n, e;
  return Cs && ((n = window == null ? void 0 : window.navigator) == null ? void 0 : n.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function vQ(n) {
  return ro();
}
function Ww(n) {
  return Array.isArray(n) ? n : [n];
}
function FA(n, e = 1e4) {
  return pF((t, r) => {
    let i = Ir(n), a;
    const o = () => setTimeout(() => {
      i = Ir(n), r();
    }, Ir(e));
    return Jp(() => {
      clearTimeout(a);
    }), {
      get() {
        return t(), i;
      },
      set(s) {
        i = s, r(), clearTimeout(a), a = o();
      }
    };
  });
}
const mQ = Ir;
function gQ(n, e) {
  vQ() && Io(n, e);
}
function VA(n, e, t = {}) {
  const {
    immediate: r = !0,
    immediateCallback: i = !1
  } = t, a = Bd(!1);
  let o = null;
  function s() {
    o && (clearTimeout(o), o = null);
  }
  function l() {
    a.value = !1, s();
  }
  function u(...c) {
    i && n(), s(), a.value = !0, o = setTimeout(() => {
      a.value = !1, o = null, n(...c);
    }, Ir(e));
  }
  return r && (a.value = !0, Cs && u()), Jp(l), {
    isPending: fp(a),
    start: u,
    stop: l
  };
}
function yQ(n = 1e3, e = {}) {
  const {
    controls: t = !1,
    callback: r
  } = e, i = VA(
    r ?? pQ,
    n,
    e
  ), a = K(() => !i.isPending.value);
  return t ? {
    ready: a,
    ...i
  } : a;
}
function bQ(n, e, t) {
  return et(
    n,
    e,
    {
      ...t,
      immediate: !0
    }
  );
}
const K_ = Cs ? window : void 0;
function Vd(n) {
  var e;
  const t = Ir(n);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
function Ep(...n) {
  const e = [], t = () => {
    e.forEach((s) => s()), e.length = 0;
  }, r = (s, l, u, c) => (s.addEventListener(l, u, c), () => s.removeEventListener(l, u, c)), i = K(() => {
    const s = Ww(Ir(n[0])).filter((l) => l != null);
    return s.every((l) => typeof l != "string") ? s : void 0;
  }), a = bQ(
    () => {
      var s, l;
      return [
        (l = (s = i.value) == null ? void 0 : s.map((u) => Vd(u))) != null ? l : [K_].filter((u) => u != null),
        Ww(Ir(i.value ? n[1] : n[0])),
        Ww(O(i.value ? n[2] : n[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        Ir(i.value ? n[3] : n[2])
      ];
    },
    ([s, l, u, c]) => {
      if (t(), !(s != null && s.length) || !(l != null && l.length) || !(u != null && u.length))
        return;
      const d = fQ(c) ? { ...c } : c;
      e.push(
        ...s.flatMap(
          (f) => l.flatMap(
            (p) => u.map((h) => r(f, p, h, d))
          )
        )
      );
    },
    { flush: "post" }
  ), o = () => {
    a(), t();
  };
  return Jp(t), o;
}
function _Q() {
  const n = Bd(!1), e = ro();
  return e && kt(() => {
    n.value = !0;
  }, e), n;
}
function xQ(n) {
  return typeof n == "function" ? n : typeof n == "string" ? (e) => e.key === n : Array.isArray(n) ? (e) => n.includes(e.key) : () => !0;
}
function aV(...n) {
  let e, t, r = {};
  n.length === 3 ? (e = n[0], t = n[1], r = n[2]) : n.length === 2 ? typeof n[1] == "object" ? (e = !0, t = n[0], r = n[1]) : (e = n[0], t = n[1]) : (e = !0, t = n[0]);
  const {
    target: i = K_,
    eventName: a = "keydown",
    passive: o = !1,
    dedupe: s = !1
  } = r, l = xQ(e);
  return Ep(i, a, (c) => {
    c.repeat && Ir(s) || l(c) && t(c);
  }, o);
}
function oV(n, e = {}) {
  const {
    immediate: t = !0,
    fpsLimit: r = void 0,
    window: i = K_,
    once: a = !1
  } = e, o = Bd(!1), s = K(() => r ? 1e3 / Ir(r) : null);
  let l = 0, u = null;
  function c(p) {
    if (!o.value || !i)
      return;
    l || (l = p);
    const h = p - l;
    if (s.value && h < s.value) {
      u = i.requestAnimationFrame(c);
      return;
    }
    if (l = p, n({ delta: h, timestamp: p }), a) {
      o.value = !1, u = null;
      return;
    }
    u = i.requestAnimationFrame(c);
  }
  function d() {
    !o.value && i && (o.value = !0, l = 0, u = i.requestAnimationFrame(c));
  }
  function f() {
    o.value = !1, u != null && i && (i.cancelAnimationFrame(u), u = null);
  }
  return t && d(), Jp(f), {
    isActive: fp(o),
    pause: f,
    resume: d
  };
}
function wQ(n) {
  return JSON.parse(JSON.stringify(n));
}
function na(n, e, t, r = {}) {
  var i, a, o;
  const {
    clone: s = !1,
    passive: l = !1,
    eventName: u,
    deep: c = !1,
    defaultValue: d,
    shouldEmit: f
  } = r, p = ro(), h = t || (p == null ? void 0 : p.emit) || ((i = p == null ? void 0 : p.$emit) == null ? void 0 : i.bind(p)) || ((o = (a = p == null ? void 0 : p.proxy) == null ? void 0 : a.$emit) == null ? void 0 : o.bind(p == null ? void 0 : p.proxy));
  let v = u;
  e || (e = "modelValue"), v = v || `update:${e.toString()}`;
  const m = (b) => s ? typeof s == "function" ? s(b) : wQ(b) : b, g = () => cQ(n[e]) ? m(n[e]) : d, y = (b) => {
    f ? f(b) && h(v, b) : h(v, b);
  };
  if (l) {
    const b = g(), _ = Z(b);
    let x = !1;
    return et(
      () => n[e],
      (w) => {
        x || (x = !0, _.value = m(w), Wt(() => x = !1));
      }
    ), et(
      _,
      (w) => {
        !x && (w !== n[e] || c) && y(w);
      },
      { deep: c }
    ), _;
  } else
    return K({
      get() {
        return g();
      },
      set(b) {
        y(b);
      }
    });
}
function qw(n) {
  if (n === null || typeof n != "object")
    return !1;
  const e = Object.getPrototypeOf(n);
  return e !== null && e !== Object.prototype && Object.getPrototypeOf(e) !== null || Symbol.iterator in n ? !1 : Symbol.toStringTag in n ? Object.prototype.toString.call(n) === "[object Module]" : !0;
}
function xT(n, e, t = ".", r) {
  if (!qw(e))
    return xT(n, {}, t, r);
  const i = Object.assign({}, e);
  for (const a in n) {
    if (a === "__proto__" || a === "constructor")
      continue;
    const o = n[a];
    o != null && (r && r(i, a, o, t) || (Array.isArray(o) && Array.isArray(i[a]) ? i[a] = [...o, ...i[a]] : qw(o) && qw(i[a]) ? i[a] = xT(
      o,
      i[a],
      (t ? `${t}.` : "") + a.toString(),
      r
    ) : i[a] = o));
  }
  return i;
}
function SQ(n) {
  return (...e) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    e.reduce((t, r) => xT(t, r, "", n), {})
  );
}
const EQ = SQ(), TQ = iV(() => {
  const n = Z(/* @__PURE__ */ new Map()), e = Z(), t = K(() => {
    for (const o of n.value.values()) if (o) return !0;
    return !1;
  }), r = Y_({ scrollBody: Z(!0) });
  let i = null;
  const a = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.documentElement.style.removeProperty("--scrollbar-width"), document.body.style.overflow = e.value ?? "", cL && (i == null || i()), e.value = void 0;
  };
  return et(t, (o, s) => {
    var d;
    if (!Cs) return;
    if (!o) {
      s && a();
      return;
    }
    e.value === void 0 && (e.value = document.body.style.overflow);
    const l = window.innerWidth - document.documentElement.clientWidth, u = {
      padding: l,
      margin: 0
    }, c = (d = r.scrollBody) != null && d.value ? typeof r.scrollBody.value == "object" ? EQ({
      padding: r.scrollBody.value.padding === !0 ? l : r.scrollBody.value.padding,
      margin: r.scrollBody.value.margin === !0 ? l : r.scrollBody.value.margin
    }, u) : u : {
      padding: 0,
      margin: 0
    };
    l > 0 && (document.body.style.paddingRight = typeof c.padding == "number" ? `${c.padding}px` : String(c.padding), document.body.style.marginRight = typeof c.margin == "number" ? `${c.margin}px` : String(c.margin), document.documentElement.style.setProperty("--scrollbar-width", `${l}px`), document.body.style.overflow = "hidden"), cL && (i = Ep(document, "touchmove", (f) => CQ(f), { passive: !1 })), Wt(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, {
    immediate: !0,
    flush: "sync"
  }), n;
});
function X_(n) {
  const e = Math.random().toString(36).substring(2, 7), t = TQ();
  t.value.set(e, n ?? !1);
  const r = K({
    get: () => t.value.get(e) ?? !1,
    set: (i) => t.value.set(e, i)
  });
  return gQ(() => {
    t.value.delete(e);
  }), r;
}
function sV(n) {
  const e = window.getComputedStyle(n);
  if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && n.clientWidth < n.scrollWidth || e.overflowY === "auto" && n.clientHeight < n.scrollHeight) return !0;
  {
    const t = n.parentNode;
    return !(t instanceof Element) || t.tagName === "BODY" ? !1 : sV(t);
  }
}
function CQ(n) {
  const e = n || window.event, t = e.target;
  return t instanceof Element && sV(t) ? !1 : e.touches.length > 1 ? !0 : (e.preventDefault && e.cancelable && e.preventDefault(), !1);
}
function Eg(n) {
  const e = Y_({ dir: Z("ltr") });
  return K(() => {
    var t;
    return (n == null ? void 0 : n.value) || ((t = e.dir) == null ? void 0 : t.value) || "ltr";
  });
}
function Tg(n) {
  const e = ro(), t = e == null ? void 0 : e.type.emits, r = {};
  return t != null && t.length || console.warn(`No emitted event found. Please check component: ${e == null ? void 0 : e.type.__name}`), t == null || t.forEach((i) => {
    r[IZ(hF(i))] = (...a) => n(i, ...a);
  }), r;
}
function kQ(n) {
  const e = K(() => O(n)), t = K(() => new Intl.Collator("en", {
    usage: "search",
    ...e.value
  }));
  return {
    startsWith: (o, s) => s.length === 0 ? !0 : (o = o.normalize("NFC"), s = s.normalize("NFC"), t.value.compare(o.slice(0, s.length), s) === 0),
    endsWith: (o, s) => s.length === 0 ? !0 : (o = o.normalize("NFC"), s = s.normalize("NFC"), t.value.compare(o.slice(-s.length), s) === 0),
    contains: (o, s) => {
      if (s.length === 0) return !0;
      o = o.normalize("NFC"), s = s.normalize("NFC");
      let l = 0;
      const u = s.length;
      for (; l + u <= o.length; l++) {
        const c = o.slice(l, l + u);
        if (t.value.compare(s, c) === 0) return !0;
      }
      return !1;
    }
  };
}
let Yw = 0;
function lV() {
  Cn((n) => {
    if (!Cs) return;
    const e = document.querySelectorAll("[data-reka-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", e[0] ?? dL()), document.body.insertAdjacentElement("beforeend", e[1] ?? dL()), Yw++, n(() => {
      Yw === 1 && document.querySelectorAll("[data-reka-focus-guard]").forEach((t) => t.remove()), Yw--;
    });
  });
}
function dL() {
  const n = document.createElement("span");
  return n.setAttribute("data-reka-focus-guard", ""), n.tabIndex = 0, n.style.outline = "none", n.style.opacity = "0", n.style.position = "fixed", n.style.pointerEvents = "none", n;
}
function AQ(n) {
  return K(() => {
    var e;
    return mQ(n) ? !!((e = Vd(n)) != null && e.closest("form")) : !0;
  });
}
function Lt() {
  const n = ro(), e = Z(), t = K(() => {
    var o, s;
    return ["#text", "#comment"].includes((o = e.value) == null ? void 0 : o.$el.nodeName) ? (s = e.value) == null ? void 0 : s.$el.nextElementSibling : Vd(e);
  }), r = Object.assign({}, n.exposed), i = {};
  for (const o in n.props) Object.defineProperty(i, o, {
    enumerable: !0,
    configurable: !0,
    get: () => n.props[o]
  });
  if (Object.keys(r).length > 0) for (const o in r) Object.defineProperty(i, o, {
    enumerable: !0,
    configurable: !0,
    get: () => r[o]
  });
  Object.defineProperty(i, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => n.vnode.el
  }), n.exposed = i;
  function a(o) {
    e.value = o, o && (Object.defineProperty(i, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => o instanceof Element ? o : o.$el
    }), n.exposed = i);
  }
  return {
    forwardRef: a,
    currentRef: e,
    currentElement: t
  };
}
function Z_(n) {
  const e = ro(), t = Object.keys((e == null ? void 0 : e.type.props) ?? {}).reduce((i, a) => {
    const o = (e == null ? void 0 : e.type.props[a]).default;
    return o !== void 0 && (i[a] = o), i;
  }, {}), r = j1(n);
  return K(() => {
    const i = {}, a = (e == null ? void 0 : e.vnode.props) ?? {};
    return Object.keys(a).forEach((o) => {
      i[hF(o)] = a[o];
    }), Object.keys({
      ...t,
      ...i
    }).reduce((o, s) => (r.value[s] !== void 0 && (o[s] = r.value[s]), o), {});
  });
}
function Lo(n, e) {
  const t = Z_(n), r = e ? Tg(e) : {};
  return K(() => ({
    ...t.value,
    ...r
  }));
}
function MQ(n, e) {
  const t = FA(!1, 300), r = Z(null), i = $v();
  function a() {
    r.value = null, t.value = !1;
  }
  function o(s, l) {
    const u = s.currentTarget, c = {
      x: s.clientX,
      y: s.clientY
    }, d = DQ(c, u.getBoundingClientRect()), f = OQ(c, d), p = IQ(l.getBoundingClientRect()), h = NQ([...f, ...p]);
    r.value = h, t.value = !0;
  }
  return Cn((s) => {
    if (n.value && e.value) {
      const l = (c) => o(c, e.value), u = (c) => o(c, n.value);
      n.value.addEventListener("pointerleave", l), e.value.addEventListener("pointerleave", u), s(() => {
        var c, d;
        (c = n.value) == null || c.removeEventListener("pointerleave", l), (d = e.value) == null || d.removeEventListener("pointerleave", u);
      });
    }
  }), Cn((s) => {
    var l;
    if (r.value) {
      const u = (c) => {
        var m, g;
        if (!r.value || !(c.target instanceof HTMLElement)) return;
        const d = c.target, f = {
          x: c.clientX,
          y: c.clientY
        }, p = ((m = n.value) == null ? void 0 : m.contains(d)) || ((g = e.value) == null ? void 0 : g.contains(d)), h = !LQ(f, r.value), v = !!d.closest("[data-grace-area-trigger]");
        p ? a() : (h || v) && (a(), i.trigger());
      };
      (l = n.value) == null || l.ownerDocument.addEventListener("pointermove", u), s(() => {
        var c;
        return (c = n.value) == null ? void 0 : c.ownerDocument.removeEventListener("pointermove", u);
      });
    }
  }), {
    isPointerInTransit: t,
    onPointerExit: i.on
  };
}
function DQ(n, e) {
  const t = Math.abs(e.top - n.y), r = Math.abs(e.bottom - n.y), i = Math.abs(e.right - n.x), a = Math.abs(e.left - n.x);
  switch (Math.min(t, r, i, a)) {
    case a:
      return "left";
    case i:
      return "right";
    case t:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function OQ(n, e, t = 5) {
  const r = [];
  switch (e) {
    case "top":
      r.push({
        x: n.x - t,
        y: n.y + t
      }, {
        x: n.x + t,
        y: n.y + t
      });
      break;
    case "bottom":
      r.push({
        x: n.x - t,
        y: n.y - t
      }, {
        x: n.x + t,
        y: n.y - t
      });
      break;
    case "left":
      r.push({
        x: n.x + t,
        y: n.y - t
      }, {
        x: n.x + t,
        y: n.y + t
      });
      break;
    case "right":
      r.push({
        x: n.x - t,
        y: n.y - t
      }, {
        x: n.x - t,
        y: n.y + t
      });
      break;
  }
  return r;
}
function IQ(n) {
  const { top: e, right: t, bottom: r, left: i } = n;
  return [
    {
      x: i,
      y: e
    },
    {
      x: t,
      y: e
    },
    {
      x: t,
      y: r
    },
    {
      x: i,
      y: r
    }
  ];
}
function LQ(n, e) {
  const { x: t, y: r } = n;
  let i = !1;
  for (let a = 0, o = e.length - 1; a < e.length; o = a++) {
    const s = e[a].x, l = e[a].y, u = e[o].x, c = e[o].y;
    l > r != c > r && t < (u - s) * (r - l) / (c - l) + s && (i = !i);
  }
  return i;
}
function NQ(n) {
  const e = n.slice();
  return e.sort((t, r) => t.x < r.x ? -1 : t.x > r.x ? 1 : t.y < r.y ? -1 : t.y > r.y ? 1 : 0), RQ(e);
}
function RQ(n) {
  if (n.length <= 1) return n.slice();
  const e = [];
  for (let r = 0; r < n.length; r++) {
    const i = n[r];
    for (; e.length >= 2; ) {
      const a = e[e.length - 1], o = e[e.length - 2];
      if ((a.x - o.x) * (i.y - o.y) >= (a.y - o.y) * (i.x - o.x)) e.pop();
      else break;
    }
    e.push(i);
  }
  e.pop();
  const t = [];
  for (let r = n.length - 1; r >= 0; r--) {
    const i = n[r];
    for (; t.length >= 2; ) {
      const a = t[t.length - 1], o = t[t.length - 2];
      if ((a.x - o.x) * (i.y - o.y) >= (a.y - o.y) * (i.x - o.x)) t.pop();
      else break;
    }
    t.push(i);
  }
  return t.pop(), e.length === 1 && t.length === 1 && e[0].x === t[0].x && e[0].y === t[0].y ? e : e.concat(t);
}
var PQ = function(n) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(n) ? n[0] : n;
  return e.ownerDocument.body;
}, ff = /* @__PURE__ */ new WeakMap(), yy = /* @__PURE__ */ new WeakMap(), by = {}, Kw = 0, uV = function(n) {
  return n && (n.host || uV(n.parentNode));
}, jQ = function(n, e) {
  return e.map(function(t) {
    if (n.contains(t))
      return t;
    var r = uV(t);
    return r && n.contains(r) ? r : (console.error("aria-hidden", t, "in not contained inside", n, ". Doing nothing"), null);
  }).filter(function(t) {
    return !!t;
  });
}, BQ = function(n, e, t, r) {
  var i = jQ(e, Array.isArray(n) ? n : [n]);
  by[t] || (by[t] = /* @__PURE__ */ new WeakMap());
  var a = by[t], o = [], s = /* @__PURE__ */ new Set(), l = new Set(i), u = function(d) {
    !d || s.has(d) || (s.add(d), u(d.parentNode));
  };
  i.forEach(u);
  var c = function(d) {
    !d || l.has(d) || Array.prototype.forEach.call(d.children, function(f) {
      if (s.has(f))
        c(f);
      else
        try {
          var p = f.getAttribute(r), h = p !== null && p !== "false", v = (ff.get(f) || 0) + 1, m = (a.get(f) || 0) + 1;
          ff.set(f, v), a.set(f, m), o.push(f), v === 1 && h && yy.set(f, !0), m === 1 && f.setAttribute(t, "true"), h || f.setAttribute(r, "true");
        } catch (g) {
          console.error("aria-hidden: cannot operate on ", f, g);
        }
    });
  };
  return c(e), s.clear(), Kw++, function() {
    o.forEach(function(d) {
      var f = ff.get(d) - 1, p = a.get(d) - 1;
      ff.set(d, f), a.set(d, p), f || (yy.has(d) || d.removeAttribute(r), yy.delete(d)), p || d.removeAttribute(t);
    }), Kw--, Kw || (ff = /* @__PURE__ */ new WeakMap(), ff = /* @__PURE__ */ new WeakMap(), yy = /* @__PURE__ */ new WeakMap(), by = {});
  };
}, $Q = function(n, e, t) {
  t === void 0 && (t = "data-aria-hidden");
  var r = Array.from(Array.isArray(n) ? n : [n]), i = PQ(n);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live], script"))), BQ(r, i, t, "aria-hidden")) : function() {
    return null;
  };
};
function J_(n) {
  let e;
  et(() => Vd(n), (t) => {
    t ? e = $Q(t) : e && e();
  }), Nn(() => {
    e && e();
  });
}
let zQ = 0;
function ra(n, e = "reka") {
  var r;
  if ("useId" in rp) return `${e}-${(r = rp.useId) == null ? void 0 : r.call(rp)}`;
  const t = Y_({ useId: void 0 });
  return t.useId ? `${e}-${t.useId()}` : `${e}-${++zQ}`;
}
function FQ() {
  return {
    ALT: "Alt",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    BACKSPACE: "Backspace",
    CAPS_LOCK: "CapsLock",
    CONTROL: "Control",
    DELETE: "Delete",
    END: "End",
    ENTER: "Enter",
    ESCAPE: "Escape",
    F1: "F1",
    F10: "F10",
    F11: "F11",
    F12: "F12",
    F2: "F2",
    F3: "F3",
    F4: "F4",
    F5: "F5",
    F6: "F6",
    F7: "F7",
    F8: "F8",
    F9: "F9",
    HOME: "Home",
    META: "Meta",
    PAGE_DOWN: "PageDown",
    PAGE_UP: "PageUp",
    SHIFT: "Shift",
    SPACE: " ",
    TAB: "Tab",
    CTRL: "Control",
    ASTERISK: "*",
    SPACE_CODE: "Space"
  };
}
function VQ(n) {
  const e = Z(), t = K(() => {
    var i;
    return ((i = e.value) == null ? void 0 : i.width) ?? 0;
  }), r = K(() => {
    var i;
    return ((i = e.value) == null ? void 0 : i.height) ?? 0;
  });
  return kt(() => {
    const i = Vd(n);
    if (i) {
      e.value = {
        width: i.offsetWidth,
        height: i.offsetHeight
      };
      const a = new ResizeObserver((o) => {
        if (!Array.isArray(o) || !o.length) return;
        const s = o[0];
        let l, u;
        if ("borderBoxSize" in s) {
          const c = s.borderBoxSize, d = Array.isArray(c) ? c[0] : c;
          l = d.inlineSize, u = d.blockSize;
        } else
          l = i.offsetWidth, u = i.offsetHeight;
        e.value = {
          width: l,
          height: u
        };
      });
      return a.observe(i, { box: "border-box" }), () => a.unobserve(i);
    } else e.value = void 0;
  }), {
    width: t,
    height: r
  };
}
function HQ(n, e) {
  const t = Z(n);
  function r(a) {
    return e[t.value][a] ?? t.value;
  }
  return {
    state: t,
    dispatch: (a) => {
      t.value = r(a);
    }
  };
}
function cV(n) {
  const e = FA("", 1e3);
  return {
    search: e,
    handleTypeaheadSearch: (i, a) => {
      e.value = e.value + i;
      {
        const o = Di(), s = a.map((f) => {
          var p, h;
          return {
            ...f,
            textValue: ((p = f.value) == null ? void 0 : p.textValue) ?? ((h = f.ref.textContent) == null ? void 0 : h.trim()) ?? ""
          };
        }), l = s.find((f) => f.ref === o), u = s.map((f) => f.textValue), c = UQ(u, e.value, l == null ? void 0 : l.textValue), d = s.find((f) => f.textValue === c);
        return d && d.ref.focus(), d == null ? void 0 : d.ref;
      }
    },
    resetTypeahead: () => {
      e.value = "";
    }
  };
}
function GQ(n, e) {
  return n.map((t, r) => n[(e + r) % n.length]);
}
function UQ(n, e, t) {
  const i = e.length > 1 && Array.from(e).every((u) => u === e[0]) ? e[0] : e, a = t ? n.indexOf(t) : -1;
  let o = GQ(n, Math.max(a, 0));
  i.length === 1 && (o = o.filter((u) => u !== t));
  const l = o.find((u) => u.toLowerCase().startsWith(i.toLowerCase()));
  return l !== t ? l : void 0;
}
function WQ(n, e) {
  var m;
  const t = Z({}), r = Z("none"), i = Z(n), a = n.value ? "mounted" : "unmounted";
  let o;
  const s = ((m = e.value) == null ? void 0 : m.ownerDocument.defaultView) ?? K_, { state: l, dispatch: u } = HQ(a, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: { MOUNT: "mounted" }
  }), c = (g) => {
    var y;
    if (Cs) {
      const b = new CustomEvent(g, {
        bubbles: !1,
        cancelable: !1
      });
      (y = e.value) == null || y.dispatchEvent(b);
    }
  };
  et(n, async (g, y) => {
    var _;
    const b = y !== g;
    if (await Wt(), b) {
      const x = r.value, w = _y(e.value);
      g ? (u("MOUNT"), c("enter"), w === "none" && c("after-enter")) : w === "none" || w === "undefined" || ((_ = t.value) == null ? void 0 : _.display) === "none" ? (u("UNMOUNT"), c("leave"), c("after-leave")) : y && x !== w ? (u("ANIMATION_OUT"), c("leave")) : (u("UNMOUNT"), c("after-leave"));
    }
  }, { immediate: !0 });
  const d = (g) => {
    const y = _y(e.value), b = y.includes(g.animationName), _ = l.value === "mounted" ? "enter" : "leave";
    if (g.target === e.value && b && (c(`after-${_}`), u("ANIMATION_END"), !i.value)) {
      const x = e.value.style.animationFillMode;
      e.value.style.animationFillMode = "forwards", o = s == null ? void 0 : s.setTimeout(() => {
        var w;
        ((w = e.value) == null ? void 0 : w.style.animationFillMode) === "forwards" && (e.value.style.animationFillMode = x);
      });
    }
    g.target === e.value && y === "none" && u("ANIMATION_END");
  }, f = (g) => {
    g.target === e.value && (r.value = _y(e.value));
  }, p = et(e, (g, y) => {
    g ? (t.value = getComputedStyle(g), g.addEventListener("animationstart", f), g.addEventListener("animationcancel", d), g.addEventListener("animationend", d)) : (u("ANIMATION_END"), o !== void 0 && (s == null || s.clearTimeout(o)), y == null || y.removeEventListener("animationstart", f), y == null || y.removeEventListener("animationcancel", d), y == null || y.removeEventListener("animationend", d));
  }, { immediate: !0 }), h = et(l, () => {
    const g = _y(e.value);
    r.value = l.value === "mounted" ? g : "none";
  });
  return Nn(() => {
    p(), h();
  }), { isPresent: K(() => ["mounted", "unmountSuspended"].includes(l.value)) };
}
function _y(n) {
  return n && getComputedStyle(n).animationName || "none";
}
var Fu = ve({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: { type: Boolean }
  },
  slots: {},
  setup(n, { slots: e, expose: t }) {
    var u;
    const { present: r, forceMount: i } = fi(n), a = Z(), { isPresent: o } = WQ(r, a);
    t({ present: o });
    let s = e.default({ present: o.value });
    s = zA(s || []);
    const l = ro();
    if (s && (s == null ? void 0 : s.length) > 1) {
      const c = (u = l == null ? void 0 : l.parent) != null && u.type.name ? `<${l.parent.type.name} />` : "component";
      throw new Error([
        `Detected an invalid children for \`${c}\` for  \`Presence\` component.`,
        "",
        "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
        "You can apply a few solutions:",
        ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map((d) => `  - ${d}`).join(`
`)
      ].join(`
`));
    }
    return () => i.value || r.value || o.value ? qt(e.default({ present: o.value })[0], { ref: (c) => {
      const d = Vd(c);
      return typeof (d == null ? void 0 : d.hasAttribute) > "u" || (d != null && d.hasAttribute("data-reka-popper-content-wrapper") ? a.value = d.firstElementChild : a.value = d), d;
    } }) : null;
  }
});
const wT = ve({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(n, { attrs: e, slots: t }) {
    return () => {
      var l;
      if (!t.default) return null;
      const r = zA(t.default()), i = r.findIndex((u) => u.type !== vF);
      if (i === -1) return r;
      const a = r[i];
      (l = a.props) == null || delete l.ref;
      const o = a.props ? He(e, a.props) : e, s = kA({
        ...a,
        props: {}
      }, o);
      return r.length === 1 ? s : (r[i] = s, r);
    };
  }
}), qQ = [
  "area",
  "img",
  "input"
], Sn = ve({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(n, { attrs: e, slots: t }) {
    const r = n.asChild ? "template" : n.as;
    return typeof r == "string" && qQ.includes(r) ? () => qt(r, e) : r !== "template" ? () => qt(n.as, e, { default: t.default }) : () => qt(wT, e, { default: t.default });
  }
});
function Au() {
  const n = Z(), e = K(() => {
    var t, r;
    return ["#text", "#comment"].includes((t = n.value) == null ? void 0 : t.$el.nodeName) ? (r = n.value) == null ? void 0 : r.$el.nextElementSibling : Vd(n);
  });
  return {
    primitiveElement: n,
    currentElement: e
  };
}
const [kl, YQ] = br("DialogRoot");
var KQ = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "DialogRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(n, { emit: e }) {
    const t = n, i = na(t, "open", e, {
      defaultValue: t.defaultOpen,
      passive: t.open === void 0
    }), a = Z(), o = Z(), { modal: s } = fi(t);
    return YQ({
      open: i,
      modal: s,
      openModal: () => {
        i.value = !0;
      },
      onOpenChange: (l) => {
        i.value = l;
      },
      onOpenToggle: () => {
        i.value = !i.value;
      },
      contentId: "",
      titleId: "",
      descriptionId: "",
      triggerElement: a,
      contentElement: o
    }), (l, u) => ue(l.$slots, "default", {
      open: O(i),
      close: () => i.value = !1
    });
  }
}), XQ = KQ, ZQ = /* @__PURE__ */ ve({
  __name: "DialogClose",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(n) {
    const e = n;
    Lt();
    const t = kl();
    return (r, i) => (L(), re(O(Sn), He(e, {
      type: r.as === "button" ? "button" : void 0,
      onClick: i[0] || (i[0] = (a) => O(t).onOpenChange(!1))
    }), {
      default: ee(() => [ue(r.$slots, "default")]),
      _: 3
    }, 16, ["type"]));
  }
}), JQ = ZQ;
const QQ = "dismissableLayer.pointerDownOutside", eee = "dismissableLayer.focusOutside";
function dV(n, e) {
  const t = e.closest("[data-dismissable-layer]"), r = n.dataset.dismissableLayer === "" ? n : n.querySelector("[data-dismissable-layer]"), i = Array.from(n.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
  return !!(t && (r === t || i.indexOf(r) < i.indexOf(t)));
}
function tee(n, e, t = !0) {
  var o;
  const r = ((o = e == null ? void 0 : e.value) == null ? void 0 : o.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), i = Z(!1), a = Z(() => {
  });
  return Cn((s) => {
    if (!Cs || !Ir(t)) return;
    const l = async (c) => {
      const d = c.target;
      if (!(!(e != null && e.value) || !d)) {
        if (dV(e.value, d)) {
          i.value = !1;
          return;
        }
        if (c.target && !i.value) {
          let p = function() {
            $A(QQ, n, f);
          };
          const f = { originalEvent: c };
          c.pointerType === "touch" ? (r.removeEventListener("click", a.value), a.value = p, r.addEventListener("click", a.value, { once: !0 })) : p();
        } else r.removeEventListener("click", a.value);
        i.value = !1;
      }
    }, u = window.setTimeout(() => {
      r.addEventListener("pointerdown", l);
    }, 0);
    s(() => {
      window.clearTimeout(u), r.removeEventListener("pointerdown", l), r.removeEventListener("click", a.value);
    });
  }), { onPointerDownCapture: () => {
    Ir(t) && (i.value = !0);
  } };
}
function nee(n, e, t = !0) {
  var a;
  const r = ((a = e == null ? void 0 : e.value) == null ? void 0 : a.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), i = Z(!1);
  return Cn((o) => {
    if (!Cs || !Ir(t)) return;
    const s = async (l) => {
      if (!(e != null && e.value)) return;
      await Wt(), await Wt();
      const u = l.target;
      !e.value || !u || dV(e.value, u) || l.target && !i.value && $A(eee, n, { originalEvent: l });
    };
    r.addEventListener("focusin", s), o(() => r.removeEventListener("focusin", s));
  }), {
    onFocusCapture: () => {
      Ir(t) && (i.value = !0);
    },
    onBlurCapture: () => {
      Ir(t) && (i.value = !1);
    }
  };
}
const Ns = Sr({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var ree = /* @__PURE__ */ ve({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "dismiss"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, { forwardRef: i, currentElement: a } = Lt(), o = K(() => {
      var h;
      return ((h = a.value) == null ? void 0 : h.ownerDocument) ?? globalThis.document;
    }), s = K(() => Ns.layersRoot), l = K(() => a.value ? Array.from(s.value).indexOf(a.value) : -1), u = K(() => Ns.layersWithOutsidePointerEventsDisabled.size > 0), c = K(() => {
      const h = Array.from(s.value), [v] = [...Ns.layersWithOutsidePointerEventsDisabled].slice(-1), m = h.indexOf(v);
      return l.value >= m;
    }), d = tee(async (h) => {
      const v = [...Ns.branches].some((m) => m == null ? void 0 : m.contains(h.target));
      !c.value || v || (r("pointerDownOutside", h), r("interactOutside", h), await Wt(), h.defaultPrevented || r("dismiss"));
    }, a), f = nee((h) => {
      [...Ns.branches].some((m) => m == null ? void 0 : m.contains(h.target)) || (r("focusOutside", h), r("interactOutside", h), h.defaultPrevented || r("dismiss"));
    }, a);
    aV("Escape", (h) => {
      l.value === s.value.size - 1 && (r("escapeKeyDown", h), h.defaultPrevented || r("dismiss"));
    });
    let p;
    return Cn((h) => {
      a.value && (t.disableOutsidePointerEvents && (Ns.layersWithOutsidePointerEventsDisabled.size === 0 && (p = o.value.body.style.pointerEvents, o.value.body.style.pointerEvents = "none"), Ns.layersWithOutsidePointerEventsDisabled.add(a.value)), s.value.add(a.value), h(() => {
        t.disableOutsidePointerEvents && Ns.layersWithOutsidePointerEventsDisabled.size === 1 && (o.value.body.style.pointerEvents = p);
      }));
    }), Cn((h) => {
      h(() => {
        a.value && (s.value.delete(a.value), Ns.layersWithOutsidePointerEventsDisabled.delete(a.value));
      });
    }), (h, v) => (L(), re(O(Sn), {
      ref: O(i),
      "as-child": h.asChild,
      as: h.as,
      "data-dismissable-layer": "",
      style: An({ pointerEvents: u.value ? c.value ? "auto" : "none" : void 0 }),
      onFocusCapture: O(f).onFocusCapture,
      onBlurCapture: O(f).onBlurCapture,
      onPointerdownCapture: O(d).onPointerDownCapture
    }, {
      default: ee(() => [ue(h.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "style",
      "onFocusCapture",
      "onBlurCapture",
      "onPointerdownCapture"
    ]));
  }
}), Cg = ree;
const iee = oQ(() => Z([]));
function aee() {
  const n = iee();
  return {
    add(e) {
      const t = n.value[0];
      e !== t && (t == null || t.pause()), n.value = fL(n.value, e), n.value.unshift(e);
    },
    remove(e) {
      var t;
      n.value = fL(n.value, e), (t = n.value[0]) == null || t.resume();
    }
  };
}
function fL(n, e) {
  const t = [...n], r = t.indexOf(e);
  return r !== -1 && t.splice(r, 1), t;
}
function oee(n) {
  return n.filter((e) => e.tagName !== "A");
}
const Xw = "focusScope.autoFocusOnMount", Zw = "focusScope.autoFocusOnUnmount", pL = {
  bubbles: !1,
  cancelable: !0
};
function see(n, { select: e = !1 } = {}) {
  const t = Di();
  for (const r of n)
    if (ql(r, { select: e }), Di() !== t) return !0;
}
function lee(n) {
  const e = fV(n), t = hL(e, n), r = hL(e.reverse(), n);
  return [t, r];
}
function fV(n) {
  const e = [], t = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, { acceptNode: (r) => {
    const i = r.tagName === "INPUT" && r.type === "hidden";
    return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; t.nextNode(); ) e.push(t.currentNode);
  return e;
}
function hL(n, e) {
  for (const t of n) if (!uee(t, { upTo: e })) return t;
}
function uee(n, { upTo: e }) {
  if (getComputedStyle(n).visibility === "hidden") return !0;
  for (; n; ) {
    if (e !== void 0 && n === e) return !1;
    if (getComputedStyle(n).display === "none") return !0;
    n = n.parentElement;
  }
  return !1;
}
function cee(n) {
  return n instanceof HTMLInputElement && "select" in n;
}
function ql(n, { select: e = !1 } = {}) {
  if (n && n.focus) {
    const t = Di();
    n.focus({ preventScroll: !0 }), n !== t && cee(n) && e && n.select();
  }
}
var dee = /* @__PURE__ */ ve({
  __name: "FocusScope",
  props: {
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    trapped: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(n, { emit: e }) {
    const t = n, r = e, { currentRef: i, currentElement: a } = Lt(), o = Z(null), s = aee(), l = Sr({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    });
    Cn((c) => {
      if (!Cs) return;
      const d = a.value;
      if (!t.trapped) return;
      function f(m) {
        if (l.paused || !d) return;
        const g = m.target;
        d.contains(g) ? o.value = g : ql(o.value, { select: !0 });
      }
      function p(m) {
        if (l.paused || !d) return;
        const g = m.relatedTarget;
        g !== null && (d.contains(g) || ql(o.value, { select: !0 }));
      }
      function h(m) {
        d.contains(o.value) || ql(d);
      }
      document.addEventListener("focusin", f), document.addEventListener("focusout", p);
      const v = new MutationObserver(h);
      d && v.observe(d, {
        childList: !0,
        subtree: !0
      }), c(() => {
        document.removeEventListener("focusin", f), document.removeEventListener("focusout", p), v.disconnect();
      });
    }), Cn(async (c) => {
      const d = a.value;
      if (await Wt(), !d) return;
      s.add(l);
      const f = Di();
      if (!d.contains(f)) {
        const h = new CustomEvent(Xw, pL);
        d.addEventListener(Xw, (v) => r("mountAutoFocus", v)), d.dispatchEvent(h), h.defaultPrevented || (see(oee(fV(d)), { select: !0 }), Di() === f && ql(d));
      }
      c(() => {
        d.removeEventListener(Xw, (m) => r("mountAutoFocus", m));
        const h = new CustomEvent(Zw, pL), v = (m) => {
          r("unmountAutoFocus", m);
        };
        d.addEventListener(Zw, v), d.dispatchEvent(h), setTimeout(() => {
          h.defaultPrevented || ql(f ?? document.body, { select: !0 }), d.removeEventListener(Zw, v), s.remove(l);
        }, 0);
      });
    });
    function u(c) {
      if (!t.loop && !t.trapped || l.paused) return;
      const d = c.key === "Tab" && !c.altKey && !c.ctrlKey && !c.metaKey, f = Di();
      if (d && f) {
        const p = c.currentTarget, [h, v] = lee(p);
        h && v ? !c.shiftKey && f === v ? (c.preventDefault(), t.loop && ql(h, { select: !0 })) : c.shiftKey && f === h && (c.preventDefault(), t.loop && ql(v, { select: !0 })) : f === p && c.preventDefault();
      }
    }
    return (c, d) => (L(), re(O(Sn), {
      ref_key: "currentRef",
      ref: i,
      tabindex: "-1",
      "as-child": c.asChild,
      as: c.as,
      onKeydown: u
    }, {
      default: ee(() => [ue(c.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), HA = dee;
const fee = "menu.itemSelect", ST = ["Enter", " "], pee = [
  "ArrowDown",
  "PageUp",
  "Home"
], pV = [
  "ArrowUp",
  "PageDown",
  "End"
], hee = [...pee, ...pV], vee = {
  ltr: [...ST, "ArrowRight"],
  rtl: [...ST, "ArrowLeft"]
}, mee = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function GA(n) {
  return n ? "open" : "closed";
}
function gee(n) {
  const e = Di();
  for (const t of n)
    if (t === e || (t.focus(), Di() !== e)) return;
}
function yee(n, e) {
  const { x: t, y: r } = n;
  let i = !1;
  for (let a = 0, o = e.length - 1; a < e.length; o = a++) {
    const s = e[a].x, l = e[a].y, u = e[o].x, c = e[o].y;
    l > r != c > r && t < (u - s) * (r - l) / (c - l) + s && (i = !i);
  }
  return i;
}
function bee(n, e) {
  if (!e) return !1;
  const t = {
    x: n.clientX,
    y: n.clientY
  };
  return yee(t, e);
}
function xm(n) {
  return n.pointerType === "mouse";
}
const _ee = "DialogTitle", xee = "DialogContent";
function wee({ titleName: n = _ee, contentName: e = xee, componentLink: t = "dialog.html#title", titleId: r, descriptionId: i, contentElement: a }) {
  const o = `Warning: \`${e}\` requires a \`${n}\` for the component to be accessible for screen reader users.

If you want to hide the \`${n}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://www.reka-ui.com/docs/components/${t}`, s = `Warning: Missing \`Description\` or \`aria-describedby="undefined"\` for ${e}.`;
  kt(() => {
    var c;
    document.getElementById(r) || console.warn(o);
    const u = (c = a.value) == null ? void 0 : c.getAttribute("aria-describedby");
    i && u && (document.getElementById(i) || console.warn(s));
  });
}
var See = /* @__PURE__ */ ve({
  __name: "DialogContentImpl",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, i = kl(), { forwardRef: a, currentElement: o } = Lt();
    return i.titleId || (i.titleId = ra(void 0, "reka-dialog-title")), i.descriptionId || (i.descriptionId = ra(void 0, "reka-dialog-description")), kt(() => {
      i.contentElement = o, Di() !== document.body && (i.triggerElement.value = Di());
    }), process.env.NODE_ENV !== "production" && wee({
      titleName: "DialogTitle",
      contentName: "DialogContent",
      componentLink: "dialog.html#title",
      titleId: i.titleId,
      descriptionId: i.descriptionId,
      contentElement: o
    }), (s, l) => (L(), re(O(HA), {
      "as-child": "",
      loop: "",
      trapped: t.trapFocus,
      onMountAutoFocus: l[5] || (l[5] = (u) => r("openAutoFocus", u)),
      onUnmountAutoFocus: l[6] || (l[6] = (u) => r("closeAutoFocus", u))
    }, {
      default: ee(() => [se(O(Cg), He({
        id: O(i).contentId,
        ref: O(a),
        as: s.as,
        "as-child": s.asChild,
        "disable-outside-pointer-events": s.disableOutsidePointerEvents,
        role: "dialog",
        "aria-describedby": O(i).descriptionId,
        "aria-labelledby": O(i).titleId,
        "data-state": O(GA)(O(i).open.value)
      }, s.$attrs, {
        onDismiss: l[0] || (l[0] = (u) => O(i).onOpenChange(!1)),
        onEscapeKeyDown: l[1] || (l[1] = (u) => r("escapeKeyDown", u)),
        onFocusOutside: l[2] || (l[2] = (u) => r("focusOutside", u)),
        onInteractOutside: l[3] || (l[3] = (u) => r("interactOutside", u)),
        onPointerDownOutside: l[4] || (l[4] = (u) => r("pointerDownOutside", u))
      }), {
        default: ee(() => [ue(s.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "as",
        "as-child",
        "disable-outside-pointer-events",
        "aria-describedby",
        "aria-labelledby",
        "data-state"
      ])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), hV = See, Eee = /* @__PURE__ */ ve({
  __name: "DialogContentModal",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, i = kl(), a = Tg(r), { forwardRef: o, currentElement: s } = Lt();
    return J_(s), (l, u) => (L(), re(hV, He({
      ...t,
      ...O(a)
    }, {
      ref: O(o),
      "trap-focus": O(i).open.value,
      "disable-outside-pointer-events": !0,
      onCloseAutoFocus: u[0] || (u[0] = (c) => {
        var d;
        c.defaultPrevented || (c.preventDefault(), (d = O(i).triggerElement.value) == null || d.focus());
      }),
      onPointerDownOutside: u[1] || (u[1] = (c) => {
        const d = c.detail.originalEvent, f = d.button === 0 && d.ctrlKey === !0;
        (d.button === 2 || f) && c.preventDefault();
      }),
      onFocusOutside: u[2] || (u[2] = (c) => {
        c.preventDefault();
      })
    }), {
      default: ee(() => [ue(l.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), Tee = Eee, Cee = /* @__PURE__ */ ve({
  __name: "DialogContentNonModal",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const t = n, i = Tg(e);
    Lt();
    const a = kl(), o = Z(!1), s = Z(!1);
    return (l, u) => (L(), re(hV, He({
      ...t,
      ...O(i)
    }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: u[0] || (u[0] = (c) => {
        var d;
        c.defaultPrevented || (o.value || (d = O(a).triggerElement.value) == null || d.focus(), c.preventDefault()), o.value = !1, s.value = !1;
      }),
      onInteractOutside: u[1] || (u[1] = (c) => {
        var p;
        c.defaultPrevented || (o.value = !0, c.detail.originalEvent.type === "pointerdown" && (s.value = !0));
        const d = c.target;
        ((p = O(a).triggerElement.value) == null ? void 0 : p.contains(d)) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && s.value && c.preventDefault();
      })
    }), {
      default: ee(() => [ue(l.$slots, "default")]),
      _: 3
    }, 16));
  }
}), kee = Cee, Aee = /* @__PURE__ */ ve({
  __name: "DialogContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, i = kl(), a = Tg(r), { forwardRef: o } = Lt();
    return (s, l) => (L(), re(O(Fu), { present: s.forceMount || O(i).open.value }, {
      default: ee(() => [O(i).modal.value ? (L(), re(Tee, He({
        key: 0,
        ref: O(o)
      }, {
        ...t,
        ...O(a),
        ...s.$attrs
      }), {
        default: ee(() => [ue(s.$slots, "default")]),
        _: 3
      }, 16)) : (L(), re(kee, He({
        key: 1,
        ref: O(o)
      }, {
        ...t,
        ...O(a),
        ...s.$attrs
      }), {
        default: ee(() => [ue(s.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), Mee = Aee, Dee = /* @__PURE__ */ ve({
  __name: "DialogDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(n) {
    const e = n;
    Lt();
    const t = kl();
    return (r, i) => (L(), re(O(Sn), He(e, { id: O(t).descriptionId }), {
      default: ee(() => [ue(r.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), vV = Dee, Oee = /* @__PURE__ */ ve({
  __name: "DialogOverlayImpl",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = kl();
    return X_(!0), Lt(), (t, r) => (L(), re(O(Sn), {
      as: t.as,
      "as-child": t.asChild,
      "data-state": O(e).open.value ? "open" : "closed",
      style: { "pointer-events": "auto" }
    }, {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-state"
    ]));
  }
}), Iee = Oee, Lee = /* @__PURE__ */ ve({
  __name: "DialogOverlay",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = kl(), { forwardRef: t } = Lt();
    return (r, i) => {
      var a;
      return (a = O(e)) != null && a.modal.value ? (L(), re(O(Fu), {
        key: 0,
        present: r.forceMount || O(e).open.value
      }, {
        default: ee(() => [se(Iee, He(r.$attrs, {
          ref: O(t),
          as: r.as,
          "as-child": r.asChild
        }), {
          default: ee(() => [ue(r.$slots, "default")]),
          _: 3
        }, 16, ["as", "as-child"])]),
        _: 3
      }, 8, ["present"])) : ge("v-if", !0);
    };
  }
}), Nee = Lee, Ree = /* @__PURE__ */ ve({
  __name: "Teleport",
  props: {
    to: {
      type: null,
      required: !1,
      default: "body"
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(n) {
    const e = _Q();
    return (t, r) => O(e) || t.forceMount ? (L(), re(wg, {
      key: 0,
      to: t.to,
      disabled: t.disabled,
      defer: t.defer
    }, [ue(t.$slots, "default")], 8, [
      "to",
      "disabled",
      "defer"
    ])) : ge("v-if", !0);
  }
}), kg = Ree, Pee = /* @__PURE__ */ ve({
  __name: "DialogPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(n) {
    const e = n;
    return (t, r) => (L(), re(O(kg), Bt(Jt(e)), {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 16));
  }
}), jee = Pee, Bee = /* @__PURE__ */ ve({
  __name: "DialogTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h2"
    }
  },
  setup(n) {
    const e = n, t = kl();
    return Lt(), (r, i) => (L(), re(O(Sn), He(e, { id: O(t).titleId }), {
      default: ee(() => [ue(r.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), mV = Bee;
const vL = "data-reka-collection-item";
function Qp(n = {}) {
  const { key: e = "", isProvider: t = !1 } = n, r = `${e}CollectionProvider`;
  let i;
  if (t) {
    const c = Z(/* @__PURE__ */ new Map());
    i = {
      collectionRef: Z(),
      itemMap: c
    }, zn(r, i);
  } else i = Xt(r);
  const a = (c = !1) => {
    const d = i.collectionRef.value;
    if (!d) return [];
    const f = Array.from(d.querySelectorAll(`[${vL}]`)), h = Array.from(i.itemMap.value.values()).sort((v, m) => f.indexOf(v.ref) - f.indexOf(m.ref));
    return c ? h : h.filter((v) => v.ref.dataset.disabled !== "");
  }, o = ve({
    name: "CollectionSlot",
    setup(c, { slots: d }) {
      const { primitiveElement: f, currentElement: p } = Au();
      return et(p, () => {
        i.collectionRef.value = p.value;
      }), () => qt(wT, { ref: f }, d);
    }
  }), s = ve({
    name: "CollectionItem",
    inheritAttrs: !1,
    props: { value: { validator: () => !0 } },
    setup(c, { slots: d, attrs: f }) {
      const { primitiveElement: p, currentElement: h } = Au();
      return Cn((v) => {
        if (h.value) {
          const m = cn(h.value);
          i.itemMap.value.set(m, {
            ref: h.value,
            value: c.value
          }), v(() => i.itemMap.value.delete(m));
        }
      }), () => qt(wT, {
        ...f,
        [vL]: "",
        ref: p
      }, d);
    }
  }), l = K(() => Array.from(i.itemMap.value.values())), u = K(() => i.itemMap.value.size);
  return {
    getItems: a,
    reactiveItems: l,
    itemMapSize: u,
    CollectionSlot: o,
    CollectionItem: s
  };
}
const $ee = "rovingFocusGroup.onEntryFocus", zee = {
  bubbles: !1,
  cancelable: !0
}, Fee = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Vee(n, e) {
  return e !== "rtl" ? n : n === "ArrowLeft" ? "ArrowRight" : n === "ArrowRight" ? "ArrowLeft" : n;
}
function Hee(n, e, t) {
  const r = Vee(n.key, t);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return Fee[r];
}
function Gee(n, e = !1) {
  const t = Di();
  for (const r of n)
    if (r === t || (r.focus({ preventScroll: e }), Di() !== t)) return;
}
const [oUe, Uee] = br("RovingFocusGroup");
var Wee = /* @__PURE__ */ ve({
  __name: "RovingFocusGroup",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    currentTabStopId: {
      type: [String, null],
      required: !1
    },
    defaultCurrentTabStopId: {
      type: String,
      required: !1
    },
    preventScrollOnEntryFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(n, { expose: e, emit: t }) {
    const r = n, i = t, { loop: a, orientation: o, dir: s } = fi(r), l = Eg(s), u = na(r, "currentTabStopId", i, {
      defaultValue: r.defaultCurrentTabStopId,
      passive: r.currentTabStopId === void 0
    }), c = Z(!1), d = Z(!1), f = Z(0), { getItems: p, CollectionSlot: h } = Qp({ isProvider: !0 });
    function v(g) {
      const y = !d.value;
      if (g.currentTarget && g.target === g.currentTarget && y && !c.value) {
        const b = new CustomEvent($ee, zee);
        if (g.currentTarget.dispatchEvent(b), i("entryFocus", b), !b.defaultPrevented) {
          const _ = p().map((C) => C.ref).filter((C) => C.dataset.disabled !== ""), x = _.find((C) => C.getAttribute("data-active") === ""), w = _.find((C) => C.id === u.value), S = [
            x,
            w,
            ..._
          ].filter(Boolean);
          Gee(S, r.preventScrollOnEntryFocus);
        }
      }
      d.value = !1;
    }
    function m() {
      setTimeout(() => {
        d.value = !1;
      }, 1);
    }
    return e({ getItems: p }), Uee({
      loop: a,
      dir: l,
      orientation: o,
      currentTabStopId: u,
      onItemFocus: (g) => {
        u.value = g;
      },
      onItemShiftTab: () => {
        c.value = !0;
      },
      onFocusableItemAdd: () => {
        f.value++;
      },
      onFocusableItemRemove: () => {
        f.value--;
      }
    }), (g, y) => (L(), re(O(h), null, {
      default: ee(() => [se(O(Sn), {
        tabindex: c.value || f.value === 0 ? -1 : 0,
        "data-orientation": O(o),
        as: g.as,
        "as-child": g.asChild,
        dir: O(l),
        style: { outline: "none" },
        onMousedown: y[0] || (y[0] = (b) => d.value = !0),
        onMouseup: m,
        onFocus: v,
        onBlur: y[1] || (y[1] = (b) => c.value = !1)
      }, {
        default: ee(() => [ue(g.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "as",
        "as-child",
        "dir"
      ])]),
      _: 3
    }));
  }
}), qee = Wee, Yee = /* @__PURE__ */ ve({
  __name: "VisuallyHidden",
  props: {
    feature: {
      type: String,
      required: !1,
      default: "focusable"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(n) {
    return (e, t) => (L(), re(O(Sn), {
      as: e.as,
      "as-child": e.asChild,
      "aria-hidden": e.feature === "focusable" ? "true" : void 0,
      "data-hidden": e.feature === "fully-hidden" ? "" : void 0,
      tabindex: e.feature === "fully-hidden" ? "-1" : void 0,
      style: {
        position: "absolute",
        border: 0,
        width: "1px",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        clipPath: "inset(50%)",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      }
    }, {
      default: ee(() => [ue(e.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-hidden",
      "data-hidden",
      "tabindex"
    ]));
  }
}), UA = Yee, Kee = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInputBubble",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(n) {
    const e = n, { primitiveElement: t, currentElement: r } = Au(), i = K(() => e.checked ?? e.value);
    return et(i, (a, o) => {
      if (!r.value) return;
      const s = r.value, l = window.HTMLInputElement.prototype, c = Object.getOwnPropertyDescriptor(l, "value").set;
      if (c && a !== o) {
        const d = new Event("input", { bubbles: !0 }), f = new Event("change", { bubbles: !0 });
        c.call(s, a), s.dispatchEvent(d), s.dispatchEvent(f);
      }
    }), (a, o) => (L(), re(UA, He({
      ref_key: "primitiveElement",
      ref: t
    }, {
      ...e,
      ...a.$attrs
    }, { as: "input" }), null, 16));
  }
}), mL = Kee, Xee = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInput",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(n) {
    const e = n, t = K(() => typeof e.value == "object" && Array.isArray(e.value) && e.value.length === 0 && e.required), r = K(() => typeof e.value == "string" || typeof e.value == "number" || typeof e.value == "boolean" || e.value === null || e.value === void 0 ? [{
      name: e.name,
      value: e.value
    }] : typeof e.value == "object" && Array.isArray(e.value) ? e.value.flatMap((i, a) => typeof i == "object" ? Object.entries(i).map(([o, s]) => ({
      name: `${e.name}[${a}][${o}]`,
      value: s
    })) : {
      name: `${e.name}[${a}]`,
      value: i
    }) : e.value !== null && typeof e.value == "object" && !Array.isArray(e.value) ? Object.entries(e.value).map(([i, a]) => ({
      name: `${e.name}[${i}]`,
      value: a
    })) : []);
    return (i, a) => (L(), W(Ke, null, [ge(" We render single input if it's required "), t.value ? (L(), re(mL, He({ key: i.name }, {
      ...e,
      ...i.$attrs
    }, {
      name: i.name,
      value: i.value
    }), null, 16, ["name", "value"])) : (L(!0), W(Ke, { key: 1 }, _t(r.value, (o) => (L(), re(mL, He({ key: o.name }, { ref_for: !0 }, {
      ...e,
      ...i.$attrs
    }, {
      name: o.name,
      value: o.value
    }), null, 16, ["name", "value"]))), 128))], 2112));
  }
}), Zee = Xee;
const [gV, Jee] = br("PopperRoot");
var Qee = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "PopperRoot",
  setup(n) {
    const e = Z();
    return Jee({
      anchor: e,
      onAnchorChange: (t) => e.value = t
    }), (t, r) => ue(t.$slots, "default");
  }
}), Ag = Qee, ete = /* @__PURE__ */ ve({
  __name: "PopperAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = n, { forwardRef: t, currentElement: r } = Lt(), i = gV();
    return mF(() => {
      i.onAnchorChange(e.reference ?? r.value);
    }), (a, o) => (L(), re(O(Sn), {
      ref: O(t),
      as: a.as,
      "as-child": a.asChild
    }, {
      default: ee(() => [ue(a.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), Q_ = ete;
const tte = {
  key: 0,
  d: "M0 0L6 6L12 0"
}, nte = {
  key: 1,
  d: "M0 0L4.58579 4.58579C5.36683 5.36683 6.63316 5.36684 7.41421 4.58579L12 0"
};
var rte = /* @__PURE__ */ ve({
  __name: "Arrow",
  props: {
    width: {
      type: Number,
      required: !1,
      default: 10
    },
    height: {
      type: Number,
      required: !1,
      default: 5
    },
    rounded: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(n) {
    const e = n;
    return Lt(), (t, r) => (L(), re(O(Sn), He(e, {
      width: t.width,
      height: t.height,
      viewBox: t.asChild ? void 0 : "0 0 12 6",
      preserveAspectRatio: t.asChild ? void 0 : "none"
    }), {
      default: ee(() => [ue(t.$slots, "default", {}, () => [t.rounded ? (L(), W("path", nte)) : (L(), W("path", tte))])]),
      _: 3
    }, 16, [
      "width",
      "height",
      "viewBox",
      "preserveAspectRatio"
    ]));
  }
}), ite = rte;
function ate(n) {
  return n !== null;
}
function ote(n) {
  return {
    name: "transformOrigin",
    options: n,
    fn(e) {
      var m, g, y;
      const { placement: t, rects: r, middlewareData: i } = e, o = ((m = i.arrow) == null ? void 0 : m.centerOffset) !== 0, s = o ? 0 : n.arrowWidth, l = o ? 0 : n.arrowHeight, [u, c] = ET(t), d = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[c], f = (((g = i.arrow) == null ? void 0 : g.x) ?? 0) + s / 2, p = (((y = i.arrow) == null ? void 0 : y.y) ?? 0) + l / 2;
      let h = "", v = "";
      return u === "bottom" ? (h = o ? d : `${f}px`, v = `${-l}px`) : u === "top" ? (h = o ? d : `${f}px`, v = `${r.floating.height + l}px`) : u === "right" ? (h = `${-l}px`, v = o ? d : `${p}px`) : u === "left" && (h = `${r.floating.width + l}px`, v = o ? d : `${p}px`), { data: {
        x: h,
        y: v
      } };
    }
  };
}
function ET(n) {
  const [e, t = "center"] = n.split("-");
  return [e, t];
}
const ste = ["top", "right", "bottom", "left"], Mu = Math.min, ua = Math.max, $1 = Math.round, xy = Math.floor, ds = (n) => ({
  x: n,
  y: n
}), lte = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, ute = {
  start: "end",
  end: "start"
};
function TT(n, e, t) {
  return ua(n, Mu(e, t));
}
function vl(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function ml(n) {
  return n.split("-")[0];
}
function eh(n) {
  return n.split("-")[1];
}
function WA(n) {
  return n === "x" ? "y" : "x";
}
function qA(n) {
  return n === "y" ? "height" : "width";
}
const cte = /* @__PURE__ */ new Set(["top", "bottom"]);
function rs(n) {
  return cte.has(ml(n)) ? "y" : "x";
}
function YA(n) {
  return WA(rs(n));
}
function dte(n, e, t) {
  t === void 0 && (t = !1);
  const r = eh(n), i = YA(n), a = qA(i);
  let o = i === "x" ? r === (t ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[a] > e.floating[a] && (o = z1(o)), [o, z1(o)];
}
function fte(n) {
  const e = z1(n);
  return [CT(n), e, CT(e)];
}
function CT(n) {
  return n.replace(/start|end/g, (e) => ute[e]);
}
const gL = ["left", "right"], yL = ["right", "left"], pte = ["top", "bottom"], hte = ["bottom", "top"];
function vte(n, e, t) {
  switch (n) {
    case "top":
    case "bottom":
      return t ? e ? yL : gL : e ? gL : yL;
    case "left":
    case "right":
      return e ? pte : hte;
    default:
      return [];
  }
}
function mte(n, e, t, r) {
  const i = eh(n);
  let a = vte(ml(n), t === "start", r);
  return i && (a = a.map((o) => o + "-" + i), e && (a = a.concat(a.map(CT)))), a;
}
function z1(n) {
  return n.replace(/left|right|bottom|top/g, (e) => lte[e]);
}
function gte(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
function yV(n) {
  return typeof n != "number" ? gte(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
function F1(n) {
  const {
    x: e,
    y: t,
    width: r,
    height: i
  } = n;
  return {
    width: r,
    height: i,
    top: t,
    left: e,
    right: e + r,
    bottom: t + i,
    x: e,
    y: t
  };
}
function bL(n, e, t) {
  let {
    reference: r,
    floating: i
  } = n;
  const a = rs(e), o = YA(e), s = qA(o), l = ml(e), u = a === "y", c = r.x + r.width / 2 - i.width / 2, d = r.y + r.height / 2 - i.height / 2, f = r[s] / 2 - i[s] / 2;
  let p;
  switch (l) {
    case "top":
      p = {
        x: c,
        y: r.y - i.height
      };
      break;
    case "bottom":
      p = {
        x: c,
        y: r.y + r.height
      };
      break;
    case "right":
      p = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      p = {
        x: r.x - i.width,
        y: d
      };
      break;
    default:
      p = {
        x: r.x,
        y: r.y
      };
  }
  switch (eh(e)) {
    case "start":
      p[o] -= f * (t && u ? -1 : 1);
      break;
    case "end":
      p[o] += f * (t && u ? -1 : 1);
      break;
  }
  return p;
}
const yte = async (n, e, t) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: a = [],
    platform: o
  } = t, s = a.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let u = await o.getElementRects({
    reference: n,
    floating: e,
    strategy: i
  }), {
    x: c,
    y: d
  } = bL(u, r, l), f = r, p = {}, h = 0;
  for (let v = 0; v < s.length; v++) {
    const {
      name: m,
      fn: g
    } = s[v], {
      x: y,
      y: b,
      data: _,
      reset: x
    } = await g({
      x: c,
      y: d,
      initialPlacement: r,
      placement: f,
      strategy: i,
      middlewareData: p,
      rects: u,
      platform: o,
      elements: {
        reference: n,
        floating: e
      }
    });
    c = y ?? c, d = b ?? d, p = {
      ...p,
      [m]: {
        ...p[m],
        ..._
      }
    }, x && h <= 50 && (h++, typeof x == "object" && (x.placement && (f = x.placement), x.rects && (u = x.rects === !0 ? await o.getElementRects({
      reference: n,
      floating: e,
      strategy: i
    }) : x.rects), {
      x: c,
      y: d
    } = bL(u, f, l)), v = -1);
  }
  return {
    x: c,
    y: d,
    placement: f,
    strategy: i,
    middlewareData: p
  };
};
async function wm(n, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: r,
    y: i,
    platform: a,
    rects: o,
    elements: s,
    strategy: l
  } = n, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: d = "floating",
    altBoundary: f = !1,
    padding: p = 0
  } = vl(e, n), h = yV(p), m = s[f ? d === "floating" ? "reference" : "floating" : d], g = F1(await a.getClippingRect({
    element: (t = await (a.isElement == null ? void 0 : a.isElement(m))) == null || t ? m : m.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(s.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: l
  })), y = d === "floating" ? {
    x: r,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, b = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(s.floating)), _ = await (a.isElement == null ? void 0 : a.isElement(b)) ? await (a.getScale == null ? void 0 : a.getScale(b)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, x = F1(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: y,
    offsetParent: b,
    strategy: l
  }) : y);
  return {
    top: (g.top - x.top + h.top) / _.y,
    bottom: (x.bottom - g.bottom + h.bottom) / _.y,
    left: (g.left - x.left + h.left) / _.x,
    right: (x.right - g.right + h.right) / _.x
  };
}
const bte = (n) => ({
  name: "arrow",
  options: n,
  async fn(e) {
    const {
      x: t,
      y: r,
      placement: i,
      rects: a,
      platform: o,
      elements: s,
      middlewareData: l
    } = e, {
      element: u,
      padding: c = 0
    } = vl(n, e) || {};
    if (u == null)
      return {};
    const d = yV(c), f = {
      x: t,
      y: r
    }, p = YA(i), h = qA(p), v = await o.getDimensions(u), m = p === "y", g = m ? "top" : "left", y = m ? "bottom" : "right", b = m ? "clientHeight" : "clientWidth", _ = a.reference[h] + a.reference[p] - f[p] - a.floating[h], x = f[p] - a.reference[p], w = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(u));
    let S = w ? w[b] : 0;
    (!S || !await (o.isElement == null ? void 0 : o.isElement(w))) && (S = s.floating[b] || a.floating[h]);
    const C = _ / 2 - x / 2, k = S / 2 - v[h] / 2 - 1, M = Mu(d[g], k), D = Mu(d[y], k), N = M, R = S - v[h] - D, j = S / 2 - v[h] / 2 + C, z = TT(N, j, R), F = !l.arrow && eh(i) != null && j !== z && a.reference[h] / 2 - (j < N ? M : D) - v[h] / 2 < 0, B = F ? j < N ? j - N : j - R : 0;
    return {
      [p]: f[p] + B,
      data: {
        [p]: z,
        centerOffset: j - z - B,
        ...F && {
          alignmentOffset: B
        }
      },
      reset: F
    };
  }
}), _te = function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(e) {
      var t, r;
      const {
        placement: i,
        middlewareData: a,
        rects: o,
        initialPlacement: s,
        platform: l,
        elements: u
      } = e, {
        mainAxis: c = !0,
        crossAxis: d = !0,
        fallbackPlacements: f,
        fallbackStrategy: p = "bestFit",
        fallbackAxisSideDirection: h = "none",
        flipAlignment: v = !0,
        ...m
      } = vl(n, e);
      if ((t = a.arrow) != null && t.alignmentOffset)
        return {};
      const g = ml(i), y = rs(s), b = ml(s) === s, _ = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), x = f || (b || !v ? [z1(s)] : fte(s)), w = h !== "none";
      !f && w && x.push(...mte(s, v, h, _));
      const S = [s, ...x], C = await wm(e, m), k = [];
      let M = ((r = a.flip) == null ? void 0 : r.overflows) || [];
      if (c && k.push(C[g]), d) {
        const j = dte(i, o, _);
        k.push(C[j[0]], C[j[1]]);
      }
      if (M = [...M, {
        placement: i,
        overflows: k
      }], !k.every((j) => j <= 0)) {
        var D, N;
        const j = (((D = a.flip) == null ? void 0 : D.index) || 0) + 1, z = S[j];
        if (z && (!(d === "alignment" ? y !== rs(z) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        M.every((H) => rs(H.placement) === y ? H.overflows[0] > 0 : !0)))
          return {
            data: {
              index: j,
              overflows: M
            },
            reset: {
              placement: z
            }
          };
        let F = (N = M.filter((B) => B.overflows[0] <= 0).sort((B, H) => B.overflows[1] - H.overflows[1])[0]) == null ? void 0 : N.placement;
        if (!F)
          switch (p) {
            case "bestFit": {
              var R;
              const B = (R = M.filter((H) => {
                if (w) {
                  const Y = rs(H.placement);
                  return Y === y || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Y === "y";
                }
                return !0;
              }).map((H) => [H.placement, H.overflows.filter((Y) => Y > 0).reduce((Y, ne) => Y + ne, 0)]).sort((H, Y) => H[1] - Y[1])[0]) == null ? void 0 : R[0];
              B && (F = B);
              break;
            }
            case "initialPlacement":
              F = s;
              break;
          }
        if (i !== F)
          return {
            reset: {
              placement: F
            }
          };
      }
      return {};
    }
  };
};
function _L(n, e) {
  return {
    top: n.top - e.height,
    right: n.right - e.width,
    bottom: n.bottom - e.height,
    left: n.left - e.width
  };
}
function xL(n) {
  return ste.some((e) => n[e] >= 0);
}
const xte = function(n) {
  return n === void 0 && (n = {}), {
    name: "hide",
    options: n,
    async fn(e) {
      const {
        rects: t
      } = e, {
        strategy: r = "referenceHidden",
        ...i
      } = vl(n, e);
      switch (r) {
        case "referenceHidden": {
          const a = await wm(e, {
            ...i,
            elementContext: "reference"
          }), o = _L(a, t.reference);
          return {
            data: {
              referenceHiddenOffsets: o,
              referenceHidden: xL(o)
            }
          };
        }
        case "escaped": {
          const a = await wm(e, {
            ...i,
            altBoundary: !0
          }), o = _L(a, t.floating);
          return {
            data: {
              escapedOffsets: o,
              escaped: xL(o)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, bV = /* @__PURE__ */ new Set(["left", "top"]);
async function wte(n, e) {
  const {
    placement: t,
    platform: r,
    elements: i
  } = n, a = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = ml(t), s = eh(t), l = rs(t) === "y", u = bV.has(o) ? -1 : 1, c = a && l ? -1 : 1, d = vl(e, n);
  let {
    mainAxis: f,
    crossAxis: p,
    alignmentAxis: h
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return s && typeof h == "number" && (p = s === "end" ? h * -1 : h), l ? {
    x: p * c,
    y: f * u
  } : {
    x: f * u,
    y: p * c
  };
}
const Ste = function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(e) {
      var t, r;
      const {
        x: i,
        y: a,
        placement: o,
        middlewareData: s
      } = e, l = await wte(e, n);
      return o === ((t = s.offset) == null ? void 0 : t.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : {
        x: i + l.x,
        y: a + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, Ete = function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(e) {
      const {
        x: t,
        y: r,
        placement: i
      } = e, {
        mainAxis: a = !0,
        crossAxis: o = !1,
        limiter: s = {
          fn: (m) => {
            let {
              x: g,
              y
            } = m;
            return {
              x: g,
              y
            };
          }
        },
        ...l
      } = vl(n, e), u = {
        x: t,
        y: r
      }, c = await wm(e, l), d = rs(ml(i)), f = WA(d);
      let p = u[f], h = u[d];
      if (a) {
        const m = f === "y" ? "top" : "left", g = f === "y" ? "bottom" : "right", y = p + c[m], b = p - c[g];
        p = TT(y, p, b);
      }
      if (o) {
        const m = d === "y" ? "top" : "left", g = d === "y" ? "bottom" : "right", y = h + c[m], b = h - c[g];
        h = TT(y, h, b);
      }
      const v = s.fn({
        ...e,
        [f]: p,
        [d]: h
      });
      return {
        ...v,
        data: {
          x: v.x - t,
          y: v.y - r,
          enabled: {
            [f]: a,
            [d]: o
          }
        }
      };
    }
  };
}, Tte = function(n) {
  return n === void 0 && (n = {}), {
    options: n,
    fn(e) {
      const {
        x: t,
        y: r,
        placement: i,
        rects: a,
        middlewareData: o
      } = e, {
        offset: s = 0,
        mainAxis: l = !0,
        crossAxis: u = !0
      } = vl(n, e), c = {
        x: t,
        y: r
      }, d = rs(i), f = WA(d);
      let p = c[f], h = c[d];
      const v = vl(s, e), m = typeof v == "number" ? {
        mainAxis: v,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...v
      };
      if (l) {
        const b = f === "y" ? "height" : "width", _ = a.reference[f] - a.floating[b] + m.mainAxis, x = a.reference[f] + a.reference[b] - m.mainAxis;
        p < _ ? p = _ : p > x && (p = x);
      }
      if (u) {
        var g, y;
        const b = f === "y" ? "width" : "height", _ = bV.has(ml(i)), x = a.reference[d] - a.floating[b] + (_ && ((g = o.offset) == null ? void 0 : g[d]) || 0) + (_ ? 0 : m.crossAxis), w = a.reference[d] + a.reference[b] + (_ ? 0 : ((y = o.offset) == null ? void 0 : y[d]) || 0) - (_ ? m.crossAxis : 0);
        h < x ? h = x : h > w && (h = w);
      }
      return {
        [f]: p,
        [d]: h
      };
    }
  };
}, Cte = function(n) {
  return n === void 0 && (n = {}), {
    name: "size",
    options: n,
    async fn(e) {
      var t, r;
      const {
        placement: i,
        rects: a,
        platform: o,
        elements: s
      } = e, {
        apply: l = () => {
        },
        ...u
      } = vl(n, e), c = await wm(e, u), d = ml(i), f = eh(i), p = rs(i) === "y", {
        width: h,
        height: v
      } = a.floating;
      let m, g;
      d === "top" || d === "bottom" ? (m = d, g = f === (await (o.isRTL == null ? void 0 : o.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (g = d, m = f === "end" ? "top" : "bottom");
      const y = v - c.top - c.bottom, b = h - c.left - c.right, _ = Mu(v - c[m], y), x = Mu(h - c[g], b), w = !e.middlewareData.shift;
      let S = _, C = x;
      if ((t = e.middlewareData.shift) != null && t.enabled.x && (C = b), (r = e.middlewareData.shift) != null && r.enabled.y && (S = y), w && !f) {
        const M = ua(c.left, 0), D = ua(c.right, 0), N = ua(c.top, 0), R = ua(c.bottom, 0);
        p ? C = h - 2 * (M !== 0 || D !== 0 ? M + D : ua(c.left, c.right)) : S = v - 2 * (N !== 0 || R !== 0 ? N + R : ua(c.top, c.bottom));
      }
      await l({
        ...e,
        availableWidth: C,
        availableHeight: S
      });
      const k = await o.getDimensions(s.floating);
      return h !== k.width || v !== k.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function ex() {
  return typeof window < "u";
}
function Hd(n) {
  return KA(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function ma(n) {
  var e;
  return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function ks(n) {
  var e;
  return (e = (KA(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : e.documentElement;
}
function KA(n) {
  return ex() ? n instanceof Node || n instanceof ma(n).Node : !1;
}
function To(n) {
  return ex() ? n instanceof Element || n instanceof ma(n).Element : !1;
}
function gs(n) {
  return ex() ? n instanceof HTMLElement || n instanceof ma(n).HTMLElement : !1;
}
function wL(n) {
  return !ex() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof ma(n).ShadowRoot;
}
const kte = /* @__PURE__ */ new Set(["inline", "contents"]);
function Mg(n) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: r,
    display: i
  } = Co(n);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + t) && !kte.has(i);
}
const Ate = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Mte(n) {
  return Ate.has(Hd(n));
}
const Dte = [":popover-open", ":modal"];
function tx(n) {
  return Dte.some((e) => {
    try {
      return n.matches(e);
    } catch {
      return !1;
    }
  });
}
const Ote = ["transform", "translate", "scale", "rotate", "perspective"], Ite = ["transform", "translate", "scale", "rotate", "perspective", "filter"], Lte = ["paint", "layout", "strict", "content"];
function XA(n) {
  const e = ZA(), t = To(n) ? Co(n) : n;
  return Ote.some((r) => t[r] ? t[r] !== "none" : !1) || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || Ite.some((r) => (t.willChange || "").includes(r)) || Lte.some((r) => (t.contain || "").includes(r));
}
function Nte(n) {
  let e = Du(n);
  for (; gs(e) && !Tp(e); ) {
    if (XA(e))
      return e;
    if (tx(e))
      return null;
    e = Du(e);
  }
  return null;
}
function ZA() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const Rte = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Tp(n) {
  return Rte.has(Hd(n));
}
function Co(n) {
  return ma(n).getComputedStyle(n);
}
function nx(n) {
  return To(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
function Du(n) {
  if (Hd(n) === "html")
    return n;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    wL(n) && n.host || // Fallback.
    ks(n)
  );
  return wL(e) ? e.host : e;
}
function _V(n) {
  const e = Du(n);
  return Tp(e) ? n.ownerDocument ? n.ownerDocument.body : n.body : gs(e) && Mg(e) ? e : _V(e);
}
function Sm(n, e, t) {
  var r;
  e === void 0 && (e = []), t === void 0 && (t = !0);
  const i = _V(n), a = i === ((r = n.ownerDocument) == null ? void 0 : r.body), o = ma(i);
  if (a) {
    const s = kT(o);
    return e.concat(o, o.visualViewport || [], Mg(i) ? i : [], s && t ? Sm(s) : []);
  }
  return e.concat(i, Sm(i, [], t));
}
function kT(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
function xV(n) {
  const e = Co(n);
  let t = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = gs(n), a = i ? n.offsetWidth : t, o = i ? n.offsetHeight : r, s = $1(t) !== a || $1(r) !== o;
  return s && (t = a, r = o), {
    width: t,
    height: r,
    $: s
  };
}
function JA(n) {
  return To(n) ? n : n.contextElement;
}
function pp(n) {
  const e = JA(n);
  if (!gs(e))
    return ds(1);
  const t = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: a
  } = xV(e);
  let o = (a ? $1(t.width) : t.width) / r, s = (a ? $1(t.height) : t.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: o,
    y: s
  };
}
const Pte = /* @__PURE__ */ ds(0);
function wV(n) {
  const e = ma(n);
  return !ZA() || !e.visualViewport ? Pte : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function jte(n, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== ma(n) ? !1 : e;
}
function bd(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const i = n.getBoundingClientRect(), a = JA(n);
  let o = ds(1);
  e && (r ? To(r) && (o = pp(r)) : o = pp(n));
  const s = jte(a, t, r) ? wV(a) : ds(0);
  let l = (i.left + s.x) / o.x, u = (i.top + s.y) / o.y, c = i.width / o.x, d = i.height / o.y;
  if (a) {
    const f = ma(a), p = r && To(r) ? ma(r) : r;
    let h = f, v = kT(h);
    for (; v && r && p !== h; ) {
      const m = pp(v), g = v.getBoundingClientRect(), y = Co(v), b = g.left + (v.clientLeft + parseFloat(y.paddingLeft)) * m.x, _ = g.top + (v.clientTop + parseFloat(y.paddingTop)) * m.y;
      l *= m.x, u *= m.y, c *= m.x, d *= m.y, l += b, u += _, h = ma(v), v = kT(h);
    }
  }
  return F1({
    width: c,
    height: d,
    x: l,
    y: u
  });
}
function rx(n, e) {
  const t = nx(n).scrollLeft;
  return e ? e.left + t : bd(ks(n)).left + t;
}
function SV(n, e) {
  const t = n.getBoundingClientRect(), r = t.left + e.scrollLeft - rx(n, t), i = t.top + e.scrollTop;
  return {
    x: r,
    y: i
  };
}
function Bte(n) {
  let {
    elements: e,
    rect: t,
    offsetParent: r,
    strategy: i
  } = n;
  const a = i === "fixed", o = ks(r), s = e ? tx(e.floating) : !1;
  if (r === o || s && a)
    return t;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = ds(1);
  const c = ds(0), d = gs(r);
  if ((d || !d && !a) && ((Hd(r) !== "body" || Mg(o)) && (l = nx(r)), gs(r))) {
    const p = bd(r);
    u = pp(r), c.x = p.x + r.clientLeft, c.y = p.y + r.clientTop;
  }
  const f = o && !d && !a ? SV(o, l) : ds(0);
  return {
    width: t.width * u.x,
    height: t.height * u.y,
    x: t.x * u.x - l.scrollLeft * u.x + c.x + f.x,
    y: t.y * u.y - l.scrollTop * u.y + c.y + f.y
  };
}
function $te(n) {
  return Array.from(n.getClientRects());
}
function zte(n) {
  const e = ks(n), t = nx(n), r = n.ownerDocument.body, i = ua(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), a = ua(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -t.scrollLeft + rx(n);
  const s = -t.scrollTop;
  return Co(r).direction === "rtl" && (o += ua(e.clientWidth, r.clientWidth) - i), {
    width: i,
    height: a,
    x: o,
    y: s
  };
}
const SL = 25;
function Fte(n, e) {
  const t = ma(n), r = ks(n), i = t.visualViewport;
  let a = r.clientWidth, o = r.clientHeight, s = 0, l = 0;
  if (i) {
    a = i.width, o = i.height;
    const c = ZA();
    (!c || c && e === "fixed") && (s = i.offsetLeft, l = i.offsetTop);
  }
  const u = rx(r);
  if (u <= 0) {
    const c = r.ownerDocument, d = c.body, f = getComputedStyle(d), p = c.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, h = Math.abs(r.clientWidth - d.clientWidth - p);
    h <= SL && (a -= h);
  } else u <= SL && (a += u);
  return {
    width: a,
    height: o,
    x: s,
    y: l
  };
}
const Vte = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Hte(n, e) {
  const t = bd(n, !0, e === "fixed"), r = t.top + n.clientTop, i = t.left + n.clientLeft, a = gs(n) ? pp(n) : ds(1), o = n.clientWidth * a.x, s = n.clientHeight * a.y, l = i * a.x, u = r * a.y;
  return {
    width: o,
    height: s,
    x: l,
    y: u
  };
}
function EL(n, e, t) {
  let r;
  if (e === "viewport")
    r = Fte(n, t);
  else if (e === "document")
    r = zte(ks(n));
  else if (To(e))
    r = Hte(e, t);
  else {
    const i = wV(n);
    r = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return F1(r);
}
function EV(n, e) {
  const t = Du(n);
  return t === e || !To(t) || Tp(t) ? !1 : Co(t).position === "fixed" || EV(t, e);
}
function Gte(n, e) {
  const t = e.get(n);
  if (t)
    return t;
  let r = Sm(n, [], !1).filter((s) => To(s) && Hd(s) !== "body"), i = null;
  const a = Co(n).position === "fixed";
  let o = a ? Du(n) : n;
  for (; To(o) && !Tp(o); ) {
    const s = Co(o), l = XA(o);
    !l && s.position === "fixed" && (i = null), (a ? !l && !i : !l && s.position === "static" && !!i && Vte.has(i.position) || Mg(o) && !l && EV(n, o)) ? r = r.filter((c) => c !== o) : i = s, o = Du(o);
  }
  return e.set(n, r), r;
}
function Ute(n) {
  let {
    element: e,
    boundary: t,
    rootBoundary: r,
    strategy: i
  } = n;
  const o = [...t === "clippingAncestors" ? tx(e) ? [] : Gte(e, this._c) : [].concat(t), r], s = o[0], l = o.reduce((u, c) => {
    const d = EL(e, c, i);
    return u.top = ua(d.top, u.top), u.right = Mu(d.right, u.right), u.bottom = Mu(d.bottom, u.bottom), u.left = ua(d.left, u.left), u;
  }, EL(e, s, i));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function Wte(n) {
  const {
    width: e,
    height: t
  } = xV(n);
  return {
    width: e,
    height: t
  };
}
function qte(n, e, t) {
  const r = gs(e), i = ks(e), a = t === "fixed", o = bd(n, !0, a, e);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = ds(0);
  function u() {
    l.x = rx(i);
  }
  if (r || !r && !a)
    if ((Hd(e) !== "body" || Mg(i)) && (s = nx(e)), r) {
      const p = bd(e, !0, a, e);
      l.x = p.x + e.clientLeft, l.y = p.y + e.clientTop;
    } else i && u();
  a && !r && i && u();
  const c = i && !r && !a ? SV(i, s) : ds(0), d = o.left + s.scrollLeft - l.x - c.x, f = o.top + s.scrollTop - l.y - c.y;
  return {
    x: d,
    y: f,
    width: o.width,
    height: o.height
  };
}
function Jw(n) {
  return Co(n).position === "static";
}
function TL(n, e) {
  if (!gs(n) || Co(n).position === "fixed")
    return null;
  if (e)
    return e(n);
  let t = n.offsetParent;
  return ks(n) === t && (t = t.ownerDocument.body), t;
}
function TV(n, e) {
  const t = ma(n);
  if (tx(n))
    return t;
  if (!gs(n)) {
    let i = Du(n);
    for (; i && !Tp(i); ) {
      if (To(i) && !Jw(i))
        return i;
      i = Du(i);
    }
    return t;
  }
  let r = TL(n, e);
  for (; r && Mte(r) && Jw(r); )
    r = TL(r, e);
  return r && Tp(r) && Jw(r) && !XA(r) ? t : r || Nte(n) || t;
}
const Yte = async function(n) {
  const e = this.getOffsetParent || TV, t = this.getDimensions, r = await t(n.floating);
  return {
    reference: qte(n.reference, await e(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function Kte(n) {
  return Co(n).direction === "rtl";
}
const Xte = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Bte,
  getDocumentElement: ks,
  getClippingRect: Ute,
  getOffsetParent: TV,
  getElementRects: Yte,
  getClientRects: $te,
  getDimensions: Wte,
  getScale: pp,
  isElement: To,
  isRTL: Kte
};
function CV(n, e) {
  return n.x === e.x && n.y === e.y && n.width === e.width && n.height === e.height;
}
function Zte(n, e) {
  let t = null, r;
  const i = ks(n);
  function a() {
    var s;
    clearTimeout(r), (s = t) == null || s.disconnect(), t = null;
  }
  function o(s, l) {
    s === void 0 && (s = !1), l === void 0 && (l = 1), a();
    const u = n.getBoundingClientRect(), {
      left: c,
      top: d,
      width: f,
      height: p
    } = u;
    if (s || e(), !f || !p)
      return;
    const h = xy(d), v = xy(i.clientWidth - (c + f)), m = xy(i.clientHeight - (d + p)), g = xy(c), b = {
      rootMargin: -h + "px " + -v + "px " + -m + "px " + -g + "px",
      threshold: ua(0, Mu(1, l)) || 1
    };
    let _ = !0;
    function x(w) {
      const S = w[0].intersectionRatio;
      if (S !== l) {
        if (!_)
          return o();
        S ? o(!1, S) : r = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      S === 1 && !CV(u, n.getBoundingClientRect()) && o(), _ = !1;
    }
    try {
      t = new IntersectionObserver(x, {
        ...b,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      t = new IntersectionObserver(x, b);
    }
    t.observe(n);
  }
  return o(!0), a;
}
function kV(n, e, t, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: a = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, u = JA(n), c = i || a ? [...u ? Sm(u) : [], ...Sm(e)] : [];
  c.forEach((g) => {
    i && g.addEventListener("scroll", t, {
      passive: !0
    }), a && g.addEventListener("resize", t);
  });
  const d = u && s ? Zte(u, t) : null;
  let f = -1, p = null;
  o && (p = new ResizeObserver((g) => {
    let [y] = g;
    y && y.target === u && p && (p.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var b;
      (b = p) == null || b.observe(e);
    })), t();
  }), u && !l && p.observe(u), p.observe(e));
  let h, v = l ? bd(n) : null;
  l && m();
  function m() {
    const g = bd(n);
    v && !CV(v, g) && t(), v = g, h = requestAnimationFrame(m);
  }
  return t(), () => {
    var g;
    c.forEach((y) => {
      i && y.removeEventListener("scroll", t), a && y.removeEventListener("resize", t);
    }), d == null || d(), (g = p) == null || g.disconnect(), p = null, l && cancelAnimationFrame(h);
  };
}
const AV = Ste, MV = Ete, AT = _te, Jte = Cte, Qte = xte, ene = bte, tne = Tte, nne = (n, e, t) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: Xte,
    ...t
  }, a = {
    ...i.platform,
    _c: r
  };
  return yte(n, e, {
    ...i,
    platform: a
  });
};
function rne(n) {
  return n != null && typeof n == "object" && "$el" in n;
}
function MT(n) {
  if (rne(n)) {
    const e = n.$el;
    return KA(e) && Hd(e) === "#comment" ? null : e;
  }
  return n;
}
function Hf(n) {
  return typeof n == "function" ? n() : O(n);
}
function ine(n) {
  return {
    name: "arrow",
    options: n,
    fn(e) {
      const t = MT(Hf(n.element));
      return t == null ? {} : ene({
        element: t,
        padding: n.padding
      }).fn(e);
    }
  };
}
function DV(n) {
  return typeof window > "u" ? 1 : (n.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function CL(n, e) {
  const t = DV(n);
  return Math.round(e * t) / t;
}
function OV(n, e, t) {
  t === void 0 && (t = {});
  const r = t.whileElementsMounted, i = K(() => {
    var S;
    return (S = Hf(t.open)) != null ? S : !0;
  }), a = K(() => Hf(t.middleware)), o = K(() => {
    var S;
    return (S = Hf(t.placement)) != null ? S : "bottom";
  }), s = K(() => {
    var S;
    return (S = Hf(t.strategy)) != null ? S : "absolute";
  }), l = K(() => {
    var S;
    return (S = Hf(t.transform)) != null ? S : !0;
  }), u = K(() => MT(n.value)), c = K(() => MT(e.value)), d = Z(0), f = Z(0), p = Z(s.value), h = Z(o.value), v = Bd({}), m = Z(!1), g = K(() => {
    const S = {
      position: p.value,
      left: "0",
      top: "0"
    };
    if (!c.value)
      return S;
    const C = CL(c.value, d.value), k = CL(c.value, f.value);
    return l.value ? {
      ...S,
      transform: "translate(" + C + "px, " + k + "px)",
      ...DV(c.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: p.value,
      left: C + "px",
      top: k + "px"
    };
  });
  let y;
  function b() {
    if (u.value == null || c.value == null)
      return;
    const S = i.value;
    nne(u.value, c.value, {
      middleware: a.value,
      placement: o.value,
      strategy: s.value
    }).then((C) => {
      d.value = C.x, f.value = C.y, p.value = C.strategy, h.value = C.placement, v.value = C.middlewareData, m.value = S !== !1;
    });
  }
  function _() {
    typeof y == "function" && (y(), y = void 0);
  }
  function x() {
    if (_(), r === void 0) {
      b();
      return;
    }
    if (u.value != null && c.value != null) {
      y = r(u.value, c.value, b);
      return;
    }
  }
  function w() {
    i.value || (m.value = !1);
  }
  return et([a, o, s, i], b, {
    flush: "sync"
  }), et([u, c], x, {
    flush: "sync"
  }), et(i, w, {
    flush: "sync"
  }), V_() && xg(_), {
    x: cf(d),
    y: cf(f),
    strategy: cf(p),
    placement: cf(h),
    middlewareData: cf(v),
    isPositioned: cf(m),
    floatingStyles: g,
    update: b
  };
}
const IV = {
  side: "bottom",
  sideOffset: 0,
  sideFlip: !0,
  align: "center",
  alignOffset: 0,
  alignFlip: !0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [ane, one] = br("PopperContent");
var sne = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ gF({
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...IV }),
  emits: ["placed"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = gV(), { forwardRef: a, currentElement: o } = Lt(), s = Z(), l = Z(), { width: u, height: c } = VQ(l), d = K(() => t.side + (t.align !== "center" ? `-${t.align}` : "")), f = K(() => typeof t.collisionPadding == "number" ? t.collisionPadding : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...t.collisionPadding
    }), p = K(() => Array.isArray(t.collisionBoundary) ? t.collisionBoundary : [t.collisionBoundary]), h = K(() => ({
      padding: f.value,
      boundary: p.value.filter(ate),
      altBoundary: p.value.length > 0
    })), v = K(() => ({
      mainAxis: t.sideFlip,
      crossAxis: t.alignFlip
    })), m = aQ(() => [
      AV({
        mainAxis: t.sideOffset + c.value,
        alignmentAxis: t.alignOffset
      }),
      t.prioritizePosition && t.avoidCollisions && AT({
        ...h.value,
        ...v.value
      }),
      t.avoidCollisions && MV({
        mainAxis: !0,
        crossAxis: !!t.prioritizePosition,
        limiter: t.sticky === "partial" ? tne() : void 0,
        ...h.value
      }),
      !t.prioritizePosition && t.avoidCollisions && AT({
        ...h.value,
        ...v.value
      }),
      Jte({
        ...h.value,
        apply: ({ elements: N, rects: R, availableWidth: j, availableHeight: z }) => {
          const { width: F, height: B } = R.reference, H = N.floating.style;
          H.setProperty("--reka-popper-available-width", `${j}px`), H.setProperty("--reka-popper-available-height", `${z}px`), H.setProperty("--reka-popper-anchor-width", `${F}px`), H.setProperty("--reka-popper-anchor-height", `${B}px`);
        }
      }),
      l.value && ine({
        element: l.value,
        padding: t.arrowPadding
      }),
      ote({
        arrowWidth: u.value,
        arrowHeight: c.value
      }),
      t.hideWhenDetached && Qte({
        strategy: "referenceHidden",
        ...h.value
      })
    ]), g = K(() => t.reference ?? i.anchor.value), { floatingStyles: y, placement: b, isPositioned: _, middlewareData: x } = OV(g, s, {
      strategy: t.positionStrategy,
      placement: d,
      whileElementsMounted: (...N) => kV(...N, {
        layoutShift: !t.disableUpdateOnLayoutShift,
        animationFrame: t.updatePositionStrategy === "always"
      }),
      middleware: m
    }), w = K(() => ET(b.value)[0]), S = K(() => ET(b.value)[1]);
    mF(() => {
      _.value && r("placed");
    });
    const C = K(() => {
      var N;
      return ((N = x.value.arrow) == null ? void 0 : N.centerOffset) !== 0;
    }), k = Z("");
    Cn(() => {
      o.value && (k.value = window.getComputedStyle(o.value).zIndex);
    });
    const M = K(() => {
      var N;
      return ((N = x.value.arrow) == null ? void 0 : N.x) ?? 0;
    }), D = K(() => {
      var N;
      return ((N = x.value.arrow) == null ? void 0 : N.y) ?? 0;
    });
    return one({
      placedSide: w,
      onArrowChange: (N) => l.value = N,
      arrowX: M,
      arrowY: D,
      shouldHideArrow: C
    }), (N, R) => {
      var j, z, F;
      return L(), W("div", {
        ref_key: "floatingRef",
        ref: s,
        "data-reka-popper-content-wrapper": "",
        style: An({
          ...O(y),
          transform: O(_) ? O(y).transform : "translate(0, -200%)",
          minWidth: "max-content",
          zIndex: k.value,
          "--reka-popper-transform-origin": [(j = O(x).transformOrigin) == null ? void 0 : j.x, (z = O(x).transformOrigin) == null ? void 0 : z.y].join(" "),
          ...((F = O(x).hide) == null ? void 0 : F.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        })
      }, [se(O(Sn), He({ ref: O(a) }, N.$attrs, {
        "as-child": t.asChild,
        as: N.as,
        "data-side": w.value,
        "data-align": S.value,
        style: { animation: O(_) ? void 0 : "none" }
      }), {
        default: ee(() => [ue(N.$slots, "default")]),
        _: 3
      }, 16, [
        "as-child",
        "as",
        "data-side",
        "data-align",
        "style"
      ])], 4);
    };
  }
}), ix = sne;
const lne = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var une = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "PopperArrow",
  props: {
    width: {
      type: Number,
      required: !1
    },
    height: {
      type: Number,
      required: !1
    },
    rounded: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(n) {
    const { forwardRef: e } = Lt(), t = ane(), r = K(() => lne[t.placedSide.value]);
    return (i, a) => {
      var o, s, l, u;
      return L(), W("span", {
        ref: (c) => {
          O(t).onArrowChange(c);
        },
        style: An({
          position: "absolute",
          left: (o = O(t).arrowX) != null && o.value ? `${(s = O(t).arrowX) == null ? void 0 : s.value}px` : void 0,
          top: (l = O(t).arrowY) != null && l.value ? `${(u = O(t).arrowY) == null ? void 0 : u.value}px` : void 0,
          [r.value]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[O(t).placedSide.value],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[O(t).placedSide.value],
          visibility: O(t).shouldHideArrow.value ? "hidden" : void 0
        })
      }, [se(ite, He(i.$attrs, {
        ref: O(e),
        style: { display: "block" },
        as: i.as,
        "as-child": i.asChild,
        rounded: i.rounded,
        width: i.width,
        height: i.height
      }), {
        default: ee(() => [ue(i.$slots, "default")]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "rounded",
        "width",
        "height"
      ])], 4);
    };
  }
}), cne = une, dne = /* @__PURE__ */ ve({
  __name: "ComboboxAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const { forwardRef: e } = Lt();
    return (t, r) => (L(), re(O(Q_), {
      "as-child": "",
      reference: t.reference
    }, {
      default: ee(() => [se(O(Sn), He({
        ref: O(e),
        "as-child": t.asChild,
        as: t.as
      }, t.$attrs), {
        default: ee(() => [ue(t.$slots, "default")]),
        _: 3
      }, 16, ["as-child", "as"])]),
      _: 3
    }, 8, ["reference"]));
  }
}), fne = dne;
function pne(n, e, t) {
  return n === void 0 ? !1 : Array.isArray(n) ? n.some((r) => zv(r, e, t)) : zv(n, e, t);
}
function zv(n, e, t) {
  return n === void 0 || e === void 0 ? !1 : typeof n == "string" ? n === e : typeof t == "function" ? t(n, e) : typeof t == "string" ? (n == null ? void 0 : n[t]) === (e == null ? void 0 : e[t]) : _T(n, e);
}
const [ax, hne] = br("ListboxRoot");
var vne = /* @__PURE__ */ ve({
  __name: "ListboxRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    selectionBehavior: {
      type: String,
      required: !1,
      default: "toggle"
    },
    highlightOnHover: {
      type: Boolean,
      required: !1
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "entryFocus",
    "leave"
  ],
  setup(n, { expose: e, emit: t }) {
    const r = n, i = t, { multiple: a, highlightOnHover: o, orientation: s, disabled: l, selectionBehavior: u, dir: c } = fi(r), { getItems: d } = Qp({ isProvider: !0 }), { handleTypeaheadSearch: f } = cV(), { primitiveElement: p, currentElement: h } = Au(), v = FQ(), m = Eg(c), g = AQ(h), y = Z(), b = Z(!1), _ = Z(!0), x = na(r, "modelValue", i, {
      defaultValue: r.defaultValue ?? (a.value ? [] : void 0),
      passive: r.modelValue === void 0,
      deep: !0
    });
    function w(Ce) {
      if (b.value = !0, r.multiple) {
        const Ee = Array.isArray(x.value) ? [...x.value] : [], ce = Ee.findIndex((Pe) => zv(Pe, Ce, r.by));
        r.selectionBehavior === "toggle" ? (ce === -1 ? Ee.push(Ce) : Ee.splice(ce, 1), x.value = Ee) : (x.value = [Ce], y.value = Ce);
      } else r.selectionBehavior === "toggle" && zv(x.value, Ce, r.by) ? x.value = void 0 : x.value = Ce;
      setTimeout(() => {
        b.value = !1;
      }, 1);
    }
    const S = Z(null), C = Z(null), k = Z(!1), M = Z(!1), D = $v(), N = $v(), R = $v();
    function j() {
      return d().map((Ce) => Ce.ref).filter((Ce) => Ce.dataset.disabled !== "");
    }
    function z(Ce, Ee = !0) {
      if (!Ce) return;
      S.value = Ce, _.value && S.value.focus(), Ee && S.value.scrollIntoView({ block: "nearest" });
      const ce = d().find((Pe) => Pe.ref === Ce);
      i("highlight", ce);
    }
    function F(Ce) {
      if (k.value) R.trigger(Ce);
      else {
        const Ee = d().find((ce) => zv(ce.value, Ce, r.by));
        Ee && (S.value = Ee.ref, z(Ee.ref));
      }
    }
    function B(Ce) {
      S.value && S.value.isConnected && (Ce.preventDefault(), Ce.stopPropagation(), M.value || S.value.click());
    }
    function H(Ce) {
      if (_.value) {
        if (b.value = !0, k.value) N.trigger(Ce);
        else {
          const Ee = Ce.altKey || Ce.ctrlKey || Ce.metaKey;
          if (Ee && Ce.key === "a" && a.value) {
            const ce = d(), Pe = ce.map((Ae) => Ae.value);
            x.value = [...Pe], Ce.preventDefault(), z(ce[ce.length - 1].ref);
          } else if (!Ee) {
            const ce = f(Ce.key, d());
            ce && z(ce);
          }
        }
        setTimeout(() => {
          b.value = !1;
        }, 1);
      }
    }
    function Y() {
      M.value = !0;
    }
    function ne() {
      Wt(() => {
        M.value = !1;
      });
    }
    function J() {
      Wt(() => {
        const Ce = new KeyboardEvent("keydown", { key: "PageUp" });
        ye(Ce);
      });
    }
    function X(Ce) {
      const Ee = S.value;
      Ee != null && Ee.isConnected && (C.value = Ee), S.value = null, i("leave", Ce);
    }
    function ie(Ce) {
      var ce, Pe;
      const Ee = new CustomEvent("listbox.entryFocus", {
        bubbles: !1,
        cancelable: !0
      });
      if ((ce = Ce.currentTarget) == null || ce.dispatchEvent(Ee), i("entryFocus", Ee), !Ee.defaultPrevented)
        if (C.value) z(C.value);
        else {
          const Ae = (Pe = j()) == null ? void 0 : Pe[0];
          z(Ae);
        }
    }
    function ye(Ce) {
      const Ee = Hee(Ce, s.value, m.value);
      if (!Ee) return;
      let ce = j();
      if (S.value) {
        if (Ee === "last") ce.reverse();
        else if (Ee === "prev" || Ee === "next") {
          Ee === "prev" && ce.reverse();
          const Pe = ce.indexOf(S.value);
          ce = ce.slice(Pe + 1);
        }
        pe(Ce, ce[0]);
      }
      if (ce.length) {
        const Pe = !S.value && Ee === "prev" ? ce.length - 1 : 0;
        z(ce[Pe]);
      }
      if (k.value) return N.trigger(Ce);
    }
    function pe(Ce, Ee) {
      var Pe;
      if (!(k.value || r.selectionBehavior !== "replace" || !a.value || !Array.isArray(x.value) || (Ce.altKey || Ce.ctrlKey || Ce.metaKey) && !Ce.shiftKey) && Ce.shiftKey) {
        const Ae = d().filter((he) => he.ref.dataset.disabled !== "");
        let fe = (Pe = Ae.find((he) => he.ref === Ee)) == null ? void 0 : Pe.value;
        if (Ce.key === v.END ? fe = Ae[Ae.length - 1].value : Ce.key === v.HOME && (fe = Ae[0].value), !fe || !y.value) return;
        const oe = nQ(Ae.map((he) => he.value), y.value, fe);
        x.value = oe;
      }
    }
    async function Be(Ce) {
      if (await Wt(), k.value) D.trigger(Ce);
      else {
        const Ee = j(), ce = Ee.find((Pe) => Pe.dataset.state === "checked");
        ce ? z(ce) : Ee.length && z(Ee[0]);
      }
    }
    return et(x, () => {
      b.value || Wt(() => {
        Be();
      });
    }, {
      immediate: !0,
      deep: !0
    }), e({
      highlightedElement: S,
      highlightItem: F,
      highlightFirstItem: J,
      highlightSelected: Be,
      getItems: d
    }), hne({
      modelValue: x,
      onValueChange: w,
      multiple: a,
      orientation: s,
      dir: m,
      disabled: l,
      highlightOnHover: o,
      highlightedElement: S,
      isVirtual: k,
      virtualFocusHook: D,
      virtualKeydownHook: N,
      virtualHighlightHook: R,
      by: r.by,
      firstValue: y,
      selectionBehavior: u,
      focusable: _,
      onLeave: X,
      onEnter: ie,
      changeHighlight: z,
      onKeydownEnter: B,
      onKeydownNavigation: ye,
      onKeydownTypeAhead: H,
      onCompositionStart: Y,
      onCompositionEnd: ne,
      highlightFirstItem: J
    }), (Ce, Ee) => (L(), re(O(Sn), {
      ref_key: "primitiveElement",
      ref: p,
      as: Ce.as,
      "as-child": Ce.asChild,
      dir: O(m),
      "data-disabled": O(l) ? "" : void 0,
      onPointerleave: X,
      onFocusout: Ee[0] || (Ee[0] = async (ce) => {
        const Pe = ce.relatedTarget || ce.target;
        await Wt(), S.value && O(h) && !O(h).contains(Pe) && X(ce);
      })
    }, {
      default: ee(() => [ue(Ce.$slots, "default", { modelValue: O(x) }), O(g) && Ce.name ? (L(), re(O(Zee), {
        key: 0,
        name: Ce.name,
        value: O(x),
        disabled: O(l),
        required: Ce.required
      }, null, 8, [
        "name",
        "value",
        "disabled",
        "required"
      ])) : ge("v-if", !0)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "dir",
      "data-disabled"
    ]));
  }
}), mne = vne, gne = /* @__PURE__ */ ve({
  __name: "ListboxContent",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const { CollectionSlot: e } = Qp(), t = ax(), r = FA(!1, 10);
    return (i, a) => (L(), re(O(e), null, {
      default: ee(() => [se(O(Sn), {
        role: "listbox",
        as: i.as,
        "as-child": i.asChild,
        tabindex: O(t).focusable.value ? O(t).highlightedElement.value ? "-1" : "0" : void 0,
        "aria-orientation": O(t).orientation.value,
        "aria-multiselectable": !!O(t).multiple.value,
        "data-orientation": O(t).orientation.value,
        onMousedown: a[0] || (a[0] = xt((o) => r.value = !0, ["left"])),
        onFocus: a[1] || (a[1] = (o) => {
          O(r) || O(t).onEnter(o);
        }),
        onKeydown: [
          a[2] || (a[2] = ci(xt((o) => {
            O(t).focusable.value && O(t).onKeydownNavigation(o);
          }, ["prevent"]), [
            "down",
            "up",
            "left",
            "right",
            "home",
            "end"
          ])),
          ci(O(t).onKeydownEnter, ["enter"]),
          O(t).onKeydownTypeAhead
        ]
      }, {
        default: ee(() => [ue(i.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "tabindex",
        "aria-orientation",
        "aria-multiselectable",
        "data-orientation",
        "onKeydown"
      ])]),
      _: 3
    }));
  }
}), yne = gne, bne = /* @__PURE__ */ ve({
  __name: "ListboxFilter",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, i = na(t, "modelValue", e, {
      defaultValue: "",
      passive: t.modelValue === void 0
    }), a = ax(), { primitiveElement: o, currentElement: s } = Au(), l = K(() => t.disabled || a.disabled.value || !1), u = Z();
    return LZ(() => {
      var c;
      return u.value = (c = a.highlightedElement.value) == null ? void 0 : c.id;
    }), kt(() => {
      a.focusable.value = !1, setTimeout(() => {
        var c;
        t.autoFocus && ((c = s.value) == null || c.focus());
      }, 1);
    }), Nn(() => {
      a.focusable.value = !0;
    }), (c, d) => (L(), re(O(Sn), {
      ref_key: "primitiveElement",
      ref: o,
      as: c.as,
      "as-child": c.asChild,
      value: O(i),
      disabled: l.value ? "" : void 0,
      "data-disabled": l.value ? "" : void 0,
      "aria-disabled": l.value ?? void 0,
      "aria-activedescendant": u.value,
      type: "text",
      onKeydown: [ci(xt(O(a).onKeydownNavigation, ["prevent"]), [
        "down",
        "up",
        "home",
        "end"
      ]), ci(O(a).onKeydownEnter, ["enter"])],
      onInput: d[0] || (d[0] = (f) => {
        i.value = f.target.value, O(a).highlightFirstItem();
      }),
      onCompositionstart: O(a).onCompositionStart,
      onCompositionend: O(a).onCompositionEnd
    }, {
      default: ee(() => [ue(c.$slots, "default", { modelValue: O(i) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "value",
      "disabled",
      "data-disabled",
      "aria-disabled",
      "aria-activedescendant",
      "onKeydown",
      "onCompositionstart",
      "onCompositionend"
    ]));
  }
}), _ne = bne;
const [sUe, xne] = br("ListboxGroup");
var wne = /* @__PURE__ */ ve({
  __name: "ListboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = n, t = ra(void 0, "reka-listbox-group");
    return xne({ id: t }), (r, i) => (L(), re(O(Sn), He({ role: "group" }, e, { "aria-labelledby": O(t) }), {
      default: ee(() => [ue(r.$slots, "default")]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), Sne = wne;
const Ene = "listbox.select", [Tne, Cne] = br("ListboxItem");
var kne = /* @__PURE__ */ ve({
  __name: "ListboxItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["select"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ra(void 0, "reka-listbox-item"), { CollectionItem: a } = Qp(), { forwardRef: o, currentElement: s } = Lt(), l = ax(), u = K(() => s.value === l.highlightedElement.value), c = K(() => pne(l.modelValue.value, t.value, l.by)), d = K(() => l.disabled.value || t.disabled);
    async function f(h) {
      r("select", h), !(h != null && h.defaultPrevented) && !d.value && h && (l.onValueChange(t.value), l.changeHighlight(s.value));
    }
    function p(h) {
      const v = {
        originalEvent: h,
        value: t.value
      };
      $A(Ene, f, v);
    }
    return Cne({ isSelected: c }), (h, v) => (L(), re(O(a), { value: h.value }, {
      default: ee(() => [NZ([u.value, c.value], () => se(O(Sn), He({ id: O(i) }, h.$attrs, {
        ref: O(o),
        role: "option",
        tabindex: O(l).focusable.value ? u.value ? "0" : "-1" : -1,
        "aria-selected": c.value,
        as: h.as,
        "as-child": h.asChild,
        disabled: d.value ? "" : void 0,
        "data-disabled": d.value ? "" : void 0,
        "data-highlighted": u.value ? "" : void 0,
        "data-state": c.value ? "checked" : "unchecked",
        onClick: p,
        onKeydown: ci(xt(p, ["prevent"]), ["space"]),
        onPointermove: v[0] || (v[0] = (m) => {
          O(l).highlightedElement.value !== O(s) && (O(l).highlightOnHover.value ? O(l).changeHighlight(O(s), !1) : O(l).focusable.value || O(l).changeHighlight(O(s), !1));
        })
      }), {
        default: ee(() => [ue(h.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "tabindex",
        "aria-selected",
        "as",
        "as-child",
        "disabled",
        "data-disabled",
        "data-highlighted",
        "data-state",
        "onKeydown"
      ]), v, 1)]),
      _: 3
    }, 8, ["value"]));
  }
}), Ane = kne, Mne = /* @__PURE__ */ ve({
  __name: "ListboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(n) {
    const e = n;
    Lt();
    const t = Tne();
    return (r, i) => O(t).isSelected.value ? (L(), re(O(Sn), He({
      key: 0,
      "aria-hidden": "true"
    }, e), {
      default: ee(() => [ue(r.$slots, "default")]),
      _: 3
    }, 16)) : ge("v-if", !0);
  }
}), Dne = Mne;
const [Vu, One] = br("ComboboxRoot");
var Ine = /* @__PURE__ */ ve({
  __name: "ComboboxRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    resetSearchTermOnBlur: {
      type: Boolean,
      required: !1,
      default: !0
    },
    resetSearchTermOnSelect: {
      type: Boolean,
      required: !1,
      default: !0
    },
    openOnFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    openOnClick: {
      type: Boolean,
      required: !1,
      default: !1
    },
    ignoreFilter: {
      type: Boolean,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    highlightOnHover: {
      type: Boolean,
      required: !1
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "update:open"
  ],
  setup(n, { expose: e, emit: t }) {
    var j, z, F;
    const r = n, i = t, { primitiveElement: a, currentElement: o } = Au(), { multiple: s, disabled: l, ignoreFilter: u, resetSearchTermOnSelect: c, openOnFocus: d, openOnClick: f, dir: p } = fi(r), h = Eg(p), v = na(r, "modelValue", i, {
      defaultValue: r.defaultValue ?? (s.value ? [] : void 0),
      passive: r.modelValue === void 0,
      deep: !0
    }), m = na(r, "open", i, {
      defaultValue: r.defaultOpen,
      passive: r.open === void 0
    });
    async function g(B) {
      var H, Y;
      m.value = B, D.value = "", B ? (await Wt(), (H = a.value) == null || H.highlightSelected(), b.value = !0) : b.value = !1, (Y = x.value) == null || Y.focus(), setTimeout(() => {
        !B && r.resetSearchTermOnBlur && y.trigger();
      }, 1);
    }
    const y = $v(), b = Z(!1), _ = Z(!1), x = Z(), w = Z(), S = K(() => {
      var B;
      return ((B = a.value) == null ? void 0 : B.highlightedElement) ?? void 0;
    }), C = Z(/* @__PURE__ */ new Map()), k = Z(/* @__PURE__ */ new Map()), { contains: M } = kQ({ sensitivity: "base" }), D = Z(""), N = K((B) => {
      if (!D.value || r.ignoreFilter || _.value) return {
        count: C.value.size,
        items: (B == null ? void 0 : B.items) ?? /* @__PURE__ */ new Map(),
        groups: (B == null ? void 0 : B.groups) ?? new Set(k.value.keys())
      };
      let H = 0;
      const Y = /* @__PURE__ */ new Map(), ne = /* @__PURE__ */ new Set();
      for (const [J, X] of C.value) {
        const ie = M(X, D.value);
        Y.set(J, ie ? 1 : 0), ie && H++;
      }
      for (const [J, X] of k.value) for (const ie of X) if (Y.get(ie) > 0) {
        ne.add(J);
        break;
      }
      return {
        count: H,
        items: Y,
        groups: ne
      };
    }), R = ro();
    return kt(() => {
      var B, H, Y;
      R != null && R.exposed && (R.exposed.highlightItem = (B = a.value) == null ? void 0 : B.highlightItem, R.exposed.highlightFirstItem = (H = a.value) == null ? void 0 : H.highlightFirstItem, R.exposed.highlightSelected = (Y = a.value) == null ? void 0 : Y.highlightSelected);
    }), e({
      filtered: N,
      highlightedElement: S,
      highlightItem: (j = a.value) == null ? void 0 : j.highlightItem,
      highlightFirstItem: (z = a.value) == null ? void 0 : z.highlightFirstItem,
      highlightSelected: (F = a.value) == null ? void 0 : F.highlightSelected
    }), One({
      modelValue: v,
      multiple: s,
      disabled: l,
      open: m,
      onOpenChange: g,
      contentId: "",
      isUserInputted: b,
      isVirtual: _,
      inputElement: x,
      highlightedElement: S,
      onInputElementChange: (B) => x.value = B,
      triggerElement: w,
      onTriggerElementChange: (B) => w.value = B,
      parentElement: o,
      resetSearchTermOnSelect: c,
      onResetSearchTerm: y.on,
      allItems: C,
      allGroups: k,
      filterSearch: D,
      filterState: N,
      ignoreFilter: u,
      openOnFocus: d,
      openOnClick: f
    }), (B, H) => (L(), re(O(Ag), null, {
      default: ee(() => [se(O(mne), He({
        ref_key: "primitiveElement",
        ref: a
      }, B.$attrs, {
        modelValue: O(v),
        "onUpdate:modelValue": H[0] || (H[0] = (Y) => al(v) ? v.value = Y : null),
        style: { pointerEvents: O(m) ? "auto" : void 0 },
        as: B.as,
        "as-child": B.asChild,
        dir: O(h),
        multiple: O(s),
        name: B.name,
        required: B.required,
        disabled: O(l),
        "highlight-on-hover": !0,
        by: r.by,
        onHighlight: H[1] || (H[1] = (Y) => i("highlight", Y))
      }), {
        default: ee(() => [ue(B.$slots, "default", {
          open: O(m),
          modelValue: O(v)
        })]),
        _: 3
      }, 16, [
        "modelValue",
        "style",
        "as",
        "as-child",
        "dir",
        "multiple",
        "name",
        "required",
        "disabled",
        "by"
      ])]),
      _: 3
    }));
  }
}), Lne = Ine;
const [lUe, Nne] = br("ComboboxContent");
var Rne = /* @__PURE__ */ ve({
  __name: "ComboboxContentImpl",
  props: {
    position: {
      type: String,
      required: !1,
      default: "inline"
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, { position: i } = fi(t), a = Vu(), { forwardRef: o, currentElement: s } = Lt();
    X_(t.bodyLock), J_(a.parentElement);
    const l = K(() => t.position === "popper" ? t : {}), u = Z_(l.value), c = {
      boxSizing: "border-box",
      "--reka-combobox-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-combobox-content-available-width": "var(--reka-popper-available-width)",
      "--reka-combobox-content-available-height": "var(--reka-popper-available-height)",
      "--reka-combobox-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-combobox-trigger-height": "var(--reka-popper-anchor-height)"
    };
    Nne({ position: i });
    const d = Z(!1);
    return kt(() => {
      a.inputElement.value && (d.value = s.value.contains(a.inputElement.value), d.value && a.inputElement.value.focus());
    }), Nn(() => {
      var f;
      d.value && ((f = a.triggerElement.value) == null || f.focus());
    }), (f, p) => (L(), re(O(yne), { "as-child": "" }, {
      default: ee(() => [se(O(Cg), {
        "as-child": "",
        "disable-outside-pointer-events": f.disableOutsidePointerEvents,
        onDismiss: p[0] || (p[0] = (h) => O(a).onOpenChange(!1)),
        onFocusOutside: p[1] || (p[1] = (h) => {
          var v;
          (v = O(a).parentElement.value) != null && v.contains(h.target) && h.preventDefault(), r("focusOutside", h);
        }),
        onInteractOutside: p[2] || (p[2] = (h) => r("interactOutside", h)),
        onEscapeKeyDown: p[3] || (p[3] = (h) => r("escapeKeyDown", h)),
        onPointerDownOutside: p[4] || (p[4] = (h) => {
          var v;
          (v = O(a).parentElement.value) != null && v.contains(h.target) && h.preventDefault(), r("pointerDownOutside", h);
        })
      }, {
        default: ee(() => [(L(), re(bn(O(i) === "popper" ? O(ix) : O(Sn)), He({
          ...f.$attrs,
          ...O(u)
        }, {
          id: O(a).contentId,
          ref: O(o),
          "data-state": O(a).open.value ? "open" : "closed",
          style: {
            display: "flex",
            flexDirection: "column",
            outline: "none",
            ...O(i) === "popper" ? c : {}
          }
        }), {
          default: ee(() => [ue(f.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "data-state",
          "style"
        ]))]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }));
  }
}), Pne = Rne, jne = /* @__PURE__ */ ve({
  __name: "ComboboxContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    position: {
      type: String,
      required: !1
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(n, { emit: e }) {
    const i = Lo(n, e), { forwardRef: a } = Lt(), o = Vu();
    return o.contentId || (o.contentId = ra(void 0, "reka-combobox-content")), (s, l) => (L(), re(O(Fu), { present: s.forceMount || O(o).open.value }, {
      default: ee(() => [se(Pne, He({
        ...O(i),
        ...s.$attrs
      }, { ref: O(a) }), {
        default: ee(() => [ue(s.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), Bne = jne, $ne = /* @__PURE__ */ ve({
  __name: "ComboboxEmpty",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = n, t = Vu(), r = K(() => t.ignoreFilter.value ? t.allItems.value.size === 0 : t.filterState.value.count === 0);
    return (i, a) => r.value ? (L(), re(O(Sn), Bt(He({ key: 0 }, e)), {
      default: ee(() => [ue(i.$slots, "default", {}, () => [a[0] || (a[0] = gn("No options"))])]),
      _: 3
    }, 16)) : ge("v-if", !0);
  }
}), zne = $ne;
const [LV, Fne] = br("ComboboxGroup");
var Vne = /* @__PURE__ */ ve({
  __name: "ComboboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = n, t = ra(void 0, "reka-combobox-group"), r = Vu(), i = K(() => r.ignoreFilter.value ? !0 : r.filterSearch.value ? r.filterState.value.groups.has(t) : !0), a = Fne({
      id: t,
      labelId: ""
    });
    return kt(() => {
      r.allGroups.value.has(t) || r.allGroups.value.set(t, /* @__PURE__ */ new Set());
    }), Nn(() => {
      r.allGroups.value.delete(t);
    }), (o, s) => (L(), re(O(Sne), He({
      id: O(t),
      "aria-labelledby": O(a).labelId
    }, e, { hidden: i.value ? void 0 : !0 }), {
      default: ee(() => [ue(o.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "aria-labelledby",
      "hidden"
    ]));
  }
}), Hne = Vne, Gne = /* @__PURE__ */ ve({
  __name: "ComboboxInput",
  props: {
    displayValue: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Vu(), a = ax(), { primitiveElement: o, currentElement: s } = Au(), l = na(t, "modelValue", r, { passive: t.modelValue === void 0 });
    kt(() => {
      s.value && i.onInputElementChange(s.value);
    });
    function u(h) {
      i.open.value || i.onOpenChange(!0);
    }
    function c(h) {
      const v = h.target;
      i.open.value ? i.filterSearch.value = v.value : (i.onOpenChange(!0), Wt(() => {
        v.value && (i.filterSearch.value = v.value, a.highlightFirstItem());
      }));
    }
    function d() {
      i.openOnFocus.value && !i.open.value && i.onOpenChange(!0);
    }
    function f() {
      i.openOnClick.value && !i.open.value && i.onOpenChange(!0);
    }
    function p() {
      const h = i.modelValue.value;
      t.displayValue ? l.value = t.displayValue(h) : !i.multiple.value && h && !Array.isArray(h) && typeof h != "object" ? l.value = h.toString() : l.value = "", Wt(() => {
        l.value = l.value;
      });
    }
    return i.onResetSearchTerm(() => {
      p();
    }), et(i.modelValue, async () => {
      !i.isUserInputted.value && i.resetSearchTermOnSelect.value && p();
    }, {
      immediate: !0,
      deep: !0
    }), et(i.filterState, () => {
      i.isVirtual.value || a.highlightFirstItem();
    }), (h, v) => (L(), re(O(_ne), {
      ref_key: "primitiveElement",
      ref: o,
      modelValue: O(l),
      "onUpdate:modelValue": v[0] || (v[0] = (m) => al(l) ? l.value = m : null),
      as: h.as,
      "as-child": h.asChild,
      "auto-focus": h.autoFocus,
      disabled: h.disabled,
      "aria-expanded": O(i).open.value,
      "aria-controls": O(i).contentId,
      "aria-autocomplete": "list",
      role: "combobox",
      autocomplete: "off",
      onClick: f,
      onInput: c,
      onKeydown: ci(xt(u, ["prevent"]), ["down", "up"]),
      onFocus: d
    }, {
      default: ee(() => [ue(h.$slots, "default")]),
      _: 3
    }, 8, [
      "modelValue",
      "as",
      "as-child",
      "auto-focus",
      "disabled",
      "aria-expanded",
      "aria-controls",
      "onKeydown"
    ]));
  }
}), Une = Gne, Wne = /* @__PURE__ */ ve({
  __name: "ComboboxItem",
  props: {
    textValue: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ra(void 0, "reka-combobox-item"), a = Vu(), o = LV(null), { primitiveElement: s, currentElement: l } = Au();
    if (t.value === "") throw new Error("A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.");
    const u = K(() => {
      if (a.isVirtual.value || a.ignoreFilter.value || !a.filterSearch.value) return !0;
      {
        const c = a.filterState.value.items.get(i);
        return c === void 0 ? !0 : c > 0;
      }
    });
    return kt(() => {
      var d;
      a.allItems.value.set(i, t.textValue || l.value.textContent || l.value.innerText);
      const c = o == null ? void 0 : o.id;
      c && (a.allGroups.value.has(c) ? (d = a.allGroups.value.get(c)) == null || d.add(i) : a.allGroups.value.set(c, /* @__PURE__ */ new Set([i])));
    }), Nn(() => {
      a.allItems.value.delete(i);
    }), (c, d) => u.value ? (L(), re(O(Ane), He({ key: 0 }, t, {
      id: O(i),
      ref_key: "primitiveElement",
      ref: s,
      disabled: O(a).disabled.value || c.disabled,
      onSelect: d[0] || (d[0] = (f) => {
        r("select", f), !f.defaultPrevented && !O(a).multiple.value && !c.disabled && !O(a).disabled.value && (f.preventDefault(), O(a).onOpenChange(!1), O(a).modelValue.value = t.value);
      })
    }), {
      default: ee(() => [ue(c.$slots, "default", {}, () => [gn(ke(c.value), 1)])]),
      _: 3
    }, 16, ["id", "disabled"])) : ge("v-if", !0);
  }
}), kL = Wne, qne = /* @__PURE__ */ ve({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(n) {
    const e = n;
    return (t, r) => (L(), re(O(Dne), Bt(Jt(e)), {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 16));
  }
}), AL = qne, Yne = /* @__PURE__ */ ve({
  __name: "ComboboxLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(n) {
    const e = n;
    Lt();
    const t = LV({
      id: "",
      labelId: ""
    });
    return t.labelId || (t.labelId = ra(void 0, "reka-combobox-group-label")), (r, i) => (L(), re(O(Sn), He(e, { id: O(t).labelId }), {
      default: ee(() => [ue(r.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), Kne = Yne, Xne = /* @__PURE__ */ ve({
  __name: "ComboboxPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(n) {
    const e = n;
    return (t, r) => (L(), re(O(kg), Bt(Jt(e)), {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Zne = Xne, Jne = /* @__PURE__ */ ve({
  __name: "ComboboxTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(n) {
    const e = n, { forwardRef: t, currentElement: r } = Lt(), i = Vu(), a = K(() => e.disabled || i.disabled.value || !1);
    return kt(() => {
      r.value && i.onTriggerElementChange(r.value);
    }), (o, s) => (L(), re(O(Sn), He(e, {
      ref: O(t),
      type: o.as === "button" ? "button" : void 0,
      tabindex: "-1",
      "aria-label": "Show popup",
      "aria-haspopup": "listbox",
      "aria-expanded": O(i).open.value,
      "aria-controls": O(i).contentId,
      "data-state": O(i).open.value ? "open" : "closed",
      disabled: a.value,
      "data-disabled": a.value ? "" : void 0,
      "aria-disabled": a.value ?? void 0,
      onClick: s[0] || (s[0] = (l) => O(i).onOpenChange(!O(i).open.value))
    }), {
      default: ee(() => [ue(o.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "disabled",
      "data-disabled",
      "aria-disabled"
    ]));
  }
}), Qne = Jne;
function ere(n) {
  const e = Y_({ nonce: Z() });
  return K(() => {
    var t;
    return (n == null ? void 0 : n.value) || ((t = e.nonce) == null ? void 0 : t.value);
  });
}
var tre = /* @__PURE__ */ ve({
  __name: "ComboboxViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = n, { forwardRef: t } = Lt(), { nonce: r } = fi(e), i = ere(r), a = Vu();
    return (o, s) => (L(), W(Ke, null, [se(O(Sn), He({
      ...o.$attrs,
      ...e
    }, {
      ref: O(t),
      "data-reka-combobox-viewport": "",
      role: "presentation",
      style: {
        position: "relative",
        flex: O(a).isVirtual.value ? void 0 : 1,
        overflow: "auto"
      }
    }), {
      default: ee(() => [ue(o.$slots, "default")]),
      _: 3
    }, 16, ["style"]), se(O(Sn), {
      as: "style",
      nonce: O(i)
    }, {
      default: ee(() => s[0] || (s[0] = [gn(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), nre = tre, rre = /* @__PURE__ */ ve({
  __name: "MenuAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = n;
    return (t, r) => (L(), re(O(Q_), Bt(Jt(e)), {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 16));
  }
}), NV = rre;
function ire() {
  const n = Z(!1);
  return kt(() => {
    Ep("keydown", () => {
      n.value = !0;
    }, {
      capture: !0,
      passive: !0
    }), Ep(["pointerdown", "pointermove"], () => {
      n.value = !1;
    }, {
      capture: !0,
      passive: !0
    });
  }), n;
}
const are = iV(ire), [Gd, RV] = br(["MenuRoot", "MenuSub"], "MenuContext"), [Dg, ore] = br("MenuRoot");
var sre = /* @__PURE__ */ ve({
  __name: "MenuRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: !1
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(n, { emit: e }) {
    const t = n, r = e, { modal: i, dir: a } = fi(t), o = Eg(a), s = na(t, "open", r), l = Z(), u = are();
    return RV({
      open: s,
      onOpenChange: (c) => {
        s.value = c;
      },
      content: l,
      onContentChange: (c) => {
        l.value = c;
      }
    }), ore({
      onClose: () => {
        s.value = !1;
      },
      isUsingKeyboardRef: u,
      dir: o,
      modal: i
    }), (c, d) => (L(), re(O(Ag), null, {
      default: ee(() => [ue(c.$slots, "default")]),
      _: 3
    }));
  }
}), lre = sre;
const [QA, ure] = br("MenuContent");
var cre = /* @__PURE__ */ ve({
  __name: "MenuContentImpl",
  props: /* @__PURE__ */ gF({
    loop: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    disableOutsideScroll: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...IV }),
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus",
    "dismiss"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Gd(), a = Dg(), { trapFocus: o, disableOutsidePointerEvents: s, loop: l } = fi(t);
    lV(), X_(s.value);
    const u = Z(""), c = Z(0), d = Z(0), f = Z(null), p = Z("right"), h = Z(0), v = Z(null), m = Z(), { forwardRef: g, currentElement: y } = Lt(), { handleTypeaheadSearch: b } = cV();
    et(y, (k) => {
      i.onContentChange(k);
    }), Nn(() => {
      window.clearTimeout(c.value);
    });
    function _(k) {
      var D, N;
      return p.value === ((D = f.value) == null ? void 0 : D.side) && bee(k, (N = f.value) == null ? void 0 : N.area);
    }
    async function x(k) {
      var M;
      r("openAutoFocus", k), !k.defaultPrevented && (k.preventDefault(), (M = y.value) == null || M.focus({ preventScroll: !0 }));
    }
    function w(k) {
      var B;
      if (k.defaultPrevented) return;
      const D = k.target.closest("[data-reka-menu-content]") === k.currentTarget, N = k.ctrlKey || k.altKey || k.metaKey, R = k.key.length === 1, j = iQ(k, Di(), y.value, {
        loop: l.value,
        arrowKeyOptions: "vertical",
        dir: a == null ? void 0 : a.dir.value,
        focus: !0,
        attributeName: "[data-reka-collection-item]:not([data-disabled])"
      });
      if (j) return j == null ? void 0 : j.focus();
      if (k.code === "Space") return;
      const z = ((B = m.value) == null ? void 0 : B.getItems()) ?? [];
      if (D && (k.key === "Tab" && k.preventDefault(), !N && R && b(k.key, z)), k.target !== y.value || !hee.includes(k.key)) return;
      k.preventDefault();
      const F = [...z.map((H) => H.ref)];
      pV.includes(k.key) && F.reverse(), gee(F);
    }
    function S(k) {
      var M, D;
      (D = (M = k == null ? void 0 : k.currentTarget) == null ? void 0 : M.contains) != null && D.call(M, k.target) || (window.clearTimeout(c.value), u.value = "");
    }
    function C(k) {
      var N;
      if (!xm(k)) return;
      const M = k.target, D = h.value !== k.clientX;
      if ((N = k == null ? void 0 : k.currentTarget) != null && N.contains(M) && D) {
        const R = k.clientX > h.value ? "right" : "left";
        p.value = R, h.value = k.clientX;
      }
    }
    return ure({
      onItemEnter: (k) => !!_(k),
      onItemLeave: (k) => {
        var M;
        _(k) || ((M = y.value) == null || M.focus(), v.value = null);
      },
      onTriggerLeave: (k) => !!_(k),
      searchRef: u,
      pointerGraceTimerRef: d,
      onPointerGraceIntentChange: (k) => {
        f.value = k;
      }
    }), (k, M) => (L(), re(O(HA), {
      "as-child": "",
      trapped: O(o),
      onMountAutoFocus: x,
      onUnmountAutoFocus: M[7] || (M[7] = (D) => r("closeAutoFocus", D))
    }, {
      default: ee(() => [se(O(Cg), {
        "as-child": "",
        "disable-outside-pointer-events": O(s),
        onEscapeKeyDown: M[2] || (M[2] = (D) => r("escapeKeyDown", D)),
        onPointerDownOutside: M[3] || (M[3] = (D) => r("pointerDownOutside", D)),
        onFocusOutside: M[4] || (M[4] = (D) => r("focusOutside", D)),
        onInteractOutside: M[5] || (M[5] = (D) => r("interactOutside", D)),
        onDismiss: M[6] || (M[6] = (D) => r("dismiss"))
      }, {
        default: ee(() => [se(O(qee), {
          ref_key: "rovingFocusGroupRef",
          ref: m,
          "current-tab-stop-id": v.value,
          "onUpdate:currentTabStopId": M[0] || (M[0] = (D) => v.value = D),
          "as-child": "",
          orientation: "vertical",
          dir: O(a).dir.value,
          loop: O(l),
          onEntryFocus: M[1] || (M[1] = (D) => {
            r("entryFocus", D), O(a).isUsingKeyboardRef.value || D.preventDefault();
          })
        }, {
          default: ee(() => [se(O(ix), {
            ref: O(g),
            role: "menu",
            as: k.as,
            "as-child": k.asChild,
            "aria-orientation": "vertical",
            "data-reka-menu-content": "",
            "data-state": O(GA)(O(i).open.value),
            dir: O(a).dir.value,
            side: k.side,
            "side-offset": k.sideOffset,
            align: k.align,
            "align-offset": k.alignOffset,
            "avoid-collisions": k.avoidCollisions,
            "collision-boundary": k.collisionBoundary,
            "collision-padding": k.collisionPadding,
            "arrow-padding": k.arrowPadding,
            "prioritize-position": k.prioritizePosition,
            "position-strategy": k.positionStrategy,
            "update-position-strategy": k.updatePositionStrategy,
            sticky: k.sticky,
            "hide-when-detached": k.hideWhenDetached,
            reference: k.reference,
            onKeydown: w,
            onBlur: S,
            onPointermove: C
          }, {
            default: ee(() => [ue(k.$slots, "default")]),
            _: 3
          }, 8, [
            "as",
            "as-child",
            "data-state",
            "dir",
            "side",
            "side-offset",
            "align",
            "align-offset",
            "avoid-collisions",
            "collision-boundary",
            "collision-padding",
            "arrow-padding",
            "prioritize-position",
            "position-strategy",
            "update-position-strategy",
            "sticky",
            "hide-when-detached",
            "reference"
          ])]),
          _: 3
        }, 8, [
          "current-tab-stop-id",
          "dir",
          "loop"
        ])]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), eM = cre, dre = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "MenuItemImpl",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = n, t = QA(), { forwardRef: r } = Lt(), { CollectionItem: i } = Qp(), a = Z(!1);
    async function o(l) {
      if (!l.defaultPrevented && xm(l)) {
        if (e.disabled) t.onItemLeave(l);
        else if (!t.onItemEnter(l)) {
          const c = l.currentTarget;
          c == null || c.focus({ preventScroll: !0 });
        }
      }
    }
    async function s(l) {
      await Wt(), !l.defaultPrevented && xm(l) && t.onItemLeave(l);
    }
    return (l, u) => (L(), re(O(i), { value: { textValue: l.textValue } }, {
      default: ee(() => [se(O(Sn), He({
        ref: O(r),
        role: "menuitem",
        tabindex: "-1"
      }, l.$attrs, {
        as: l.as,
        "as-child": l.asChild,
        "aria-disabled": l.disabled || void 0,
        "data-disabled": l.disabled ? "" : void 0,
        "data-highlighted": a.value ? "" : void 0,
        onPointermove: o,
        onPointerleave: s,
        onFocus: u[0] || (u[0] = async (c) => {
          await Wt(), !(c.defaultPrevented || l.disabled) && (a.value = !0);
        }),
        onBlur: u[1] || (u[1] = async (c) => {
          await Wt(), !c.defaultPrevented && (a.value = !1);
        })
      }), {
        default: ee(() => [ue(l.$slots, "default")]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "aria-disabled",
        "data-disabled",
        "data-highlighted"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), PV = dre, fre = /* @__PURE__ */ ve({
  __name: "MenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(n, { emit: e }) {
    const t = n, r = e, { forwardRef: i, currentElement: a } = Lt(), o = Dg(), s = QA(), l = Z(!1);
    async function u() {
      const c = a.value;
      if (!t.disabled && c) {
        const d = new CustomEvent(fee, {
          bubbles: !0,
          cancelable: !0
        });
        r("select", d), await Wt(), d.defaultPrevented ? l.value = !1 : o.onClose();
      }
    }
    return (c, d) => (L(), re(PV, He(t, {
      ref: O(i),
      onClick: u,
      onPointerdown: d[0] || (d[0] = () => {
        l.value = !0;
      }),
      onPointerup: d[1] || (d[1] = async (f) => {
        var p;
        await Wt(), !f.defaultPrevented && (l.value || (p = f.currentTarget) == null || p.click());
      }),
      onKeydown: d[2] || (d[2] = async (f) => {
        const p = O(s).searchRef.value !== "";
        c.disabled || p && f.key === " " || O(ST).includes(f.key) && (f.currentTarget.click(), f.preventDefault());
      })
    }), {
      default: ee(() => [ue(c.$slots, "default")]),
      _: 3
    }, 16));
  }
}), pre = fre, hre = /* @__PURE__ */ ve({
  __name: "MenuRootContentModal",
  props: {
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Lo(t, r), a = Gd(), { forwardRef: o, currentElement: s } = Lt();
    return J_(s), (l, u) => (L(), re(eM, He(O(i), {
      ref: O(o),
      "trap-focus": O(a).open.value,
      "disable-outside-pointer-events": O(a).open.value,
      "disable-outside-scroll": !0,
      onDismiss: u[0] || (u[0] = (c) => O(a).onOpenChange(!1)),
      onFocusOutside: u[1] || (u[1] = xt((c) => r("focusOutside", c), ["prevent"]))
    }), {
      default: ee(() => [ue(l.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus", "disable-outside-pointer-events"]));
  }
}), vre = hre, mre = /* @__PURE__ */ ve({
  __name: "MenuRootContentNonModal",
  props: {
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const i = Lo(n, e), a = Gd();
    return (o, s) => (L(), re(eM, He(O(i), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      "disable-outside-scroll": !1,
      onDismiss: s[0] || (s[0] = (l) => O(a).onOpenChange(!1))
    }), {
      default: ee(() => [ue(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), gre = mre, yre = /* @__PURE__ */ ve({
  __name: "MenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const i = Lo(n, e), a = Gd(), o = Dg();
    return (s, l) => (L(), re(O(Fu), { present: s.forceMount || O(a).open.value }, {
      default: ee(() => [O(o).modal.value ? (L(), re(vre, Bt(He({ key: 0 }, {
        ...s.$attrs,
        ...O(i)
      })), {
        default: ee(() => [ue(s.$slots, "default")]),
        _: 3
      }, 16)) : (L(), re(gre, Bt(He({ key: 1 }, {
        ...s.$attrs,
        ...O(i)
      })), {
        default: ee(() => [ue(s.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), bre = yre, _re = /* @__PURE__ */ ve({
  __name: "MenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(n) {
    const e = n;
    return (t, r) => (L(), re(O(Sn), Bt(Jt(e)), {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 16));
  }
}), xre = _re, wre = /* @__PURE__ */ ve({
  __name: "MenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(n) {
    const e = n;
    return (t, r) => (L(), re(O(kg), Bt(Jt(e)), {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Sre = wre;
const [jV, Ere] = br("MenuSub");
var Tre = /* @__PURE__ */ ve({
  __name: "MenuSub",
  props: { open: {
    type: Boolean,
    required: !1,
    default: void 0
  } },
  emits: ["update:open"],
  setup(n, { emit: e }) {
    const t = n, i = na(t, "open", e, {
      defaultValue: !1,
      passive: t.open === void 0
    }), a = Gd(), o = Z(), s = Z();
    return Cn((l) => {
      (a == null ? void 0 : a.open.value) === !1 && (i.value = !1), l(() => i.value = !1);
    }), RV({
      open: i,
      onOpenChange: (l) => {
        i.value = l;
      },
      content: s,
      onContentChange: (l) => {
        s.value = l;
      }
    }), Ere({
      triggerId: "",
      contentId: "",
      trigger: o,
      onTriggerChange: (l) => {
        o.value = l;
      }
    }), (l, u) => (L(), re(O(Ag), null, {
      default: ee(() => [ue(l.$slots, "default")]),
      _: 3
    }));
  }
}), Cre = Tre, kre = /* @__PURE__ */ ve({
  __name: "MenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1,
      default: !0
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const i = Lo(n, e), a = Gd(), o = Dg(), s = jV(), { forwardRef: l, currentElement: u } = Lt();
    return s.contentId || (s.contentId = ra(void 0, "reka-menu-sub-content")), (c, d) => (L(), re(O(Fu), { present: c.forceMount || O(a).open.value }, {
      default: ee(() => [se(eM, He(O(i), {
        id: O(s).contentId,
        ref: O(l),
        "aria-labelledby": O(s).triggerId,
        align: "start",
        side: O(o).dir.value === "rtl" ? "left" : "right",
        "disable-outside-pointer-events": !1,
        "disable-outside-scroll": !1,
        "trap-focus": !1,
        onOpenAutoFocus: d[0] || (d[0] = xt((f) => {
          var p;
          O(o).isUsingKeyboardRef.value && ((p = O(u)) == null || p.focus());
        }, ["prevent"])),
        onCloseAutoFocus: d[1] || (d[1] = xt(() => {
        }, ["prevent"])),
        onFocusOutside: d[2] || (d[2] = (f) => {
          f.defaultPrevented || f.target !== O(s).trigger.value && O(a).onOpenChange(!1);
        }),
        onEscapeKeyDown: d[3] || (d[3] = (f) => {
          O(o).onClose(), f.preventDefault();
        }),
        onKeydown: d[4] || (d[4] = (f) => {
          var v, m;
          const p = (v = f.currentTarget) == null ? void 0 : v.contains(f.target), h = O(mee)[O(o).dir.value].includes(f.key);
          p && h && (O(a).onOpenChange(!1), (m = O(s).trigger.value) == null || m.focus(), f.preventDefault());
        })
      }), {
        default: ee(() => [ue(c.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-labelledby",
        "side"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Are = kre, Mre = /* @__PURE__ */ ve({
  __name: "MenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = n, t = Gd(), r = Dg(), i = jV(), a = QA(), o = Z(null);
    i.triggerId || (i.triggerId = ra(void 0, "reka-menu-sub-trigger"));
    function s() {
      o.value && window.clearTimeout(o.value), o.value = null;
    }
    Nn(() => {
      s();
    });
    function l(d) {
      !xm(d) || a.onItemEnter(d) || !e.disabled && !t.open.value && !o.value && (a.onPointerGraceIntentChange(null), o.value = window.setTimeout(() => {
        t.onOpenChange(!0), s();
      }, 100));
    }
    async function u(d) {
      var p, h;
      if (!xm(d)) return;
      s();
      const f = (p = t.content.value) == null ? void 0 : p.getBoundingClientRect();
      if (f != null && f.width) {
        const v = (h = t.content.value) == null ? void 0 : h.dataset.side, m = v === "right", g = m ? -5 : 5, y = f[m ? "left" : "right"], b = f[m ? "right" : "left"];
        a.onPointerGraceIntentChange({
          area: [
            {
              x: d.clientX + g,
              y: d.clientY
            },
            {
              x: y,
              y: f.top
            },
            {
              x: b,
              y: f.top
            },
            {
              x: b,
              y: f.bottom
            },
            {
              x: y,
              y: f.bottom
            }
          ],
          side: v
        }), window.clearTimeout(a.pointerGraceTimerRef.value), a.pointerGraceTimerRef.value = window.setTimeout(() => a.onPointerGraceIntentChange(null), 300);
      } else {
        if (a.onTriggerLeave(d)) return;
        a.onPointerGraceIntentChange(null);
      }
    }
    async function c(d) {
      var p;
      const f = a.searchRef.value !== "";
      e.disabled || f && d.key === " " || vee[r.dir.value].includes(d.key) && (t.onOpenChange(!0), await Wt(), (p = t.content.value) == null || p.focus(), d.preventDefault());
    }
    return (d, f) => (L(), re(NV, { "as-child": "" }, {
      default: ee(() => [se(PV, He(e, {
        id: O(i).triggerId,
        ref: (p) => {
          var h;
          (h = O(i)) == null || h.onTriggerChange(p == null ? void 0 : p.$el);
        },
        "aria-haspopup": "menu",
        "aria-expanded": O(t).open.value,
        "aria-controls": O(i).contentId,
        "data-state": O(GA)(O(t).open.value),
        onClick: f[0] || (f[0] = async (p) => {
          e.disabled || p.defaultPrevented || (p.currentTarget.focus(), O(t).open.value || O(t).onOpenChange(!0));
        }),
        onPointermove: l,
        onPointerleave: u,
        onKeydown: c
      }), {
        default: ee(() => [ue(d.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-expanded",
        "aria-controls",
        "data-state"
      ])]),
      _: 3
    }));
  }
}), Dre = Mre;
const [Og, Ore] = br("PopoverRoot");
var Ire = /* @__PURE__ */ ve({
  __name: "PopoverRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:open"],
  setup(n, { emit: e }) {
    const t = n, r = e, { modal: i } = fi(t), a = na(t, "open", r, {
      defaultValue: t.defaultOpen,
      passive: t.open === void 0
    }), o = Z(), s = Z(!1);
    return Ore({
      contentId: "",
      triggerId: "",
      modal: i,
      open: a,
      onOpenChange: (l) => {
        a.value = l;
      },
      onOpenToggle: () => {
        a.value = !a.value;
      },
      triggerElement: o,
      hasCustomAnchor: s
    }), (l, u) => (L(), re(O(Ag), null, {
      default: ee(() => [ue(l.$slots, "default", {
        open: O(a),
        close: () => a.value = !1
      })]),
      _: 3
    }));
  }
}), Lre = Ire, Nre = /* @__PURE__ */ ve({
  __name: "PopoverAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = n;
    Lt();
    const t = Og();
    return AA(() => {
      t.hasCustomAnchor.value = !0;
    }), Nn(() => {
      t.hasCustomAnchor.value = !1;
    }), (r, i) => (L(), re(O(Q_), Bt(Jt(e)), {
      default: ee(() => [ue(r.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Rre = Nre, Pre = /* @__PURE__ */ ve({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Z_(uQ(t, "trapFocus", "disableOutsidePointerEvents")), { forwardRef: a } = Lt(), o = Og();
    return lV(), (s, l) => (L(), re(O(HA), {
      "as-child": "",
      loop: "",
      trapped: s.trapFocus,
      onMountAutoFocus: l[5] || (l[5] = (u) => r("openAutoFocus", u)),
      onUnmountAutoFocus: l[6] || (l[6] = (u) => r("closeAutoFocus", u))
    }, {
      default: ee(() => [se(O(Cg), {
        "as-child": "",
        "disable-outside-pointer-events": s.disableOutsidePointerEvents,
        onPointerDownOutside: l[0] || (l[0] = (u) => r("pointerDownOutside", u)),
        onInteractOutside: l[1] || (l[1] = (u) => r("interactOutside", u)),
        onEscapeKeyDown: l[2] || (l[2] = (u) => r("escapeKeyDown", u)),
        onFocusOutside: l[3] || (l[3] = (u) => r("focusOutside", u)),
        onDismiss: l[4] || (l[4] = (u) => O(o).onOpenChange(!1))
      }, {
        default: ee(() => [se(O(ix), He(O(i), {
          id: O(o).contentId,
          ref: O(a),
          "data-state": O(o).open.value ? "open" : "closed",
          "aria-labelledby": O(o).triggerId,
          style: {
            "--reka-popover-content-transform-origin": "var(--reka-popper-transform-origin)",
            "--reka-popover-content-available-width": "var(--reka-popper-available-width)",
            "--reka-popover-content-available-height": "var(--reka-popper-available-height)",
            "--reka-popover-trigger-width": "var(--reka-popper-anchor-width)",
            "--reka-popover-trigger-height": "var(--reka-popper-anchor-height)"
          },
          role: "dialog"
        }), {
          default: ee(() => [ue(s.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "data-state",
          "aria-labelledby"
        ])]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), BV = Pre, jre = /* @__PURE__ */ ve({
  __name: "PopoverContentModal",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Og(), a = Z(!1);
    X_(!0);
    const o = Lo(t, r), { forwardRef: s, currentElement: l } = Lt();
    return J_(l), (u, c) => (L(), re(BV, He(O(o), {
      ref: O(s),
      "trap-focus": O(i).open.value,
      "disable-outside-pointer-events": "",
      onCloseAutoFocus: c[0] || (c[0] = xt((d) => {
        var f;
        r("closeAutoFocus", d), a.value || (f = O(i).triggerElement.value) == null || f.focus();
      }, ["prevent"])),
      onPointerDownOutside: c[1] || (c[1] = (d) => {
        r("pointerDownOutside", d);
        const f = d.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0, h = f.button === 2 || p;
        a.value = h;
      }),
      onFocusOutside: c[2] || (c[2] = xt(() => {
      }, ["prevent"]))
    }), {
      default: ee(() => [ue(u.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), Bre = jre, $re = /* @__PURE__ */ ve({
  __name: "PopoverContentNonModal",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Og(), a = Z(!1), o = Z(!1), s = Lo(t, r);
    return (l, u) => (L(), re(BV, He(O(s), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: u[0] || (u[0] = (c) => {
        var d;
        r("closeAutoFocus", c), c.defaultPrevented || (a.value || (d = O(i).triggerElement.value) == null || d.focus(), c.preventDefault()), a.value = !1, o.value = !1;
      }),
      onInteractOutside: u[1] || (u[1] = async (c) => {
        var p;
        r("interactOutside", c), c.defaultPrevented || (a.value = !0, c.detail.originalEvent.type === "pointerdown" && (o.value = !0));
        const d = c.target;
        ((p = O(i).triggerElement.value) == null ? void 0 : p.contains(d)) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && o.value && c.preventDefault();
      })
    }), {
      default: ee(() => [ue(l.$slots, "default")]),
      _: 3
    }, 16));
  }
}), zre = $re, Fre = /* @__PURE__ */ ve({
  __name: "PopoverContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Og(), a = Lo(t, r), { forwardRef: o } = Lt();
    return i.contentId || (i.contentId = ra(void 0, "reka-popover-content")), (s, l) => (L(), re(O(Fu), { present: s.forceMount || O(i).open.value }, {
      default: ee(() => [O(i).modal.value ? (L(), re(Bre, He({ key: 0 }, O(a), { ref: O(o) }), {
        default: ee(() => [ue(s.$slots, "default")]),
        _: 3
      }, 16)) : (L(), re(zre, He({ key: 1 }, O(a), { ref: O(o) }), {
        default: ee(() => [ue(s.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), Vre = Fre, Hre = /* @__PURE__ */ ve({
  __name: "PopoverPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(n) {
    const e = n;
    return (t, r) => (L(), re(O(kg), Bt(Jt(e)), {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Gre = Hre;
const [$V, Ure] = br("DropdownMenuRoot");
var Wre = /* @__PURE__ */ ve({
  __name: "DropdownMenuRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(n, { emit: e }) {
    const t = n, r = e;
    Lt();
    const i = na(t, "open", r, {
      defaultValue: t.defaultOpen,
      passive: t.open === void 0
    }), a = Z(), { modal: o, dir: s } = fi(t), l = Eg(s);
    return Ure({
      open: i,
      onOpenChange: (u) => {
        i.value = u;
      },
      onOpenToggle: () => {
        i.value = !i.value;
      },
      triggerId: "",
      triggerElement: a,
      contentId: "",
      modal: o,
      dir: l
    }), (u, c) => (L(), re(O(lre), {
      open: O(i),
      "onUpdate:open": c[0] || (c[0] = (d) => al(i) ? i.value = d : null),
      dir: O(l),
      modal: O(o)
    }, {
      default: ee(() => [ue(u.$slots, "default", { open: O(i) })]),
      _: 3
    }, 8, [
      "open",
      "dir",
      "modal"
    ]));
  }
}), qre = Wre, Yre = /* @__PURE__ */ ve({
  __name: "DropdownMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const i = Lo(n, e);
    Lt();
    const a = $V(), o = Z(!1);
    function s(l) {
      l.defaultPrevented || (o.value || setTimeout(() => {
        var u;
        (u = a.triggerElement.value) == null || u.focus();
      }, 0), o.value = !1, l.preventDefault());
    }
    return a.contentId || (a.contentId = ra(void 0, "reka-dropdown-menu-content")), (l, u) => {
      var c;
      return L(), re(O(bre), He(O(i), {
        id: O(a).contentId,
        "aria-labelledby": (c = O(a)) == null ? void 0 : c.triggerId,
        style: {
          "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
          "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
          "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onCloseAutoFocus: s,
        onInteractOutside: u[0] || (u[0] = (d) => {
          var v;
          if (d.defaultPrevented) return;
          const f = d.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0, h = f.button === 2 || p;
          (!O(a).modal.value || h) && (o.value = !0), (v = O(a).triggerElement.value) != null && v.contains(d.target) && d.preventDefault();
        })
      }), {
        default: ee(() => [ue(l.$slots, "default")]),
        _: 3
      }, 16, ["id", "aria-labelledby"]);
    };
  }
}), Kre = Yre, Xre = /* @__PURE__ */ ve({
  __name: "DropdownMenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(n, { emit: e }) {
    const t = n, i = Tg(e);
    return Lt(), (a, o) => (L(), re(O(pre), Bt(Jt({
      ...t,
      ...O(i)
    })), {
      default: ee(() => [ue(a.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ML = Xre, Zre = /* @__PURE__ */ ve({
  __name: "DropdownMenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = n;
    return Lt(), (t, r) => (L(), re(O(xre), Bt(Jt(e)), {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 16));
  }
}), DL = Zre, Jre = /* @__PURE__ */ ve({
  __name: "DropdownMenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(n) {
    const e = n;
    return (t, r) => (L(), re(O(Sre), Bt(Jt(e)), {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 16));
  }
}), OL = Jre, Qre = /* @__PURE__ */ ve({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(n, { emit: e }) {
    const t = n, i = na(t, "open", e, {
      passive: t.open === void 0,
      defaultValue: t.defaultOpen ?? !1
    });
    return Lt(), (a, o) => (L(), re(O(Cre), {
      open: O(i),
      "onUpdate:open": o[0] || (o[0] = (s) => al(i) ? i.value = s : null)
    }, {
      default: ee(() => [ue(a.$slots, "default", { open: O(i) })]),
      _: 3
    }, 8, ["open"]));
  }
}), eie = Qre, tie = /* @__PURE__ */ ve({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(n, { emit: e }) {
    const i = Lo(n, e);
    return Lt(), (a, o) => (L(), re(O(Are), He(O(i), { style: {
      "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
      "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
      "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: ee(() => [ue(a.$slots, "default")]),
      _: 3
    }, 16));
  }
}), nie = tie, rie = /* @__PURE__ */ ve({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = n;
    return Lt(), (t, r) => (L(), re(O(Dre), Bt(Jt(e)), {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 16));
  }
}), iie = rie, aie = /* @__PURE__ */ ve({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(n) {
    const e = n, t = $V(), { forwardRef: r, currentElement: i } = Lt();
    return kt(() => {
      t.triggerElement = i;
    }), t.triggerId || (t.triggerId = ra(void 0, "reka-dropdown-menu-trigger")), (a, o) => (L(), re(O(NV), { "as-child": "" }, {
      default: ee(() => [se(O(Sn), {
        id: O(t).triggerId,
        ref: O(r),
        type: a.as === "button" ? "button" : void 0,
        "as-child": e.asChild,
        as: a.as,
        "aria-haspopup": "menu",
        "aria-expanded": O(t).open.value,
        "aria-controls": O(t).open.value ? O(t).contentId : void 0,
        "data-disabled": a.disabled ? "" : void 0,
        disabled: a.disabled,
        "data-state": O(t).open.value ? "open" : "closed",
        onClick: o[0] || (o[0] = async (s) => {
          var l;
          !a.disabled && s.button === 0 && s.ctrlKey === !1 && ((l = O(t)) == null || l.onOpenToggle(), await Wt(), O(t).open.value && s.preventDefault());
        }),
        onKeydown: o[1] || (o[1] = ci((s) => {
          a.disabled || (["Enter", " "].includes(s.key) && O(t).onOpenToggle(), s.key === "ArrowDown" && O(t).onOpenChange(!0), [
            "Enter",
            " ",
            "ArrowDown"
          ].includes(s.key) && s.preventDefault());
        }, [
          "enter",
          "space",
          "arrow-down"
        ]))
      }, {
        default: ee(() => [ue(a.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "type",
        "as-child",
        "as",
        "aria-expanded",
        "aria-controls",
        "data-disabled",
        "disabled",
        "data-state"
      ])]),
      _: 3
    }));
  }
}), oie = aie, sie = /* @__PURE__ */ ve({
  __name: "ToastAnnounceExclude",
  props: {
    altText: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    return (e, t) => (L(), re(O(Sn), {
      as: e.as,
      "as-child": e.asChild,
      "data-reka-toast-announce-exclude": "",
      "data-reka-toast-announce-alt": e.altText || void 0
    }, {
      default: ee(() => [ue(e.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-reka-toast-announce-alt"
    ]));
  }
}), zV = sie;
const [FV, uUe] = br("ToastProvider");
var lie = /* @__PURE__ */ ve({
  __name: "ToastAnnounce",
  setup(n) {
    const e = FV(), t = yQ(1e3), r = Z(!1);
    return oV(() => {
      r.value = !0;
    }), (i, a) => O(t) || r.value ? (L(), re(O(UA), { key: 0 }, {
      default: ee(() => [gn(ke(O(e).label.value) + " ", 1), ue(i.$slots, "default")]),
      _: 3
    })) : ge("v-if", !0);
  }
}), uie = lie;
const cie = "toast.swipeStart", die = "toast.swipeMove", fie = "toast.swipeCancel", pie = "toast.swipeEnd", IL = "toast.viewportPause", LL = "toast.viewportResume";
function wy(n, e, t) {
  const r = t.originalEvent.currentTarget, i = new CustomEvent(n, {
    bubbles: !1,
    cancelable: !0,
    detail: t
  });
  e && r.addEventListener(n, e, { once: !0 }), r.dispatchEvent(i);
}
function NL(n, e, t = 0) {
  const r = Math.abs(n.x), i = Math.abs(n.y), a = r > i;
  return e === "left" || e === "right" ? a && r > t : !a && i > t;
}
function hie(n) {
  return n.nodeType === n.ELEMENT_NODE;
}
function VV(n) {
  const e = [];
  return Array.from(n.childNodes).forEach((r) => {
    if (r.nodeType === r.TEXT_NODE && r.textContent && e.push(r.textContent), hie(r)) {
      const i = r.ariaHidden || r.hidden || r.style.display === "none", a = r.dataset.rekaToastAnnounceExclude === "";
      if (!i) if (a) {
        const o = r.dataset.rekaToastAnnounceAlt;
        o && e.push(o);
      } else e.push(...VV(r));
    }
  }), e;
}
const [vie, mie] = br("ToastRoot");
var gie = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "ToastRootImpl",
  props: {
    type: {
      type: String,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: !1
    },
    duration: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "li"
    }
  },
  emits: [
    "close",
    "escapeKeyDown",
    "pause",
    "resume",
    "swipeStart",
    "swipeMove",
    "swipeCancel",
    "swipeEnd"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, { forwardRef: i, currentElement: a } = Lt(), { CollectionItem: o } = Qp(), s = FV(), l = Z(null), u = Z(null), c = K(() => typeof t.duration == "number" ? t.duration : s.duration.value), d = Z(0), f = Z(c.value), p = Z(0), h = Z(c.value), v = oV(() => {
      const b = (/* @__PURE__ */ new Date()).getTime() - d.value;
      h.value = Math.max(f.value - b, 0);
    }, { fpsLimit: 60 });
    function m(b) {
      b <= 0 || b === Number.POSITIVE_INFINITY || Cs && (window.clearTimeout(p.value), d.value = (/* @__PURE__ */ new Date()).getTime(), p.value = window.setTimeout(g, b));
    }
    function g(b) {
      var w, S;
      const _ = (b == null ? void 0 : b.pointerType) === "";
      ((w = a.value) == null ? void 0 : w.contains(Di())) && _ && ((S = s.viewport.value) == null || S.focus()), _ && (s.isClosePausedRef.value = !1), r("close");
    }
    const y = K(() => a.value ? VV(a.value) : null);
    if (t.type && !["foreground", "background"].includes(t.type)) {
      const b = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.";
      throw new Error(b);
    }
    return Cn((b) => {
      const _ = s.viewport.value;
      if (_) {
        const x = () => {
          m(f.value), v.resume(), r("resume");
        }, w = () => {
          const S = (/* @__PURE__ */ new Date()).getTime() - d.value;
          f.value = f.value - S, window.clearTimeout(p.value), v.pause(), r("pause");
        };
        return _.addEventListener(IL, w), _.addEventListener(LL, x), () => {
          _.removeEventListener(IL, w), _.removeEventListener(LL, x);
        };
      }
    }), et(() => [t.open, c.value], () => {
      f.value = c.value, t.open && !s.isClosePausedRef.value && m(c.value);
    }, { immediate: !0 }), aV("Escape", (b) => {
      r("escapeKeyDown", b), b.defaultPrevented || (s.isFocusedToastEscapeKeyDownRef.value = !0, g());
    }), kt(() => {
      s.onToastAdd();
    }), Nn(() => {
      s.onToastRemove();
    }), mie({ onClose: g }), (b, _) => (L(), W(Ke, null, [y.value ? (L(), re(uie, {
      key: 0,
      role: "alert",
      "aria-live": b.type === "foreground" ? "assertive" : "polite",
      "aria-atomic": "true"
    }, {
      default: ee(() => [gn(ke(y.value), 1)]),
      _: 1
    }, 8, ["aria-live"])) : ge("v-if", !0), O(s).viewport.value ? (L(), re(wg, {
      key: 1,
      to: O(s).viewport.value
    }, [se(O(o), null, {
      default: ee(() => [se(O(Sn), He({
        ref: O(i),
        role: "alert",
        "aria-live": "off",
        "aria-atomic": "true",
        tabindex: "0"
      }, b.$attrs, {
        as: b.as,
        "as-child": b.asChild,
        "data-state": b.open ? "open" : "closed",
        "data-swipe-direction": O(s).swipeDirection.value,
        style: {
          userSelect: "none",
          touchAction: "none"
        },
        onPointerdown: _[0] || (_[0] = xt((x) => {
          l.value = {
            x: x.clientX,
            y: x.clientY
          };
        }, ["left"])),
        onPointermove: _[1] || (_[1] = (x) => {
          if (!l.value) return;
          const w = x.clientX - l.value.x, S = x.clientY - l.value.y, C = !!u.value, k = ["left", "right"].includes(O(s).swipeDirection.value), M = ["left", "up"].includes(O(s).swipeDirection.value) ? Math.min : Math.max, D = k ? M(0, w) : 0, N = k ? 0 : M(0, S), R = x.pointerType === "touch" ? 10 : 2, j = {
            x: D,
            y: N
          }, z = {
            originalEvent: x,
            delta: j
          };
          C ? (u.value = j, O(wy)(O(die), (F) => r("swipeMove", F), z)) : O(NL)(j, O(s).swipeDirection.value, R) ? (u.value = j, O(wy)(O(cie), (F) => r("swipeStart", F), z), x.target.setPointerCapture(x.pointerId)) : (Math.abs(w) > R || Math.abs(S) > R) && (l.value = null);
        }),
        onPointerup: _[2] || (_[2] = (x) => {
          const w = u.value, S = x.target;
          if (S.hasPointerCapture(x.pointerId) && S.releasePointerCapture(x.pointerId), u.value = null, l.value = null, w) {
            const C = x.currentTarget, k = {
              originalEvent: x,
              delta: w
            };
            O(NL)(w, O(s).swipeDirection.value, O(s).swipeThreshold.value) ? O(wy)(O(pie), (M) => r("swipeEnd", M), k) : O(wy)(O(fie), (M) => r("swipeCancel", M), k), C == null || C.addEventListener("click", (M) => M.preventDefault(), { once: !0 });
          }
        })
      }), {
        default: ee(() => [ue(b.$slots, "default", {
          remaining: h.value,
          duration: c.value
        })]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "data-state",
        "data-swipe-direction"
      ])]),
      _: 3
    })], 8, ["to"])) : ge("v-if", !0)], 64));
  }
}), yie = gie, bie = /* @__PURE__ */ ve({
  __name: "ToastClose",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(n) {
    const e = n, t = vie(), { forwardRef: r } = Lt();
    return (i, a) => (L(), re(zV, { "as-child": "" }, {
      default: ee(() => [se(O(Sn), He(e, {
        ref: O(r),
        type: i.as === "button" ? "button" : void 0,
        onClick: O(t).onClose
      }), {
        default: ee(() => [ue(i.$slots, "default")]),
        _: 3
      }, 16, ["type", "onClick"])]),
      _: 3
    }));
  }
}), HV = bie, _ie = /* @__PURE__ */ ve({
  __name: "ToastAction",
  props: {
    altText: {
      type: String,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    if (!n.altText) throw new Error("Missing prop `altText` expected on `ToastAction`");
    const { forwardRef: t } = Lt();
    return (r, i) => r.altText ? (L(), re(zV, {
      key: 0,
      "alt-text": r.altText,
      "as-child": ""
    }, {
      default: ee(() => [se(HV, {
        ref: O(t),
        as: r.as,
        "as-child": r.asChild
      }, {
        default: ee(() => [ue(r.$slots, "default")]),
        _: 3
      }, 8, ["as", "as-child"])]),
      _: 3
    }, 8, ["alt-text"])) : ge("v-if", !0);
  }
}), xie = _ie, wie = /* @__PURE__ */ ve({
  __name: "ToastDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(n) {
    const e = n;
    return Lt(), (t, r) => (L(), re(O(Sn), Bt(Jt(e)), {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Sie = wie, Eie = /* @__PURE__ */ ve({
  __name: "ToastRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !0
    },
    forceMount: {
      type: Boolean,
      required: !1
    },
    type: {
      type: String,
      required: !1,
      default: "foreground"
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    duration: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "li"
    }
  },
  emits: [
    "escapeKeyDown",
    "pause",
    "resume",
    "swipeStart",
    "swipeMove",
    "swipeCancel",
    "swipeEnd",
    "update:open"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, { forwardRef: i } = Lt(), a = na(t, "open", r, {
      defaultValue: t.defaultOpen,
      passive: t.open === void 0
    });
    return (o, s) => (L(), re(O(Fu), { present: o.forceMount || O(a) }, {
      default: ee(() => [se(yie, He({
        ref: O(i),
        open: O(a),
        type: o.type,
        as: o.as,
        "as-child": o.asChild,
        duration: o.duration
      }, o.$attrs, {
        onClose: s[0] || (s[0] = (l) => a.value = !1),
        onPause: s[1] || (s[1] = (l) => r("pause")),
        onResume: s[2] || (s[2] = (l) => r("resume")),
        onEscapeKeyDown: s[3] || (s[3] = (l) => r("escapeKeyDown", l)),
        onSwipeStart: s[4] || (s[4] = (l) => {
          r("swipeStart", l), l.defaultPrevented || l.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: s[5] || (s[5] = (l) => {
          if (r("swipeMove", l), !l.defaultPrevented) {
            const { x: u, y: c } = l.detail.delta, d = l.currentTarget;
            d.setAttribute("data-swipe", "move"), d.style.setProperty("--reka-toast-swipe-move-x", `${u}px`), d.style.setProperty("--reka-toast-swipe-move-y", `${c}px`);
          }
        }),
        onSwipeCancel: s[6] || (s[6] = (l) => {
          if (r("swipeCancel", l), !l.defaultPrevented) {
            const u = l.currentTarget;
            u.setAttribute("data-swipe", "cancel"), u.style.removeProperty("--reka-toast-swipe-move-x"), u.style.removeProperty("--reka-toast-swipe-move-y"), u.style.removeProperty("--reka-toast-swipe-end-x"), u.style.removeProperty("--reka-toast-swipe-end-y");
          }
        }),
        onSwipeEnd: s[7] || (s[7] = (l) => {
          if (r("swipeEnd", l), !l.defaultPrevented) {
            const { x: u, y: c } = l.detail.delta, d = l.currentTarget;
            d.setAttribute("data-swipe", "end"), d.style.removeProperty("--reka-toast-swipe-move-x"), d.style.removeProperty("--reka-toast-swipe-move-y"), d.style.setProperty("--reka-toast-swipe-end-x", `${u}px`), d.style.setProperty("--reka-toast-swipe-end-y", `${c}px`), a.value = !1;
          }
        })
      }), {
        default: ee(({ remaining: l, duration: u }) => [ue(o.$slots, "default", {
          remaining: l,
          duration: u,
          open: O(a)
        })]),
        _: 3
      }, 16, [
        "open",
        "type",
        "as",
        "as-child",
        "duration"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Tie = Eie, Cie = /* @__PURE__ */ ve({
  __name: "TooltipArrow",
  props: {
    width: {
      type: Number,
      required: !1,
      default: 10
    },
    height: {
      type: Number,
      required: !1,
      default: 5
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(n) {
    const e = n;
    return Lt(), (t, r) => (L(), re(O(cne), Bt(Jt(e)), {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 16));
  }
}), kie = Cie;
const [tM, Aie] = br("TooltipProvider");
var Mie = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "TooltipProvider",
  props: {
    delayDuration: {
      type: Number,
      required: !1,
      default: 700
    },
    skipDelayDuration: {
      type: Number,
      required: !1,
      default: 300
    },
    disableHoverableContent: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableClosingTrigger: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    ignoreNonKeyboardFocus: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(n) {
    const e = n, { delayDuration: t, skipDelayDuration: r, disableHoverableContent: i, disableClosingTrigger: a, ignoreNonKeyboardFocus: o, disabled: s } = fi(e);
    Lt();
    const l = Z(!0), u = Z(!1), { start: c, stop: d } = VA(() => {
      l.value = !0;
    }, r, { immediate: !1 });
    return Aie({
      isOpenDelayed: l,
      delayDuration: t,
      onOpen() {
        d(), l.value = !1;
      },
      onClose() {
        c();
      },
      isPointerInTransitRef: u,
      disableHoverableContent: i,
      disableClosingTrigger: a,
      disabled: s,
      ignoreNonKeyboardFocus: o
    }), (f, p) => ue(f.$slots, "default");
  }
}), Die = Mie;
const GV = "tooltip.open", [ox, Oie] = br("TooltipRoot");
var Iie = /* @__PURE__ */ ve({
  __name: "TooltipRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    delayDuration: {
      type: Number,
      required: !1,
      default: void 0
    },
    disableHoverableContent: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disableClosingTrigger: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    ignoreNonKeyboardFocus: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(n, { emit: e }) {
    const t = n, r = e;
    Lt();
    const i = tM(), a = K(() => t.disableHoverableContent ?? i.disableHoverableContent.value), o = K(() => t.disableClosingTrigger ?? i.disableClosingTrigger.value), s = K(() => t.disabled ?? i.disabled.value), l = K(() => t.delayDuration ?? i.delayDuration.value), u = K(() => t.ignoreNonKeyboardFocus ?? i.ignoreNonKeyboardFocus.value), c = na(t, "open", r, {
      defaultValue: t.defaultOpen,
      passive: t.open === void 0
    });
    et(c, (b) => {
      i.onClose && (b ? (i.onOpen(), document.dispatchEvent(new CustomEvent(GV))) : i.onClose());
    });
    const d = Z(!1), f = Z(), p = K(() => c.value ? d.value ? "delayed-open" : "instant-open" : "closed"), { start: h, stop: v } = VA(() => {
      d.value = !0, c.value = !0;
    }, l, { immediate: !1 });
    function m() {
      v(), d.value = !1, c.value = !0;
    }
    function g() {
      v(), c.value = !1;
    }
    function y() {
      h();
    }
    return Oie({
      contentId: "",
      open: c,
      stateAttribute: p,
      trigger: f,
      onTriggerChange(b) {
        f.value = b;
      },
      onTriggerEnter() {
        i.isOpenDelayed.value ? y() : m();
      },
      onTriggerLeave() {
        a.value ? g() : v();
      },
      onOpen: m,
      onClose: g,
      disableHoverableContent: a,
      disableClosingTrigger: o,
      disabled: s,
      ignoreNonKeyboardFocus: u
    }), (b, _) => (L(), re(O(Ag), null, {
      default: ee(() => [ue(b.$slots, "default", { open: O(c) })]),
      _: 3
    }));
  }
}), Lie = Iie, Nie = /* @__PURE__ */ ve({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1,
      default: "top"
    },
    sideOffset: {
      type: Number,
      required: !1,
      default: 0
    },
    align: {
      type: null,
      required: !1,
      default: "center"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1,
      default: !0
    },
    collisionBoundary: {
      type: null,
      required: !1,
      default: () => []
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: 0
    },
    arrowPadding: {
      type: Number,
      required: !1,
      default: 0
    },
    sticky: {
      type: String,
      required: !1,
      default: "partial"
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1,
      default: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ox(), { forwardRef: a } = Lt(), o = Xp(), s = K(() => {
      var c;
      return (c = o.default) == null ? void 0 : c.call(o, {});
    }), l = K(() => {
      var f;
      if (t.ariaLabel) return t.ariaLabel;
      let c = "";
      function d(p) {
        typeof p.children == "string" && p.type !== vF ? c += p.children : Array.isArray(p.children) && p.children.forEach((h) => d(h));
      }
      return (f = s.value) == null || f.forEach((p) => d(p)), c;
    }), u = K(() => {
      const { ariaLabel: c, ...d } = t;
      return d;
    });
    return kt(() => {
      Ep(window, "scroll", (c) => {
        const d = c.target;
        d != null && d.contains(i.trigger.value) && i.onClose();
      }), Ep(window, GV, i.onClose);
    }), (c, d) => (L(), re(O(Cg), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: d[0] || (d[0] = (f) => r("escapeKeyDown", f)),
      onPointerDownOutside: d[1] || (d[1] = (f) => {
        var p;
        O(i).disableClosingTrigger.value && ((p = O(i).trigger.value) != null && p.contains(f.target)) && f.preventDefault(), r("pointerDownOutside", f);
      }),
      onFocusOutside: d[2] || (d[2] = xt(() => {
      }, ["prevent"])),
      onDismiss: d[3] || (d[3] = (f) => O(i).onClose())
    }, {
      default: ee(() => [se(O(ix), He({
        ref: O(a),
        "data-state": O(i).stateAttribute.value
      }, {
        ...c.$attrs,
        ...u.value
      }, { style: {
        "--reka-tooltip-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-tooltip-content-available-width": "var(--reka-popper-available-width)",
        "--reka-tooltip-content-available-height": "var(--reka-popper-available-height)",
        "--reka-tooltip-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-tooltip-trigger-height": "var(--reka-popper-anchor-height)"
      } }), {
        default: ee(() => [ue(c.$slots, "default"), se(O(UA), {
          id: O(i).contentId,
          role: "tooltip"
        }, {
          default: ee(() => [gn(ke(l.value), 1)]),
          _: 1
        }, 8, ["id"])]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }));
  }
}), UV = Nie, Rie = /* @__PURE__ */ ve({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  setup(n) {
    const t = Z_(n), { forwardRef: r, currentElement: i } = Lt(), { trigger: a, onClose: o } = ox(), s = tM(), { isPointerInTransit: l, onPointerExit: u } = MQ(a, i);
    return s.isPointerInTransitRef = l, u(() => {
      o();
    }), (c, d) => (L(), re(UV, He({ ref: O(r) }, O(t)), {
      default: ee(() => [ue(c.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Pie = Rie, jie = /* @__PURE__ */ ve({
  __name: "TooltipContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1,
      default: "top"
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = ox(), a = Lo(t, r), { forwardRef: o } = Lt();
    return (s, l) => (L(), re(O(Fu), { present: s.forceMount || O(i).open.value }, {
      default: ee(() => [(L(), re(bn(O(i).disableHoverableContent.value ? UV : Pie), He({ ref: O(o) }, O(a)), {
        default: ee(() => [ue(s.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), Bie = jie, $ie = /* @__PURE__ */ ve({
  __name: "TooltipPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(n) {
    const e = n;
    return (t, r) => (L(), re(O(kg), Bt(Jt(e)), {
      default: ee(() => [ue(t.$slots, "default")]),
      _: 3
    }, 16));
  }
}), zie = $ie, Fie = /* @__PURE__ */ ve({
  __name: "TooltipTrigger",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(n) {
    const e = n, t = ox(), r = tM();
    t.contentId || (t.contentId = ra(void 0, "reka-tooltip-content"));
    const { forwardRef: i, currentElement: a } = Lt(), o = Z(!1), s = Z(!1), l = K(() => t.disabled.value ? {} : {
      click: v,
      focus: p,
      pointermove: d,
      pointerleave: f,
      pointerdown: c,
      blur: h
    });
    kt(() => {
      t.onTriggerChange(a.value);
    });
    function u() {
      setTimeout(() => {
        o.value = !1;
      }, 1);
    }
    function c() {
      t.open && !t.disableClosingTrigger.value && t.onClose(), o.value = !0, document.addEventListener("pointerup", u, { once: !0 });
    }
    function d(m) {
      m.pointerType !== "touch" && !s.value && !r.isPointerInTransitRef.value && (t.onTriggerEnter(), s.value = !0);
    }
    function f() {
      t.onTriggerLeave(), s.value = !1;
    }
    function p(m) {
      var g, y;
      o.value || t.ignoreNonKeyboardFocus.value && !((y = (g = m.target).matches) != null && y.call(g, ":focus-visible")) || t.onOpen();
    }
    function h() {
      t.onClose();
    }
    function v() {
      t.disableClosingTrigger.value || t.onClose();
    }
    return (m, g) => (L(), re(O(Q_), {
      "as-child": "",
      reference: m.reference
    }, {
      default: ee(() => [se(O(Sn), He({
        ref: O(i),
        "aria-describedby": O(t).open.value ? O(t).contentId : void 0,
        "data-state": O(t).stateAttribute.value,
        as: m.as,
        "as-child": e.asChild,
        "data-grace-area-trigger": ""
      }, yF(l.value)), {
        default: ee(() => [ue(m.$slots, "default")]),
        _: 3
      }, 16, [
        "aria-describedby",
        "data-state",
        "as",
        "as-child"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), Vie = Fie;
const Hie = { class: "rounded-lg border bg-surface-modal shadow-xl" }, th = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "Popover",
  props: {
    show: { type: Boolean, default: void 0 },
    trigger: { default: "click" },
    hoverDelay: { default: 0 },
    leaveDelay: { default: 0.5 },
    placement: { default: "bottom-start" },
    popoverClass: { default: "" },
    transition: { default: null },
    hideOnBlur: { type: Boolean, default: !0 }
  },
  emits: ["open", "close", "update:show"],
  setup(n, { expose: e, emit: t }) {
    const r = n, i = t;
    e({ open: m, close: g });
    const a = Z(!1), o = Z(!1), s = Z(null), l = Z(null), u = Z(null), c = K({
      get: () => d.value ? r.show : a.value,
      set: (S) => {
        d.value || (a.value = S), i("update:show", S);
      }
    }), d = K(() => r.show !== void 0), f = K(() => {
      const [S] = r.placement.split("-");
      return S;
    }), p = K(() => {
      const [, S] = r.placement.split("-");
      return S || "center";
    });
    function h(S) {
      S instanceof Event && (S = void 0), S == null && (S = !c.value), S = !!S, S ? m() : g();
    }
    function v() {
    }
    function m() {
      c.value = !0;
    }
    function g() {
      c.value = !1;
    }
    function y(S) {
      i("update:show", S), i(S ? "open" : "close");
    }
    function b() {
      o.value = !0, l.value && (clearTimeout(l.value), l.value = null), r.trigger === "hover" && (r.hoverDelay ? s.value = setTimeout(
        () => {
          o.value && m();
        },
        Number(r.hoverDelay) * 1e3
      ) : m());
    }
    function _() {
      o.value = !1, s.value && (clearTimeout(s.value), s.value = null), r.trigger === "hover" && (l.value && clearTimeout(l.value), r.leaveDelay ? l.value = setTimeout(
        () => {
          o.value || g();
        },
        Number(r.leaveDelay) * 1e3
      ) : o.value || g());
    }
    function x(S) {
      if (!r.hideOnBlur) {
        S.preventDefault();
        return;
      }
      const C = S.target;
      if (u.value && (u.value.contains(C) || u.value === C)) {
        S.preventDefault();
        return;
      }
    }
    const w = K(() => r.transition === "default");
    return Nn(() => {
      s.value && clearTimeout(s.value), l.value && clearTimeout(l.value);
    }), (S, C) => (L(), re(O(Lre), {
      open: c.value,
      "onUpdate:open": [
        C[1] || (C[1] = (k) => c.value = k),
        y
      ]
    }, {
      default: ee(() => [
        se(O(Rre), { asChild: "" }, {
          default: ee(() => [
            G("div", {
              ref_key: "anchorRef",
              ref: u,
              class: _e(["flex", S.$attrs.class]),
              onMouseover: b,
              onMouseleave: _
            }, [
              ue(S.$slots, "target", Bt(Jt({
                togglePopover: h,
                updatePosition: v,
                open: m,
                close: g,
                isOpen: c.value
              })))
            ], 34)
          ]),
          _: 3
        }),
        se(O(Gre), null, {
          default: ee(() => [
            se(O(Vre), {
              side: f.value,
              align: p.value,
              style: {
                minWidth: "var(--reka-popover-trigger-width)"
              },
              class: _e(["PopoverContent", { "has-transition": w.value }]),
              onMouseover: C[0] || (C[0] = () => {
                o.value = !0;
              }),
              onMouseleave: _,
              onInteractOutside: x
            }, {
              default: ee(() => [
                G("div", {
                  class: _e(["relative", ["body-container", S.popoverClass]])
                }, [
                  ue(S.$slots, "body", Bt(Jt({ togglePopover: h, updatePosition: v, open: m, close: g, isOpen: c.value })), () => [
                    G("div", Hie, [
                      ue(S.$slots, "body-main", Bt(Jt({
                        togglePopover: h,
                        updatePosition: v,
                        open: m,
                        close: g,
                        isOpen: c.value
                      })))
                    ])
                  ])
                ], 2)
              ]),
              _: 3
            }, 8, ["side", "align", "class"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["open"]));
  }
});
var WV = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function nM(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var qV = { exports: {} };
(function(n, e) {
  (function(r, i) {
    n.exports = i();
  })(typeof self < "u" ? self : WV, function() {
    return (
      /******/
      function(t) {
        var r = {};
        function i(a) {
          if (r[a])
            return r[a].exports;
          var o = r[a] = {
            /******/
            i: a,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return t[a].call(o.exports, o, o.exports, i), o.l = !0, o.exports;
        }
        return i.m = t, i.c = r, i.d = function(a, o, s) {
          i.o(a, o) || Object.defineProperty(a, o, {
            /******/
            configurable: !1,
            /******/
            enumerable: !0,
            /******/
            get: s
            /******/
          });
        }, i.r = function(a) {
          Object.defineProperty(a, "__esModule", { value: !0 });
        }, i.n = function(a) {
          var o = a && a.__esModule ? (
            /******/
            function() {
              return a.default;
            }
          ) : (
            /******/
            function() {
              return a;
            }
          );
          return i.d(o, "a", o), o;
        }, i.o = function(a, o) {
          return Object.prototype.hasOwnProperty.call(a, o);
        }, i.p = "", i(i.s = 0);
      }({
        /***/
        "./dist/icons.json": (
          /*!*************************!*\
            !*** ./dist/icons.json ***!
            \*************************/
          /*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, aperture, archive, arrow-down-circle, arrow-down-left, arrow-down-right, arrow-down, arrow-left-circle, arrow-left, arrow-right-circle, arrow-right, arrow-up-circle, arrow-up-left, arrow-up-right, arrow-up, at-sign, award, bar-chart-2, bar-chart, battery-charging, battery, bell-off, bell, bluetooth, bold, book-open, book, bookmark, box, briefcase, calendar, camera-off, camera, cast, check-circle, check-square, check, chevron-down, chevron-left, chevron-right, chevron-up, chevrons-down, chevrons-left, chevrons-right, chevrons-up, chrome, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-off, cloud-rain, cloud-snow, cloud, code, codepen, codesandbox, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, divide-circle, divide-square, divide, dollar-sign, download-cloud, download, dribbble, droplet, edit-2, edit-3, edit, external-link, eye-off, eye, facebook, fast-forward, feather, figma, file-minus, file-plus, file-text, file, film, filter, flag, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, grid, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, info, instagram, italic, key, layers, layout, life-buoy, link-2, link, linkedin, list, loader, lock, log-in, log-out, mail, map-pin, map, maximize-2, maximize, meh, menu, message-circle, message-square, mic-off, mic, minimize-2, minimize, minus-circle, minus-square, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation-2, navigation, octagon, package, paperclip, pause-circle, pause, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, pie-chart, play-circle, play, plus-circle, plus-square, plus, pocket, power, printer, radio, refresh-ccw, refresh-cw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, server, settings, share-2, share, shield-off, shield, shopping-bag, shopping-cart, shuffle, sidebar, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, square, star, stop-circle, sun, sunrise, sunset, table, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, tool, trash-2, trash, trello, trending-down, trending-up, triangle, truck, tv, twitch, twitter, type, umbrella, underline, unlock, upload-cloud, upload, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume-1, volume-2, volume-x, volume, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default */
          /***/
          function(t) {
            t.exports = { activity: '<polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>', airplay: '<path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon points="12 15 17 21 7 21 12 15"></polygon>', "alert-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>', "align-center": '<line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line>', "align-justify": '<line x1="21" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line>', "align-left": '<line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line>', "align-right": '<line x1="21" y1="10" x2="7" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="7" y2="18"></line>', anchor: '<circle cx="12" cy="5" r="3"></circle><line x1="12" y1="22" x2="12" y2="8"></line><path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>', aperture: '<circle cx="12" cy="12" r="10"></circle><line x1="14.31" y1="8" x2="20.05" y2="17.94"></line><line x1="9.69" y1="8" x2="21.17" y2="8"></line><line x1="7.38" y1="12" x2="13.12" y2="2.06"></line><line x1="9.69" y1="16" x2="3.95" y2="6.06"></line><line x1="14.31" y1="16" x2="2.83" y2="16"></line><line x1="16.62" y1="12" x2="10.88" y2="21.94"></line>', archive: '<polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line>', "arrow-down-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="8 12 12 16 16 12"></polyline><line x1="12" y1="8" x2="12" y2="16"></line>', "arrow-down-left": '<line x1="17" y1="7" x2="7" y2="17"></line><polyline points="17 17 7 17 7 7"></polyline>', "arrow-down-right": '<line x1="7" y1="7" x2="17" y2="17"></line><polyline points="17 7 17 17 7 17"></polyline>', "arrow-down": '<line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline>', "arrow-left-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 8 8 12 12 16"></polyline><line x1="16" y1="12" x2="8" y2="12"></line>', "arrow-left": '<line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>', "arrow-right-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 16 16 12 12 8"></polyline><line x1="8" y1="12" x2="16" y2="12"></line>', "arrow-right": '<line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline>', "arrow-up-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="16 12 12 8 8 12"></polyline><line x1="12" y1="16" x2="12" y2="8"></line>', "arrow-up-left": '<line x1="17" y1="17" x2="7" y2="7"></line><polyline points="7 17 7 7 17 7"></polyline>', "arrow-up-right": '<line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline>', "arrow-up": '<line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline>', "at-sign": '<circle cx="12" cy="12" r="4"></circle><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"></path>', award: '<circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>', "bar-chart-2": '<line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line>', "bar-chart": '<line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>', "battery-charging": '<path d="M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19"></path><line x1="23" y1="13" x2="23" y2="11"></line><polyline points="11 6 7 12 13 12 9 18"></polyline>', battery: '<rect x="1" y="6" width="18" height="12" rx="2" ry="2"></rect><line x1="23" y1="13" x2="23" y2="11"></line>', "bell-off": '<path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18.63 13A17.89 17.89 0 0 1 18 8"></path><path d="M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14"></path><path d="M18 8a6 6 0 0 0-9.33-5"></path><line x1="1" y1="1" x2="23" y2="23"></line>', bell: '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path>', bluetooth: '<polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"></polyline>', bold: '<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>', "book-open": '<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>', book: '<path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>', bookmark: '<path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>', box: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', briefcase: '<rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>', calendar: '<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>', "camera-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56"></path>', camera: '<path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle>', cast: '<path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"></path><line x1="2" y1="20" x2="2.01" y2="20"></line>', "check-circle": '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>', "check-square": '<polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>', check: '<polyline points="20 6 9 17 4 12"></polyline>', "chevron-down": '<polyline points="6 9 12 15 18 9"></polyline>', "chevron-left": '<polyline points="15 18 9 12 15 6"></polyline>', "chevron-right": '<polyline points="9 18 15 12 9 6"></polyline>', "chevron-up": '<polyline points="18 15 12 9 6 15"></polyline>', "chevrons-down": '<polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline>', "chevrons-left": '<polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline>', "chevrons-right": '<polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline>', "chevrons-up": '<polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline>', chrome: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="21.17" y1="8" x2="12" y2="8"></line><line x1="3.95" y1="6.06" x2="8.54" y2="14"></line><line x1="10.88" y1="21.94" x2="15.46" y2="14"></line>', circle: '<circle cx="12" cy="12" r="10"></circle>', clipboard: '<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>', clock: '<circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>', "cloud-drizzle": '<line x1="8" y1="19" x2="8" y2="21"></line><line x1="8" y1="13" x2="8" y2="15"></line><line x1="16" y1="19" x2="16" y2="21"></line><line x1="16" y1="13" x2="16" y2="15"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="12" y1="15" x2="12" y2="17"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-lightning": '<path d="M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9"></path><polyline points="13 11 9 17 15 17 11 23"></polyline>', "cloud-off": '<path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "cloud-rain": '<line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-snow": '<path d="M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25"></path><line x1="8" y1="16" x2="8.01" y2="16"></line><line x1="8" y1="20" x2="8.01" y2="20"></line><line x1="12" y1="18" x2="12.01" y2="18"></line><line x1="12" y1="22" x2="12.01" y2="22"></line><line x1="16" y1="16" x2="16.01" y2="16"></line><line x1="16" y1="20" x2="16.01" y2="20"></line>', cloud: '<path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>', code: '<polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline>', codepen: '<polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"></polygon><line x1="12" y1="22" x2="12" y2="15.5"></line><polyline points="22 8.5 12 15.5 2 8.5"></polyline><polyline points="2 15.5 12 8.5 22 15.5"></polyline><line x1="12" y1="2" x2="12" y2="8.5"></line>', codesandbox: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', coffee: '<path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line>', columns: '<path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>', command: '<path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>', compass: '<circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>', copy: '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>', "corner-down-left": '<polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path>', "corner-down-right": '<polyline points="15 10 20 15 15 20"></polyline><path d="M4 4v7a4 4 0 0 0 4 4h12"></path>', "corner-left-down": '<polyline points="14 15 9 20 4 15"></polyline><path d="M20 4h-7a4 4 0 0 0-4 4v12"></path>', "corner-left-up": '<polyline points="14 9 9 4 4 9"></polyline><path d="M20 20h-7a4 4 0 0 1-4-4V4"></path>', "corner-right-down": '<polyline points="10 15 15 20 20 15"></polyline><path d="M4 4h7a4 4 0 0 1 4 4v12"></path>', "corner-right-up": '<polyline points="10 9 15 4 20 9"></polyline><path d="M4 20h7a4 4 0 0 0 4-4V4"></path>', "corner-up-left": '<polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>', "corner-up-right": '<polyline points="15 14 20 9 15 4"></polyline><path d="M4 20v-7a4 4 0 0 1 4-4h12"></path>', cpu: '<rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line>', "credit-card": '<rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line>', crop: '<path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path>', crosshair: '<circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line>', database: '<ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>', delete: '<path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line>', disc: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle>', "divide-circle": '<line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line><circle cx="12" cy="12" r="10"></circle>', "divide-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line>', divide: '<circle cx="12" cy="6" r="2"></circle><line x1="5" y1="12" x2="19" y2="12"></line><circle cx="12" cy="18" r="2"></circle>', "dollar-sign": '<line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>', "download-cloud": '<polyline points="8 17 12 21 16 17"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"></path>', download: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>', dribbble: '<circle cx="12" cy="12" r="10"></circle><path d="M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32"></path>', droplet: '<path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>', "edit-2": '<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>', "edit-3": '<path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>', edit: '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>', "external-link": '<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line>', "eye-off": '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line>', eye: '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>', facebook: '<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>', "fast-forward": '<polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon>', feather: '<path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line>', figma: '<path d="M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z"></path><path d="M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z"></path><path d="M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z"></path><path d="M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z"></path><path d="M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z"></path>', "file-minus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="9" y1="15" x2="15" y2="15"></line>', "file-plus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line>', "file-text": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline>', file: '<path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>', film: '<rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line>', filter: '<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>', flag: '<path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line>', "folder-minus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="9" y1="14" x2="15" y2="14"></line>', "folder-plus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line>', folder: '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>', framer: '<path d="M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7"></path>', frown: '<circle cx="12" cy="12" r="10"></circle><path d="M16 16s-1.5-2-4-2-4 2-4 2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', gift: '<polyline points="20 12 20 22 4 22 4 12"></polyline><rect x="2" y="7" width="20" height="5"></rect><line x1="12" y1="22" x2="12" y2="7"></line><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path>', "git-branch": '<line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path>', "git-commit": '<circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line>', "git-merge": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M6 21V9a9 9 0 0 0 9 9"></path>', "git-pull-request": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M13 6h3a2 2 0 0 1 2 2v7"></path><line x1="6" y1="9" x2="6" y2="21"></line>', github: '<path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>', gitlab: '<path d="M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z"></path>', globe: '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>', grid: '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>', "hard-drive": '<line x1="22" y1="12" x2="2" y2="12"></line><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path><line x1="6" y1="16" x2="6.01" y2="16"></line><line x1="10" y1="16" x2="10.01" y2="16"></line>', hash: '<line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>', headphones: '<path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path>', heart: '<path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>', "help-circle": '<circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line>', hexagon: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>', home: '<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>', image: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>', inbox: '<polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path>', info: '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>', instagram: '<rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>', italic: '<line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line>', key: '<path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>', layers: '<polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline>', layout: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line>', "life-buoy": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>', "link-2": '<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line>', link: '<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>', linkedin: '<path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>', list: '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>', loader: '<line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>', lock: '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>', "log-in": '<path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line>', "log-out": '<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line>', mail: '<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>', "map-pin": '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle>', map: '<polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line>', "maximize-2": '<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line>', maximize: '<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>', meh: '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', menu: '<line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>', "message-circle": '<path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>', "message-square": '<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>', "mic-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', mic: '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', "minimize-2": '<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line>', minimize: '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>', "minus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="12" x2="16" y2="12"></line>', "minus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line>', minus: '<line x1="5" y1="12" x2="19" y2="12"></line>', monitor: '<rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line>', moon: '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>', "more-horizontal": '<circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle>', "more-vertical": '<circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle>', "mouse-pointer": '<path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path>', move: '<polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 9 22 12 19 15"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line>', music: '<path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle>', "navigation-2": '<polygon points="12 2 19 21 12 17 5 21 12 2"></polygon>', navigation: '<polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>', octagon: '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>', package: '<line x1="16.5" y1="9.4" x2="7.5" y2="4.21"></line><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', paperclip: '<path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>', "pause-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line>', pause: '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>', "pen-tool": '<path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle>', percent: '<line x1="19" y1="5" x2="5" y2="19"></line><circle cx="6.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="17.5" r="2.5"></circle>', "phone-call": '<path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-forwarded": '<polyline points="19 1 23 5 19 9"></polyline><line x1="15" y1="5" x2="23" y2="5"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-incoming": '<polyline points="16 2 16 8 22 8"></polyline><line x1="23" y1="1" x2="16" y2="8"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-missed": '<line x1="23" y1="1" x2="17" y2="7"></line><line x1="17" y1="1" x2="23" y2="7"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-off": '<path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><line x1="23" y1="1" x2="1" y2="23"></line>', "phone-outgoing": '<polyline points="23 7 23 1 17 1"></polyline><line x1="16" y1="8" x2="23" y2="1"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', phone: '<path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "pie-chart": '<path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path><path d="M22 12A10 10 0 0 0 12 2v10z"></path>', "play-circle": '<circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon>', play: '<polygon points="5 3 19 12 5 21 5 3"></polygon>', "plus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', "plus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', plus: '<line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>', pocket: '<path d="M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z"></path><polyline points="8 10 12 14 16 10"></polyline>', power: '<path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line>', printer: '<polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect>', radio: '<circle cx="12" cy="12" r="2"></circle><path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path>', "refresh-ccw": '<polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>', "refresh-cw": '<polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>', repeat: '<polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path>', rewind: '<polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon>', "rotate-ccw": '<polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>', "rotate-cw": '<polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>', rss: '<path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>', save: '<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline>', scissors: '<circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line>', search: '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>', send: '<line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>', server: '<rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line>', settings: '<circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>', "share-2": '<circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>', share: '<path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line>', "shield-off": '<path d="M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18"></path><path d="M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38"></path><line x1="1" y1="1" x2="23" y2="23"></line>', shield: '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>', "shopping-bag": '<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>', "shopping-cart": '<circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>', shuffle: '<polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line>', sidebar: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line>', "skip-back": '<polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line>', "skip-forward": '<polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line>', slack: '<path d="M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z"></path><path d="M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path><path d="M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z"></path><path d="M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z"></path><path d="M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z"></path><path d="M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path><path d="M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z"></path><path d="M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z"></path>', slash: '<circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>', sliders: '<line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line>', smartphone: '<rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', smile: '<circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', speaker: '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><circle cx="12" cy="14" r="4"></circle><line x1="12" y1="6" x2="12.01" y2="6"></line>', square: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>', star: '<polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>', "stop-circle": '<circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect>', sun: '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>', sunrise: '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="2" x2="12" y2="9"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="8 6 12 2 16 6"></polyline>', sunset: '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="9" x2="12" y2="2"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="16 5 12 9 8 5"></polyline>', table: '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"></path>', tablet: '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', tag: '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>', target: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>', terminal: '<polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line>', thermometer: '<path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"></path>', "thumbs-down": '<path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>', "thumbs-up": '<path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>', "toggle-left": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="8" cy="12" r="3"></circle>', "toggle-right": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="16" cy="12" r="3"></circle>', tool: '<path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>', "trash-2": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line>', trash: '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>', trello: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="9"></rect><rect x="14" y="7" width="3" height="5"></rect>', "trending-down": '<polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline><polyline points="17 18 23 18 23 12"></polyline>', "trending-up": '<polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline>', triangle: '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>', truck: '<rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle>', tv: '<rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline>', twitch: '<path d="M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7"></path>', twitter: '<path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>', type: '<polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line>', umbrella: '<path d="M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7"></path>', underline: '<path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line>', unlock: '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>', "upload-cloud": '<polyline points="16 16 12 12 8 16"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16"></polyline>', upload: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line>', "user-check": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><polyline points="17 11 19 13 23 9"></polyline>', "user-minus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="23" y1="11" x2="17" y2="11"></line>', "user-plus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line>', "user-x": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="18" y1="8" x2="23" y2="13"></line><line x1="23" y1="8" x2="18" y2="13"></line>', user: '<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>', users: '<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path>', "video-off": '<path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path><line x1="1" y1="1" x2="23" y2="23"></line>', video: '<polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>', voicemail: '<circle cx="5.5" cy="11.5" r="4.5"></circle><circle cx="18.5" cy="11.5" r="4.5"></circle><line x1="5.5" y1="16" x2="18.5" y2="16"></line>', "volume-1": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-2": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-x": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line>', volume: '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>', watch: '<circle cx="12" cy="12" r="7"></circle><polyline points="12 9 12 12 13.5 13.5"></polyline><path d="M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83"></path>', "wifi-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.58 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', wifi: '<path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', wind: '<path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>', "x-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="15"></line><line x1="15" y1="9" x2="9" y2="15"></line>', x: '<line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>', youtube: '<path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>', "zap-off": '<polyline points="12.41 6.75 13 2 10.57 4.92"></polyline><polyline points="18.57 12.91 21 10 15.66 10"></polyline><polyline points="8 8 3 14 12 14 11 22 16 16"></polyline><line x1="1" y1="1" x2="23" y2="23"></line>', zap: '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>', "zoom-in": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line>', "zoom-out": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line>' };
          }
        ),
        /***/
        "./node_modules/classnames/dedupe.js": (
          /*!*******************************************!*\
            !*** ./node_modules/classnames/dedupe.js ***!
            \*******************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a, o;
            /*!
              Copyright (c) 2016 Jed Watson.
              Licensed under the MIT License (MIT), see
              http://jedwatson.github.io/classnames
            */
            (function() {
              var s = function() {
                function l() {
                }
                l.prototype = /* @__PURE__ */ Object.create(null);
                function u(g, y) {
                  for (var b = y.length, _ = 0; _ < b; ++_)
                    v(g, y[_]);
                }
                var c = {}.hasOwnProperty;
                function d(g, y) {
                  g[y] = !0;
                }
                function f(g, y) {
                  for (var b in y)
                    c.call(y, b) && (g[b] = !!y[b]);
                }
                var p = /\s+/;
                function h(g, y) {
                  for (var b = y.split(p), _ = b.length, x = 0; x < _; ++x)
                    g[b[x]] = !0;
                }
                function v(g, y) {
                  if (y) {
                    var b = typeof y;
                    b === "string" ? h(g, y) : Array.isArray(y) ? u(g, y) : b === "object" ? f(g, y) : b === "number" && d(g, y);
                  }
                }
                function m() {
                  for (var g = arguments.length, y = Array(g), b = 0; b < g; b++)
                    y[b] = arguments[b];
                  var _ = new l();
                  u(_, y);
                  var x = [];
                  for (var w in _)
                    _[w] && x.push(w);
                  return x.join(" ");
                }
                return m;
              }();
              typeof t < "u" && t.exports ? t.exports = s : (a = [], o = (function() {
                return s;
              }).apply(r, a), o !== void 0 && (t.exports = o));
            })();
          }
        ),
        /***/
        "./node_modules/core-js/es/array/from.js": (
          /*!***********************************************!*\
            !*** ./node_modules/core-js/es/array/from.js ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            i(
              /*! ../../modules/es.string.iterator */
              "./node_modules/core-js/modules/es.string.iterator.js"
            ), i(
              /*! ../../modules/es.array.from */
              "./node_modules/core-js/modules/es.array.from.js"
            );
            var a = i(
              /*! ../../internals/path */
              "./node_modules/core-js/internals/path.js"
            );
            t.exports = a.Array.from;
          }
        ),
        /***/
        "./node_modules/core-js/internals/a-function.js": (
          /*!******************************************************!*\
            !*** ./node_modules/core-js/internals/a-function.js ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            t.exports = function(i) {
              if (typeof i != "function")
                throw TypeError(String(i) + " is not a function");
              return i;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/an-object.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/an-object.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/is-object */
              "./node_modules/core-js/internals/is-object.js"
            );
            t.exports = function(o) {
              if (!a(o))
                throw TypeError(String(o) + " is not an object");
              return o;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/array-from.js": (
          /*!******************************************************!*\
            !*** ./node_modules/core-js/internals/array-from.js ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/bind-context */
              "./node_modules/core-js/internals/bind-context.js"
            ), o = i(
              /*! ../internals/to-object */
              "./node_modules/core-js/internals/to-object.js"
            ), s = i(
              /*! ../internals/call-with-safe-iteration-closing */
              "./node_modules/core-js/internals/call-with-safe-iteration-closing.js"
            ), l = i(
              /*! ../internals/is-array-iterator-method */
              "./node_modules/core-js/internals/is-array-iterator-method.js"
            ), u = i(
              /*! ../internals/to-length */
              "./node_modules/core-js/internals/to-length.js"
            ), c = i(
              /*! ../internals/create-property */
              "./node_modules/core-js/internals/create-property.js"
            ), d = i(
              /*! ../internals/get-iterator-method */
              "./node_modules/core-js/internals/get-iterator-method.js"
            );
            t.exports = function(p) {
              var h = o(p), v = typeof this == "function" ? this : Array, m = arguments.length, g = m > 1 ? arguments[1] : void 0, y = g !== void 0, b = 0, _ = d(h), x, w, S, C;
              if (y && (g = a(g, m > 2 ? arguments[2] : void 0, 2)), _ != null && !(v == Array && l(_)))
                for (C = _.call(h), w = new v(); !(S = C.next()).done; b++)
                  c(
                    w,
                    b,
                    y ? s(C, g, [S.value, b], !0) : S.value
                  );
              else
                for (x = u(h.length), w = new v(x); x > b; b++)
                  c(w, b, y ? g(h[b], b) : h[b]);
              return w.length = b, w;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/array-includes.js": (
          /*!**********************************************************!*\
            !*** ./node_modules/core-js/internals/array-includes.js ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/to-indexed-object */
              "./node_modules/core-js/internals/to-indexed-object.js"
            ), o = i(
              /*! ../internals/to-length */
              "./node_modules/core-js/internals/to-length.js"
            ), s = i(
              /*! ../internals/to-absolute-index */
              "./node_modules/core-js/internals/to-absolute-index.js"
            );
            t.exports = function(l) {
              return function(u, c, d) {
                var f = a(u), p = o(f.length), h = s(d, p), v;
                if (l && c != c) {
                  for (; p > h; )
                    if (v = f[h++], v != v) return !0;
                } else for (; p > h; h++) if ((l || h in f) && f[h] === c)
                  return l || h || 0;
                return !l && -1;
              };
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/bind-context.js": (
          /*!********************************************************!*\
            !*** ./node_modules/core-js/internals/bind-context.js ***!
            \********************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/a-function */
              "./node_modules/core-js/internals/a-function.js"
            );
            t.exports = function(o, s, l) {
              if (a(o), s === void 0) return o;
              switch (l) {
                case 0:
                  return function() {
                    return o.call(s);
                  };
                case 1:
                  return function(u) {
                    return o.call(s, u);
                  };
                case 2:
                  return function(u, c) {
                    return o.call(s, u, c);
                  };
                case 3:
                  return function(u, c, d) {
                    return o.call(s, u, c, d);
                  };
              }
              return function() {
                return o.apply(s, arguments);
              };
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/call-with-safe-iteration-closing.js": (
          /*!****************************************************************************!*\
            !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
            \****************************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/an-object */
              "./node_modules/core-js/internals/an-object.js"
            );
            t.exports = function(o, s, l, u) {
              try {
                return u ? s(a(l)[0], l[1]) : s(l);
              } catch (d) {
                var c = o.return;
                throw c !== void 0 && a(c.call(o)), d;
              }
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/check-correctness-of-iteration.js": (
          /*!**************************************************************************!*\
            !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
            \**************************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            ), o = a("iterator"), s = !1;
            try {
              var l = 0, u = {
                next: function() {
                  return { done: !!l++ };
                },
                return: function() {
                  s = !0;
                }
              };
              u[o] = function() {
                return this;
              }, Array.from(u, function() {
                throw 2;
              });
            } catch {
            }
            t.exports = function(c, d) {
              if (!d && !s) return !1;
              var f = !1;
              try {
                var p = {};
                p[o] = function() {
                  return {
                    next: function() {
                      return { done: f = !0 };
                    }
                  };
                }, c(p);
              } catch {
              }
              return f;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/classof-raw.js": (
          /*!*******************************************************!*\
            !*** ./node_modules/core-js/internals/classof-raw.js ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            var i = {}.toString;
            t.exports = function(a) {
              return i.call(a).slice(8, -1);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/classof.js": (
          /*!***************************************************!*\
            !*** ./node_modules/core-js/internals/classof.js ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/classof-raw */
              "./node_modules/core-js/internals/classof-raw.js"
            ), o = i(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            ), s = o("toStringTag"), l = a(/* @__PURE__ */ function() {
              return arguments;
            }()) == "Arguments", u = function(c, d) {
              try {
                return c[d];
              } catch {
              }
            };
            t.exports = function(c) {
              var d, f, p;
              return c === void 0 ? "Undefined" : c === null ? "Null" : typeof (f = u(d = Object(c), s)) == "string" ? f : l ? a(d) : (p = a(d)) == "Object" && typeof d.callee == "function" ? "Arguments" : p;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/copy-constructor-properties.js": (
          /*!***********************************************************************!*\
            !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
            \***********************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            ), o = i(
              /*! ../internals/own-keys */
              "./node_modules/core-js/internals/own-keys.js"
            ), s = i(
              /*! ../internals/object-get-own-property-descriptor */
              "./node_modules/core-js/internals/object-get-own-property-descriptor.js"
            ), l = i(
              /*! ../internals/object-define-property */
              "./node_modules/core-js/internals/object-define-property.js"
            );
            t.exports = function(u, c) {
              for (var d = o(c), f = l.f, p = s.f, h = 0; h < d.length; h++) {
                var v = d[h];
                a(u, v) || f(u, v, p(c, v));
              }
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/correct-prototype-getter.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
            \********************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/fails */
              "./node_modules/core-js/internals/fails.js"
            );
            t.exports = !a(function() {
              function o() {
              }
              return o.prototype.constructor = null, Object.getPrototypeOf(new o()) !== o.prototype;
            });
          }
        ),
        /***/
        "./node_modules/core-js/internals/create-iterator-constructor.js": (
          /*!***********************************************************************!*\
            !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
            \***********************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/iterators-core */
              "./node_modules/core-js/internals/iterators-core.js"
            ).IteratorPrototype, o = i(
              /*! ../internals/object-create */
              "./node_modules/core-js/internals/object-create.js"
            ), s = i(
              /*! ../internals/create-property-descriptor */
              "./node_modules/core-js/internals/create-property-descriptor.js"
            ), l = i(
              /*! ../internals/set-to-string-tag */
              "./node_modules/core-js/internals/set-to-string-tag.js"
            ), u = i(
              /*! ../internals/iterators */
              "./node_modules/core-js/internals/iterators.js"
            ), c = function() {
              return this;
            };
            t.exports = function(d, f, p) {
              var h = f + " Iterator";
              return d.prototype = o(a, { next: s(1, p) }), l(d, h, !1, !0), u[h] = c, d;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/create-property-descriptor.js": (
          /*!**********************************************************************!*\
            !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
            \**********************************************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            t.exports = function(i, a) {
              return {
                enumerable: !(i & 1),
                configurable: !(i & 2),
                writable: !(i & 4),
                value: a
              };
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/create-property.js": (
          /*!***********************************************************!*\
            !*** ./node_modules/core-js/internals/create-property.js ***!
            \***********************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/to-primitive */
              "./node_modules/core-js/internals/to-primitive.js"
            ), o = i(
              /*! ../internals/object-define-property */
              "./node_modules/core-js/internals/object-define-property.js"
            ), s = i(
              /*! ../internals/create-property-descriptor */
              "./node_modules/core-js/internals/create-property-descriptor.js"
            );
            t.exports = function(l, u, c) {
              var d = a(u);
              d in l ? o.f(l, d, s(0, c)) : l[d] = c;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/define-iterator.js": (
          /*!***********************************************************!*\
            !*** ./node_modules/core-js/internals/define-iterator.js ***!
            \***********************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/export */
              "./node_modules/core-js/internals/export.js"
            ), o = i(
              /*! ../internals/create-iterator-constructor */
              "./node_modules/core-js/internals/create-iterator-constructor.js"
            ), s = i(
              /*! ../internals/object-get-prototype-of */
              "./node_modules/core-js/internals/object-get-prototype-of.js"
            ), l = i(
              /*! ../internals/object-set-prototype-of */
              "./node_modules/core-js/internals/object-set-prototype-of.js"
            ), u = i(
              /*! ../internals/set-to-string-tag */
              "./node_modules/core-js/internals/set-to-string-tag.js"
            ), c = i(
              /*! ../internals/hide */
              "./node_modules/core-js/internals/hide.js"
            ), d = i(
              /*! ../internals/redefine */
              "./node_modules/core-js/internals/redefine.js"
            ), f = i(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            ), p = i(
              /*! ../internals/is-pure */
              "./node_modules/core-js/internals/is-pure.js"
            ), h = i(
              /*! ../internals/iterators */
              "./node_modules/core-js/internals/iterators.js"
            ), v = i(
              /*! ../internals/iterators-core */
              "./node_modules/core-js/internals/iterators-core.js"
            ), m = v.IteratorPrototype, g = v.BUGGY_SAFARI_ITERATORS, y = f("iterator"), b = "keys", _ = "values", x = "entries", w = function() {
              return this;
            };
            t.exports = function(S, C, k, M, D, N, R) {
              o(k, C, M);
              var j = function(ye) {
                if (ye === D && Y) return Y;
                if (!g && ye in B) return B[ye];
                switch (ye) {
                  case b:
                    return function() {
                      return new k(this, ye);
                    };
                  case _:
                    return function() {
                      return new k(this, ye);
                    };
                  case x:
                    return function() {
                      return new k(this, ye);
                    };
                }
                return function() {
                  return new k(this);
                };
              }, z = C + " Iterator", F = !1, B = S.prototype, H = B[y] || B["@@iterator"] || D && B[D], Y = !g && H || j(D), ne = C == "Array" && B.entries || H, J, X, ie;
              if (ne && (J = s(ne.call(new S())), m !== Object.prototype && J.next && (!p && s(J) !== m && (l ? l(J, m) : typeof J[y] != "function" && c(J, y, w)), u(J, z, !0, !0), p && (h[z] = w))), D == _ && H && H.name !== _ && (F = !0, Y = function() {
                return H.call(this);
              }), (!p || R) && B[y] !== Y && c(B, y, Y), h[C] = Y, D)
                if (X = {
                  values: j(_),
                  keys: N ? Y : j(b),
                  entries: j(x)
                }, R) for (ie in X)
                  (g || F || !(ie in B)) && d(B, ie, X[ie]);
                else a({ target: C, proto: !0, forced: g || F }, X);
              return X;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/descriptors.js": (
          /*!*******************************************************!*\
            !*** ./node_modules/core-js/internals/descriptors.js ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/fails */
              "./node_modules/core-js/internals/fails.js"
            );
            t.exports = !a(function() {
              return Object.defineProperty({}, "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          }
        ),
        /***/
        "./node_modules/core-js/internals/document-create-element.js": (
          /*!*******************************************************************!*\
            !*** ./node_modules/core-js/internals/document-create-element.js ***!
            \*******************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            ), o = i(
              /*! ../internals/is-object */
              "./node_modules/core-js/internals/is-object.js"
            ), s = a.document, l = o(s) && o(s.createElement);
            t.exports = function(u) {
              return l ? s.createElement(u) : {};
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/enum-bug-keys.js": (
          /*!*********************************************************!*\
            !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
            \*********************************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            t.exports = [
              "constructor",
              "hasOwnProperty",
              "isPrototypeOf",
              "propertyIsEnumerable",
              "toLocaleString",
              "toString",
              "valueOf"
            ];
          }
        ),
        /***/
        "./node_modules/core-js/internals/export.js": (
          /*!**************************************************!*\
            !*** ./node_modules/core-js/internals/export.js ***!
            \**************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            ), o = i(
              /*! ../internals/object-get-own-property-descriptor */
              "./node_modules/core-js/internals/object-get-own-property-descriptor.js"
            ).f, s = i(
              /*! ../internals/hide */
              "./node_modules/core-js/internals/hide.js"
            ), l = i(
              /*! ../internals/redefine */
              "./node_modules/core-js/internals/redefine.js"
            ), u = i(
              /*! ../internals/set-global */
              "./node_modules/core-js/internals/set-global.js"
            ), c = i(
              /*! ../internals/copy-constructor-properties */
              "./node_modules/core-js/internals/copy-constructor-properties.js"
            ), d = i(
              /*! ../internals/is-forced */
              "./node_modules/core-js/internals/is-forced.js"
            );
            t.exports = function(f, p) {
              var h = f.target, v = f.global, m = f.stat, g, y, b, _, x, w;
              if (v ? y = a : m ? y = a[h] || u(h, {}) : y = (a[h] || {}).prototype, y) for (b in p) {
                if (x = p[b], f.noTargetGet ? (w = o(y, b), _ = w && w.value) : _ = y[b], g = d(v ? b : h + (m ? "." : "#") + b, f.forced), !g && _ !== void 0) {
                  if (typeof x == typeof _) continue;
                  c(x, _);
                }
                (f.sham || _ && _.sham) && s(x, "sham", !0), l(y, b, x, f);
              }
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/fails.js": (
          /*!*************************************************!*\
            !*** ./node_modules/core-js/internals/fails.js ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            t.exports = function(i) {
              try {
                return !!i();
              } catch {
                return !0;
              }
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/function-to-string.js": (
          /*!**************************************************************!*\
            !*** ./node_modules/core-js/internals/function-to-string.js ***!
            \**************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/shared */
              "./node_modules/core-js/internals/shared.js"
            );
            t.exports = a("native-function-to-string", Function.toString);
          }
        ),
        /***/
        "./node_modules/core-js/internals/get-iterator-method.js": (
          /*!***************************************************************!*\
            !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
            \***************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/classof */
              "./node_modules/core-js/internals/classof.js"
            ), o = i(
              /*! ../internals/iterators */
              "./node_modules/core-js/internals/iterators.js"
            ), s = i(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            ), l = s("iterator");
            t.exports = function(u) {
              if (u != null) return u[l] || u["@@iterator"] || o[a(u)];
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/global.js": (
          /*!**************************************************!*\
            !*** ./node_modules/core-js/internals/global.js ***!
            \**************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            (function(a) {
              var o = "object", s = function(l) {
                return l && l.Math == Math && l;
              };
              t.exports = // eslint-disable-next-line no-undef
              s(typeof globalThis == o && globalThis) || s(typeof window == o && window) || s(typeof self == o && self) || s(typeof a == o && a) || // eslint-disable-next-line no-new-func
              Function("return this")();
            }).call(this, i(
              /*! ./../../webpack/buildin/global.js */
              "./node_modules/webpack/buildin/global.js"
            ));
          }
        ),
        /***/
        "./node_modules/core-js/internals/has.js": (
          /*!***********************************************!*\
            !*** ./node_modules/core-js/internals/has.js ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            var i = {}.hasOwnProperty;
            t.exports = function(a, o) {
              return i.call(a, o);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/hidden-keys.js": (
          /*!*******************************************************!*\
            !*** ./node_modules/core-js/internals/hidden-keys.js ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            t.exports = {};
          }
        ),
        /***/
        "./node_modules/core-js/internals/hide.js": (
          /*!************************************************!*\
            !*** ./node_modules/core-js/internals/hide.js ***!
            \************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/descriptors */
              "./node_modules/core-js/internals/descriptors.js"
            ), o = i(
              /*! ../internals/object-define-property */
              "./node_modules/core-js/internals/object-define-property.js"
            ), s = i(
              /*! ../internals/create-property-descriptor */
              "./node_modules/core-js/internals/create-property-descriptor.js"
            );
            t.exports = a ? function(l, u, c) {
              return o.f(l, u, s(1, c));
            } : function(l, u, c) {
              return l[u] = c, l;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/html.js": (
          /*!************************************************!*\
            !*** ./node_modules/core-js/internals/html.js ***!
            \************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            ), o = a.document;
            t.exports = o && o.documentElement;
          }
        ),
        /***/
        "./node_modules/core-js/internals/ie8-dom-define.js": (
          /*!**********************************************************!*\
            !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/descriptors */
              "./node_modules/core-js/internals/descriptors.js"
            ), o = i(
              /*! ../internals/fails */
              "./node_modules/core-js/internals/fails.js"
            ), s = i(
              /*! ../internals/document-create-element */
              "./node_modules/core-js/internals/document-create-element.js"
            );
            t.exports = !a && !o(function() {
              return Object.defineProperty(s("div"), "a", {
                get: function() {
                  return 7;
                }
              }).a != 7;
            });
          }
        ),
        /***/
        "./node_modules/core-js/internals/indexed-object.js": (
          /*!**********************************************************!*\
            !*** ./node_modules/core-js/internals/indexed-object.js ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/fails */
              "./node_modules/core-js/internals/fails.js"
            ), o = i(
              /*! ../internals/classof-raw */
              "./node_modules/core-js/internals/classof-raw.js"
            ), s = "".split;
            t.exports = a(function() {
              return !Object("z").propertyIsEnumerable(0);
            }) ? function(l) {
              return o(l) == "String" ? s.call(l, "") : Object(l);
            } : Object;
          }
        ),
        /***/
        "./node_modules/core-js/internals/internal-state.js": (
          /*!**********************************************************!*\
            !*** ./node_modules/core-js/internals/internal-state.js ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/native-weak-map */
              "./node_modules/core-js/internals/native-weak-map.js"
            ), o = i(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            ), s = i(
              /*! ../internals/is-object */
              "./node_modules/core-js/internals/is-object.js"
            ), l = i(
              /*! ../internals/hide */
              "./node_modules/core-js/internals/hide.js"
            ), u = i(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            ), c = i(
              /*! ../internals/shared-key */
              "./node_modules/core-js/internals/shared-key.js"
            ), d = i(
              /*! ../internals/hidden-keys */
              "./node_modules/core-js/internals/hidden-keys.js"
            ), f = o.WeakMap, p, h, v, m = function(S) {
              return v(S) ? h(S) : p(S, {});
            }, g = function(S) {
              return function(C) {
                var k;
                if (!s(C) || (k = h(C)).type !== S)
                  throw TypeError("Incompatible receiver, " + S + " required");
                return k;
              };
            };
            if (a) {
              var y = new f(), b = y.get, _ = y.has, x = y.set;
              p = function(S, C) {
                return x.call(y, S, C), C;
              }, h = function(S) {
                return b.call(y, S) || {};
              }, v = function(S) {
                return _.call(y, S);
              };
            } else {
              var w = c("state");
              d[w] = !0, p = function(S, C) {
                return l(S, w, C), C;
              }, h = function(S) {
                return u(S, w) ? S[w] : {};
              }, v = function(S) {
                return u(S, w);
              };
            }
            t.exports = {
              set: p,
              get: h,
              has: v,
              enforce: m,
              getterFor: g
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/is-array-iterator-method.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
            \********************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            ), o = i(
              /*! ../internals/iterators */
              "./node_modules/core-js/internals/iterators.js"
            ), s = a("iterator"), l = Array.prototype;
            t.exports = function(u) {
              return u !== void 0 && (o.Array === u || l[s] === u);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/is-forced.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/is-forced.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/fails */
              "./node_modules/core-js/internals/fails.js"
            ), o = /#|\.prototype\./, s = function(f, p) {
              var h = u[l(f)];
              return h == d ? !0 : h == c ? !1 : typeof p == "function" ? a(p) : !!p;
            }, l = s.normalize = function(f) {
              return String(f).replace(o, ".").toLowerCase();
            }, u = s.data = {}, c = s.NATIVE = "N", d = s.POLYFILL = "P";
            t.exports = s;
          }
        ),
        /***/
        "./node_modules/core-js/internals/is-object.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/is-object.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            t.exports = function(i) {
              return typeof i == "object" ? i !== null : typeof i == "function";
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/is-pure.js": (
          /*!***************************************************!*\
            !*** ./node_modules/core-js/internals/is-pure.js ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            t.exports = !1;
          }
        ),
        /***/
        "./node_modules/core-js/internals/iterators-core.js": (
          /*!**********************************************************!*\
            !*** ./node_modules/core-js/internals/iterators-core.js ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/object-get-prototype-of */
              "./node_modules/core-js/internals/object-get-prototype-of.js"
            ), o = i(
              /*! ../internals/hide */
              "./node_modules/core-js/internals/hide.js"
            ), s = i(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            ), l = i(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            ), u = i(
              /*! ../internals/is-pure */
              "./node_modules/core-js/internals/is-pure.js"
            ), c = l("iterator"), d = !1, f = function() {
              return this;
            }, p, h, v;
            [].keys && (v = [].keys(), "next" in v ? (h = a(a(v)), h !== Object.prototype && (p = h)) : d = !0), p == null && (p = {}), !u && !s(p, c) && o(p, c, f), t.exports = {
              IteratorPrototype: p,
              BUGGY_SAFARI_ITERATORS: d
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/iterators.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/iterators.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            t.exports = {};
          }
        ),
        /***/
        "./node_modules/core-js/internals/native-symbol.js": (
          /*!*********************************************************!*\
            !*** ./node_modules/core-js/internals/native-symbol.js ***!
            \*********************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/fails */
              "./node_modules/core-js/internals/fails.js"
            );
            t.exports = !!Object.getOwnPropertySymbols && !a(function() {
              return !String(Symbol());
            });
          }
        ),
        /***/
        "./node_modules/core-js/internals/native-weak-map.js": (
          /*!***********************************************************!*\
            !*** ./node_modules/core-js/internals/native-weak-map.js ***!
            \***********************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            ), o = i(
              /*! ../internals/function-to-string */
              "./node_modules/core-js/internals/function-to-string.js"
            ), s = a.WeakMap;
            t.exports = typeof s == "function" && /native code/.test(o.call(s));
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-create.js": (
          /*!*********************************************************!*\
            !*** ./node_modules/core-js/internals/object-create.js ***!
            \*********************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/an-object */
              "./node_modules/core-js/internals/an-object.js"
            ), o = i(
              /*! ../internals/object-define-properties */
              "./node_modules/core-js/internals/object-define-properties.js"
            ), s = i(
              /*! ../internals/enum-bug-keys */
              "./node_modules/core-js/internals/enum-bug-keys.js"
            ), l = i(
              /*! ../internals/hidden-keys */
              "./node_modules/core-js/internals/hidden-keys.js"
            ), u = i(
              /*! ../internals/html */
              "./node_modules/core-js/internals/html.js"
            ), c = i(
              /*! ../internals/document-create-element */
              "./node_modules/core-js/internals/document-create-element.js"
            ), d = i(
              /*! ../internals/shared-key */
              "./node_modules/core-js/internals/shared-key.js"
            ), f = d("IE_PROTO"), p = "prototype", h = function() {
            }, v = function() {
              var m = c("iframe"), g = s.length, y = "<", b = "script", _ = ">", x = "java" + b + ":", w;
              for (m.style.display = "none", u.appendChild(m), m.src = String(x), w = m.contentWindow.document, w.open(), w.write(y + b + _ + "document.F=Object" + y + "/" + b + _), w.close(), v = w.F; g--; ) delete v[p][s[g]];
              return v();
            };
            t.exports = Object.create || function(g, y) {
              var b;
              return g !== null ? (h[p] = a(g), b = new h(), h[p] = null, b[f] = g) : b = v(), y === void 0 ? b : o(b, y);
            }, l[f] = !0;
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-define-properties.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/core-js/internals/object-define-properties.js ***!
            \********************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/descriptors */
              "./node_modules/core-js/internals/descriptors.js"
            ), o = i(
              /*! ../internals/object-define-property */
              "./node_modules/core-js/internals/object-define-property.js"
            ), s = i(
              /*! ../internals/an-object */
              "./node_modules/core-js/internals/an-object.js"
            ), l = i(
              /*! ../internals/object-keys */
              "./node_modules/core-js/internals/object-keys.js"
            );
            t.exports = a ? Object.defineProperties : function(c, d) {
              s(c);
              for (var f = l(d), p = f.length, h = 0, v; p > h; ) o.f(c, v = f[h++], d[v]);
              return c;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-define-property.js": (
          /*!******************************************************************!*\
            !*** ./node_modules/core-js/internals/object-define-property.js ***!
            \******************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/descriptors */
              "./node_modules/core-js/internals/descriptors.js"
            ), o = i(
              /*! ../internals/ie8-dom-define */
              "./node_modules/core-js/internals/ie8-dom-define.js"
            ), s = i(
              /*! ../internals/an-object */
              "./node_modules/core-js/internals/an-object.js"
            ), l = i(
              /*! ../internals/to-primitive */
              "./node_modules/core-js/internals/to-primitive.js"
            ), u = Object.defineProperty;
            r.f = a ? u : function(d, f, p) {
              if (s(d), f = l(f, !0), s(p), o) try {
                return u(d, f, p);
              } catch {
              }
              if ("get" in p || "set" in p) throw TypeError("Accessors not supported");
              return "value" in p && (d[f] = p.value), d;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-get-own-property-descriptor.js": (
          /*!******************************************************************************!*\
            !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
            \******************************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/descriptors */
              "./node_modules/core-js/internals/descriptors.js"
            ), o = i(
              /*! ../internals/object-property-is-enumerable */
              "./node_modules/core-js/internals/object-property-is-enumerable.js"
            ), s = i(
              /*! ../internals/create-property-descriptor */
              "./node_modules/core-js/internals/create-property-descriptor.js"
            ), l = i(
              /*! ../internals/to-indexed-object */
              "./node_modules/core-js/internals/to-indexed-object.js"
            ), u = i(
              /*! ../internals/to-primitive */
              "./node_modules/core-js/internals/to-primitive.js"
            ), c = i(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            ), d = i(
              /*! ../internals/ie8-dom-define */
              "./node_modules/core-js/internals/ie8-dom-define.js"
            ), f = Object.getOwnPropertyDescriptor;
            r.f = a ? f : function(h, v) {
              if (h = l(h), v = u(v, !0), d) try {
                return f(h, v);
              } catch {
              }
              if (c(h, v)) return s(!o.f.call(h, v), h[v]);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-get-own-property-names.js": (
          /*!*************************************************************************!*\
            !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
            \*************************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/object-keys-internal */
              "./node_modules/core-js/internals/object-keys-internal.js"
            ), o = i(
              /*! ../internals/enum-bug-keys */
              "./node_modules/core-js/internals/enum-bug-keys.js"
            ), s = o.concat("length", "prototype");
            r.f = Object.getOwnPropertyNames || function(u) {
              return a(u, s);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-get-own-property-symbols.js": (
          /*!***************************************************************************!*\
            !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
            \***************************************************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            r.f = Object.getOwnPropertySymbols;
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-get-prototype-of.js": (
          /*!*******************************************************************!*\
            !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
            \*******************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            ), o = i(
              /*! ../internals/to-object */
              "./node_modules/core-js/internals/to-object.js"
            ), s = i(
              /*! ../internals/shared-key */
              "./node_modules/core-js/internals/shared-key.js"
            ), l = i(
              /*! ../internals/correct-prototype-getter */
              "./node_modules/core-js/internals/correct-prototype-getter.js"
            ), u = s("IE_PROTO"), c = Object.prototype;
            t.exports = l ? Object.getPrototypeOf : function(d) {
              return d = o(d), a(d, u) ? d[u] : typeof d.constructor == "function" && d instanceof d.constructor ? d.constructor.prototype : d instanceof Object ? c : null;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-keys-internal.js": (
          /*!****************************************************************!*\
            !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
            \****************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            ), o = i(
              /*! ../internals/to-indexed-object */
              "./node_modules/core-js/internals/to-indexed-object.js"
            ), s = i(
              /*! ../internals/array-includes */
              "./node_modules/core-js/internals/array-includes.js"
            ), l = i(
              /*! ../internals/hidden-keys */
              "./node_modules/core-js/internals/hidden-keys.js"
            ), u = s(!1);
            t.exports = function(c, d) {
              var f = o(c), p = 0, h = [], v;
              for (v in f) !a(l, v) && a(f, v) && h.push(v);
              for (; d.length > p; ) a(f, v = d[p++]) && (~u(h, v) || h.push(v));
              return h;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-keys.js": (
          /*!*******************************************************!*\
            !*** ./node_modules/core-js/internals/object-keys.js ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/object-keys-internal */
              "./node_modules/core-js/internals/object-keys-internal.js"
            ), o = i(
              /*! ../internals/enum-bug-keys */
              "./node_modules/core-js/internals/enum-bug-keys.js"
            );
            t.exports = Object.keys || function(l) {
              return a(l, o);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-property-is-enumerable.js": (
          /*!*************************************************************************!*\
            !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
            \*************************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = {}.propertyIsEnumerable, o = Object.getOwnPropertyDescriptor, s = o && !a.call({ 1: 2 }, 1);
            r.f = s ? function(u) {
              var c = o(this, u);
              return !!c && c.enumerable;
            } : a;
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-set-prototype-of.js": (
          /*!*******************************************************************!*\
            !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
            \*******************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/validate-set-prototype-of-arguments */
              "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js"
            );
            t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
              var o = !1, s = {}, l;
              try {
                l = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set, l.call(s, []), o = s instanceof Array;
              } catch {
              }
              return function(c, d) {
                return a(c, d), o ? l.call(c, d) : c.__proto__ = d, c;
              };
            }() : void 0);
          }
        ),
        /***/
        "./node_modules/core-js/internals/own-keys.js": (
          /*!****************************************************!*\
            !*** ./node_modules/core-js/internals/own-keys.js ***!
            \****************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            ), o = i(
              /*! ../internals/object-get-own-property-names */
              "./node_modules/core-js/internals/object-get-own-property-names.js"
            ), s = i(
              /*! ../internals/object-get-own-property-symbols */
              "./node_modules/core-js/internals/object-get-own-property-symbols.js"
            ), l = i(
              /*! ../internals/an-object */
              "./node_modules/core-js/internals/an-object.js"
            ), u = a.Reflect;
            t.exports = u && u.ownKeys || function(d) {
              var f = o.f(l(d)), p = s.f;
              return p ? f.concat(p(d)) : f;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/path.js": (
          /*!************************************************!*\
            !*** ./node_modules/core-js/internals/path.js ***!
            \************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            t.exports = i(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            );
          }
        ),
        /***/
        "./node_modules/core-js/internals/redefine.js": (
          /*!****************************************************!*\
            !*** ./node_modules/core-js/internals/redefine.js ***!
            \****************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            ), o = i(
              /*! ../internals/shared */
              "./node_modules/core-js/internals/shared.js"
            ), s = i(
              /*! ../internals/hide */
              "./node_modules/core-js/internals/hide.js"
            ), l = i(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            ), u = i(
              /*! ../internals/set-global */
              "./node_modules/core-js/internals/set-global.js"
            ), c = i(
              /*! ../internals/function-to-string */
              "./node_modules/core-js/internals/function-to-string.js"
            ), d = i(
              /*! ../internals/internal-state */
              "./node_modules/core-js/internals/internal-state.js"
            ), f = d.get, p = d.enforce, h = String(c).split("toString");
            o("inspectSource", function(v) {
              return c.call(v);
            }), (t.exports = function(v, m, g, y) {
              var b = y ? !!y.unsafe : !1, _ = y ? !!y.enumerable : !1, x = y ? !!y.noTargetGet : !1;
              if (typeof g == "function" && (typeof m == "string" && !l(g, "name") && s(g, "name", m), p(g).source = h.join(typeof m == "string" ? m : "")), v === a) {
                _ ? v[m] = g : u(m, g);
                return;
              } else b ? !x && v[m] && (_ = !0) : delete v[m];
              _ ? v[m] = g : s(v, m, g);
            })(Function.prototype, "toString", function() {
              return typeof this == "function" && f(this).source || c.call(this);
            });
          }
        ),
        /***/
        "./node_modules/core-js/internals/require-object-coercible.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
            \********************************************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            t.exports = function(i) {
              if (i == null) throw TypeError("Can't call method on " + i);
              return i;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/set-global.js": (
          /*!******************************************************!*\
            !*** ./node_modules/core-js/internals/set-global.js ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            ), o = i(
              /*! ../internals/hide */
              "./node_modules/core-js/internals/hide.js"
            );
            t.exports = function(s, l) {
              try {
                o(a, s, l);
              } catch {
                a[s] = l;
              }
              return l;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/set-to-string-tag.js": (
          /*!*************************************************************!*\
            !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/object-define-property */
              "./node_modules/core-js/internals/object-define-property.js"
            ).f, o = i(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            ), s = i(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            ), l = s("toStringTag");
            t.exports = function(u, c, d) {
              u && !o(u = d ? u : u.prototype, l) && a(u, l, { configurable: !0, value: c });
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/shared-key.js": (
          /*!******************************************************!*\
            !*** ./node_modules/core-js/internals/shared-key.js ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/shared */
              "./node_modules/core-js/internals/shared.js"
            ), o = i(
              /*! ../internals/uid */
              "./node_modules/core-js/internals/uid.js"
            ), s = a("keys");
            t.exports = function(l) {
              return s[l] || (s[l] = o(l));
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/shared.js": (
          /*!**************************************************!*\
            !*** ./node_modules/core-js/internals/shared.js ***!
            \**************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            ), o = i(
              /*! ../internals/set-global */
              "./node_modules/core-js/internals/set-global.js"
            ), s = i(
              /*! ../internals/is-pure */
              "./node_modules/core-js/internals/is-pure.js"
            ), l = "__core-js_shared__", u = a[l] || o(l, {});
            (t.exports = function(c, d) {
              return u[c] || (u[c] = d !== void 0 ? d : {});
            })("versions", []).push({
              version: "3.1.3",
              mode: s ? "pure" : "global",
              copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
            });
          }
        ),
        /***/
        "./node_modules/core-js/internals/string-at.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/string-at.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/to-integer */
              "./node_modules/core-js/internals/to-integer.js"
            ), o = i(
              /*! ../internals/require-object-coercible */
              "./node_modules/core-js/internals/require-object-coercible.js"
            );
            t.exports = function(s, l, u) {
              var c = String(o(s)), d = a(l), f = c.length, p, h;
              return d < 0 || d >= f ? u ? "" : void 0 : (p = c.charCodeAt(d), p < 55296 || p > 56319 || d + 1 === f || (h = c.charCodeAt(d + 1)) < 56320 || h > 57343 ? u ? c.charAt(d) : p : u ? c.slice(d, d + 2) : (p - 55296 << 10) + (h - 56320) + 65536);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/to-absolute-index.js": (
          /*!*************************************************************!*\
            !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/to-integer */
              "./node_modules/core-js/internals/to-integer.js"
            ), o = Math.max, s = Math.min;
            t.exports = function(l, u) {
              var c = a(l);
              return c < 0 ? o(c + u, 0) : s(c, u);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/to-indexed-object.js": (
          /*!*************************************************************!*\
            !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/indexed-object */
              "./node_modules/core-js/internals/indexed-object.js"
            ), o = i(
              /*! ../internals/require-object-coercible */
              "./node_modules/core-js/internals/require-object-coercible.js"
            );
            t.exports = function(s) {
              return a(o(s));
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/to-integer.js": (
          /*!******************************************************!*\
            !*** ./node_modules/core-js/internals/to-integer.js ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            var i = Math.ceil, a = Math.floor;
            t.exports = function(o) {
              return isNaN(o = +o) ? 0 : (o > 0 ? a : i)(o);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/to-length.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/to-length.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/to-integer */
              "./node_modules/core-js/internals/to-integer.js"
            ), o = Math.min;
            t.exports = function(s) {
              return s > 0 ? o(a(s), 9007199254740991) : 0;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/to-object.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/to-object.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/require-object-coercible */
              "./node_modules/core-js/internals/require-object-coercible.js"
            );
            t.exports = function(o) {
              return Object(a(o));
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/to-primitive.js": (
          /*!********************************************************!*\
            !*** ./node_modules/core-js/internals/to-primitive.js ***!
            \********************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/is-object */
              "./node_modules/core-js/internals/is-object.js"
            );
            t.exports = function(o, s) {
              if (!a(o)) return o;
              var l, u;
              if (s && typeof (l = o.toString) == "function" && !a(u = l.call(o)) || typeof (l = o.valueOf) == "function" && !a(u = l.call(o)) || !s && typeof (l = o.toString) == "function" && !a(u = l.call(o))) return u;
              throw TypeError("Can't convert object to primitive value");
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/uid.js": (
          /*!***********************************************!*\
            !*** ./node_modules/core-js/internals/uid.js ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            var i = 0, a = Math.random();
            t.exports = function(o) {
              return "Symbol(".concat(o === void 0 ? "" : o, ")_", (++i + a).toString(36));
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js": (
          /*!*******************************************************************************!*\
            !*** ./node_modules/core-js/internals/validate-set-prototype-of-arguments.js ***!
            \*******************************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/is-object */
              "./node_modules/core-js/internals/is-object.js"
            ), o = i(
              /*! ../internals/an-object */
              "./node_modules/core-js/internals/an-object.js"
            );
            t.exports = function(s, l) {
              if (o(s), !a(l) && l !== null)
                throw TypeError("Can't set " + String(l) + " as a prototype");
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/well-known-symbol.js": (
          /*!*************************************************************!*\
            !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            ), o = i(
              /*! ../internals/shared */
              "./node_modules/core-js/internals/shared.js"
            ), s = i(
              /*! ../internals/uid */
              "./node_modules/core-js/internals/uid.js"
            ), l = i(
              /*! ../internals/native-symbol */
              "./node_modules/core-js/internals/native-symbol.js"
            ), u = a.Symbol, c = o("wks");
            t.exports = function(d) {
              return c[d] || (c[d] = l && u[d] || (l ? u : s)("Symbol." + d));
            };
          }
        ),
        /***/
        "./node_modules/core-js/modules/es.array.from.js": (
          /*!*******************************************************!*\
            !*** ./node_modules/core-js/modules/es.array.from.js ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/export */
              "./node_modules/core-js/internals/export.js"
            ), o = i(
              /*! ../internals/array-from */
              "./node_modules/core-js/internals/array-from.js"
            ), s = i(
              /*! ../internals/check-correctness-of-iteration */
              "./node_modules/core-js/internals/check-correctness-of-iteration.js"
            ), l = !s(function(u) {
              Array.from(u);
            });
            a({ target: "Array", stat: !0, forced: l }, {
              from: o
            });
          }
        ),
        /***/
        "./node_modules/core-js/modules/es.string.iterator.js": (
          /*!************************************************************!*\
            !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
            \************************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ../internals/string-at */
              "./node_modules/core-js/internals/string-at.js"
            ), o = i(
              /*! ../internals/internal-state */
              "./node_modules/core-js/internals/internal-state.js"
            ), s = i(
              /*! ../internals/define-iterator */
              "./node_modules/core-js/internals/define-iterator.js"
            ), l = "String Iterator", u = o.set, c = o.getterFor(l);
            s(String, "String", function(d) {
              u(this, {
                type: l,
                string: String(d),
                index: 0
              });
            }, function() {
              var f = c(this), p = f.string, h = f.index, v;
              return h >= p.length ? { value: void 0, done: !0 } : (v = a(p, h, !0), f.index += v.length, { value: v, done: !1 });
            });
          }
        ),
        /***/
        "./node_modules/webpack/buildin/global.js": (
          /*!***********************************!*\
            !*** (webpack)/buildin/global.js ***!
            \***********************************/
          /*! no static exports found */
          /***/
          function(t, r) {
            var i;
            i = /* @__PURE__ */ function() {
              return this;
            }();
            try {
              i = i || Function("return this")() || (0, eval)("this");
            } catch {
              typeof window == "object" && (i = window);
            }
            t.exports = i;
          }
        ),
        /***/
        "./src/default-attrs.json": (
          /*!********************************!*\
            !*** ./src/default-attrs.json ***!
            \********************************/
          /*! exports provided: xmlns, width, height, viewBox, fill, stroke, stroke-width, stroke-linecap, stroke-linejoin, default */
          /***/
          function(t) {
            t.exports = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": 2, "stroke-linecap": "round", "stroke-linejoin": "round" };
          }
        ),
        /***/
        "./src/icon.js": (
          /*!*********************!*\
            !*** ./src/icon.js ***!
            \*********************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            Object.defineProperty(r, "__esModule", {
              value: !0
            });
            var a = Object.assign || function(v) {
              for (var m = 1; m < arguments.length; m++) {
                var g = arguments[m];
                for (var y in g)
                  Object.prototype.hasOwnProperty.call(g, y) && (v[y] = g[y]);
              }
              return v;
            }, o = /* @__PURE__ */ function() {
              function v(m, g) {
                for (var y = 0; y < g.length; y++) {
                  var b = g[y];
                  b.enumerable = b.enumerable || !1, b.configurable = !0, "value" in b && (b.writable = !0), Object.defineProperty(m, b.key, b);
                }
              }
              return function(m, g, y) {
                return g && v(m.prototype, g), y && v(m, y), m;
              };
            }(), s = i(
              /*! classnames/dedupe */
              "./node_modules/classnames/dedupe.js"
            ), l = d(s), u = i(
              /*! ./default-attrs.json */
              "./src/default-attrs.json"
            ), c = d(u);
            function d(v) {
              return v && v.__esModule ? v : { default: v };
            }
            function f(v, m) {
              if (!(v instanceof m))
                throw new TypeError("Cannot call a class as a function");
            }
            var p = function() {
              function v(m, g) {
                var y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
                f(this, v), this.name = m, this.contents = g, this.tags = y, this.attrs = a({}, c.default, { class: "feather feather-" + m });
              }
              return o(v, [{
                key: "toSvg",
                value: function() {
                  var g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, y = a({}, this.attrs, g, { class: (0, l.default)(this.attrs.class, g.class) });
                  return "<svg " + h(y) + ">" + this.contents + "</svg>";
                }
                /**
                 * Return string representation of an `Icon`.
                 *
                 * Added for backward compatibility. If old code expects `feather.icons.<name>`
                 * to be a string, `toString()` will get implicitly called.
                 *
                 * @returns {string}
                 */
              }, {
                key: "toString",
                value: function() {
                  return this.contents;
                }
              }]), v;
            }();
            function h(v) {
              return Object.keys(v).map(function(m) {
                return m + '="' + v[m] + '"';
              }).join(" ");
            }
            r.default = p;
          }
        ),
        /***/
        "./src/icons.js": (
          /*!**********************!*\
            !*** ./src/icons.js ***!
            \**********************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            Object.defineProperty(r, "__esModule", {
              value: !0
            });
            var a = i(
              /*! ./icon */
              "./src/icon.js"
            ), o = d(a), s = i(
              /*! ../dist/icons.json */
              "./dist/icons.json"
            ), l = d(s), u = i(
              /*! ./tags.json */
              "./src/tags.json"
            ), c = d(u);
            function d(f) {
              return f && f.__esModule ? f : { default: f };
            }
            r.default = Object.keys(l.default).map(function(f) {
              return new o.default(f, l.default[f], c.default[f]);
            }).reduce(function(f, p) {
              return f[p.name] = p, f;
            }, {});
          }
        ),
        /***/
        "./src/index.js": (
          /*!**********************!*\
            !*** ./src/index.js ***!
            \**********************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            var a = i(
              /*! ./icons */
              "./src/icons.js"
            ), o = d(a), s = i(
              /*! ./to-svg */
              "./src/to-svg.js"
            ), l = d(s), u = i(
              /*! ./replace */
              "./src/replace.js"
            ), c = d(u);
            function d(f) {
              return f && f.__esModule ? f : { default: f };
            }
            t.exports = { icons: o.default, toSvg: l.default, replace: c.default };
          }
        ),
        /***/
        "./src/replace.js": (
          /*!************************!*\
            !*** ./src/replace.js ***!
            \************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            Object.defineProperty(r, "__esModule", {
              value: !0
            });
            var a = Object.assign || function(h) {
              for (var v = 1; v < arguments.length; v++) {
                var m = arguments[v];
                for (var g in m)
                  Object.prototype.hasOwnProperty.call(m, g) && (h[g] = m[g]);
              }
              return h;
            }, o = i(
              /*! classnames/dedupe */
              "./node_modules/classnames/dedupe.js"
            ), s = c(o), l = i(
              /*! ./icons */
              "./src/icons.js"
            ), u = c(l);
            function c(h) {
              return h && h.__esModule ? h : { default: h };
            }
            function d() {
              var h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              if (typeof document > "u")
                throw new Error("`feather.replace()` only works in a browser environment.");
              var v = document.querySelectorAll("[data-feather]");
              Array.from(v).forEach(function(m) {
                return f(m, h);
              });
            }
            function f(h) {
              var v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, m = p(h), g = m["data-feather"];
              if (delete m["data-feather"], u.default[g] === void 0) {
                console.warn("feather: '" + g + "' is not a valid icon");
                return;
              }
              var y = u.default[g].toSvg(a({}, v, m, { class: (0, s.default)(v.class, m.class) })), b = new DOMParser().parseFromString(y, "image/svg+xml"), _ = b.querySelector("svg");
              h.parentNode.replaceChild(_, h);
            }
            function p(h) {
              return Array.from(h.attributes).reduce(function(v, m) {
                return v[m.name] = m.value, v;
              }, {});
            }
            r.default = d;
          }
        ),
        /***/
        "./src/tags.json": (
          /*!***********************!*\
            !*** ./src/tags.json ***!
            \***********************/
          /*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, archive, at-sign, award, aperture, bar-chart, bar-chart-2, battery, battery-charging, bell, bell-off, bluetooth, book-open, book, bookmark, box, briefcase, calendar, camera, cast, chevron-down, chevron-up, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-rain, cloud-snow, cloud, codepen, codesandbox, code, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, dollar-sign, droplet, edit, edit-2, edit-3, eye, eye-off, external-link, facebook, fast-forward, figma, file-minus, file-plus, file-text, film, filter, flag, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, instagram, key, layers, layout, life-buoy, link, link-2, linkedin, list, lock, log-in, log-out, mail, map-pin, map, maximize, maximize-2, meh, menu, message-circle, message-square, mic-off, mic, minimize, minimize-2, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation, navigation-2, octagon, package, paperclip, pause, pause-circle, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, play, pie-chart, play-circle, plus, plus-circle, plus-square, pocket, power, printer, radio, refresh-cw, refresh-ccw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, settings, share-2, shield, shield-off, shopping-bag, shopping-cart, shuffle, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, star, stop-circle, sun, sunrise, sunset, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, tool, trash, trash-2, triangle, truck, tv, twitch, twitter, type, umbrella, unlock, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume, volume-1, volume-2, volume-x, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default */
          /***/
          function(t) {
            t.exports = { activity: ["pulse", "health", "action", "motion"], airplay: ["stream", "cast", "mirroring"], "alert-circle": ["warning", "alert", "danger"], "alert-octagon": ["warning", "alert", "danger"], "alert-triangle": ["warning", "alert", "danger"], "align-center": ["text alignment", "center"], "align-justify": ["text alignment", "justified"], "align-left": ["text alignment", "left"], "align-right": ["text alignment", "right"], anchor: [], archive: ["index", "box"], "at-sign": ["mention", "at", "email", "message"], award: ["achievement", "badge"], aperture: ["camera", "photo"], "bar-chart": ["statistics", "diagram", "graph"], "bar-chart-2": ["statistics", "diagram", "graph"], battery: ["power", "electricity"], "battery-charging": ["power", "electricity"], bell: ["alarm", "notification", "sound"], "bell-off": ["alarm", "notification", "silent"], bluetooth: ["wireless"], "book-open": ["read", "library"], book: ["read", "dictionary", "booklet", "magazine", "library"], bookmark: ["read", "clip", "marker", "tag"], box: ["cube"], briefcase: ["work", "bag", "baggage", "folder"], calendar: ["date"], camera: ["photo"], cast: ["chromecast", "airplay"], "chevron-down": ["expand"], "chevron-up": ["collapse"], circle: ["off", "zero", "record"], clipboard: ["copy"], clock: ["time", "watch", "alarm"], "cloud-drizzle": ["weather", "shower"], "cloud-lightning": ["weather", "bolt"], "cloud-rain": ["weather"], "cloud-snow": ["weather", "blizzard"], cloud: ["weather"], codepen: ["logo"], codesandbox: ["logo"], code: ["source", "programming"], coffee: ["drink", "cup", "mug", "tea", "cafe", "hot", "beverage"], columns: ["layout"], command: ["keyboard", "cmd", "terminal", "prompt"], compass: ["navigation", "safari", "travel", "direction"], copy: ["clone", "duplicate"], "corner-down-left": ["arrow", "return"], "corner-down-right": ["arrow"], "corner-left-down": ["arrow"], "corner-left-up": ["arrow"], "corner-right-down": ["arrow"], "corner-right-up": ["arrow"], "corner-up-left": ["arrow"], "corner-up-right": ["arrow"], cpu: ["processor", "technology"], "credit-card": ["purchase", "payment", "cc"], crop: ["photo", "image"], crosshair: ["aim", "target"], database: ["storage", "memory"], delete: ["remove"], disc: ["album", "cd", "dvd", "music"], "dollar-sign": ["currency", "money", "payment"], droplet: ["water"], edit: ["pencil", "change"], "edit-2": ["pencil", "change"], "edit-3": ["pencil", "change"], eye: ["view", "watch"], "eye-off": ["view", "watch", "hide", "hidden"], "external-link": ["outbound"], facebook: ["logo", "social"], "fast-forward": ["music"], figma: ["logo", "design", "tool"], "file-minus": ["delete", "remove", "erase"], "file-plus": ["add", "create", "new"], "file-text": ["data", "txt", "pdf"], film: ["movie", "video"], filter: ["funnel", "hopper"], flag: ["report"], "folder-minus": ["directory"], "folder-plus": ["directory"], folder: ["directory"], framer: ["logo", "design", "tool"], frown: ["emoji", "face", "bad", "sad", "emotion"], gift: ["present", "box", "birthday", "party"], "git-branch": ["code", "version control"], "git-commit": ["code", "version control"], "git-merge": ["code", "version control"], "git-pull-request": ["code", "version control"], github: ["logo", "version control"], gitlab: ["logo", "version control"], globe: ["world", "browser", "language", "translate"], "hard-drive": ["computer", "server", "memory", "data"], hash: ["hashtag", "number", "pound"], headphones: ["music", "audio", "sound"], heart: ["like", "love", "emotion"], "help-circle": ["question mark"], hexagon: ["shape", "node.js", "logo"], home: ["house", "living"], image: ["picture"], inbox: ["email"], instagram: ["logo", "camera"], key: ["password", "login", "authentication", "secure"], layers: ["stack"], layout: ["window", "webpage"], "life-buoy": ["help", "life ring", "support"], link: ["chain", "url"], "link-2": ["chain", "url"], linkedin: ["logo", "social media"], list: ["options"], lock: ["security", "password", "secure"], "log-in": ["sign in", "arrow", "enter"], "log-out": ["sign out", "arrow", "exit"], mail: ["email", "message"], "map-pin": ["location", "navigation", "travel", "marker"], map: ["location", "navigation", "travel"], maximize: ["fullscreen"], "maximize-2": ["fullscreen", "arrows", "expand"], meh: ["emoji", "face", "neutral", "emotion"], menu: ["bars", "navigation", "hamburger"], "message-circle": ["comment", "chat"], "message-square": ["comment", "chat"], "mic-off": ["record", "sound", "mute"], mic: ["record", "sound", "listen"], minimize: ["exit fullscreen", "close"], "minimize-2": ["exit fullscreen", "arrows", "close"], minus: ["subtract"], monitor: ["tv", "screen", "display"], moon: ["dark", "night"], "more-horizontal": ["ellipsis"], "more-vertical": ["ellipsis"], "mouse-pointer": ["arrow", "cursor"], move: ["arrows"], music: ["note"], navigation: ["location", "travel"], "navigation-2": ["location", "travel"], octagon: ["stop"], package: ["box", "container"], paperclip: ["attachment"], pause: ["music", "stop"], "pause-circle": ["music", "audio", "stop"], "pen-tool": ["vector", "drawing"], percent: ["discount"], "phone-call": ["ring"], "phone-forwarded": ["call"], "phone-incoming": ["call"], "phone-missed": ["call"], "phone-off": ["call", "mute"], "phone-outgoing": ["call"], phone: ["call"], play: ["music", "start"], "pie-chart": ["statistics", "diagram"], "play-circle": ["music", "start"], plus: ["add", "new"], "plus-circle": ["add", "new"], "plus-square": ["add", "new"], pocket: ["logo", "save"], power: ["on", "off"], printer: ["fax", "office", "device"], radio: ["signal"], "refresh-cw": ["synchronise", "arrows"], "refresh-ccw": ["arrows"], repeat: ["loop", "arrows"], rewind: ["music"], "rotate-ccw": ["arrow"], "rotate-cw": ["arrow"], rss: ["feed", "subscribe"], save: ["floppy disk"], scissors: ["cut"], search: ["find", "magnifier", "magnifying glass"], send: ["message", "mail", "email", "paper airplane", "paper aeroplane"], settings: ["cog", "edit", "gear", "preferences"], "share-2": ["network", "connections"], shield: ["security", "secure"], "shield-off": ["security", "insecure"], "shopping-bag": ["ecommerce", "cart", "purchase", "store"], "shopping-cart": ["ecommerce", "cart", "purchase", "store"], shuffle: ["music"], "skip-back": ["music"], "skip-forward": ["music"], slack: ["logo"], slash: ["ban", "no"], sliders: ["settings", "controls"], smartphone: ["cellphone", "device"], smile: ["emoji", "face", "happy", "good", "emotion"], speaker: ["audio", "music"], star: ["bookmark", "favorite", "like"], "stop-circle": ["media", "music"], sun: ["brightness", "weather", "light"], sunrise: ["weather", "time", "morning", "day"], sunset: ["weather", "time", "evening", "night"], tablet: ["device"], tag: ["label"], target: ["logo", "bullseye"], terminal: ["code", "command line", "prompt"], thermometer: ["temperature", "celsius", "fahrenheit", "weather"], "thumbs-down": ["dislike", "bad", "emotion"], "thumbs-up": ["like", "good", "emotion"], "toggle-left": ["on", "off", "switch"], "toggle-right": ["on", "off", "switch"], tool: ["settings", "spanner"], trash: ["garbage", "delete", "remove", "bin"], "trash-2": ["garbage", "delete", "remove", "bin"], triangle: ["delta"], truck: ["delivery", "van", "shipping", "transport", "lorry"], tv: ["television", "stream"], twitch: ["logo"], twitter: ["logo", "social"], type: ["text"], umbrella: ["rain", "weather"], unlock: ["security"], "user-check": ["followed", "subscribed"], "user-minus": ["delete", "remove", "unfollow", "unsubscribe"], "user-plus": ["new", "add", "create", "follow", "subscribe"], "user-x": ["delete", "remove", "unfollow", "unsubscribe", "unavailable"], user: ["person", "account"], users: ["group"], "video-off": ["camera", "movie", "film"], video: ["camera", "movie", "film"], voicemail: ["phone"], volume: ["music", "sound", "mute"], "volume-1": ["music", "sound"], "volume-2": ["music", "sound"], "volume-x": ["music", "sound", "mute"], watch: ["clock", "time"], "wifi-off": ["disabled"], wifi: ["connection", "signal", "wireless"], wind: ["weather", "air"], "x-circle": ["cancel", "close", "delete", "remove", "times", "clear"], "x-octagon": ["delete", "stop", "alert", "warning", "times", "clear"], "x-square": ["cancel", "close", "delete", "remove", "times", "clear"], x: ["cancel", "close", "delete", "remove", "times", "clear"], youtube: ["logo", "video", "play"], "zap-off": ["flash", "camera", "lightning"], zap: ["flash", "camera", "lightning"], "zoom-in": ["magnifying glass"], "zoom-out": ["magnifying glass"] };
          }
        ),
        /***/
        "./src/to-svg.js": (
          /*!***********************!*\
            !*** ./src/to-svg.js ***!
            \***********************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            Object.defineProperty(r, "__esModule", {
              value: !0
            });
            var a = i(
              /*! ./icons */
              "./src/icons.js"
            ), o = s(a);
            function s(u) {
              return u && u.__esModule ? u : { default: u };
            }
            function l(u) {
              var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              if (console.warn("feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead."), !u)
                throw new Error("The required `key` (icon name) parameter is missing.");
              if (!o.default[u])
                throw new Error("No icon matching '" + u + "'. See the complete list of icons at https://feathericons.com");
              return o.default[u].toSvg(c);
            }
            r.default = l;
          }
        ),
        /***/
        0: (
          /*!**************************************************!*\
            !*** multi core-js/es/array/from ./src/index.js ***!
            \**************************************************/
          /*! no static exports found */
          /***/
          function(t, r, i) {
            i(
              /*! core-js/es/array/from */
              "./node_modules/core-js/es/array/from.js"
            ), t.exports = i(
              /*! /home/runner/work/feather/feather/src/index.js */
              "./src/index.js"
            );
          }
        )
        /******/
      })
    );
  });
})(qV);
var Gie = qV.exports;
const DT = /* @__PURE__ */ nM(Gie), RL = Object.keys(DT.icons), En = {
  props: {
    name: {
      type: String,
      required: !0,
      validator(n) {
        const e = RL.includes(n);
        return e || (console.groupCollapsed(
          "[frappe-ui] name property for feather-icon must be one of "
        ), console.dir(RL), console.groupEnd()), e;
      }
    },
    color: {
      type: String,
      default: null
    },
    strokeWidth: {
      type: Number,
      default: 1.5
    }
  },
  render() {
    let n = DT.icons[this.name];
    return n || (n = DT.icons.circle), qt(
      "svg",
      He(
        n.attrs,
        {
          fill: "none",
          stroke: "currentColor",
          color: this.color,
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          "stroke-width": this.strokeWidth,
          width: null,
          height: null,
          class: [n.attrs.class, "shrink-0"],
          innerHTML: n.contents
        },
        this.$attrs
      )
    );
  }
}, nh = /* @__PURE__ */ ve({
  __name: "LoadingIndicator",
  props: { scale: { required: !1, default: 100 } },
  setup(n) {
    return (e, t) => (L(), W("svg", {
      class: "max-w-xs animate-spin",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      style: An(`scale: ${n.scale}%;`),
      viewBox: "0 0 24 24"
    }, [...t[0] || (t[0] = [
      G("circle", {
        class: "opacity-25",
        cx: "12",
        cy: "12",
        r: "10",
        stroke: "currentColor",
        "stroke-width": "4"
      }, null, -1),
      G("path", {
        class: "opacity-75",
        fill: "currentColor",
        d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      }, null, -1)
    ])], 4));
  }
});
/*!
  * vue-router v4.5.1
  * (c) 2025 Eduardo San Martin Morote
  * @license MIT
  */
var PL;
(function(n) {
  n.pop = "pop", n.push = "push";
})(PL || (PL = {}));
var jL;
(function(n) {
  n.back = "back", n.forward = "forward", n.unknown = "";
})(jL || (jL = {}));
Symbol(process.env.NODE_ENV !== "production" ? "navigation failure" : "");
var BL;
(function(n) {
  n[n.aborted = 4] = "aborted", n[n.cancelled = 8] = "cancelled", n[n.duplicated = 16] = "duplicated";
})(BL || (BL = {}));
Symbol(process.env.NODE_ENV !== "production" ? "router view location matched" : "");
Symbol(process.env.NODE_ENV !== "production" ? "router view depth" : "");
const Uie = Symbol(process.env.NODE_ENV !== "production" ? "router" : "");
Symbol(process.env.NODE_ENV !== "production" ? "route location" : "");
Symbol(process.env.NODE_ENV !== "production" ? "router view location" : "");
function sx() {
  return Xt(Uie);
}
const Wie = { class: "rounded bg-surface-gray-7 px-2 py-1 text-xs text-ink-white shadow-xl" }, Ei = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "Tooltip",
  props: {
    text: { default: "" },
    hoverDelay: { default: 0.5 },
    placement: { default: "top" },
    arrowClass: { default: "fill-surface-gray-7" },
    disabled: { type: Boolean, default: !1 }
  },
  setup(n) {
    const e = n, t = K(() => e.hoverDelay * 1e3);
    return (r, i) => r.disabled ? ue(r.$slots, "default", { key: 0 }) : (L(), re(O(Die), {
      key: 1,
      delayDuration: t.value
    }, {
      default: ee(() => [
        se(O(Lie), null, {
          default: ee(() => [
            se(O(Vie), { "as-child": "" }, {
              default: ee(() => [
                ue(r.$slots, "default")
              ]),
              _: 3
            }),
            se(O(zie), null, {
              default: ee(() => [
                e.text || r.$slots.body || r.$slots.content ? (L(), re(O(Bie), {
                  key: 0,
                  side: e.placement,
                  "side-offset": 4,
                  class: "z-[100]"
                }, {
                  default: ee(() => [
                    ue(r.$slots, "body", {}, () => [
                      G("div", Wie, [
                        ue(r.$slots, "content", {}, () => [
                          gn(ke(e.text), 1)
                        ])
                      ])
                    ]),
                    se(O(kie), {
                      class: _e(e.arrowClass),
                      width: 8,
                      height: 4
                    }, null, 8, ["class"])
                  ]),
                  _: 3
                }, 8, ["side"])) : ge("", !0)
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["delayDuration"]));
  }
}), qie = ["disabled", "ariaLabel"], fn = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "Button",
  props: {
    theme: { default: "gray" },
    size: { default: "sm" },
    variant: { default: "subtle" },
    label: {},
    icon: {},
    iconLeft: {},
    iconRight: {},
    tooltip: {},
    loading: { type: Boolean, default: !1 },
    loadingText: {},
    disabled: { type: Boolean, default: !1 },
    route: {},
    link: {}
  },
  setup(n, { expose: e }) {
    const t = n, r = Xp(), i = sx(), a = K(() => {
      let p = {
        gray: "text-ink-white bg-surface-gray-7 hover:bg-surface-gray-6 active:bg-surface-gray-5",
        blue: "text-ink-white bg-blue-500 hover:bg-surface-blue-3 active:bg-blue-700",
        green: "text-ink-white bg-surface-green-3 hover:bg-green-700 active:bg-green-800",
        red: "text-ink-white bg-surface-red-5 hover:bg-surface-red-6 active:bg-surface-red-7"
      }[t.theme], h = {
        gray: "text-ink-gray-8 bg-surface-gray-2 hover:bg-surface-gray-3 active:bg-surface-gray-4",
        blue: "text-ink-blue-3 bg-surface-blue-2 hover:bg-blue-200 active:bg-blue-300",
        green: "text-green-800 bg-surface-green-2 hover:bg-green-200 active:bg-green-300",
        red: "text-red-700 bg-surface-red-2 hover:bg-surface-red-3 active:bg-surface-red-4"
      }[t.theme], v = {
        gray: "text-ink-gray-8 bg-surface-white bg-surface-white border border-outline-gray-2 hover:border-outline-gray-3 active:border-outline-gray-3 active:bg-surface-gray-4",
        blue: "text-ink-blue-3 bg-surface-white border border-outline-blue-1 hover:border-blue-400 active:border-blue-400 active:bg-blue-300",
        green: "text-green-800 bg-surface-white border border-outline-green-2 hover:border-green-500 active:border-green-500 active:bg-green-300",
        red: "text-red-700 bg-surface-white border border-outline-red-1 hover:border-outline-red-2 active:border-outline-red-2 active:bg-surface-red-3"
      }[t.theme], m = {
        gray: "text-ink-gray-8 bg-transparent hover:bg-surface-gray-3 active:bg-surface-gray-4",
        blue: "text-ink-blue-3 bg-transparent hover:bg-blue-200 active:bg-blue-300",
        green: "text-green-800 bg-transparent hover:bg-green-200 active:bg-green-300",
        red: "text-red-700 bg-transparent hover:bg-surface-red-3 active:bg-surface-red-4"
      }[t.theme], g = {
        gray: "focus-visible:ring focus-visible:ring-outline-gray-3",
        blue: "focus-visible:ring focus-visible:ring-blue-400",
        green: "focus-visible:ring focus-visible:ring-outline-green-2",
        red: "focus-visible:ring focus-visible:ring-outline-red-2"
      }[t.theme], y = {
        subtle: h,
        solid: p,
        outline: v,
        ghost: m
      }[t.variant], b = `${t.theme}-${t.variant}`, x = {
        "gray-solid": "bg-surface-gray-2 text-ink-gray-4",
        "gray-subtle": "bg-surface-gray-2 text-ink-gray-4",
        "gray-outline": "bg-surface-gray-2 text-ink-gray-4 border border-outline-gray-2",
        "gray-ghost": "text-ink-gray-4",
        "blue-solid": "bg-blue-300 text-ink-white",
        "blue-subtle": "bg-surface-blue-2 text-ink-blue-link",
        "blue-outline": "bg-surface-blue-2 text-ink-blue-link border border-outline-blue-1",
        "blue-ghost": "text-ink-blue-link",
        "green-solid": "bg-surface-green-2 text-ink-green-2",
        "green-subtle": "bg-surface-green-2 text-ink-green-2",
        "green-outline": "bg-surface-green-2 text-ink-green-2 border border-outline-green-2",
        "green-ghost": "text-ink-green-2",
        "red-solid": "bg-surface-red-2 text-ink-red-2",
        "red-subtle": "bg-surface-red-2 text-ink-red-2",
        "red-outline": "bg-surface-red-2 text-ink-red-2 border border-outline-red-1",
        "red-ghost": "text-ink-red-2"
      }[b], w = {
        sm: "h-7 text-base px-2 rounded",
        md: "h-8 text-base font-medium px-2.5 rounded",
        lg: "h-10 text-lg font-medium px-3 rounded-md",
        xl: "h-11.5 text-xl font-medium px-3.5 rounded-lg",
        "2xl": "h-13 text-2xl font-medium px-3.5 rounded-xl"
      }[t.size];
      return u.value && (w = {
        sm: "h-7 w-7 rounded",
        md: "h-8 w-8 rounded",
        lg: "h-10 w-10 rounded-md",
        xl: "h-11.5 w-11.5 rounded-lg",
        "2xl": "h-13 w-13 rounded-xl"
      }[t.size]), [
        "inline-flex items-center justify-center gap-2 transition-colors focus:outline-none shrink-0",
        s.value ? x : y,
        g,
        w
      ];
    }), o = K(() => ({
      sm: "h-4",
      md: "h-4.5",
      lg: "h-5",
      xl: "h-6",
      "2xl": "h-6"
    })[t.size]), s = K(() => t.disabled || t.loading), l = K(() => u.value ? t.label : null), u = K(() => t.icon || r.icon || c.value), c = K(() => {
      var v, m, g;
      if (!r.default) return !1;
      const p = r.default();
      if (!Array.isArray(p)) return !1;
      let h = p[0];
      return !!(typeof ((v = h.type) == null ? void 0 : v.name) == "string" && ((g = (m = h.type) == null ? void 0 : m.name) != null && g.startsWith("lucide-")));
    }), d = () => {
      if (t.route)
        return i.push(t.route);
      if (t.link)
        return window.open(t.link, "_blank");
    }, f = Z();
    return e({ rootRef: f }), (p, h) => {
      var v;
      return L(), re(Ei, {
        text: p.tooltip,
        disabled: !((v = p.tooltip) != null && v.length)
      }, {
        default: ee(() => [
          G("button", He(p.$attrs, {
            class: a.value,
            onClick: d,
            disabled: s.value,
            ariaLabel: l.value,
            ref_key: "rootRef",
            ref: f
          }), [
            p.loading ? (L(), re(nh, {
              key: 0,
              class: _e({
                "h-3 w-3": p.size == "sm",
                "h-[13.5px] w-[13.5px]": p.size == "md",
                "h-[15px] w-[15px]": p.size == "lg",
                "h-4.5 w-4.5": p.size == "xl" || p.size == "2xl"
              })
            }, null, 8, ["class"])) : p.$slots.prefix || p.iconLeft ? ue(p.$slots, "prefix", { key: 1 }, () => [
              p.iconLeft && typeof p.iconLeft == "string" ? (L(), re(En, {
                key: 0,
                name: p.iconLeft,
                class: _e(o.value),
                "aria-hidden": "true"
              }, null, 8, ["name", "class"])) : p.iconLeft ? (L(), re(bn(p.iconLeft), {
                key: 1,
                class: _e(o.value)
              }, null, 8, ["class"])) : ge("", !0)
            ]) : ge("", !0),
            p.loading && p.loadingText ? (L(), W(Ke, { key: 2 }, [
              gn(ke(p.loadingText), 1)
            ], 64)) : u.value && !p.loading ? (L(), W(Ke, { key: 3 }, [
              p.icon && typeof p.icon == "string" ? (L(), re(En, {
                key: 0,
                name: p.icon,
                class: _e(o.value),
                "aria-label": p.label
              }, null, 8, ["name", "class", "aria-label"])) : p.icon ? (L(), re(bn(p.icon), {
                key: 1,
                class: _e(o.value)
              }, null, 8, ["class"])) : p.$slots.icon ? ue(p.$slots, "icon", { key: 2 }) : c.value ? (L(), W("div", {
                key: 3,
                class: _e(o.value)
              }, [
                ue(p.$slots, "default", {}, () => [
                  gn(ke(p.label), 1)
                ])
              ], 2)) : ge("", !0)
            ], 64)) : (L(), W("span", {
              key: 4,
              class: _e([{ "sr-only": u.value }, "truncate"])
            }, [
              ue(p.$slots, "default", {}, () => [
                gn(ke(p.label), 1)
              ])
            ], 2)),
            ue(p.$slots, "suffix", {}, () => [
              p.iconRight && typeof p.iconRight == "string" ? (L(), re(En, {
                key: 0,
                name: p.iconRight,
                class: _e(o.value),
                "aria-hidden": "true"
              }, null, 8, ["name", "class"])) : p.iconRight ? (L(), re(bn(p.iconRight), {
                key: 1,
                class: _e(o.value)
              }, null, 8, ["class"])) : ge("", !0)
            ])
          ], 16, qie)
        ]),
        _: 3
      }, 8, ["text", "disabled"]);
    };
  }
}), Yie = { class: "w-full space-y-1.5" }, Kie = {
  key: 0,
  class: "block text-xs text-ink-gray-5"
}, Xie = ["onClick"], Zie = { class: "flex items-center overflow-hidden" }, Jie = {
  key: 0,
  class: "truncate text-base leading-5 text-ink-gray-8"
}, Qie = {
  key: 1,
  class: "text-base leading-5 text-ink-gray-4"
}, eae = {
  key: 0,
  class: "sticky top-0 z-10 flex items-stretch space-x-1.5 bg-surface-modal py-1.5"
}, tae = { class: "relative w-full" }, nae = { class: "absolute right-0 inline-flex h-7 w-7 items-center justify-center" }, rae = {
  key: 0,
  class: "sticky top-10 truncate bg-surface-modal px-2.5 py-1.5 text-sm font-medium text-ink-gray-5"
}, iae = { class: "flex flex-1 gap-2 overflow-hidden items-center" }, aae = {
  key: 0,
  class: "flex flex-shrink-0"
}, oae = {
  key: 1,
  class: "h-4 w-4"
}, sae = { class: "flex-1 truncate text-ink-gray-7" }, lae = {
  key: 0,
  class: "ml-2 flex-shrink-0"
}, uae = {
  key: 0,
  class: "text-sm text-ink-gray-5"
}, cae = {
  key: 1,
  class: "rounded-md px-2.5 py-1.5 text-base text-ink-gray-5"
}, dae = {
  key: 0,
  class: "border-t p-1"
}, fae = {
  key: 0,
  class: "flex items-center justify-end"
}, pae = {
  key: 1,
  class: "flex items-center justify-end"
}, hae = /* @__PURE__ */ ve({
  __name: "Autocomplete",
  props: {
    label: {},
    options: {},
    hideSearch: { type: Boolean, default: !1 },
    placeholder: {},
    bodyClasses: {},
    loading: { type: Boolean },
    placement: {},
    showFooter: { type: Boolean },
    compareFn: { type: Function, default: (n, e) => n.value === e.value },
    maxOptions: { default: 50 },
    multiple: { type: Boolean, default: !1 },
    modelValue: { type: [Array, null, String, Number, Boolean, Object] }
  },
  emits: ["update:modelValue", "update:query", "change"],
  setup(n, { expose: e, emit: t }) {
    const r = n, i = t, a = Z(), o = Z(!1), s = Z(""), l = K(() => {
      var M;
      if (!((M = r.options) != null && M.length)) return [];
      let k;
      return w(r.options[0]) ? k = r.options : k = [
        {
          group: "",
          items: c(r.options),
          hideLabel: !1
        }
      ], k.map((D, N) => ({
        key: N,
        group: D.group,
        hideLabel: D.hideLabel,
        items: d(c(D.items || []))
      })).filter((D) => D.items.length > 0);
    }), u = K(() => l.value.flatMap((k) => k.items)), c = (k) => k ? k.map((M) => x(M) ? M : { label: M.toString(), value: M }) : [], d = (k) => s.value ? k.filter((M) => M.label.toLowerCase().includes(s.value.trim().toLowerCase()) || M.value.toString().toLowerCase().includes(s.value.trim().toLowerCase())) : k, f = K({
      get() {
        if (!r.multiple)
          return p(r.modelValue) || // if the modelValue is not found in the option list
          // return the modelValue as is
          h(r.modelValue);
        const k = r.modelValue || [];
        return x(k[0]) ? k : k.map((M) => p(M) || h(M));
      },
      set(k) {
        if (s.value = "", k && !r.multiple && (o.value = !1), !r.multiple) {
          i("update:modelValue", k);
          return;
        }
        i("update:modelValue", k);
      }
    }), p = (k) => {
      if (!k) return k;
      const M = x(k) ? k.value : k;
      return u.value.find((D) => D.value === M);
    }, h = (k) => x(k) ? k : { label: k, value: k }, v = (k) => x(k) ? (k == null ? void 0 : k.label) || (k == null ? void 0 : k.value) : k, m = K(() => f.value ? r.multiple ? f.value.map((k) => v(k)).join(", ") : v(f.value) : ""), g = (k) => {
      if (!f.value) return !1;
      const M = x(k) ? k.value : k;
      return r.multiple ? f.value.find(
        (D) => x(D) ? D.value === M : D === M
      ) : f.value === M;
    }, y = K(() => {
      var k;
      return r.multiple ? u.value.length === ((k = f.value) == null ? void 0 : k.length) : !1;
    }), b = () => {
      f.value = u.value;
    }, _ = () => {
      f.value = r.multiple ? [] : void 0;
    }, x = (k) => typeof k == "object", w = (k) => typeof k == "object" && "items" in k && "group" in k;
    et(
      () => s.value,
      () => {
        i("update:query", s.value);
      }
    ), et(
      () => o.value,
      () => {
        o.value && Wt(() => {
          var k;
          return (k = a.value) == null ? void 0 : k.$el.focus();
        });
      }
    );
    const S = Z();
    return e({
      rootRef: S,
      togglePopover: () => {
        o.value = !o.value;
      }
    }), (k, M) => (L(), re(O(jF), {
      modelValue: f.value,
      "onUpdate:modelValue": M[2] || (M[2] = (D) => f.value = D),
      multiple: k.multiple,
      nullable: "",
      by: k.compareFn
    }, {
      default: ee(({ open: D }) => [
        se(O(th), {
          class: "w-full",
          show: o.value,
          "onUpdate:show": M[1] || (M[1] = (N) => o.value = N),
          ref_key: "rootRef",
          ref: S,
          placement: k.placement
        }, {
          target: ee(({ open: N, togglePopover: R, close: j }) => [
            ue(k.$slots, "target", Bt(Jt({
              open: N,
              close: j,
              togglePopover: R,
              isOpen: D
            })), () => [
              G("div", Yie, [
                r.label ? (L(), W("label", Kie, ke(r.label), 1)) : ge("", !0),
                G("button", {
                  class: _e(["flex h-7 w-full items-center justify-between gap-2 rounded bg-surface-gray-2 px-2 py-1 transition-colors hover:bg-surface-gray-3 border border-transparent focus:border-outline-gray-4 focus:outline-none focus:ring-2 focus:ring-outline-gray-3", { "bg-surface-gray-3": D }]),
                  onClick: () => R()
                }, [
                  G("div", Zie, [
                    ue(k.$slots, "prefix"),
                    m.value ? (L(), W("span", Jie, ke(m.value), 1)) : (L(), W("span", Qie, ke(k.placeholder || ""), 1)),
                    ue(k.$slots, "suffix")
                  ]),
                  se(En, {
                    name: "chevron-down",
                    class: "h-4 w-4 text-ink-gray-5",
                    "aria-hidden": "true"
                  })
                ], 10, Xie)
              ])
            ])
          ]),
          body: ee(({ isOpen: N, togglePopover: R }) => [
            ta(G("div", null, [
              G("div", {
                class: _e(["relative mt-1 rounded-lg bg-surface-modal text-base shadow-2xl", k.bodyClasses])
              }, [
                se(O($F), {
                  class: _e(["max-h-[15rem] overflow-y-auto px-1.5 pb-1.5", { "pt-1.5": k.hideSearch }]),
                  static: ""
                }, {
                  default: ee(() => [
                    k.hideSearch ? ge("", !0) : (L(), W("div", eae, [
                      G("div", tae, [
                        se(O(BF), {
                          ref_key: "searchInput",
                          ref: a,
                          class: "form-input w-full focus:bg-surface-gray-3 hover:bg-surface-gray-4 text-ink-gray-8",
                          type: "text",
                          value: s.value,
                          onChange: M[0] || (M[0] = (j) => s.value = j.target.value),
                          autocomplete: "off",
                          placeholder: "Search"
                        }, null, 8, ["value"]),
                        G("div", nae, [
                          r.loading ? (L(), re(nh, {
                            key: 0,
                            class: "h-4 w-4 text-ink-gray-5"
                          })) : (L(), W("button", {
                            key: 1,
                            onClick: _
                          }, [
                            se(En, {
                              name: "x",
                              class: "w-4 text-ink-gray-8"
                            })
                          ]))
                        ])
                      ])
                    ])),
                    (L(!0), W(Ke, null, _t(l.value, (j) => ta((L(), W("div", {
                      key: j.key
                    }, [
                      j.group && !j.hideLabel ? (L(), W("div", rae, ke(j.group), 1)) : ge("", !0),
                      (L(!0), W(Ke, null, _t(j.items.slice(
                        0,
                        r.maxOptions
                      ), (z, F) => (L(), re(O(zF), {
                        as: "template",
                        key: F,
                        value: z,
                        disabled: z.disabled
                      }, {
                        default: ee(({ active: B, selected: H }) => [
                          G("li", {
                            class: _e([
                              "flex cursor-pointer items-center justify-between rounded px-2.5 py-1.5 text-base",
                              {
                                "bg-surface-gray-3": B,
                                "opacity-50": z.disabled
                              }
                            ])
                          }, [
                            G("div", iae, [
                              k.$slots["item-prefix"] || r.multiple ? (L(), W("div", aae, [
                                ue(k.$slots, "item-prefix", He({ ref_for: !0 }, { active: B, selected: H, option: z }), () => [
                                  g(z) ? (L(), re(En, {
                                    key: 0,
                                    name: "check",
                                    class: "h-4 w-4 text-ink-gray-7"
                                  })) : (L(), W("div", oae))
                                ])
                              ])) : ge("", !0),
                              G("span", sae, ke(v(z)), 1)
                            ]),
                            k.$slots["item-suffix"] || z != null && z.description ? (L(), W("div", lae, [
                              ue(k.$slots, "item-suffix", He({ ref_for: !0 }, { active: B, selected: H, option: z }), () => [
                                z != null && z.description ? (L(), W("div", uae, ke(z.description), 1)) : ge("", !0)
                              ])
                            ])) : ge("", !0)
                          ], 2)
                        ]),
                        _: 2
                      }, 1032, ["value", "disabled"]))), 128))
                    ])), [
                      [hs, j.items.length > 0]
                    ])), 128)),
                    l.value.length == 0 ? (L(), W("li", cae, " No results found ")) : ge("", !0)
                  ]),
                  _: 3
                }, 8, ["class"]),
                k.$slots.footer || r.showFooter || k.multiple ? (L(), W("div", dae, [
                  ue(k.$slots, "footer", Bt(Jt({ togglePopover: R })), () => [
                    k.multiple ? (L(), W("div", fae, [
                      y.value ? ge("", !0) : (L(), re(O(fn), {
                        key: 0,
                        label: "Select All",
                        onClick: xt(b, ["stop"])
                      })),
                      y.value ? (L(), re(O(fn), {
                        key: 1,
                        label: "Clear All",
                        onClick: xt(_, ["stop"])
                      })) : ge("", !0)
                    ])) : (L(), W("div", pae, [
                      se(O(fn), {
                        label: "Clear",
                        onClick: xt(_, ["stop"])
                      })
                    ]))
                  ])
                ])) : ge("", !0)
              ], 2)
            ], 512), [
              [hs, N]
            ])
          ]),
          _: 2
        }, 1032, ["show", "placement"])
      ]),
      _: 3
    }, 8, ["modelValue", "multiple", "by"]));
  }
}), vae = ["src", "alt"], cUe = /* @__PURE__ */ ve({
  __name: "Avatar",
  props: {
    image: {},
    label: {},
    size: { default: "md" },
    shape: { default: "circle" }
  },
  setup(n) {
    const e = Z(!1), t = n, r = K(() => ({
      circle: "rounded-full",
      square: {
        xs: "rounded-[4px]",
        sm: "rounded-[5px]",
        md: "rounded-[5px]",
        lg: "rounded-[6px]",
        xl: "rounded-[6px]",
        "2xl": "rounded-[8px]",
        "3xl": "rounded-[10px]"
      }[t.size]
    })[t.shape]), i = K(() => ({
      xs: "w-4 h-4",
      sm: "w-5 h-5",
      md: "w-6 h-6",
      lg: "w-7 h-7",
      xl: "w-8 h-8",
      "2xl": "w-10 h-10",
      "3xl": "w-11.5 h-11.5"
    })[t.size]), a = K(() => ["font-medium", {
      xs: "text-2xs",
      sm: "text-sm",
      md: "text-base",
      lg: "text-base",
      xl: "text-lg",
      "2xl": "text-xl",
      "3xl": "text-2xl"
    }[t.size]]), o = K(() => ({
      xs: "-mr-[.1rem] -mb-[.1rem] h-2 w-2",
      sm: "-mr-[.1rem] -mb-[.1rem] h-[9px] w-[9px]",
      md: "-mr-[.1rem] -mb-[.1rem] h-2.5 w-2.5",
      lg: "-mr-[.1rem] -mb-[.1rem] h-3 w-3",
      xl: "-mr-[.1rem] -mb-[.1rem] h-3 w-3",
      "2xl": "-mr-[.1rem] -mb-[.1rem] h-3.5 w-3.5",
      "3xl": "-mr-[.2rem] -mb-[.2rem] h-4 w-4"
    })[t.size]), s = K(() => ({
      xs: "h-1 w-1",
      sm: "h-[5px] w-[5px]",
      md: "h-1.5 w-1.5",
      lg: "h-2 w-2",
      xl: "h-2 w-2",
      "2xl": "h-2.5 w-2.5",
      "3xl": "h-3 w-3"
    })[t.size]), l = K(() => ({
      xs: "h-2.5 w-2.5",
      sm: "h-3 w-3",
      md: "h-4 w-4",
      lg: "h-4 w-4",
      xl: "h-4 w-4",
      "2xl": "h-5 w-5",
      "3xl": "h-5 w-5"
    })[t.size]);
    function u(c) {
      c.type && (e.value = !0);
    }
    return (c, d) => (L(), W("div", {
      class: _e(["relative inline-block shrink-0", [i.value, r.value]])
    }, [
      c.image && !e.value ? (L(), W("img", {
        key: 0,
        src: c.image,
        alt: c.label,
        class: _e([r.value, "h-full w-full object-cover"]),
        onError: d[0] || (d[0] = (f) => u(f))
      }, null, 42, vae)) : (L(), W("div", {
        key: 1,
        class: _e(["flex h-full w-full items-center justify-center bg-surface-gray-2 uppercase text-ink-gray-5 select-none", [a.value, r.value]])
      }, [
        c.$slots.default ? (L(), W("div", {
          key: 0,
          class: _e(l.value)
        }, [
          ue(c.$slots, "default")
        ], 2)) : (L(), W(Ke, { key: 1 }, [
          gn(ke(c.label && c.label[0]), 1)
        ], 64))
      ], 2)),
      c.$slots.indicator ? (L(), W("div", {
        key: 2,
        class: _e([
          "absolute bottom-0 right-0 grid place-items-center rounded-full bg-surface-white",
          o.value
        ])
      }, [
        G("div", {
          class: _e(s.value)
        }, [
          ue(c.$slots, "indicator")
        ], 2)
      ], 2)) : ge("", !0)
    ], 2));
  }
}), dUe = /* @__PURE__ */ ve({
  __name: "Badge",
  props: {
    theme: { default: "gray" },
    size: { default: "md" },
    variant: { default: "subtle" },
    label: {}
  },
  setup(n) {
    const e = n, t = K(() => {
      let r = {
        gray: "text-ink-white bg-surface-gray-7",
        blue: "text-ink-blue-1 bg-surface-blue-2",
        green: "text-ink-green-1 bg-surface-green-3",
        orange: "text-ink-amber-1 bg-surface-amber-2",
        red: "text-ink-red-1 bg-surface-red-4"
      }[e.theme], i = {
        gray: "text-ink-gray-6 bg-surface-gray-2",
        blue: "text-ink-blue-2 bg-surface-blue-1",
        green: "text-ink-green-3 bg-surface-green-2",
        orange: "text-ink-amber-3 bg-surface-amber-1",
        red: "text-ink-red-4 bg-surface-red-1"
      }[e.theme], a = {
        gray: "text-ink-gray-6 bg-transparent border border-outline-gray-1",
        blue: "text-ink-blue-2 bg-transparent border border-outline-blue-1",
        green: "text-ink-green-3 bg-transparent border border-outline-green-2",
        orange: "text-ink-amber-3 bg-transparent border border-outline-amber-2",
        red: "text-ink-red-4 bg-transparent border border-outline-red-2"
      }[e.theme], o = {
        gray: "text-ink-gray-6 bg-transparent",
        blue: "text-ink-blue-2 bg-transparent",
        green: "text-ink-green-3 bg-transparent",
        orange: "text-ink-amber-3 bg-transparent",
        red: "text-ink-red-4 bg-transparent"
      }[e.theme], s = {
        subtle: i,
        solid: r,
        outline: a,
        ghost: o
      }[e.variant], l = {
        sm: "h-4 text-xs px-1.5",
        md: "h-5 text-xs px-1.5",
        lg: "h-6 text-sm px-2"
      }[e.size];
      return [s, l];
    });
    return (r, i) => (L(), W("div", {
      class: _e(["inline-flex select-none items-center gap-1 rounded-full", t.value])
    }, [
      r.$slots.prefix ? (L(), W("div", {
        key: 0,
        class: _e([e.size == "lg" ? "max-h-6" : "max-h-4"])
      }, [
        ue(r.$slots, "prefix")
      ], 2)) : ge("", !0),
      ue(r.$slots, "default", {}, () => {
        var a;
        return [
          gn(ke((a = e.label) == null ? void 0 : a.toString()), 1)
        ];
      }),
      r.$slots.suffix ? (L(), W("div", {
        key: 1,
        class: _e([e.size == "lg" ? "max-h-6" : "max-h-4"])
      }, [
        ue(r.$slots, "suffix")
      ], 2)) : ge("", !0)
    ], 2));
  }
});
function YV(n) {
  return V_() ? (xg(n), !0) : !1;
}
function _d(n) {
  return typeof n == "function" ? n() : O(n);
}
const mae = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const gae = Object.prototype.toString, yae = (n) => gae.call(n) === "[object Object]", OT = () => {
};
function bae(n, e) {
  function t(...r) {
    return new Promise((i, a) => {
      Promise.resolve(n(() => e.apply(this, r), { fn: e, thisArg: this, args: r })).then(i).catch(a);
    });
  }
  return t;
}
function _ae(n, e = {}) {
  let t, r, i = OT;
  const a = (s) => {
    clearTimeout(s), i(), i = OT;
  };
  return (s) => {
    const l = _d(n), u = _d(e.maxWait);
    return t && a(t), l <= 0 || u !== void 0 && u <= 0 ? (r && (a(r), r = null), Promise.resolve(s())) : new Promise((c, d) => {
      i = e.rejectOnCancel ? d : c, u && !r && (r = setTimeout(() => {
        t && a(t), r = null, c(s());
      }, u)), t = setTimeout(() => {
        r && a(r), r = null, c(s());
      }, l);
    });
  };
}
function xae(n, e) {
  var t;
  if (typeof n == "number")
    return n + e;
  const r = ((t = n.match(/^-?\d+\.?\d*/)) == null ? void 0 : t[0]) || "", i = n.slice(r.length), a = Number.parseFloat(r) + e;
  return Number.isNaN(a) ? n : a + i;
}
function wae(n) {
  return ro();
}
function Sae(n, e = 200, t = {}) {
  return bae(
    _ae(e, t),
    n
  );
}
function Eae(n, e = !0, t) {
  wae() ? kt(n, t) : e ? n() : Wt(n);
}
function Tae(n) {
  var e;
  const t = _d(n);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const lx = mae ? window : void 0;
function Cae(...n) {
  let e, t, r, i;
  if (typeof n[0] == "string" || Array.isArray(n[0]) ? ([t, r, i] = n, e = lx) : [e, t, r, i] = n, !e)
    return OT;
  Array.isArray(t) || (t = [t]), Array.isArray(r) || (r = [r]);
  const a = [], o = () => {
    a.forEach((c) => c()), a.length = 0;
  }, s = (c, d, f, p) => (c.addEventListener(d, f, p), () => c.removeEventListener(d, f, p)), l = et(
    () => [Tae(e), _d(i)],
    ([c, d]) => {
      if (o(), !c)
        return;
      const f = yae(d) ? { ...d } : d;
      a.push(
        ...t.flatMap((p) => r.map((h) => s(c, p, h, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    l(), o();
  };
  return YV(u), u;
}
function kae() {
  const n = Z(!1), e = ro();
  return e && kt(() => {
    n.value = !0;
  }, e), n;
}
function Aae(n) {
  const e = kae();
  return K(() => (e.value, !!n()));
}
function Gf(n, e = {}) {
  const { window: t = lx } = e, r = Aae(() => t && "matchMedia" in t && typeof t.matchMedia == "function");
  let i;
  const a = Z(!1), o = (u) => {
    a.value = u.matches;
  }, s = () => {
    i && ("removeEventListener" in i ? i.removeEventListener("change", o) : i.removeListener(o));
  }, l = Cn(() => {
    r.value && (s(), i = t.matchMedia(_d(n)), "addEventListener" in i ? i.addEventListener("change", o) : i.addListener(o), a.value = i.matches);
  });
  return YV(() => {
    l(), s(), i = void 0;
  }), a;
}
const Mae = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536
};
function Dae(n, e = {}) {
  function t(c, d) {
    let f = _d(n[_d(c)]);
    return d != null && (f = xae(f, d)), typeof f == "number" && (f = `${f}px`), f;
  }
  const { window: r = lx, strategy: i = "min-width" } = e;
  function a(c) {
    return r ? r.matchMedia(c).matches : !1;
  }
  const o = (c) => Gf(() => `(min-width: ${t(c)})`, e), s = (c) => Gf(() => `(max-width: ${t(c)})`, e), l = Object.keys(n).reduce((c, d) => (Object.defineProperty(c, d, {
    get: () => i === "min-width" ? o(d) : s(d),
    enumerable: !0,
    configurable: !0
  }), c), {});
  function u() {
    const c = Object.keys(n).map((d) => [d, o(d)]);
    return K(() => c.filter(([, d]) => d.value).map(([d]) => d));
  }
  return Object.assign(l, {
    greaterOrEqual: o,
    smallerOrEqual: s,
    greater(c) {
      return Gf(() => `(min-width: ${t(c, 0.1)})`, e);
    },
    smaller(c) {
      return Gf(() => `(max-width: ${t(c, -0.1)})`, e);
    },
    between(c, d) {
      return Gf(() => `(min-width: ${t(c)}) and (max-width: ${t(d, -0.1)})`, e);
    },
    isGreater(c) {
      return a(`(min-width: ${t(c, 0.1)})`);
    },
    isGreaterOrEqual(c) {
      return a(`(min-width: ${t(c)})`);
    },
    isSmaller(c) {
      return a(`(max-width: ${t(c, -0.1)})`);
    },
    isSmallerOrEqual(c) {
      return a(`(max-width: ${t(c)})`);
    },
    isInBetween(c, d) {
      return a(`(min-width: ${t(c)}) and (max-width: ${t(d, -0.1)})`);
    },
    current: u,
    active() {
      const c = u();
      return K(() => c.value.length === 0 ? "" : c.value.at(-1));
    }
  });
}
function Oae(n = {}) {
  const {
    window: e = lx,
    initialWidth: t = Number.POSITIVE_INFINITY,
    initialHeight: r = Number.POSITIVE_INFINITY,
    listenOrientation: i = !0,
    includeScrollbar: a = !0
  } = n, o = Z(t), s = Z(r), l = () => {
    e && (a ? (o.value = e.innerWidth, s.value = e.innerHeight) : (o.value = e.document.documentElement.clientWidth, s.value = e.document.documentElement.clientHeight));
  };
  if (l(), Eae(l), Cae("resize", l, { passive: !0 }), i) {
    const u = Gf("(orientation: portrait)");
    et(u, () => l());
  }
  return { width: o, height: s };
}
const Iae = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "Dropdown",
  props: {
    button: {},
    options: { default: () => [] },
    placement: { default: "left" }
  },
  setup(n) {
    const e = Z(!1), t = sx(), r = $d(), i = n;
    function a() {
      e.value = !1;
    }
    const o = (_) => {
      _.route ? t.push(_.route) : _.onClick && _.onClick();
    }, s = (_) => ({
      ..._,
      label: _.label,
      theme: _.theme || "gray",
      icon: _.icon,
      component: _.component,
      onClick: () => o(_),
      submenu: _.submenu
    }), l = (_) => _.theme === "red" ? "text-ink-red-3" : "text-ink-gray-6", u = (_) => _.theme === "red" ? "text-ink-red-3" : "text-ink-gray-7", c = (_) => _.theme === "red" ? "focus:bg-surface-red-3 data-[highlighted]:bg-surface-red-3 data-[state=open]:bg-surface-red-3" : "focus:bg-surface-gray-3 data-[highlighted]:bg-surface-gray-3 data-[state=open]:bg-surface-gray-3", d = (_) => c(_) + " data-[state=open]:bg-surface-" + (_.theme === "red" ? "red-3" : "gray-3"), f = (_) => {
      let x = [], w = null, S = 0;
      for (let C of _)
        if (C != null) {
          if ("group" in C) {
            w && (x.push(w), w = null);
            let k = {
              key: S,
              ...C,
              items: h(C.items)
            };
            x.push(k);
          } else
            w || (w = {
              key: S,
              group: "",
              hideLabel: !0,
              items: []
            }), w.items.push(...h([C]));
          S++;
        }
      return w && x.push(w), x;
    }, p = (_) => f(_), h = (_) => (_ || []).filter(Boolean).filter((x) => x.condition ? x.condition() : !0).map((x) => s(x)), v = (_) => _.items.some((x) => x.icon), m = {
      // Container classes
      dropdownContent: "min-w-40 divide-y divide-outline-gray-modals rounded-lg bg-surface-modal shadow-2xl ring-1 ring-black ring-opacity-5 focus:outline-none dropdown-content",
      groupContainer: "p-1.5",
      // Label classes
      groupLabel: "flex h-7 items-center px-2 text-sm font-medium",
      itemLabel: "whitespace-nowrap",
      // Icon classes
      itemIcon: "mr-2 h-4 w-4 flex-shrink-0",
      itemIconPlaceholder: "mr-2 h-4 w-4 flex-shrink-0",
      chevronIcon: "ml-auto h-4 w-4 flex-shrink-0",
      // Button classes
      itemButton: "group flex h-7 w-full items-center rounded px-2 text-base focus:outline-none",
      submenuTrigger: "group flex h-7 w-full items-center rounded px-2 text-base text-ink-gray-6 focus:outline-none"
    }, g = K(() => f(i.options)), y = K(() => "bottom"), b = K(() => i.placement === "left" ? "start" : i.placement === "right" ? "end" : i.placement === "center" ? "center" : "start");
    return (_, x) => (L(), re(O(qre), {
      open: e.value,
      "onUpdate:open": x[0] || (x[0] = (w) => e.value = w)
    }, {
      default: ee(({ open: w }) => [
        se(O(oie), { "as-child": "" }, {
          default: ee(() => [
            _.$slots.default ? ue(_.$slots, "default", Bt(He({ key: 0 }, { open: w, close: a, ...O(r) })), void 0, !0) : (L(), re(O(fn), He({
              key: 1,
              active: !1
            }, { ..._.button, ...O(r) }), {
              default: ee(() => {
                var S;
                return [
                  gn(ke(_.button ? ((S = _.button) == null ? void 0 : S.label) || null : "Options"), 1)
                ];
              }),
              _: 1
            }, 16))
          ]),
          _: 2
        }, 1024),
        se(O(OL), null, {
          default: ee(() => [
            se(O(Kre), {
              class: _e([
                m.dropdownContent,
                {
                  "origin-top-left": _.placement == "left",
                  "origin-top-right": _.placement == "right",
                  "origin-top": _.placement == "center"
                }
              ]),
              side: y.value,
              align: b.value,
              "side-offset": 4
            }, {
              default: ee(() => [
                (L(!0), W(Ke, null, _t(g.value, (S) => (L(), W(Ke, {
                  key: S.key
                }, [
                  S.items.length ? (L(), W("div", {
                    key: 0,
                    class: _e(m.groupContainer)
                  }, [
                    S.group && !S.hideLabel ? (L(), re(O(DL), {
                      key: 0,
                      class: _e([m.groupLabel, u(S)])
                    }, {
                      default: ee(() => [
                        gn(ke(S.group), 1)
                      ]),
                      _: 2
                    }, 1032, ["class"])) : ge("", !0),
                    (L(!0), W(Ke, null, _t(S.items, (C) => (L(), re(O(ML), {
                      key: C.label,
                      "as-child": "",
                      onSelect: C.onClick
                    }, {
                      default: ee(() => [
                        _.$slots.item ? ue(_.$slots, "item", He({
                          key: 0,
                          ref_for: !0
                        }, { item: C, close: a }), void 0, !0) : C.component ? (L(), re(bn(C.component), {
                          key: 1,
                          active: !1
                        })) : C.submenu ? (L(), re(O(eie), { key: 2 }, {
                          default: ee(() => [
                            se(O(iie), { "as-child": "" }, {
                              default: ee(() => [
                                G("button", {
                                  class: _e([
                                    m.submenuTrigger,
                                    d(C)
                                  ])
                                }, [
                                  C.icon && typeof C.icon == "string" ? (L(), re(En, {
                                    key: 0,
                                    name: C.icon,
                                    class: _e([m.itemIcon, l(C)]),
                                    "aria-hidden": "true"
                                  }, null, 8, ["name", "class"])) : C.icon ? (L(), re(bn(C.icon), {
                                    key: 1,
                                    class: _e([m.itemIcon, l(C)])
                                  }, null, 8, ["class"])) : v(S) ? (L(), W("div", {
                                    key: 2,
                                    class: _e(m.itemIconPlaceholder)
                                  }, null, 2)) : ge("", !0),
                                  G("span", {
                                    class: _e([m.itemLabel, u(C)])
                                  }, ke(C.label), 3),
                                  se(En, {
                                    name: "chevron-right",
                                    class: _e([m.chevronIcon, l(C)]),
                                    "aria-hidden": "true"
                                  }, null, 8, ["class"])
                                ], 2)
                              ]),
                              _: 2
                            }, 1024),
                            se(O(OL), null, {
                              default: ee(() => [
                                se(O(nie), {
                                  class: _e(m.dropdownContent),
                                  "side-offset": 4
                                }, {
                                  default: ee(() => [
                                    (L(!0), W(Ke, null, _t(p(C.submenu), (k) => (L(), W("div", {
                                      key: k.key,
                                      class: _e(m.groupContainer)
                                    }, [
                                      k.group && !k.hideLabel ? (L(), re(O(DL), {
                                        key: 0,
                                        class: _e(m.groupLabel)
                                      }, {
                                        default: ee(() => [
                                          gn(ke(k.group), 1)
                                        ]),
                                        _: 2
                                      }, 1032, ["class"])) : ge("", !0),
                                      (L(!0), W(Ke, null, _t(k.items, (M) => (L(), re(O(ML), {
                                        key: M.label,
                                        "as-child": "",
                                        onSelect: () => o(M)
                                      }, {
                                        default: ee(() => [
                                          M.component ? (L(), re(bn(M.component), {
                                            key: 0,
                                            active: !1
                                          })) : (L(), W("button", {
                                            key: 1,
                                            class: _e([
                                              m.itemButton,
                                              c(M)
                                            ])
                                          }, [
                                            M.icon && typeof M.icon == "string" ? (L(), re(En, {
                                              key: 0,
                                              name: M.icon,
                                              class: _e([
                                                m.itemIcon,
                                                l(M)
                                              ]),
                                              "aria-hidden": "true"
                                            }, null, 8, ["name", "class"])) : M.icon ? (L(), re(bn(M.icon), {
                                              key: 1,
                                              class: _e([
                                                m.itemIcon,
                                                l(M)
                                              ])
                                            }, null, 8, ["class"])) : v(k) ? (L(), W("div", {
                                              key: 2,
                                              class: _e(m.itemIconPlaceholder)
                                            }, null, 2)) : ge("", !0),
                                            G("span", {
                                              class: _e([
                                                m.itemLabel,
                                                u(M)
                                              ])
                                            }, ke(M.label), 3)
                                          ], 2))
                                        ]),
                                        _: 2
                                      }, 1032, ["onSelect"]))), 128))
                                    ], 2))), 128))
                                  ]),
                                  _: 2
                                }, 1032, ["class"])
                              ]),
                              _: 2
                            }, 1024)
                          ]),
                          _: 2
                        }, 1024)) : (L(), W("button", {
                          key: 3,
                          class: _e([m.itemButton, c(C)])
                        }, [
                          C.icon && typeof C.icon == "string" ? (L(), re(En, {
                            key: 0,
                            name: C.icon,
                            class: _e([m.itemIcon, l(C)]),
                            "aria-hidden": "true"
                          }, null, 8, ["name", "class"])) : C.icon ? (L(), re(bn(C.icon), {
                            key: 1,
                            class: _e([m.itemIcon, l(C)])
                          }, null, 8, ["class"])) : v(S) ? (L(), W("div", {
                            key: 2,
                            class: _e(m.itemIconPlaceholder)
                          }, null, 2)) : ge("", !0),
                          G("span", {
                            class: _e([m.itemLabel, u(C)])
                          }, ke(C.label), 3)
                        ], 2))
                      ]),
                      _: 2
                    }, 1032, ["onSelect"]))), 128))
                  ], 2)) : ge("", !0)
                ], 64))), 128))
              ]),
              _: 3
            }, 8, ["class", "side", "align"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), zt = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [r, i] of e)
    t[r] = i;
  return t;
}, KV = /* @__PURE__ */ zt(Iae, [["__scopeId", "data-v-e3641362"]]), Lae = { class: "flex min-w-0 items-center" }, Nae = { class: "flex min-w-0 items-center overflow-hidden text-ellipsis whitespace-nowrap" }, Rae = ["onClick"], Pae = {
  key: 2,
  class: "mx-0.5 text-base text-ink-gray-4",
  "aria-hidden": "true"
}, fUe = /* @__PURE__ */ ve({
  __name: "Breadcrumbs",
  props: {
    items: {}
  },
  setup(n) {
    const e = n, t = sx(), { width: r } = Oae(), i = K(() => (e.items || []).filter(Boolean)), a = K(() => r.value > 640 ? [] : i.value.slice(0, -2).map((l) => {
      let u = () => {
        l.onClick && l.onClick(), l.route && t.push(l.route);
      };
      return {
        ...l,
        icon: null,
        label: l.label,
        onClick: u
      };
    })), o = K(() => r.value > 640 ? i.value : i.value.slice(-2));
    return (s, l) => {
      const u = ol("router-link");
      return L(), W("div", Lae, [
        a.value.length ? (L(), W(Ke, { key: 0 }, [
          se(O(KV), {
            class: "h-7",
            options: a.value
          }, {
            default: ee(() => [
              se(O(fn), { variant: "ghost" }, {
                icon: ee(() => [...l[0] || (l[0] = [
                  G("svg", {
                    class: "w-4 text-ink-gray-5",
                    xmlns: "http://www.w3.org/2000/svg",
                    width: "24",
                    height: "24",
                    viewBox: "0 0 24 24",
                    fill: "none",
                    stroke: "currentColor",
                    "stroke-width": "2",
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round"
                  }, [
                    G("circle", {
                      cx: "12",
                      cy: "12",
                      r: "1"
                    }),
                    G("circle", {
                      cx: "19",
                      cy: "12",
                      r: "1"
                    }),
                    G("circle", {
                      cx: "5",
                      cy: "12",
                      r: "1"
                    })
                  ], -1)
                ])]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["options"]),
          l[1] || (l[1] = G("span", {
            class: "ml-1 mr-0.5 text-base text-ink-gray-4",
            "aria-hidden": "true"
          }, " / ", -1))
        ], 64)) : ge("", !0),
        G("div", Nae, [
          (L(!0), W(Ke, null, _t(o.value, (c, d) => (L(), W(Ke, {
            key: c.label
          }, [
            c.route ? (L(), re(u, {
              key: 0,
              to: c.route,
              onClick: (f) => c.onClick ? c.onClick() : null,
              class: _e(["flex items-center rounded px-0.5 py-1 text-lg font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-outline-gray-3", [
                d == o.value.length - 1 ? "text-ink-gray-9" : "text-ink-gray-5 hover:text-ink-gray-7"
              ]])
            }, {
              default: ee(() => [
                ue(s.$slots, "prefix", { item: c }),
                G("span", null, ke(c.label), 1),
                ue(s.$slots, "suffix", { item: c })
              ]),
              _: 2
            }, 1032, ["to", "onClick", "class"])) : (L(), W("button", {
              key: 1,
              onClick: (f) => c.onClick ? c.onClick() : null,
              class: _e(["flex items-center rounded px-0.5 py-1 text-lg font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-outline-gray-3", [
                d == o.value.length - 1 ? "text-ink-gray-9" : "text-ink-gray-5 hover:text-ink-gray-7"
              ]])
            }, [
              ue(s.$slots, "prefix", { item: c }),
              G("span", null, ke(c.label), 1),
              ue(s.$slots, "suffix", { item: c })
            ], 10, Rae)),
            d != o.value.length - 1 ? (L(), W("span", Pae, " / ")) : ge("", !0)
          ], 64))), 128))
        ])
      ]);
    };
  }
}), jae = {
  name: "Loading",
  props: {
    text: {
      type: String,
      default: "Loading..."
    }
  },
  components: {
    LoadingIndicator: nh
  }
}, Bae = { class: "flex items-center text-base text-ink-gray-4" };
function $ae(n, e, t, r, i, a) {
  const o = nh;
  return L(), W("div", Bae, [
    se(o, { class: "-ml-1 mr-2 h-3 w-3" }),
    gn(" " + ke(t.text), 1)
  ]);
}
const XV = /* @__PURE__ */ zt(jae, [["render", $ae]]), zae = {
  name: "Card",
  props: {
    title: {
      type: String
    },
    subtitle: {
      type: String
    },
    loading: {
      type: Boolean
    }
  },
  components: {
    LoadingText: XV
  }
}, Fae = { class: "flex flex-col rounded-lg border bg-white px-6 py-5 shadow" }, Vae = { class: "flex items-baseline justify-between" }, Hae = { class: "flex items-baseline space-x-2" }, Gae = {
  key: 0,
  class: "flex items-center space-x-2"
}, Uae = { class: "text-xl font-semibold" }, Wae = {
  key: 0,
  class: "flex items-center space-x-2"
}, qae = {
  key: 0,
  class: "mt-1.5 text-base text-gray-600"
}, Yae = {
  key: 1,
  class: "mt-4 flex flex-auto flex-col items-center justify-center rounded-md"
}, Kae = {
  key: 2,
  class: "mt-4 flex-auto overflow-auto"
};
function Xae(n, e, t, r, i, a) {
  const o = XV;
  return L(), W("div", Fae, [
    G("div", Vae, [
      G("div", Hae, [
        n.$slots["actions-left"] ? (L(), W("div", Gae, [
          ue(n.$slots, "actions-left")
        ])) : ge("", !0),
        G("h2", Uae, ke(t.title), 1)
      ]),
      n.$slots.actions ? (L(), W("div", Wae, [
        ue(n.$slots, "actions")
      ])) : ge("", !0)
    ]),
    t.subtitle ? (L(), W("p", qae, ke(t.subtitle), 1)) : ge("", !0),
    t.loading ? (L(), W("div", Yae, [
      se(o)
    ])) : n.$slots.default ? (L(), W("div", Kae, [
      ue(n.$slots, "default")
    ])) : ge("", !0)
  ]);
}
const pUe = /* @__PURE__ */ zt(zae, [["render", Xae]]), Zae = {
  class: "lucide lucide-check",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Jae(n, e) {
  return L(), W("svg", Zae, [...e[0] || (e[0] = [
    G("path", { d: "M20 6 9 17l-5-5" }, null, -1)
  ])]);
}
const IT = cn({ name: "lucide-check", render: Jae }), Qae = {
  class: "lucide lucide-chevron-down",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function eoe(n, e) {
  return L(), W("svg", Qae, [...e[0] || (e[0] = [
    G("path", { d: "m6 9 6 6 6-6" }, null, -1)
  ])]);
}
const ZV = cn({ name: "lucide-chevron-down", render: eoe }), toe = { class: "relative" }, noe = { class: "flex items-center gap-2 flex-1 overflow-hidden" }, roe = { class: "flex items-center gap-2 pr-6 flex-1" }, ioe = { class: "flex items-center gap-2 pr-6 flex-1" }, hUe = /* @__PURE__ */ ve({
  __name: "Combobox",
  props: {
    options: {},
    modelValue: {},
    placeholder: {},
    disabled: { type: Boolean }
  },
  emits: [
    "update:modelValue",
    "update:selectedOption",
    "focus",
    "blur"
  ],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Z(v(t.modelValue)), a = Z(t.modelValue), o = Z(!1), s = Z(!1);
    et(
      () => t.modelValue,
      (k) => {
        a.value = k, i.value = v(k);
      }
    );
    const l = (k) => {
      a.value = k, r("update:modelValue", k), i.value = v(k), s.value = !1;
      const M = k && h.value.find((D) => d(D) === k) || null;
      r("update:selectedOption", M);
    };
    function u(k) {
      return typeof k == "object" && "group" in k;
    }
    function c(k) {
      return typeof k == "string" ? k : k.label;
    }
    function d(k) {
      return typeof k == "string" ? k : k.value;
    }
    function f(k) {
      return typeof k == "object" && !!k.disabled;
    }
    function p(k) {
      return typeof k == "object" ? k.icon : void 0;
    }
    const h = K(() => {
      const k = [];
      return t.options.forEach((M) => {
        u(M) ? k.push(...M.options) : k.push(M);
      }), k;
    });
    function v(k) {
      if (!k) return "";
      const D = t.options.flatMap(
        (N) => u(N) ? N.options : N
      ).find((N) => d(N) === k);
      return D ? c(D) : k || "";
    }
    const m = K(() => a.value ? h.value.find(
      (k) => d(k) === a.value
    ) : null), g = K(() => m.value ? p(m.value) : void 0), y = (k) => {
      if (!k.icon) return null;
      const M = typeof k.icon == "string" ? qt("span", k.icon) : qt(k.icon, { class: "w-4 h-4" });
      return qt(
        "span",
        {
          class: "flex-shrink-0 w-4 h-4 inline-flex items-center justify-center"
        },
        [M]
      );
    }, b = (k, M) => {
      if (!M) return k;
      const D = M.toLowerCase(), N = [];
      return k.forEach((R) => {
        if (u(R)) {
          const j = R.options.filter((z) => {
            const F = c(z).toLowerCase(), B = d(z).toLowerCase();
            return F.includes(D) || B.includes(D);
          });
          j.length > 0 && N.push({ ...R, options: j });
        } else {
          const j = c(R).toLowerCase(), z = d(R).toLowerCase();
          (j.includes(D) || z.includes(D)) && N.push(R);
        }
      }), N;
    }, _ = K(() => o.value && !s.value && a.value ? t.options : b(t.options, i.value)), x = (k) => {
      const M = k.target;
      i.value = M.value, s.value = !0, i.value === "" && (a.value = null, r("update:modelValue", null));
    }, w = (k) => {
      o.value = k, k || (i.value = v(a.value)), s.value = !1;
    }, S = (k) => {
      r("focus", k);
    }, C = (k) => {
      r("blur", k);
    };
    return (k, M) => (L(), W("div", toe, [
      se(O(Lne), {
        "model-value": a.value,
        "onUpdate:modelValue": l,
        "onUpdate:open": w,
        "ignore-filter": !0
      }, {
        default: ee(() => [
          se(O(fne), {
            class: _e(["flex h-7 w-full items-center justify-between gap-2 rounded bg-surface-gray-2 px-2 py-1 transition-colors hover:bg-surface-gray-3 border border-transparent focus-within:border-outline-gray-4 focus-within:ring-2 focus-within:ring-outline-gray-3", { "opacity-50 pointer-events-none": k.disabled }])
          }, {
            default: ee(() => [
              G("div", noe, [
                g.value ? (L(), re(y, {
                  key: 0,
                  icon: g.value
                }, null, 8, ["icon"])) : ge("", !0),
                se(O(Une), {
                  value: i.value,
                  onInput: x,
                  onFocus: S,
                  onBlur: C,
                  class: "bg-transparent p-0 focus:outline-0 border-0 focus:border-0 focus:ring-0 text-base text-ink-gray-8 h-full placeholder:text-ink-gray-4 w-full",
                  placeholder: k.placeholder || "",
                  disabled: k.disabled,
                  autocomplete: "off"
                }, null, 8, ["value", "placeholder", "disabled"])
              ]),
              se(O(Qne), { disabled: k.disabled }, {
                default: ee(() => [
                  se(O(ZV), { class: "h-4 w-4 text-ink-gray-5" })
                ]),
                _: 1
              }, 8, ["disabled"])
            ]),
            _: 1
          }, 8, ["class"]),
          se(O(Zne), null, {
            default: ee(() => [
              se(O(Bne), {
                class: "z-10 min-w-[--reka-combobox-trigger-width] mt-1 bg-surface-modal overflow-hidden rounded-lg shadow-2xl",
                position: "popper",
                onOpenAutoFocus: M[0] || (M[0] = xt(() => {
                }, ["prevent"])),
                onCloseAutoFocus: M[1] || (M[1] = xt(() => {
                }, ["prevent"])),
                align: "start"
              }, {
                default: ee(() => [
                  se(O(nre), {
                    class: _e(["max-h-60 overflow-auto pb-1.5", { "px-1.5 pt-1.5": !u(_.value[0]) }])
                  }, {
                    default: ee(() => [
                      se(O(zne), { class: "text-ink-gray-5 text-base text-center py-1.5 px-2.5" }, {
                        default: ee(() => [
                          gn(' No results found for "' + ke(i.value) + '" ', 1)
                        ]),
                        _: 1
                      }),
                      (L(!0), W(Ke, null, _t(_.value, (D, N) => (L(), W(Ke, { key: N }, [
                        u(D) ? (L(), re(O(Hne), {
                          key: 0,
                          class: "px-1.5"
                        }, {
                          default: ee(() => [
                            se(O(Kne), { class: "px-2.5 pt-3 pb-1.5 text-sm font-medium text-ink-gray-5 sticky top-0 bg-surface-modal z-10" }, {
                              default: ee(() => [
                                gn(ke(D.group), 1)
                              ]),
                              _: 2
                            }, 1024),
                            (L(!0), W(Ke, null, _t(D.options, (R, j) => (L(), re(O(kL), {
                              key: `${N}-${j}`,
                              value: d(R),
                              disabled: f(R),
                              class: "text-base leading-none text-ink-gray-7 rounded flex items-center h-7 px-2.5 py-1.5 relative select-none data-[disabled]:opacity-50 data-[disabled]:pointer-events-none data-[highlighted]:outline-none data-[highlighted]:bg-surface-gray-3"
                            }, {
                              default: ee(() => [
                                G("span", roe, [
                                  se(y, {
                                    icon: p(R)
                                  }, null, 8, ["icon"]),
                                  gn(" " + ke(c(R)), 1)
                                ]),
                                se(O(AL), { class: "inline-flex ml-2 items-center justify-center" }, {
                                  default: ee(() => [
                                    se(O(IT), { class: "size-4" })
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 2
                            }, 1032, ["value", "disabled"]))), 128))
                          ]),
                          _: 2
                        }, 1024)) : (L(), re(O(kL), {
                          key: N,
                          value: d(D),
                          disabled: f(D),
                          class: "text-base leading-none text-ink-gray-7 rounded flex items-center h-7 px-2.5 py-1.5 relative select-none data-[disabled]:opacity-50 data-[disabled]:pointer-events-none data-[highlighted]:outline-none data-[highlighted]:bg-surface-gray-3"
                        }, {
                          default: ee(() => [
                            G("span", ioe, [
                              p(D) ? (L(), re(y, {
                                key: 0,
                                icon: p(D)
                              }, null, 8, ["icon"])) : ge("", !0),
                              gn(" " + ke(c(D)), 1)
                            ]),
                            se(O(AL), { class: "absolute right-0 w-6 inline-flex items-center justify-center" }, {
                              default: ee(() => [
                                se(O(IT), { class: "h-4 w-4" })
                              ]),
                              _: 1
                            })
                          ]),
                          _: 2
                        }, 1032, ["value", "disabled"]))
                      ], 64))), 128))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["model-value"])
    ]));
  }
});
let aoe = 0;
function ooe() {
  return ++aoe;
}
function JV() {
  return ooe();
}
const soe = ["disabled", "id", "checked"], loe = ["for"], ux = /* @__PURE__ */ ve({
  __name: "Checkbox",
  props: {
    size: { default: "sm" },
    label: {},
    checked: { type: Boolean },
    disabled: { type: Boolean },
    padding: { type: Boolean, default: !1 },
    modelValue: { type: [Boolean, Number] },
    id: {}
  },
  setup(n) {
    const e = n, t = $d(), r = e.id ?? JV(), i = K(() => [
      {
        sm: "text-base font-medium",
        md: "text-lg font-medium"
      }[e.size],
      e.disabled ? "text-ink-gray-4" : "text-ink-gray-8",
      "select-none"
    ]), a = K(() => {
      let o = e.disabled ? "border-outline-gray-2 bg-surface-menu-bar text-ink-gray-3" : "border-outline-gray-4 text-ink-gray-9 hover:border-gray-600 focus:ring-offset-0 focus:border-gray-900 active:border-gray-700 transition", s = e.disabled ? "" : e.padding ? "focus:ring-0" : "hover:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3 active:bg-surface-gray-2", l = {
        sm: "w-3.5 h-3.5",
        md: "w-4 h-4"
      }[e.size];
      return [o, s, l];
    });
    return (o, s) => (L(), W("div", {
      class: _e(["inline-flex space-x-2 rounded transition", {
        "px-2.5 py-1.5": o.padding && o.size === "sm",
        "px-3 py-2": o.padding && o.size === "md",
        "focus-within:bg-surface-gray-2 focus-within:ring-2 focus-within:ring-outline-gray-3 hover:bg-surface-gray-3 active:bg-surface-gray-4": o.padding && !o.disabled
      }])
    }, [
      G("input", He({
        class: ["rounded-sm mt-[1px]", a.value],
        type: "checkbox",
        disabled: o.disabled,
        id: O(r),
        checked: !!o.modelValue,
        onChange: s[0] || (s[0] = (l) => o.$emit("update:modelValue", l.target.checked))
      }, O(t)), null, 16, soe),
      o.label ? (L(), W("label", {
        key: 0,
        class: _e(["block", i.value]),
        for: O(r)
      }, ke(o.label), 11, loe)) : ge("", !0)
    ], 2));
  }
});
function cx(n, e, t) {
  var r;
  return function() {
    var i = this, a = arguments, o = function() {
      r = void 0, t || n.apply(i, a);
    }, s = t && !r;
    clearTimeout(r), r = window.setTimeout(o, e), s && n.apply(i, a);
  };
}
const uoe = ["type", "placeholder", "disabled", "id", "value", "required"], Ga = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "TextInput",
  props: {
    type: { default: "text" },
    size: { default: "sm" },
    variant: { default: "subtle" },
    placeholder: {},
    disabled: { type: Boolean },
    id: {},
    modelValue: {},
    debounce: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(n, { expose: e, emit: t }) {
    const r = n, i = t, a = Xp(), o = $d(), s = K(() => Object.fromEntries(
      // class and style is passed to the root element
      Object.entries(o).filter(([v]) => v !== "class" && v !== "style")
    )), l = Z(null);
    e({ el: l });
    const u = K(() => r.disabled ? "text-ink-gray-5" : "text-ink-gray-8"), c = K(() => {
      let v = {
        sm: "text-base rounded h-7",
        md: "text-base rounded h-8",
        lg: "text-lg rounded-md h-10",
        xl: "text-xl rounded-md h-10"
      }[r.size], m = {
        sm: [
          "py-1.5",
          a.prefix ? "pl-8" : "pl-2",
          a.suffix ? "pr-8" : "pr-2"
        ],
        md: [
          "py-1.5",
          a.prefix ? "pl-9" : "pl-2.5",
          a.suffix ? "pr-9" : "pr-2.5"
        ],
        lg: [
          "py-1.5",
          a.prefix ? "pl-10" : "pl-3",
          a.suffix ? "pr-10" : "pr-3"
        ],
        xl: [
          "py-1.5",
          a.prefix ? "pl-10" : "pl-3",
          a.suffix ? "pr-10" : "pr-3"
        ]
      }[r.size], g = r.disabled ? "disabled" : r.variant, y = {
        subtle: "border border-[--surface-gray-2] bg-surface-gray-2 placeholder-ink-gray-4 hover:border-outline-gray-modals hover:bg-surface-gray-3 focus:bg-surface-white focus:border-outline-gray-4 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3",
        outline: "border border-outline-gray-2 bg-surface-white placeholder-ink-gray-4 hover:border-outline-gray-3 hover:shadow-sm focus:bg-surface-white focus:border-outline-gray-4 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3",
        disabled: [
          "border bg-surface-gray-1 placeholder-ink-gray-3",
          r.variant === "outline" ? "border-outline-gray-2" : "border-transparent"
        ]
      }[g];
      return [
        v,
        m,
        y,
        u.value,
        "transition-colors w-full dark:[color-scheme:dark]"
      ];
    });
    let d = K(() => ({
      sm: "pl-2",
      md: "pl-2.5",
      lg: "pl-3",
      xl: "pl-3"
    })[r.size]), f = K(() => ({
      sm: "pr-2",
      md: "pr-2.5",
      lg: "pr-3",
      xl: "pr-3"
    })[r.size]), p = (v) => {
      i("update:modelValue", v);
    };
    r.debounce && (p = cx(p, r.debounce));
    let h = (v) => {
      p(v.target.value);
    };
    return (v, m) => (L(), W("div", {
      class: _e(["relative flex items-center", O(o).class]),
      style: An(O(o).style)
    }, [
      v.$slots.prefix ? (L(), W("div", {
        key: 0,
        class: _e([
          "absolute inset-y-0 left-0 flex items-center",
          u.value,
          O(d)
        ])
      }, [
        ue(v.$slots, "prefix")
      ], 2)) : ge("", !0),
      G("input", He({
        ref_key: "inputRef",
        ref: l,
        type: v.type,
        placeholder: v.placeholder,
        class: c.value,
        disabled: v.disabled,
        id: v.id,
        value: v.modelValue,
        required: v.required,
        onInput: m[0] || (m[0] = //@ts-ignore
        (...g) => O(h) && O(h)(...g)),
        onChange: m[1] || (m[1] = //@ts-ignore
        (...g) => O(h) && O(h)(...g))
      }, s.value), null, 16, uoe),
      v.$slots.suffix ? (L(), W("div", {
        key: 1,
        class: _e([
          "absolute inset-y-0 right-0 flex items-center",
          u.value,
          O(f)
        ])
      }, [
        ue(v.$slots, "suffix")
      ], 2)) : ge("", !0)
    ], 6));
  }
});
var QV = 60, e6 = QV * 60, t6 = e6 * 24, coe = t6 * 7, gl = 1e3, Jc = QV * gl, Em = e6 * gl, Tm = t6 * gl, n6 = coe * gl, dx = "millisecond", Bc = "second", is = "minute", $c = "hour", Ks = "day", n1 = "week", za = "month", r6 = "quarter", Xs = "year", ip = "date", rM = "YYYY-MM-DDTHH:mm:ssZ", $L = "Invalid Date", doe = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, i6 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
const foe = {
  name: "en",
  weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
  months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
  ordinal: function(e) {
    var t = ["th", "st", "nd", "rd"], r = e % 100;
    return "[" + e + (t[(r - 20) % 10] || t[r] || t[0]) + "]";
  }
};
var LT = function(e, t, r) {
  var i = String(e);
  return !i || i.length >= t ? e : "" + Array(t + 1 - i.length).join(r) + e;
}, poe = function(e) {
  var t = -e.utcOffset(), r = Math.abs(t), i = Math.floor(r / 60), a = r % 60;
  return (t <= 0 ? "+" : "-") + LT(i, 2, "0") + ":" + LT(a, 2, "0");
}, hoe = function n(e, t) {
  if (e.date() < t.date()) return -n(t, e);
  var r = (t.year() - e.year()) * 12 + (t.month() - e.month()), i = e.clone().add(r, za), a = t - i < 0, o = e.clone().add(r + (a ? -1 : 1), za);
  return +(-(r + (t - i) / (a ? i - o : o - i)) || 0);
}, voe = function(e) {
  return e < 0 ? Math.ceil(e) || 0 : Math.floor(e);
}, moe = function(e) {
  var t = {
    M: za,
    y: Xs,
    w: n1,
    d: Ks,
    D: ip,
    h: $c,
    m: is,
    s: Bc,
    ms: dx,
    Q: r6
  };
  return t[e] || String(e || "").toLowerCase().replace(/s$/, "");
}, goe = function(e) {
  return e === void 0;
};
const yoe = {
  s: LT,
  z: poe,
  m: hoe,
  a: voe,
  p: moe,
  u: goe
};
var Fv = "en", Qc = {};
Qc[Fv] = foe;
var a6 = "$isDayjsObject", iM = function(e) {
  return e instanceof fx || !!(e && e[a6]);
}, V1 = function n(e, t, r) {
  var i;
  if (!e) return Fv;
  if (typeof e == "string") {
    var a = e.toLowerCase();
    Qc[a] && (i = a), t && (Qc[a] = t, i = a);
    var o = e.split("-");
    if (!i && o.length > 1)
      return n(o[0]);
  } else {
    var s = e.name;
    Qc[s] = e, i = s;
  }
  return !r && i && (Fv = i), i || !r && Fv;
}, xn = function(e, t) {
  if (iM(e))
    return e.clone();
  var r = typeof t == "object" ? t : {};
  return r.date = e, r.args = arguments, new fx(r);
}, boe = function(e, t) {
  return xn(e, {
    locale: t.$L,
    utc: t.$u,
    x: t.$x,
    $offset: t.$offset
    // todo: refactor; do not use this.$offset in you code
  });
}, Bn = yoe;
Bn.l = V1;
Bn.i = iM;
Bn.w = boe;
var _oe = function(e) {
  var t = e.date, r = e.utc;
  if (t === null) return /* @__PURE__ */ new Date(NaN);
  if (Bn.u(t)) return /* @__PURE__ */ new Date();
  if (t instanceof Date) return new Date(t);
  if (typeof t == "string" && !/Z$/i.test(t)) {
    var i = t.match(doe);
    if (i) {
      var a = i[2] - 1 || 0, o = (i[7] || "0").substring(0, 3);
      return r ? new Date(Date.UTC(i[1], a, i[3] || 1, i[4] || 0, i[5] || 0, i[6] || 0, o)) : new Date(i[1], a, i[3] || 1, i[4] || 0, i[5] || 0, i[6] || 0, o);
    }
  }
  return new Date(t);
}, fx = /* @__PURE__ */ function() {
  function n(t) {
    this.$L = V1(t.locale, null, !0), this.parse(t), this.$x = this.$x || t.x || {}, this[a6] = !0;
  }
  var e = n.prototype;
  return e.parse = function(r) {
    this.$d = _oe(r), this.init();
  }, e.init = function() {
    var r = this.$d;
    this.$y = r.getFullYear(), this.$M = r.getMonth(), this.$D = r.getDate(), this.$W = r.getDay(), this.$H = r.getHours(), this.$m = r.getMinutes(), this.$s = r.getSeconds(), this.$ms = r.getMilliseconds();
  }, e.$utils = function() {
    return Bn;
  }, e.isValid = function() {
    return this.$d.toString() !== $L;
  }, e.isSame = function(r, i) {
    var a = xn(r);
    return this.startOf(i) <= a && a <= this.endOf(i);
  }, e.isAfter = function(r, i) {
    return xn(r) < this.startOf(i);
  }, e.isBefore = function(r, i) {
    return this.endOf(i) < xn(r);
  }, e.$g = function(r, i, a) {
    return Bn.u(r) ? this[i] : this.set(a, r);
  }, e.unix = function() {
    return Math.floor(this.valueOf() / 1e3);
  }, e.valueOf = function() {
    return this.$d.getTime();
  }, e.startOf = function(r, i) {
    var a = this, o = Bn.u(i) ? !0 : i, s = Bn.p(r), l = function(g, y) {
      var b = Bn.w(a.$u ? Date.UTC(a.$y, y, g) : new Date(a.$y, y, g), a);
      return o ? b : b.endOf(Ks);
    }, u = function(g, y) {
      var b = [0, 0, 0, 0], _ = [23, 59, 59, 999];
      return Bn.w(a.toDate()[g].apply(
        // eslint-disable-line prefer-spread
        a.toDate("s"),
        (o ? b : _).slice(y)
      ), a);
    }, c = this.$W, d = this.$M, f = this.$D, p = "set" + (this.$u ? "UTC" : "");
    switch (s) {
      case Xs:
        return o ? l(1, 0) : l(31, 11);
      case za:
        return o ? l(1, d) : l(0, d + 1);
      case n1: {
        var h = this.$locale().weekStart || 0, v = (c < h ? c + 7 : c) - h;
        return l(o ? f - v : f + (6 - v), d);
      }
      case Ks:
      case ip:
        return u(p + "Hours", 0);
      case $c:
        return u(p + "Minutes", 1);
      case is:
        return u(p + "Seconds", 2);
      case Bc:
        return u(p + "Milliseconds", 3);
      default:
        return this.clone();
    }
  }, e.endOf = function(r) {
    return this.startOf(r, !1);
  }, e.$set = function(r, i) {
    var a, o = Bn.p(r), s = "set" + (this.$u ? "UTC" : ""), l = (a = {}, a[Ks] = s + "Date", a[ip] = s + "Date", a[za] = s + "Month", a[Xs] = s + "FullYear", a[$c] = s + "Hours", a[is] = s + "Minutes", a[Bc] = s + "Seconds", a[dx] = s + "Milliseconds", a)[o], u = o === Ks ? this.$D + (i - this.$W) : i;
    if (o === za || o === Xs) {
      var c = this.clone().set(ip, 1);
      c.$d[l](u), c.init(), this.$d = c.set(ip, Math.min(this.$D, c.daysInMonth())).$d;
    } else l && this.$d[l](u);
    return this.init(), this;
  }, e.set = function(r, i) {
    return this.clone().$set(r, i);
  }, e.get = function(r) {
    return this[Bn.p(r)]();
  }, e.add = function(r, i) {
    var a = this, o;
    r = Number(r);
    var s = Bn.p(i), l = function(f) {
      var p = xn(a);
      return Bn.w(p.date(p.date() + Math.round(f * r)), a);
    };
    if (s === za)
      return this.set(za, this.$M + r);
    if (s === Xs)
      return this.set(Xs, this.$y + r);
    if (s === Ks)
      return l(1);
    if (s === n1)
      return l(7);
    var u = (o = {}, o[is] = Jc, o[$c] = Em, o[Bc] = gl, o)[s] || 1, c = this.$d.getTime() + r * u;
    return Bn.w(c, this);
  }, e.subtract = function(r, i) {
    return this.add(r * -1, i);
  }, e.format = function(r) {
    var i = this, a = this.$locale();
    if (!this.isValid()) return a.invalidDate || $L;
    var o = r || rM, s = Bn.z(this), l = this.$H, u = this.$m, c = this.$M, d = a.weekdays, f = a.months, p = a.meridiem, h = function(b, _, x, w) {
      return b && (b[_] || b(i, o)) || x[_].slice(0, w);
    }, v = function(b) {
      return Bn.s(l % 12 || 12, b, "0");
    }, m = p || function(y, b, _) {
      var x = y < 12 ? "AM" : "PM";
      return _ ? x.toLowerCase() : x;
    }, g = function(b) {
      switch (b) {
        case "YY":
          return String(i.$y).slice(-2);
        case "YYYY":
          return Bn.s(i.$y, 4, "0");
        case "M":
          return c + 1;
        case "MM":
          return Bn.s(c + 1, 2, "0");
        case "MMM":
          return h(a.monthsShort, c, f, 3);
        case "MMMM":
          return h(f, c);
        case "D":
          return i.$D;
        case "DD":
          return Bn.s(i.$D, 2, "0");
        case "d":
          return String(i.$W);
        case "dd":
          return h(a.weekdaysMin, i.$W, d, 2);
        case "ddd":
          return h(a.weekdaysShort, i.$W, d, 3);
        case "dddd":
          return d[i.$W];
        case "H":
          return String(l);
        case "HH":
          return Bn.s(l, 2, "0");
        case "h":
          return v(1);
        case "hh":
          return v(2);
        case "a":
          return m(l, u, !0);
        case "A":
          return m(l, u, !1);
        case "m":
          return String(u);
        case "mm":
          return Bn.s(u, 2, "0");
        case "s":
          return String(i.$s);
        case "ss":
          return Bn.s(i.$s, 2, "0");
        case "SSS":
          return Bn.s(i.$ms, 3, "0");
        case "Z":
          return s;
      }
      return null;
    };
    return o.replace(i6, function(y, b) {
      return b || g(y) || s.replace(":", "");
    });
  }, e.utcOffset = function() {
    return -Math.round(this.$d.getTimezoneOffset() / 15) * 15;
  }, e.diff = function(r, i, a) {
    var o = this, s = Bn.p(i), l = xn(r), u = (l.utcOffset() - this.utcOffset()) * Jc, c = this - l, d = function() {
      return Bn.m(o, l);
    }, f;
    switch (s) {
      case Xs:
        f = d() / 12;
        break;
      case za:
        f = d();
        break;
      case r6:
        f = d() / 3;
        break;
      case n1:
        f = (c - u) / n6;
        break;
      case Ks:
        f = (c - u) / Tm;
        break;
      case $c:
        f = c / Em;
        break;
      case is:
        f = c / Jc;
        break;
      case Bc:
        f = c / gl;
        break;
      default:
        f = c;
        break;
    }
    return a ? f : Bn.a(f);
  }, e.daysInMonth = function() {
    return this.endOf(za).$D;
  }, e.$locale = function() {
    return Qc[this.$L];
  }, e.locale = function(r, i) {
    if (!r) return this.$L;
    var a = this.clone(), o = V1(r, i, !0);
    return o && (a.$L = o), a;
  }, e.clone = function() {
    return Bn.w(this.$d, this);
  }, e.toDate = function() {
    return new Date(this.valueOf());
  }, e.toJSON = function() {
    return this.isValid() ? this.toISOString() : null;
  }, e.toISOString = function() {
    return this.$d.toISOString();
  }, e.toString = function() {
    return this.$d.toUTCString();
  }, n;
}(), o6 = fx.prototype;
xn.prototype = o6;
[["$ms", dx], ["$s", Bc], ["$m", is], ["$H", $c], ["$W", Ks], ["$M", za], ["$y", Xs], ["$D", ip]].forEach(function(n) {
  o6[n[1]] = function(e) {
    return this.$g(e, n[0], n[1]);
  };
});
xn.extend = function(n, e) {
  return n.$i || (n(e, fx, xn), n.$i = !0), xn;
};
xn.locale = V1;
xn.isDayjs = iM;
xn.unix = function(n) {
  return xn(n * 1e3);
};
xn.en = Qc[Fv];
xn.Ls = Qc;
xn.p = {};
const xoe = function(n, e, t) {
  n = n || {};
  var r = e.prototype, i = {
    future: "in %s",
    past: "%s ago",
    s: "a few seconds",
    m: "a minute",
    mm: "%d minutes",
    h: "an hour",
    hh: "%d hours",
    d: "a day",
    dd: "%d days",
    M: "a month",
    MM: "%d months",
    y: "a year",
    yy: "%d years"
  };
  t.en.relativeTime = i, r.fromToBase = function(s, l, u, c, d) {
    for (var f = u.$locale().relativeTime || i, p = n.thresholds || [{
      l: "s",
      r: 44,
      d: Bc
    }, {
      l: "m",
      r: 89
    }, {
      l: "mm",
      r: 44,
      d: is
    }, {
      l: "h",
      r: 89
    }, {
      l: "hh",
      r: 21,
      d: $c
    }, {
      l: "d",
      r: 35
    }, {
      l: "dd",
      r: 25,
      d: Ks
    }, {
      l: "M",
      r: 45
    }, {
      l: "MM",
      r: 10,
      d: za
    }, {
      l: "y",
      r: 17
    }, {
      l: "yy",
      d: Xs
    }], h = p.length, v, m, g, y = 0; y < h; y += 1) {
      var b = p[y];
      b.d && (v = c ? t(s).diff(u, b.d, !0) : u.diff(s, b.d, !0));
      var _ = (n.rounding || Math.round)(Math.abs(v));
      if (g = v > 0, _ <= b.r || !b.r) {
        _ <= 1 && y > 0 && (b = p[y - 1]);
        var x = f[b.l];
        d && (_ = d("" + _)), typeof x == "string" ? m = x.replace("%d", _) : m = x(_, l, b.l, g);
        break;
      }
    }
    if (l) return m;
    var w = g ? f.future : f.past;
    return typeof w == "function" ? w(m) : w.replace("%s", m);
  };
  function a(s, l, u, c) {
    return r.fromToBase(s, l, u, c);
  }
  r.to = function(s, l) {
    return a(s, l, this, !0);
  }, r.from = function(s, l) {
    return a(s, l, this);
  };
  var o = function(l) {
    return l.$u ? t.utc() : t();
  };
  r.toNow = function(s) {
    return this.to(o(this), s);
  }, r.fromNow = function(s) {
    return this.from(o(this), s);
  };
};
var woe = function(e) {
  return e.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(t, r, i) {
    return r || i.slice(1);
  });
}, s6 = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
}, Soe = function(e, t) {
  return e.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(r, i, a) {
    var o = a && a.toUpperCase();
    return i || t[a] || s6[a] || woe(t[o]);
  });
};
const Eoe = function(n, e, t) {
  var r = e.prototype, i = r.format;
  t.en.formats = s6, r.format = function(a) {
    a === void 0 && (a = rM);
    var o = this.$locale(), s = o.formats, l = s === void 0 ? {} : s, u = Soe(a, l);
    return i.call(this, u);
  };
}, Toe = function(n, e, t) {
  t.updateLocale = function(r, i) {
    var a = t.Ls, o = a[r];
    if (o) {
      var s = i ? Object.keys(i) : [];
      return s.forEach(function(l) {
        o[l] = i[l];
      }), o;
    }
  };
}, Coe = function(n, e, t) {
  var r = e.prototype;
  r.isToday = function() {
    var i = "YYYY-MM-DD", a = t();
    return this.format(i) === a.format(i);
  };
};
var H1 = Tm * 365, NT = H1 / 12, koe = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, Lh = {
  years: H1,
  months: NT,
  days: Tm,
  hours: Em,
  minutes: Jc,
  seconds: gl,
  milliseconds: 1,
  weeks: n6
}, r1 = function(e) {
  return e instanceof c6;
}, l6, Yo, xv = function(e, t, r) {
  return new c6(e, r, t.$l);
}, Nh = function(e) {
  return Yo.p(e) + "s";
}, u6 = function(e) {
  return e < 0;
}, Zu = function(e) {
  return u6(e) ? Math.ceil(e) : Math.floor(e);
}, Aoe = function(e) {
  return Math.abs(e);
}, pf = function(e, t) {
  return e ? u6(e) ? {
    negative: !0,
    format: "" + Aoe(e) + t
  } : {
    negative: !1,
    format: "" + e + t
  } : {
    negative: !1,
    format: ""
  };
}, c6 = /* @__PURE__ */ function() {
  function n(t, r, i) {
    var a = this;
    if (this.$d = {}, this.$l = i, t === void 0 && (this.$ms = 0, this.parseFromMilliseconds()), r)
      return xv(t * Lh[Nh(r)], this);
    if (typeof t == "number")
      return this.$ms = t, this.parseFromMilliseconds(), this;
    if (typeof t == "object")
      return Object.keys(t).forEach(function(u) {
        a.$d[Nh(u)] = t[u];
      }), this.calMilliseconds(), this;
    if (typeof t == "string") {
      var o = t.match(koe);
      if (o) {
        var s = o.slice(2), l = s.map(function(u) {
          return u != null ? Number(u) : 0;
        });
        return this.$d.years = l[0], this.$d.months = l[1], this.$d.weeks = l[2], this.$d.days = l[3], this.$d.hours = l[4], this.$d.minutes = l[5], this.$d.seconds = l[6], this.calMilliseconds(), this;
      }
    }
    return this;
  }
  var e = n.prototype;
  return e.calMilliseconds = function() {
    var r = this;
    this.$ms = Object.keys(this.$d).reduce(function(i, a) {
      return i + (r.$d[a] || 0) * Lh[a];
    }, 0);
  }, e.parseFromMilliseconds = function() {
    var r = this.$ms;
    this.$d.years = Zu(r / H1), r %= H1, this.$d.months = Zu(r / NT), r %= NT, this.$d.days = Zu(r / Tm), r %= Tm, this.$d.hours = Zu(r / Em), r %= Em, this.$d.minutes = Zu(r / Jc), r %= Jc, this.$d.seconds = Zu(r / gl), r %= gl, this.$d.milliseconds = r;
  }, e.toISOString = function() {
    var r = pf(this.$d.years, "Y"), i = pf(this.$d.months, "M"), a = +this.$d.days || 0;
    this.$d.weeks && (a += this.$d.weeks * 7);
    var o = pf(a, "D"), s = pf(this.$d.hours, "H"), l = pf(this.$d.minutes, "M"), u = this.$d.seconds || 0;
    this.$d.milliseconds && (u += this.$d.milliseconds / 1e3, u = Math.round(u * 1e3) / 1e3);
    var c = pf(u, "S"), d = r.negative || i.negative || o.negative || s.negative || l.negative || c.negative, f = s.format || l.format || c.format ? "T" : "", p = d ? "-" : "", h = p + "P" + r.format + i.format + o.format + f + s.format + l.format + c.format;
    return h === "P" || h === "-P" ? "P0D" : h;
  }, e.toJSON = function() {
    return this.toISOString();
  }, e.format = function(r) {
    var i = r || "YYYY-MM-DDTHH:mm:ss", a = {
      Y: this.$d.years,
      YY: Yo.s(this.$d.years, 2, "0"),
      YYYY: Yo.s(this.$d.years, 4, "0"),
      M: this.$d.months,
      MM: Yo.s(this.$d.months, 2, "0"),
      D: this.$d.days,
      DD: Yo.s(this.$d.days, 2, "0"),
      H: this.$d.hours,
      HH: Yo.s(this.$d.hours, 2, "0"),
      m: this.$d.minutes,
      mm: Yo.s(this.$d.minutes, 2, "0"),
      s: this.$d.seconds,
      ss: Yo.s(this.$d.seconds, 2, "0"),
      SSS: Yo.s(this.$d.milliseconds, 3, "0")
    };
    return i.replace(i6, function(o, s) {
      return s || String(a[o]);
    });
  }, e.as = function(r) {
    return this.$ms / Lh[Nh(r)];
  }, e.get = function(r) {
    var i = this.$ms, a = Nh(r);
    return a === "milliseconds" ? i %= 1e3 : a === "weeks" ? i = Zu(i / Lh[a]) : i = this.$d[a], i || 0;
  }, e.add = function(r, i, a) {
    var o;
    return i ? o = r * Lh[Nh(i)] : r1(r) ? o = r.$ms : o = xv(r, this).$ms, xv(this.$ms + o * (a ? -1 : 1), this);
  }, e.subtract = function(r, i) {
    return this.add(r, i, !0);
  }, e.locale = function(r) {
    var i = this.clone();
    return i.$l = r, i;
  }, e.clone = function() {
    return xv(this.$ms, this);
  }, e.humanize = function(r) {
    return l6().add(this.$ms, "ms").locale(this.$l).fromNow(!r);
  }, e.valueOf = function() {
    return this.asMilliseconds();
  }, e.milliseconds = function() {
    return this.get("milliseconds");
  }, e.asMilliseconds = function() {
    return this.as("milliseconds");
  }, e.seconds = function() {
    return this.get("seconds");
  }, e.asSeconds = function() {
    return this.as("seconds");
  }, e.minutes = function() {
    return this.get("minutes");
  }, e.asMinutes = function() {
    return this.as("minutes");
  }, e.hours = function() {
    return this.get("hours");
  }, e.asHours = function() {
    return this.as("hours");
  }, e.days = function() {
    return this.get("days");
  }, e.asDays = function() {
    return this.as("days");
  }, e.weeks = function() {
    return this.get("weeks");
  }, e.asWeeks = function() {
    return this.as("weeks");
  }, e.months = function() {
    return this.get("months");
  }, e.asMonths = function() {
    return this.as("months");
  }, e.years = function() {
    return this.get("years");
  }, e.asYears = function() {
    return this.as("years");
  }, n;
}(), zL = function(e, t, r) {
  return e.add(t.years() * r, "y").add(t.months() * r, "M").add(t.days() * r, "d").add(t.hours() * r, "h").add(t.minutes() * r, "m").add(t.seconds() * r, "s").add(t.milliseconds() * r, "ms");
};
const Moe = function(n, e, t) {
  l6 = t, Yo = t().$utils(), t.duration = function(a, o) {
    var s = t.locale();
    return xv(a, {
      $l: s
    }, o);
  }, t.isDuration = r1;
  var r = e.prototype.add, i = e.prototype.subtract;
  e.prototype.add = function(a, o) {
    return r1(a) ? zL(this, a, 1) : r.bind(this)(a, o);
  }, e.prototype.subtract = function(a, o) {
    return r1(a) ? zL(this, a, -1) : i.bind(this)(a, o);
  };
};
var Doe = /[+-]\d\d(?::?\d\d)?/g, Ooe = /([+-]|\d\d)/g;
function Ioe(n) {
  n === void 0 && (n = "");
  var e = n.match(Doe);
  if (!e)
    return null;
  var t = ("" + e[0]).match(Ooe) || ["-", 0, 0], r = t[0], i = t[1], a = t[2], o = +i * 60 + +a;
  return o === 0 ? 0 : r === "+" ? o : -o;
}
const Loe = function(n, e, t) {
  var r = e.prototype;
  t.utc = function(d) {
    var f = {
      date: d,
      utc: !0,
      args: arguments
    };
    return new e(f);
  }, r.utc = function(d) {
    var f = t(this.toDate(), {
      locale: this.$L,
      utc: !0
    });
    return d ? f.add(this.utcOffset(), is) : f;
  }, r.local = function() {
    return t(this.toDate(), {
      locale: this.$L,
      utc: !1
    });
  };
  var i = r.parse;
  r.parse = function(d) {
    d.utc && (this.$u = !0), this.$utils().u(d.$offset) || (this.$offset = d.$offset), i.call(this, d);
  };
  var a = r.init;
  r.init = function() {
    if (this.$u) {
      var d = this.$d;
      this.$y = d.getUTCFullYear(), this.$M = d.getUTCMonth(), this.$D = d.getUTCDate(), this.$W = d.getUTCDay(), this.$H = d.getUTCHours(), this.$m = d.getUTCMinutes(), this.$s = d.getUTCSeconds(), this.$ms = d.getUTCMilliseconds();
    } else
      a.call(this);
  };
  var o = r.utcOffset;
  r.utcOffset = function(d, f) {
    var p = this.$utils(), h = p.u;
    if (h(d))
      return this.$u ? 0 : h(this.$offset) ? o.call(this) : this.$offset;
    if (typeof d == "string" && (d = Ioe(d), d === null))
      return this;
    var v = Math.abs(d) <= 16 ? d * 60 : d, m = this;
    if (f)
      return m.$offset = v, m.$u = d === 0, m;
    if (d !== 0) {
      var g = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
      m = this.local().add(v + g, is), m.$offset = v, m.$x.$localOffset = g;
    } else
      m = this.utc();
    return m;
  };
  var s = r.format, l = "YYYY-MM-DDTHH:mm:ss[Z]";
  r.format = function(d) {
    var f = d || (this.$u ? l : "");
    return s.call(this, f);
  }, r.valueOf = function() {
    var d = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
    return this.$d.valueOf() - d * Jc;
  }, r.isUTC = function() {
    return !!this.$u;
  }, r.toISOString = function() {
    return this.toDate().toISOString();
  }, r.toString = function() {
    return this.toDate().toUTCString();
  };
  var u = r.toDate;
  r.toDate = function(d) {
    return d === "s" && this.$offset ? t(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : u.call(this);
  };
  var c = r.diff;
  r.diff = function(d, f, p) {
    if (d && this.$u === d.$u)
      return c.call(this, d, f, p);
    var h = this.local(), v = t(d).local();
    return c.call(h, v, f, p);
  };
};
var Noe = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
}, FL = {}, Roe = function(e, t) {
  t === void 0 && (t = {});
  var r = t.timeZoneName || "short", i = e + "|" + r, a = FL[i];
  return a || (a = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: e,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: r
  }), FL[i] = a), a;
};
const Poe = function(n, e, t) {
  var r, i = function(c, d, f) {
    f === void 0 && (f = {});
    var p = new Date(c), h = Roe(d, f);
    return h.formatToParts(p);
  }, a = function(c, d) {
    for (var f = i(c, d), p = [], h = 0; h < f.length; h += 1) {
      var v = f[h], m = v.type, g = v.value, y = Noe[m];
      y >= 0 && (p[y] = parseInt(g, 10));
    }
    var b = p[3], _ = b === 24 ? 0 : b, x = p[0] + "-" + p[1] + "-" + p[2] + " " + _ + ":" + p[4] + ":" + p[5] + ":000", w = t.utc(x).valueOf(), S = +c, C = S % 1e3;
    return S -= C, (w - S) / 6e4;
  }, o = function(c, d, f) {
    var p = c - d * 60 * 1e3, h = a(p, f);
    if (d === h)
      return [p, d];
    p -= (h - d) * 60 * 1e3;
    var v = a(p, f);
    return h === v ? [p, h] : [c - Math.min(h, v) * 60 * 1e3, Math.max(h, v)];
  }, s = e.prototype;
  s.tz = function(u, c) {
    u === void 0 && (u = r);
    var d = this.utcOffset(), f = this.toDate(), p = f.toLocaleString("en-US", {
      timeZone: u
    }), h = Math.round((f - new Date(p)) / 1e3 / 60), v = -Math.round(f.getTimezoneOffset() / 15) * 15 - h, m = !Number(v), g;
    if (m)
      g = this.utcOffset(0, c);
    else if (g = t(p, {
      locale: this.$L
    }).$set(dx, this.$ms).utcOffset(v, !0), c) {
      var y = g.utcOffset();
      g = g.add(d - y, is);
    }
    return g.$x.$timezone = u, g;
  }, s.offsetName = function(u) {
    var c = this.$x.$timezone || t.tz.guess(), d = i(this.valueOf(), c, {
      timeZoneName: u
    }).find(function(f) {
      return f.type.toLowerCase() === "timezonename";
    });
    return d && d.value;
  };
  var l = s.startOf;
  s.startOf = function(u, c) {
    if (!this.$x || !this.$x.$timezone)
      return l.call(this, u, c);
    var d = t(this.format("YYYY-MM-DD HH:mm:ss:SSS"), {
      locale: this.$L
    }), f = l.call(d, u, c);
    return f.tz(this.$x.$timezone, !0);
  }, t.tz = function(u, c, d) {
    var f = d && c, p = d || c || r, h = a(+t(), p);
    if (typeof u != "string")
      return t(u).tz(p);
    var v = t.utc(u, f).valueOf(), m = o(v, h, p), g = m[0], y = m[1], b = t(g).utcOffset(y);
    return b.$x.$timezone = p, b;
  }, t.tz.guess = function() {
    return Intl.DateTimeFormat().resolvedOptions().timeZone;
  }, t.tz.setDefault = function(u) {
    r = u;
  };
}, joe = function(n, e) {
  var t = e.prototype, r = t.format;
  t.format = function(i) {
    var a = this, o = this.$locale();
    if (!this.isValid())
      return r.bind(this)(i);
    var s = this.$utils(), l = i || rM, u = l.replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(c) {
      switch (c) {
        case "Q":
          return Math.ceil((a.$M + 1) / 3);
        case "Do":
          return o.ordinal(a.$D);
        case "gggg":
          return a.weekYear();
        case "GGGG":
          return a.isoWeekYear();
        case "wo":
          return o.ordinal(a.week(), "W");
        case "w":
        case "ww":
          return s.s(a.week(), c === "w" ? 1 : 2, "0");
        case "W":
        case "WW":
          return s.s(a.isoWeek(), c === "W" ? 1 : 2, "0");
        case "k":
        case "kk":
          return s.s(String(a.$H === 0 ? 24 : a.$H), c === "k" ? 1 : 2, "0");
        case "X":
          return Math.floor(a.$d.getTime() / 1e3);
        case "x":
          return a.$d.getTime();
        case "z":
          return "[" + a.offsetName() + "]";
        case "zzz":
          return "[" + a.offsetName("long") + "]";
        default:
          return c;
      }
    });
    return r.bind(this)(u);
  };
};
let Boe = {};
function G1(n) {
  return Boe[n] ?? null;
}
xn.extend(Toe);
xn.extend(xoe);
xn.extend(Eoe);
xn.extend(Coe);
xn.extend(Moe);
xn.extend(Loe);
xn.extend(Poe);
xn.extend(joe);
function d6() {
  return Intl.DateTimeFormat().resolvedOptions().timeZone;
}
function RT(n) {
  let e = G1("systemTimezone"), t = G1("localTimezone") || d6();
  return e ? n ? xn.tz(n, e).tz(t) : xn().tz(t) : xn(n);
}
function $oe(n) {
  let e = G1("systemTimezone"), t = G1("localTimezone") || d6();
  return e ? n ? xn.tz(n, t).tz(e) : xn().tz(e) : xn(n);
}
let Cm = xn;
function lr(...n) {
  return new Date(...n);
}
function jr(n) {
  return !n || n.toString() === "Invalid Date" ? "" : Cm(n).set("hour", 0).set("minute", 0).set("second", 0).set("millisecond", 0).format("YYYY-MM-DD");
}
function Sy(n, e) {
  let t = 1;
  e < 0 && (t = -1, e = Math.abs(e));
  const r = [];
  for (; e; )
    n = lr(
      n.getFullYear(),
      n.getMonth(),
      n.getDate() + t
    ), r.push(n), e--;
  return t === -1 ? r.reverse() : r;
}
function zoe(n, e) {
  const r = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n];
  return n === 1 && Foe(e) ? 29 : r;
}
function Foe(n) {
  return n % 400 === 0 ? !0 : n % 100 === 0 ? !1 : n % 4 === 0;
}
function aM() {
  const n = Z(0), e = Z(0), t = K(() => lr()), r = K(() => {
    if (!(n.value && e.value))
      return [];
    const u = e.value - 1, c = n.value, d = lr(c, u, 1), f = lr(c, u + 1, 0), p = d.getDay(), h = 6 - f.getDay(), v = Sy(d, -p), m = Sy(f, h), g = zoe(u, c), y = Sy(d, g - 1);
    let b = [
      ...v,
      d,
      ...y,
      ...m
    ];
    if (b.length < 42) {
      const _ = b.at(-1);
      if (_) {
        const x = Sy(_, 42 - b.length);
        b = b.concat(...x);
      }
    }
    return b;
  }), i = K(() => {
    const u = [], c = r.value.slice();
    for (; c.length; ) {
      const d = c.splice(0, 7);
      u.push(d);
    }
    return u;
  }), a = K(() => {
    if (!(n.value && e.value))
      return "";
    const u = lr(n.value, e.value - 1, 1);
    return `${u.toLocaleString("en-US", {
      month: "long"
    })}, ${u.getFullYear()}`;
  });
  function o() {
    l(-1);
  }
  function s() {
    l(1);
  }
  function l(u) {
    e.value = e.value + u, e.value < 1 && (e.value = 12, n.value = n.value - 1), e.value > 12 && (e.value = 1, n.value = n.value + 1);
  }
  return {
    currentYear: n,
    currentMonth: e,
    today: t,
    dates: r,
    datesAsWeeks: i,
    formattedMonth: a,
    prevMonth: o,
    nextMonth: s,
    changeMonth: l
  };
}
const Voe = { class: "flex flex-col space-y-1.5" }, Hoe = {
  key: 0,
  class: "block text-xs text-ink-gray-5"
}, Goe = { class: "flex items-center p-1 text-ink-gray-4" }, Uoe = { class: "flex-1 text-center text-base font-medium text-ink-gray-6" }, Woe = { class: "flex items-center justify-center gap-1 p-1" }, qoe = { class: "flex flex-col items-center justify-center p-1 text-ink-gray-8" }, Yoe = { class: "flex items-center text-xs uppercase" }, Koe = ["onClick"], Xoe = { class: "flex justify-end p-1" }, vUe = /* @__PURE__ */ ve({
  __name: "DatePicker",
  props: {
    value: {},
    modelValue: {},
    placeholder: {},
    formatter: { type: Function },
    readonly: { type: Boolean },
    inputClass: {},
    placement: {},
    label: {}
  },
  emits: ["update:modelValue", "change"],
  setup(n, { emit: e }) {
    const t = n, r = e, {
      currentYear: i,
      currentMonth: a,
      today: o,
      datesAsWeeks: s,
      formattedMonth: l,
      prevMonth: u,
      nextMonth: c
    } = aM(), d = K(() => {
      var m, g, y;
      let v = "mt-2";
      return (m = t.placement) != null && m.startsWith("top") ? v = "mb-2" : (g = t.placement) != null && g.startsWith("left") ? v = "mr-2" : (y = t.placement) != null && y.startsWith("right") && (v = "ml-2"), v;
    }), f = K(() => t.value ? t.value : t.modelValue);
    function p(v, m = !1) {
      v = m ? RT(v) : v, r("change", jr(v)), r("update:modelValue", jr(v));
    }
    function h() {
      let v = f.value ? lr(f.value) : lr();
      v.toString() === "Invalid Date" && (v = lr()), i.value = v.getFullYear(), a.value = v.getMonth() + 1;
    }
    return kt(() => h()), (v, m) => (L(), re(O(th), {
      onOpen: h,
      class: "flex w-full [&>div:first-child]:w-full",
      placement: v.placement
    }, {
      target: ee(({ togglePopover: g }) => [
        G("div", Voe, [
          t.label ? (L(), W("label", Hoe, ke(t.label), 1)) : ge("", !0),
          se(O(Ga), He({
            readonly: "",
            type: "text",
            placeholder: v.placeholder,
            value: f.value && v.formatter ? v.formatter(f.value) : f.value,
            onFocus: (y) => v.readonly ? null : g(),
            class: ["w-full", v.inputClass]
          }, v.$attrs), Zc({ _: 2 }, [
            v.$slots.prefix ? {
              name: "prefix",
              fn: ee(() => [
                ue(v.$slots, "prefix")
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["placeholder", "value", "onFocus", "class"])
        ])
      ]),
      body: ee(({ togglePopover: g }) => [
        G("div", {
          class: _e(["w-fit select-none text-base text-ink-gray-9 divide-y divide-outline-gray-modals rounded-lg bg-surface-modal shadow-2xl ring-1 ring-black ring-opacity-5 focus:outline-none", d.value])
        }, [
          G("div", Goe, [
            se(O(fn), {
              variant: "ghost",
              class: "h-7 w-7",
              onClick: O(u)
            }, {
              default: ee(() => [
                se(En, {
                  "stroke-width": 2,
                  name: "chevron-left",
                  class: "h-4 w-4"
                })
              ]),
              _: 1
            }, 8, ["onClick"]),
            G("div", Uoe, ke(O(l)), 1),
            se(O(fn), {
              variant: "ghost",
              class: "h-7 w-7",
              onClick: O(c)
            }, {
              default: ee(() => [
                se(En, {
                  "stroke-width": 2,
                  name: "chevron-right",
                  class: "h-4 w-4"
                })
              ]),
              _: 1
            }, 8, ["onClick"])
          ]),
          G("div", Woe, [
            se(O(Ga), {
              class: "text-sm",
              type: "text",
              value: f.value && v.formatter ? v.formatter(f.value) : f.value,
              onChange: m[0] || (m[0] = (y) => p(O(lr)(y.target.value)))
            }, null, 8, ["value"]),
            se(O(fn), {
              label: "Today",
              class: "text-sm",
              onClick: () => {
                p(O(lr)(), !0), g();
              }
            }, null, 8, ["onClick"])
          ]),
          G("div", qoe, [
            G("div", Yoe, [
              (L(), W(Ke, null, _t(["s", "m", "t", "w", "t", "f", "s"], (y, b) => G("div", {
                class: "flex h-6 w-8 items-center justify-center text-center",
                key: b
              }, ke(y), 1)), 64))
            ]),
            (L(!0), W(Ke, null, _t(O(s), (y, b) => (L(), W("div", {
              class: "flex items-center",
              key: b
            }, [
              (L(!0), W(Ke, null, _t(y, (_) => (L(), W("div", {
                key: O(jr)(_),
                class: _e(["flex h-8 w-8 cursor-pointer items-center justify-center rounded hover:bg-surface-gray-2", {
                  "text-ink-gray-3": _.getMonth() !== O(a) - 1,
                  "font-extrabold text-ink-gray-9": O(jr)(_) === O(jr)(O(o)),
                  "bg-surface-gray-6 text-ink-white hover:bg-surface-gray-6": O(jr)(_) === f.value
                }]),
                onClick: () => {
                  p(_), g();
                }
              }, ke(_.getDate()), 11, Koe))), 128))
            ]))), 128))
          ]),
          G("div", Xoe, [
            se(O(fn), {
              label: "Clear",
              class: "text-sm",
              onClick: () => {
                p(""), g();
              }
            }, null, 8, ["onClick"])
          ])
        ], 2)
      ]),
      _: 3
    }, 8, ["placement"]));
  }
}), Zoe = { class: "flex flex-col space-y-1.5" }, Joe = {
  key: 0,
  class: "block text-xs text-ink-gray-5"
}, Qoe = { class: "flex items-center p-1 text-ink-gray-4" }, ese = { class: "flex-1 text-center text-base font-medium text-ink-gray-6" }, tse = { class: "flex items-center justify-center gap-1 p-1" }, nse = { class: "flex flex-col items-center justify-center p-1 text-ink-gray-8" }, rse = { class: "flex items-center text-xs uppercase" }, ise = ["onClick"], ase = { class: "flex items-center justify-around gap-2 p-1" }, ose = { class: "flex flex-col items-center justify-center" }, sse = { class: "slider flex min-h-4 items-center justify-center" }, lse = { class: "slider flex min-h-4 items-center justify-center" }, use = { class: "slider flex min-h-4 items-center justify-center" }, cse = { class: "flex justify-end p-1" }, dse = /* @__PURE__ */ ve({
  __name: "DateTimePicker",
  props: {
    value: {},
    modelValue: {},
    placeholder: {},
    formatter: { type: Function },
    readonly: { type: Boolean },
    inputClass: {},
    placement: {},
    label: {}
  },
  emits: ["update:modelValue", "change"],
  setup(n, { emit: e }) {
    const t = n, r = e, {
      currentYear: i,
      currentMonth: a,
      today: o,
      datesAsWeeks: s,
      formattedMonth: l,
      prevMonth: u,
      nextMonth: c
    } = aM(), d = K(() => {
      var S, C, k;
      let w = "mt-2";
      return (S = t.placement) != null && S.startsWith("top") ? w = "mb-2" : (C = t.placement) != null && C.startsWith("left") ? w = "mr-2" : (k = t.placement) != null && k.startsWith("right") && (w = "ml-2"), w;
    }), f = Z(0), p = Z(0), h = Z(0), v = K(() => {
      let w = t.value ? t.value : t.modelValue;
      return w ? RT(w).format("YYYY-MM-DD HH:mm:ss") : "";
    });
    function m() {
      let w = v.value ? lr(v.value) : lr();
      g(w);
    }
    function g(w, S = !1) {
      S && (w = RT(w), f.value = w.hour(), p.value = w.minute(), h.value = w.second());
      let C = w ? $oe(y(w)).format("YYYY-MM-DD HH:mm:ss") : "";
      r("change", C), r("update:modelValue", C);
    }
    function y(w) {
      return !w || w.toString() === "Invalid Date" ? "" : Cm(w).set("hour", f.value).set("minute", p.value).set("second", h.value).format("YYYY-MM-DD HH:mm:ss");
    }
    function b(w) {
      return w.toString().padStart(2, "0");
    }
    function _(w) {
      w = lr(w), f.value = w.getHours(), p.value = w.getMinutes(), h.value = w.getSeconds(), g(w);
    }
    function x() {
      let w = v.value ? lr(v.value) : lr();
      w.toString() === "Invalid Date" && (w = lr()), i.value = w.getFullYear(), a.value = w.getMonth() + 1, f.value = w.getHours(), p.value = w.getMinutes(), h.value = w.getSeconds();
    }
    return kt(() => x()), (w, S) => (L(), re(O(th), {
      onOpen: x,
      class: "flex w-full [&>div:first-child]:w-full",
      placement: w.placement
    }, {
      target: ee(({ togglePopover: C }) => [
        G("div", Zoe, [
          t.label ? (L(), W("label", Joe, ke(t.label), 1)) : ge("", !0),
          se(O(Ga), He({
            readonly: "",
            type: "text",
            placeholder: w.placeholder,
            value: v.value && w.formatter ? w.formatter(v.value) : v.value,
            onFocus: (k) => w.readonly ? null : C(),
            class: ["w-full", w.inputClass]
          }, w.$attrs), Zc({ _: 2 }, [
            w.$slots.prefix ? {
              name: "prefix",
              fn: ee(() => [
                ue(w.$slots, "prefix", {}, void 0, !0)
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["placeholder", "value", "onFocus", "class"])
        ])
      ]),
      body: ee(({ togglePopover: C }) => [
        G("div", {
          class: _e(["w-fit select-none text-base text-ink-gray-9 divide-y divide-outline-gray-modals rounded-lg bg-surface-modal shadow-2xl ring-1 ring-black ring-opacity-5 focus:outline-none", d.value])
        }, [
          G("div", Qoe, [
            se(O(fn), {
              variant: "ghost",
              class: "h-7 w-7",
              onClick: O(u)
            }, {
              default: ee(() => [
                se(En, {
                  "stroke-width": 2,
                  name: "chevron-left",
                  class: "h-4 w-4"
                })
              ]),
              _: 1
            }, 8, ["onClick"]),
            G("div", ese, ke(O(l)), 1),
            se(O(fn), {
              variant: "ghost",
              class: "h-7 w-7",
              onClick: O(c)
            }, {
              default: ee(() => [
                se(En, {
                  "stroke-width": 2,
                  name: "chevron-right",
                  class: "h-4 w-4"
                })
              ]),
              _: 1
            }, 8, ["onClick"])
          ]),
          G("div", tse, [
            se(O(Ga), {
              class: "text-sm",
              type: "text",
              value: v.value,
              onChange: (k) => {
                _(k.target.value), C();
              }
            }, null, 8, ["value", "onChange"]),
            se(O(fn), {
              label: "Now",
              class: "text-sm",
              onClick: () => {
                g(O(lr)(), !0), C();
              }
            }, null, 8, ["onClick"])
          ]),
          G("div", nse, [
            G("div", rse, [
              (L(), W(Ke, null, _t(["s", "m", "t", "w", "t", "f", "s"], (k, M) => G("div", {
                class: "flex h-6 w-8 items-center justify-center text-center",
                key: M
              }, ke(k), 1)), 64))
            ]),
            (L(!0), W(Ke, null, _t(O(s), (k, M) => (L(), W("div", {
              class: "flex items-center",
              key: M
            }, [
              (L(!0), W(Ke, null, _t(k, (D) => (L(), W("div", {
                key: y(D),
                class: _e(["flex h-8 w-8 cursor-pointer items-center justify-center rounded hover:bg-surface-gray-2", {
                  "text-ink-gray-3": D.getMonth() !== O(a) - 1,
                  "font-extrabold text-ink-gray-9": y(D) === y(O(o)),
                  "bg-surface-gray-6 text-ink-white hover:bg-surface-gray-6": y(D) === v.value
                }]),
                onClick: () => {
                  g(D), C();
                }
              }, ke(D.getDate()), 11, ise))), 128))
            ]))), 128))
          ]),
          G("div", ase, [
            G("div", null, ke(b(f.value)) + " : " + ke(b(p.value)) + " : " + ke(b(h.value)), 1),
            G("div", ose, [
              G("div", sse, [
                se(O(Ga), {
                  modelValue: f.value,
                  "onUpdate:modelValue": S[0] || (S[0] = (k) => f.value = k),
                  name: "hours",
                  type: "range",
                  min: "0",
                  max: "23",
                  step: "1",
                  onChange: () => {
                    m(), C();
                  }
                }, null, 8, ["modelValue", "onChange"])
              ]),
              G("div", lse, [
                se(O(Ga), {
                  modelValue: p.value,
                  "onUpdate:modelValue": S[1] || (S[1] = (k) => p.value = k),
                  name: "minutes",
                  type: "range",
                  min: "0",
                  max: "59",
                  step: "1",
                  onChange: () => {
                    m(), C();
                  }
                }, null, 8, ["modelValue", "onChange"])
              ]),
              G("div", use, [
                se(O(Ga), {
                  modelValue: h.value,
                  "onUpdate:modelValue": S[2] || (S[2] = (k) => h.value = k),
                  name: "seconds",
                  type: "range",
                  min: "0",
                  max: "59",
                  step: "1",
                  onChange: () => {
                    m(), C();
                  }
                }, null, 8, ["modelValue", "onChange"])
              ])
            ])
          ]),
          G("div", cse, [
            se(O(fn), {
              label: "Clear",
              class: "text-sm",
              onClick: () => {
                g(""), C();
              }
            }, null, 8, ["onClick"])
          ])
        ], 2)
      ]),
      _: 3
    }, 8, ["placement"]));
  }
}), mUe = /* @__PURE__ */ zt(dse, [["__scopeId", "data-v-6d85ba81"]]), fse = { class: "flex flex-col space-y-1.5" }, pse = {
  key: 0,
  class: "block text-xs text-ink-gray-5"
}, hse = { class: "flex items-center p-1 text-ink-gray-4" }, vse = { class: "flex-1 text-center text-base font-medium text-ink-gray-6" }, mse = { class: "flex items-center justify-center gap-1 p-1" }, gse = { class: "flex flex-col items-center justify-center p-1 text-ink-gray-8" }, yse = { class: "flex items-center text-xs uppercase" }, bse = ["onClick"], _se = { class: "flex justify-end space-x-1 p-1" }, gUe = /* @__PURE__ */ ve({
  __name: "DateRangePicker",
  props: {
    value: {},
    modelValue: {},
    placeholder: {},
    formatter: { type: Function },
    readonly: { type: Boolean },
    inputClass: {},
    placement: {},
    label: {}
  },
  emits: ["update:modelValue", "change"],
  setup(n, { expose: e, emit: t }) {
    const r = n, i = t, {
      currentYear: a,
      currentMonth: o,
      today: s,
      datesAsWeeks: l,
      formattedMonth: u,
      prevMonth: c,
      nextMonth: d
    } = aM(), f = K(() => {
      var k, M, D;
      let C = "mt-2";
      return (k = r.placement) != null && k.startsWith("top") ? C = "mb-2" : (M = r.placement) != null && M.startsWith("left") ? C = "mr-2" : (D = r.placement) != null && D.startsWith("right") && (C = "ml-2"), C;
    }), p = K(() => r.value ? r.value : r.modelValue), h = Z(""), v = Z("");
    function m(C) {
      h.value && v.value ? (h.value = jr(C), v.value = "") : h.value && !v.value ? v.value = jr(C) : h.value = jr(C), g();
    }
    function g() {
      if (!h.value || !v.value)
        return;
      let C = lr(h.value), k = lr(v.value);
      if (C > k) {
        let M = C;
        C = k, k = M;
      }
      h.value = jr(C), v.value = jr(k);
    }
    function y() {
      let C = `${h.value},${v.value}`;
      !h.value && !v.value && (C = ""), i("change", C), i("update:modelValue", C);
    }
    function b() {
      let C = v.value ? lr(v.value) : s.value;
      a.value = C.getFullYear(), o.value = C.getMonth() + 1;
    }
    function _(C) {
      return !h.value || !v.value ? !1 : C >= lr(h.value) && C <= lr(v.value);
    }
    function x(C) {
      return C ? (typeof C == "string" && (C = C.split(",")), r.formatter ? r.formatter(C[0]) + " to " + r.formatter(C[1]) : C) : "";
    }
    function w() {
      h.value = "", v.value = "", y();
    }
    const S = Z();
    return kt(() => {
      let C = typeof (p == null ? void 0 : p.value) == "string" ? p.value.split(",") : p.value;
      h.value = (C == null ? void 0 : C[0]) || "", v.value = (C == null ? void 0 : C[1]) || "", b();
    }), e({
      open: () => {
        var C;
        (C = S.value) == null || C.open();
      }
    }), (C, k) => {
      const M = En, D = fn;
      return L(), re(O(th), {
        ref_key: "popoverRef",
        ref: S,
        onOpen: b,
        class: "flex w-full [&>div:first-child]:w-full",
        placement: C.placement
      }, {
        target: ee(({ togglePopover: N }) => [
          G("div", fse, [
            r.label ? (L(), W("label", pse, ke(r.label), 1)) : ge("", !0),
            se(O(Ga), He({
              readonly: "",
              type: "text",
              placeholder: C.placeholder,
              value: p.value && C.formatter ? x(p.value) : p.value,
              onFocus: (R) => C.readonly ? null : N(),
              class: ["w-full", C.inputClass]
            }, C.$attrs), Zc({ _: 2 }, [
              C.$slots.prefix ? {
                name: "prefix",
                fn: ee(() => [
                  ue(C.$slots, "prefix")
                ]),
                key: "0"
              } : void 0
            ]), 1040, ["placeholder", "value", "onFocus", "class"])
          ])
        ]),
        body: ee(({ togglePopover: N }) => [
          G("div", {
            class: _e(["w-fit select-none text-base text-ink-gray-9 divide-y divide-outline-gray-modals rounded-lg bg-surface-modal shadow-2xl ring-1 ring-black ring-opacity-5 focus:outline-none", f.value])
          }, [
            G("div", hse, [
              se(D, {
                variant: "ghost",
                class: "h-7 w-7",
                onClick: O(c)
              }, {
                default: ee(() => [
                  se(M, {
                    "stroke-width": 2,
                    name: "chevron-left",
                    class: "h-4 w-4"
                  })
                ]),
                _: 1
              }, 8, ["onClick"]),
              G("div", vse, ke(O(u)), 1),
              se(D, {
                variant: "ghost",
                class: "h-7 w-7",
                onClick: O(d)
              }, {
                default: ee(() => [
                  se(M, {
                    "stroke-width": 2,
                    name: "chevron-right",
                    class: "h-4 w-4"
                  })
                ]),
                _: 1
              }, 8, ["onClick"])
            ]),
            G("div", mse, [
              se(O(Ga), {
                class: "w-28 text-sm",
                type: "text",
                modelValue: h.value,
                "onUpdate:modelValue": k[0] || (k[0] = (R) => h.value = R)
              }, null, 8, ["modelValue"]),
              se(O(Ga), {
                class: "w-28 text-sm",
                type: "text",
                modelValue: v.value,
                "onUpdate:modelValue": k[1] || (k[1] = (R) => v.value = R)
              }, null, 8, ["modelValue"])
            ]),
            G("div", gse, [
              G("div", yse, [
                (L(), W(Ke, null, _t(["s", "m", "t", "w", "t", "f", "s"], (R, j) => G("div", {
                  class: "flex h-6 w-8 items-center justify-center text-center",
                  key: j
                }, ke(R), 1)), 64))
              ]),
              (L(!0), W(Ke, null, _t(O(l), (R, j) => (L(), W("div", {
                class: "flex items-center",
                key: j
              }, [
                (L(!0), W(Ke, null, _t(R, (z) => (L(), W("div", {
                  key: O(jr)(z),
                  class: _e(["flex h-8 w-8 cursor-pointer items-center justify-center rounded hover:bg-surface-gray-2", {
                    "text-ink-gray-3": z.getMonth() !== O(o) - 1,
                    "text-ink-gray-9": z.getMonth() === O(o) - 1,
                    "font-extrabold text-ink-gray-9": O(jr)(z) === O(jr)(O(s)),
                    "rounded-none bg-surface-gray-3": _(z),
                    "rounded-l-md rounded-r-none bg-surface-gray-6 text-ink-white hover:bg-surface-gray-6": h.value && O(jr)(z) === O(jr)(h.value),
                    "rounded-r-md bg-surface-gray-6 text-ink-white hover:bg-surface-gray-6": v.value && O(jr)(z) === O(jr)(v.value)
                  }]),
                  onClick: () => m(z)
                }, ke(z.getDate()), 11, bse))), 128))
              ]))), 128))
            ]),
            G("div", _se, [
              se(D, {
                label: "Clear",
                onClick: () => {
                  w(), N();
                },
                disabled: !h.value || !v.value
              }, null, 8, ["onClick", "disabled"]),
              se(D, {
                variant: "solid",
                label: "Apply",
                disabled: !h.value || !v.value,
                onClick: () => {
                  y(), N();
                }
              }, null, 8, ["disabled", "onClick"])
            ])
          ], 2)
        ]),
        _: 3
      }, 8, ["placement"]);
    };
  }
}), xse = {
  class: "lucide lucide-x",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function wse(n, e) {
  return L(), W("svg", xse, [...e[0] || (e[0] = [
    G("path", { d: "M18 6 6 18" }, null, -1),
    G("path", { d: "m6 6 12 12" }, null, -1)
  ])]);
}
const rh = cn({ name: "lucide-x", render: wse }), Sse = { class: "bg-surface-modal px-4 pb-6 pt-5 sm:px-6" }, Ese = { class: "flex" }, Tse = { class: "w-full flex-1" }, Cse = { class: "mb-6 flex items-center justify-between" }, kse = { class: "flex items-center space-x-2" }, Ase = { class: "text-2xl font-semibold leading-6 text-ink-gray-9" }, Mse = { class: "text-p-base text-ink-gray-7" }, Dse = {
  key: 0,
  class: "px-4 pb-7 pt-4 sm:px-6"
}, Ose = { class: "space-y-2" }, Ise = /* @__PURE__ */ ve({
  __name: "Dialog",
  props: {
    modelValue: { type: Boolean },
    options: { default: () => ({}) },
    disableOutsideClickToClose: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "close", "after-leave"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = K(() => {
      let f = t.options.actions;
      return f != null && f.length ? f.map((p) => {
        let h = Sr({
          ...p,
          loading: !1,
          onClick: p.onClick ? async () => {
            h.loading = !0;
            try {
              if (p.onClick) {
                let v = () => {
                  console.warn(
                    "Value passed to onClick is a context object. Please use context.close() instead of context() to close the dialog."
                  ), s();
                };
                v.close = s, await p.onClick(v);
              }
            } finally {
              h.loading = !1;
            }
          } : s
        });
        return h;
      }) : [];
    }), a = K({
      get() {
        return t.modelValue;
      },
      set(f) {
        r("update:modelValue", f), f || r("close");
      }
    });
    function o(f) {
      a.value = f;
    }
    function s() {
      a.value = !1;
    }
    const l = K(() => {
      var p;
      if (!((p = t.options) != null && p.icon)) return null;
      let f = t.options.icon;
      return typeof f == "string" && (f = { name: f }), f;
    }), u = K(() => {
      var h;
      const f = ((h = t.options) == null ? void 0 : h.position) || "center";
      return {
        center: "justify-center",
        top: "pt-[20vh]"
      }[f];
    }), c = K(() => {
      var h;
      const f = (h = l.value) == null ? void 0 : h.appearance;
      return f ? {
        warning: "bg-surface-amber-2",
        info: "bg-surface-blue-2",
        danger: "bg-surface-red-2",
        success: "bg-surface-green-2"
      }[f] : "bg-surface-gray-2";
    }), d = K(() => {
      var h;
      const f = (h = l.value) == null ? void 0 : h.appearance;
      return f ? {
        warning: "text-ink-amber-3",
        info: "text-ink-blue-3",
        danger: "text-ink-red-4",
        success: "text-ink-green-3"
      }[f] : "text-ink-gray-5";
    });
    return (f, p) => (L(), re(O(XQ), {
      open: a.value,
      "onUpdate:open": [
        p[3] || (p[3] = (h) => a.value = h),
        o
      ]
    }, {
      default: ee(() => [
        se(O(jee), null, {
          default: ee(() => [
            se(O(Nee), {
              class: "fixed inset-0 bg-black-overlay-200 backdrop-filter backdrop-blur-[12px] overflow-y-auto dialog-overlay",
              "data-dialog": f.options.title,
              onAfterLeave: p[2] || (p[2] = (h) => f.$emit("after-leave"))
            }, {
              default: ee(() => [
                G("div", {
                  class: _e(["flex min-h-screen flex-col items-center px-4 py-4 text-center", u.value])
                }, [
                  se(O(Mee), {
                    class: _e(["my-8 inline-block w-full transform overflow-hidden rounded-xl bg-surface-modal text-left align-middle shadow-xl dialog-content", {
                      "max-w-7xl": f.options.size === "7xl",
                      "max-w-6xl": f.options.size === "6xl",
                      "max-w-5xl": f.options.size === "5xl",
                      "max-w-4xl": f.options.size === "4xl",
                      "max-w-3xl": f.options.size === "3xl",
                      "max-w-2xl": f.options.size === "2xl",
                      "max-w-xl": f.options.size === "xl",
                      "max-w-lg": f.options.size === "lg" || !f.options.size,
                      "max-w-md": f.options.size === "md",
                      "max-w-sm": f.options.size === "sm",
                      "max-w-xs": f.options.size === "xs"
                    }]),
                    onEscapeKeyDown: p[0] || (p[0] = (h) => s()),
                    onInteractOutside: p[1] || (p[1] = (h) => {
                      t.disableOutsideClickToClose && h.preventDefault();
                    })
                  }, {
                    default: ee(() => [
                      ue(f.$slots, "body", {}, () => [
                        ue(f.$slots, "body-main", {}, () => [
                          G("div", Sse, [
                            G("div", Ese, [
                              G("div", Tse, [
                                ue(f.$slots, "body-header", {}, () => [
                                  G("div", Cse, [
                                    G("div", kse, [
                                      l.value ? (L(), W("div", {
                                        key: 0,
                                        class: _e(["flex h-7 w-7 flex-shrink-0 items-center justify-center rounded-full", c.value])
                                      }, [
                                        se(En, {
                                          name: l.value.name,
                                          class: _e(["h-4 w-4", d.value]),
                                          "aria-hidden": "true"
                                        }, null, 8, ["name", "class"])
                                      ], 2)) : ge("", !0),
                                      se(O(mV), { as: "header" }, {
                                        default: ee(() => [
                                          ue(f.$slots, "body-title", {}, () => [
                                            G("h3", Ase, ke(f.options.title || "Untitled"), 1)
                                          ], !0)
                                        ]),
                                        _: 3
                                      })
                                    ]),
                                    se(O(JQ), { "as-child": "" }, {
                                      default: ee(() => [
                                        se(O(fn), {
                                          variant: "ghost",
                                          onClick: s
                                        }, {
                                          icon: ee(() => [
                                            se(O(rh), { class: "h-4 w-4 text-ink-gray-9" })
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    })
                                  ])
                                ], !0),
                                ue(f.$slots, "body-content", {}, () => [
                                  f.options.message ? (L(), re(O(vV), {
                                    key: 0,
                                    "as-child": ""
                                  }, {
                                    default: ee(() => [
                                      G("p", Mse, ke(f.options.message), 1)
                                    ]),
                                    _: 1
                                  })) : ge("", !0)
                                ], !0)
                              ])
                            ])
                          ])
                        ], !0),
                        i.value.length || f.$slots.actions ? (L(), W("div", Dse, [
                          ue(f.$slots, "actions", Bt(Jt({ close: s })), () => [
                            G("div", Ose, [
                              (L(!0), W(Ke, null, _t(i.value, (h) => (L(), re(O(fn), He({
                                class: "w-full",
                                key: h.label,
                                disabled: h.disabled
                              }, { ref_for: !0 }, h), {
                                default: ee(() => [
                                  gn(ke(h.label), 1)
                                ]),
                                _: 2
                              }, 1040, ["disabled"]))), 128))
                            ])
                          ], !0)
                        ])) : ge("", !0)
                      ], !0)
                    ]),
                    _: 3
                  }, 8, ["class"])
                ], 2)
              ]),
              _: 3
            }, 8, ["data-dialog"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), px = /* @__PURE__ */ zt(Ise, [["__scopeId", "data-v-f9e3f3b0"]]), hx = px;
hx.Title = mV;
hx.Description = vV;
const Lse = {
  name: "ConfirmDialog",
  props: {
    title: {
      type: String
    },
    message: {
      type: String
    },
    onConfirm: {
      type: Function,
      default: null
    },
    onCancel: {
      type: Function,
      default: null
    }
  },
  expose: ["show", "hide"],
  components: {
    Dialog: hx,
    Button: fn
  },
  data() {
    return {
      showDialog: !0,
      isLoading: !1
    };
  },
  methods: {
    handleConfirmation() {
      var n;
      try {
        (n = this.onConfirm) == null || n.call(this, {
          hideDialog: this.hide
        });
      } finally {
        this.isLoading = !1;
      }
    },
    show() {
      this.showDialog = !0;
    },
    closeDialog() {
      var n;
      this.hide(), (n = this.onCancel) == null || n.call(this);
    },
    hide() {
      this.showDialog = !1;
    }
  },
  computed: {
    primaryActionProps() {
      return {
        label: "Confirm",
        variant: "solid",
        loading: this.isLoading,
        onClick: this.handleConfirmation
      };
    }
  }
}, Nse = { class: "space-y-4" }, Rse = ["innerHTML"];
function Pse(n, e, t, r, i, a) {
  const o = fn, s = px;
  return L(), re(s, {
    modelValue: i.showDialog,
    "onUpdate:modelValue": e[0] || (e[0] = (l) => i.showDialog = l),
    options: { title: t.title },
    onClose: a.closeDialog
  }, {
    "body-content": ee(() => [
      G("div", Nse, [
        t.message ? (L(), W("p", {
          key: 0,
          class: "text-p-base text-gray-800",
          innerHTML: t.message
        }, null, 8, Rse)) : ge("", !0)
      ])
    ]),
    actions: ee(() => [
      se(o, He({ class: "w-full" }, a.primaryActionProps), null, 16)
    ]),
    _: 1
  }, 8, ["modelValue", "options", "onClose"]);
}
const jse = /* @__PURE__ */ zt(Lse, [["render", Pse]]);
function yUe({ title: n = "Untitled", message: e = "", onConfirm: t, onCancel: r }) {
  Bse(
    qt(jse, {
      title: n,
      message: e,
      onConfirm: t,
      onCancel: r
    })
  );
}
const PT = Z([]);
function Bse(n) {
  n.id = PT.length, PT.value.push(n);
}
const bUe = {
  __name: "Dialogs",
  setup(n) {
    return (e, t) => (L(), W("div", null, [
      (L(!0), W(Ke, null, _t(O(PT), (r) => (L(), re(bn(r)))), 256))
    ]));
  }
}, _Ue = /* @__PURE__ */ ve({
  __name: "Divider",
  props: {
    orientation: { default: "horizontal" },
    position: { default: "center" },
    flexItem: { type: Boolean },
    action: {}
  },
  setup(n) {
    const e = n, t = K(() => {
      let i = {
        horizontal: "border-t-[1px] w-full",
        vertical: "border-l-[1px]"
      }[e.orientation], a = e.flexItem ? "self-stretch h-auto" : "h-full";
      return [i, a];
    }), r = K(() => ({
      horizontal: {
        center: "left-1/2 top-0 -translate-y-2/4 -translate-x-1/2",
        start: "left-0 top-0 -translate-y-2/4 ml-4",
        end: "right-0 -translate-y-2/4 mr-4"
      },
      vertical: {
        center: "-translate-x-2/4 top-1/2 left-0 -translate-y-1/2",
        start: "-translate-x-2/4 top-0 mt-4 left-0",
        end: "-translate-x-2/4 bottom-0 mb-4 left-0"
      }
    })[e.orientation][e.position]);
    return (i, a) => (L(), re(bn(e.action ? "div" : "hr"), {
      class: _e(["relative whitespace-nowrap border-0 border-outline-gray-2", t.value])
    }, {
      default: ee(() => {
        var o, s, l;
        return [
          e.action ? (L(), W("span", {
            key: 0,
            class: _e(["absolute", r.value])
          }, [
            se(O(fn), {
              label: (o = e.action) == null ? void 0 : o.label,
              loading: (s = e.action) == null ? void 0 : s.loading,
              size: "sm",
              variant: "outline",
              onClick: (l = e.action) == null ? void 0 : l.handler
            }, null, 8, ["label", "loading", "onClick"])
          ], 2)) : ge("", !0)
        ];
      }),
      _: 1
    }, 8, ["class"]));
  }
}), $se = ["innerHTML"], f6 = /* @__PURE__ */ ve({
  __name: "ErrorMessage",
  props: {
    message: {}
  },
  setup(n) {
    const e = n, t = K(() => e.message ? e.message instanceof Error ? e.message.messages || e.message.message : e.message : "");
    return (r, i) => r.message ? (L(), W("div", {
      key: 0,
      class: "whitespace-pre-line text-sm text-ink-red-4",
      role: "alert",
      innerHTML: t.value
    }, null, 8, $se)) : ge("", !0);
  }
}), zse = { class: "relative flex items-center" }, Fse = ["disabled", "id", "value"], Vse = ["value", "disabled", "selected"], oM = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "Select",
  props: {
    size: { default: "sm" },
    variant: { default: "subtle" },
    placeholder: {},
    disabled: { type: Boolean },
    id: {},
    modelValue: {},
    options: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e;
    Xp();
    const i = $d();
    function a(f) {
      r("update:modelValue", f.target.value);
    }
    const o = K(() => {
      var f;
      return ((f = t.options) == null ? void 0 : f.map((p) => typeof p == "string" ? {
        label: p,
        value: p
      } : p).filter(Boolean)) || [];
    }), s = K(() => t.disabled ? "text-ink-gray-4" : "text-ink-gray-8"), l = K(() => ({
      sm: "text-base",
      md: "text-base",
      lg: "text-lg",
      xl: "text-xl"
    })[t.size]), u = K(() => ({
      sm: "pl-2 pr-5",
      md: "pl-2.5 pr-5.5",
      lg: "pl-3 pr-6",
      xl: "pl-3 pr-6"
    })[t.size]), c = K(() => {
      let f = {
        sm: "rounded h-7",
        md: "rounded h-8",
        lg: "rounded-md h-10",
        xl: "rounded-md h-10"
      }[t.size], p = t.disabled ? "disabled" : t.variant, h = {
        subtle: "border border-[--surface-gray-2] bg-surface-gray-2 hover:border-outline-gray-modals hover:bg-surface-gray-3 focus:border-outline-gray-4 focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3",
        outline: "border border-outline-gray-2 bg-surface-white hover:border-outline-gray-3 focus:border-outline-gray-4 focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3",
        ghost: "bg-transparent border-transparent hover:bg-surface-gray-3 focus:bg-surface-gray-3 focus:border-outline-gray-4 focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3",
        disabled: [
          "border",
          t.variant !== "ghost" ? "bg-surface-gray-1" : "",
          t.variant === "outline" ? "border-outline-gray-2" : "border-transparent"
        ]
      }[p];
      return [
        f,
        l.value,
        u.value,
        h,
        s.value,
        "transition-colors w-full py-0 truncate"
      ];
    });
    let d = K(() => ({
      sm: "pl-2",
      md: "pl-2.5",
      lg: "pl-3",
      xl: "pl-3"
    })[t.size]);
    return (f, p) => (L(), W("div", zse, [
      f.$slots.prefix ? (L(), W("div", {
        key: 0,
        class: _e([
          "absolute inset-y-0 left-0 flex items-center",
          s.value,
          O(d)
        ])
      }, [
        ue(f.$slots, "prefix")
      ], 2)) : ge("", !0),
      f.placeholder ? ta((L(), W("div", {
        key: 1,
        class: _e(["pointer-events-none absolute text-ink-gray-4 truncate w-full", [l.value, u.value]])
      }, ke(f.placeholder), 3)), [
        [hs, !f.modelValue]
      ]) : ge("", !0),
      G("select", He({
        class: c.value,
        disabled: f.disabled,
        id: f.id,
        value: f.modelValue,
        onChange: a
      }, O(i)), [
        (L(!0), W(Ke, null, _t(o.value, (h) => (L(), W("option", {
          key: h.value,
          value: h.value,
          disabled: h.disabled || !1,
          selected: f.modelValue === h.value
        }, ke(h.label), 9, Vse))), 128))
      ], 16, Fse)
    ]));
  }
}), Hse = { class: "space-y-1.5" }, Gse = ["for"], Use = ["placeholder", "disabled", "id", "value", "rows"], Wse = /* @__PURE__ */ ve({
  __name: "Textarea",
  props: {
    size: { default: "sm" },
    variant: { default: "subtle" },
    placeholder: {},
    disabled: { type: Boolean },
    id: {},
    modelValue: {},
    debounce: {},
    rows: { default: 3 },
    label: {}
  },
  emits: ["update:modelValue"],
  setup(n, { expose: e, emit: t }) {
    const r = n, i = t, a = $d(), o = Z(null), s = K(() => {
      let d = {
        sm: "text-base rounded",
        md: "text-base rounded",
        lg: "text-lg rounded-md",
        xl: "text-xl rounded-md"
      }[r.size], f = {
        sm: ["py-1.5 px-2"],
        md: ["py-1.5 px-2.5"],
        lg: ["py-1.5 px-3"],
        xl: ["py-1.5 px-3"]
      }[r.size], p = r.disabled ? "disabled" : r.variant, h = {
        subtle: "border border-[--surface-gray-2] bg-surface-gray-2 placeholder-ink-gray-4 hover:border-outline-gray-modals hover:bg-surface-gray-3 focus:bg-surface-white focus:border-outline-gray-4 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3",
        outline: "border border-outline-gray-2 bg-surface-white placeholder-ink-gray-4 hover:border-outline-gray-3 hover:shadow-sm focus:bg-surface-white focus:border-outline-gray-4 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3",
        disabled: [
          "border bg-surface-gray-1 placeholder-ink-gray-3",
          r.variant === "outline" ? "border-outline-gray-2" : "border-transparent"
        ]
      }[p];
      return [
        d,
        f,
        h,
        r.disabled ? "text-ink-gray-5" : "text-ink-gray-8",
        "transition-colors w-full block"
      ];
    }), l = K(() => [
      {
        sm: "text-xs",
        md: "text-base",
        lg: "text-lg",
        xl: "text-xl"
      }[r.size],
      "text-ink-gray-5"
    ]);
    let u = (d) => {
      i("update:modelValue", d);
    };
    r.debounce && (u = cx(u, r.debounce));
    let c = (d) => {
      u(d.target.value);
    };
    return e({ el: o }), (d, f) => (L(), W("div", Hse, [
      d.label ? (L(), W("label", {
        key: 0,
        class: _e(["block", l.value]),
        for: d.id
      }, ke(d.label), 11, Gse)) : ge("", !0),
      G("textarea", He({
        ref_key: "textareaRef",
        ref: o,
        placeholder: d.placeholder,
        class: s.value,
        disabled: d.disabled,
        id: d.id,
        value: d.modelValue,
        rows: d.rows,
        onInput: f[0] || (f[0] = //@ts-ignore
        (...p) => O(c) && O(c)(...p)),
        onChange: f[1] || (f[1] = //@ts-ignore
        (...p) => O(c) && O(c)(...p))
      }, O(a)), null, 16, Use)
    ]));
  }
}), qse = ["for"], Yse = /* @__PURE__ */ ve({
  __name: "FormLabel",
  props: {
    label: {},
    size: { default: "sm" },
    id: {},
    required: { type: Boolean }
  },
  setup(n) {
    const e = n, t = K(() => [
      {
        sm: "text-xs",
        md: "text-base"
      }[e.size],
      "text-ink-gray-5"
    ]);
    return (r, i) => (L(), W("label", {
      class: _e(["block", t.value]),
      for: r.id
    }, [
      gn(ke(r.label) + " ", 1),
      r.required ? (L(), W(Ke, { key: 0 }, [
        i[0] || (i[0] = G("span", {
          class: "text-ink-red-3 select-none",
          "aria-hidden": "true"
        }, "*", -1)),
        i[1] || (i[1] = G("span", { class: "sr-only" }, "(required)", -1))
      ], 64)) : ge("", !0)
    ], 10, qse));
  }
}), Kse = {
  inheritAttrs: !1
}, Fs = /* @__PURE__ */ ve({
  ...Kse,
  __name: "FormControl",
  props: {
    label: {},
    description: {},
    type: { default: "text" },
    size: { default: "sm" },
    variant: { default: "subtle" },
    required: { type: Boolean }
  },
  setup(n) {
    const e = JV(), t = n, r = $d(), i = K(() => {
      let o = {};
      for (let s in r)
        s !== "class" && s !== "style" && (o[s] = r[s]);
      return o;
    }), a = K(() => [
      {
        sm: "text-xs",
        md: "text-base"
      }[t.size],
      "text-ink-gray-5"
    ]);
    return (o, s) => o.type != "checkbox" ? (L(), W("div", {
      key: 0,
      class: _e(["space-y-1.5", O(r).class]),
      style: An(O(r).style)
    }, [
      o.label ? (L(), re(Yse, {
        key: 0,
        label: o.label,
        size: o.size,
        id: O(e),
        required: o.required
      }, null, 8, ["label", "size", "id", "required"])) : ge("", !0),
      o.type === "select" ? (L(), re(O(oM), He({
        key: 1,
        id: O(e)
      }, { ...i.value, size: o.size, variant: o.variant }), Zc({ _: 2 }, [
        o.$slots.prefix ? {
          name: "prefix",
          fn: ee(() => [
            ue(o.$slots, "prefix")
          ]),
          key: "0"
        } : void 0
      ]), 1040, ["id"])) : o.type === "autocomplete" ? (L(), re(O(hae), Bt(He({ key: 2 }, { ...i.value })), Zc({ _: 2 }, [
        o.$slots.prefix ? {
          name: "prefix",
          fn: ee(() => [
            ue(o.$slots, "prefix")
          ]),
          key: "0"
        } : void 0,
        o.$slots["item-prefix"] ? {
          name: "item-prefix",
          fn: ee((l) => [
            ue(o.$slots, "item-prefix", Bt(Jt(l)))
          ]),
          key: "1"
        } : void 0
      ]), 1040)) : o.type === "textarea" ? (L(), re(O(Wse), He({
        key: 3,
        id: O(e)
      }, { ...i.value, size: o.size, variant: o.variant }), null, 16, ["id"])) : (L(), re(O(Ga), He({
        key: 4,
        id: O(e)
      }, { ...i.value, type: o.type, size: o.size, variant: o.variant, required: o.required }), Zc({ _: 2 }, [
        o.$slots.prefix ? {
          name: "prefix",
          fn: ee(() => [
            ue(o.$slots, "prefix")
          ]),
          key: "0"
        } : void 0,
        o.$slots.suffix ? {
          name: "suffix",
          fn: ee(() => [
            ue(o.$slots, "suffix")
          ]),
          key: "1"
        } : void 0
      ]), 1040, ["id"])),
      ue(o.$slots, "description", {}, () => [
        o.description ? (L(), W("p", {
          key: 0,
          class: _e(a.value)
        }, ke(o.description), 3)) : ge("", !0)
      ])
    ], 6)) : (L(), re(O(ux), He({
      key: 1,
      id: O(e)
    }, { ...i.value, label: o.label, size: o.size, class: O(r).class }), null, 16, ["id"]));
  }
}), Xse = {}, Zse = {
  viewBox: "0 0 32 32",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function Jse(n, e) {
  return L(), W("svg", Zse, [...e[0] || (e[0] = [
    G("path", {
      d: "M16 32c8.837 0 16-7.163 16-16S24.837 0 16 0 0 7.163 0 16s7.163 16 16 16z",
      fill: "#59B179"
    }, null, -1),
    G("path", {
      d: "M9.333 17.227l1.333 1.333 2.667 2.667 5.333-5.333 2.667-2.667 1.333-1.333",
      stroke: "#fff",
      "stroke-width": "2",
      "stroke-miterlimit": "10",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }, null, -1)
  ])]);
}
const xUe = /* @__PURE__ */ zt(Xse, [["render", Jse]]), Qse = {
  name: "Input",
  inheritAttrs: !1,
  expose: ["getInputValue"],
  components: { FeatherIcon: En },
  props: {
    label: {
      type: String
    },
    type: {
      type: String,
      default: "text",
      validator(n) {
        let e = [
          "text",
          "number",
          "checkbox",
          "textarea",
          "select",
          "email",
          "password",
          "date"
        ].includes(n);
        return e || console.warn(`Invalid value "${n}" for "type" prop for Input`), e;
      }
    },
    modelValue: {
      type: [String, Number, Boolean, Object, Array]
    },
    inputClass: {
      type: [String, Array, Object]
    },
    debounce: {
      type: Number
    },
    options: {
      type: Array
    },
    disabled: {
      type: Boolean
    },
    rows: {
      type: Number,
      default: 3
    },
    placeholder: {
      type: String
    },
    iconLeft: {
      type: String
    }
  },
  emits: ["input", "change", "update:modelValue"],
  methods: {
    focus() {
      this.$refs.input.focus();
    },
    blur() {
      this.$refs.input.blur();
    },
    getInputValue(n) {
      let e = n ? n.target : this.$refs.input, t = e.value;
      return this.type == "checkbox" && (t = e.checked), t;
    }
  },
  computed: {
    passedInputValue() {
      return "value" in this.$attrs ? this.$attrs.value : this.modelValue || null;
    },
    inputAttributes() {
      let n = {}, e = (t) => {
        this.$emit("input", this.getInputValue(t));
      };
      return this.debounce && (e = cx(e, this.debounce)), this.type == "checkbox" && (n.checked = this.passedInputValue), Object.assign(n, this.$attrs, {
        onInput: e,
        onChange: (t) => {
          this.$emit("change", this.getInputValue(t)), this.$emit("update:modelValue", this.getInputValue(t));
        }
      });
    },
    selectOptions() {
      return this.options.map((n) => typeof n == "string" ? {
        label: n,
        value: n
      } : n).filter(Boolean);
    },
    isNormalInput() {
      return [
        "text",
        "number",
        "checkbox",
        "email",
        "password",
        "date"
      ].includes(this.type);
    }
  }
}, ele = {
  key: 0,
  class: "mb-2 block text-sm leading-4 text-gray-700"
}, tle = ["type", "disabled", "placeholder", "value"], nle = ["placeholder", "value", "disabled", "rows"], rle = ["disabled"], ile = ["value", "disabled", "selected"], ale = {
  key: 1,
  class: "ml-2 inline-block text-base leading-4"
};
function ole(n, e, t, r, i, a) {
  const o = En;
  return L(), W("label", {
    class: _e([t.type == "checkbox" ? "flex" : "block", n.$attrs.class]),
    style: An(n.$attrs.style)
  }, [
    t.label && t.type != "checkbox" ? (L(), W("span", ele, ke(t.label), 1)) : ge("", !0),
    G("div", {
      class: _e(["relative flex", { "items-center": a.isNormalInput || t.type == "select" }])
    }, [
      t.iconLeft && t.type != "checkbox" ? (L(), re(o, {
        key: 0,
        name: t.iconLeft,
        class: _e(["absolute mx-2 h-4 w-4 text-gray-600", { "mt-2": t.type == "textarea" }])
      }, null, 8, ["name", "class"])) : ge("", !0),
      a.isNormalInput ? (L(), W("input", He({ key: 1 }, a.inputAttributes, {
        class: ["border-gray-400 placeholder-gray-500", [
          {
            "form-input block w-full": t.type != "checkbox",
            "form-checkbox": t.type == "checkbox",
            "pl-8": t.iconLeft && t.type != "checkbox"
          },
          t.inputClass
        ]],
        ref: "input",
        type: t.type || "text",
        disabled: t.disabled,
        placeholder: t.placeholder,
        value: a.passedInputValue
      }), null, 16, tle)) : ge("", !0),
      t.type === "textarea" ? (L(), W("textarea", He({ key: 2 }, a.inputAttributes, {
        placeholder: t.placeholder,
        class: ["placeholder-gray-500", [
          "form-textarea block w-full resize-none",
          t.inputClass,
          {
            "pl-8": t.iconLeft
          }
        ]],
        ref: "input",
        value: a.passedInputValue,
        disabled: t.disabled,
        rows: t.rows
      }), null, 16, nle)) : ge("", !0),
      t.type === "select" ? (L(), W("select", He({ key: 3 }, a.inputAttributes, {
        class: ["form-select block w-full", { "pl-8": t.iconLeft }],
        ref: "input",
        disabled: t.disabled
      }), [
        (L(!0), W(Ke, null, _t(a.selectOptions, (s) => (L(), W("option", {
          key: s.value,
          value: s.value,
          disabled: s.disabled || !1,
          selected: a.passedInputValue === s.value
        }, ke(s.label), 9, ile))), 128))
      ], 16, rle)) : ge("", !0)
    ], 2),
    t.label && t.type == "checkbox" ? (L(), W("span", ale, ke(t.label), 1)) : ge("", !0)
  ], 6);
}
const wUe = /* @__PURE__ */ zt(Qse, [["render", ole]]), sle = {
  props: ["to"],
  computed: {
    attributes() {
      return {
        ...this.$attrs,
        target: this.isExternal ? "_blank" : null,
        to: this.isExternal ? void 0 : this.to,
        href: this.isExternal ? this.to : void 0
      };
    },
    isExternal() {
      return this.to.startsWith("http");
    }
  }
};
function lle(n, e, t, r, i, a) {
  return L(), re(bn(a.isExternal ? "a" : "router-link"), He(a.attributes, { class: "cursor-pointer text-blue-500 hover:text-blue-600" }), {
    default: ee(() => [
      ue(n.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const SUe = /* @__PURE__ */ zt(sle, [["render", lle]]), ule = {
  name: "ListItem",
  props: ["title", "subtitle"],
  computed: {
    secondaryText() {
      return (this.subtitle || "").replace(`
`, "<br>");
    }
  }
}, cle = { class: "flex items-center justify-between py-3" }, dle = { class: "text-base font-medium text-gray-900" }, fle = {
  key: 0,
  class: "mt-1"
}, ple = ["innerHTML"];
function hle(n, e, t, r, i, a) {
  return L(), W("div", cle, [
    G("div", null, [
      G("h3", dle, ke(t.title), 1),
      a.secondaryText || n.$slots.subtitle ? (L(), W("div", fle, [
        a.secondaryText ? (L(), W("span", {
          key: 0,
          class: "text-base text-gray-600",
          innerHTML: a.secondaryText
        }, null, 8, ple)) : ge("", !0),
        n.$slots.subtitle ? ue(n.$slots, "subtitle", { key: 1 }) : ge("", !0)
      ])) : ge("", !0)
    ]),
    ue(n.$slots, "actions")
  ]);
}
const EUe = /* @__PURE__ */ zt(ule, [["render", hle]]), vle = { class: "w-full space-y-[10px]" }, mle = {
  key: 0,
  class: "flex items-baseline justify-between"
}, gle = {
  key: 0,
  class: "text-base font-medium text-ink-gray-8"
}, yle = { key: 1 }, ble = {
  key: 2,
  class: "self-end"
}, _le = { class: "text-base font-medium text-ink-gray-4" }, xle = ["aria-valuenow"], wle = 0, Qw = 100, TUe = /* @__PURE__ */ ve({
  __name: "Progress",
  props: {
    value: {},
    size: { default: "sm" },
    label: { default: "" },
    hint: { type: Boolean, default: !1 },
    intervals: { type: Boolean, default: !1 },
    intervalCount: { default: 6 }
  },
  setup(n) {
    const e = n, t = K(() => {
      const i = {
        sm: "h-[2px]",
        md: "h-1",
        lg: "h-2",
        xl: "h-3"
      }[e.size], a = e.intervals ? "flex space-x-1" : "relative bg-surface-gray-2";
      return [i, a];
    }), r = K(() => e.value > Qw ? e.intervalCount : Math.round(e.value / Qw * e.intervalCount));
    return (i, a) => (L(), W("div", vle, [
      e.label || e.hint ? (L(), W("div", mle, [
        e.label ? (L(), W("span", gle, ke(e.label), 1)) : (L(), W("span", yle)),
        e.hint || i.$slots.hint ? (L(), W("span", ble, [
          ue(i.$slots, "hint", {}, () => [
            G("span", _le, ke(e.value) + "% ", 1)
          ])
        ])) : ge("", !0)
      ])) : ge("", !0),
      G("div", {
        class: _e(["overflow-hidden rounded-xl", t.value]),
        "aria-valuemax": Qw,
        "aria-valuemin": wle,
        "aria-valuenow": e.value,
        role: "progressbar"
      }, [
        e.intervals ? (L(!0), W(Ke, { key: 1 }, _t(i.intervalCount, (o) => (L(), W("div", {
          class: _e([
            "h-full w-full",
            o <= r.value ? "bg-surface-gray-7" : "bg-surface-gray-2"
          ])
        }, null, 2))), 256)) : (L(), W("div", {
          key: 0,
          class: "h-full bg-surface-gray-7",
          style: An(`width: ${e.value}%`)
        }, null, 4))
      ], 10, xle)
    ]));
  }
}), Sle = { class: "space-y-1" }, Ele = {
  key: 0,
  class: "block text-xs text-ink-gray-5"
}, Tle = { class: "flex text-center" }, Cle = ["onMouseover"], CUe = /* @__PURE__ */ ve({
  __name: "Rating",
  props: {
    modelValue: { default: 0 },
    rating_from: { default: 5 },
    label: {},
    readonly: { type: Boolean, default: !1 },
    size: { default: "md" }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Z(t.modelValue), a = Z(0), o = (u) => {
      let c = [
        {
          sm: "size-4",
          md: "size-5",
          lg: "size-6",
          xl: "size-7"
        }[t.size]
      ];
      return u <= a.value && u > i.value ? c.push("!fill-yellow-200") : u <= i.value && c.push("!fill-yellow-500"), t.readonly || c.push("cursor-pointer"), c.join(" ");
    }, s = (u) => {
      r("update:modelValue", u);
    }, l = (u) => {
      t.readonly || (s(u), i.value = u);
    };
    return et(
      () => t.modelValue,
      (u) => {
        i.value = u;
      }
    ), (u, c) => (L(), W("div", Sle, [
      u.label ? (L(), W("label", Ele, ke(u.label), 1)) : ge("", !0),
      G("div", Tle, [
        (L(!0), W(Ke, null, _t(u.rating_from, (d) => (L(), W("div", {
          key: d,
          onMouseover: () => !u.readonly && (a.value = d),
          onMouseleave: c[0] || (c[0] = () => !u.readonly && (a.value = 0))
        }, [
          se(En, {
            name: "star",
            class: _e(["fill-gray-300 text-transparent mr-0.5", o(d)]),
            onClick: (f) => l(d)
          }, null, 8, ["class", "onClick"])
        ], 40, Cle))), 128))
      ])
    ]));
  }
}), kUe = {
  name: "Resource",
  props: ["options"],
  resources: {
    resource() {
      return this.options;
    }
  },
  render() {
    return this.$slots.default({
      resource: this.$resources.resource,
      data: this.$resources.resource.data,
      error: this.$resources.resource.error,
      loading: this.$resources.resource.loading,
      fetch: (n) => this.$resources.resource.fetch(n),
      submit: (n) => this.$resources.resource.submit(n)
    });
  }
}, kle = {
  class: "lucide lucide-eye",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Ale(n, e) {
  return L(), W("svg", kle, [...e[0] || (e[0] = [
    G("path", { d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0" }, null, -1),
    G("circle", {
      cx: "12",
      cy: "12",
      r: "3"
    }, null, -1)
  ])]);
}
const Mle = cn({ name: "lucide-eye", render: Ale }), Dle = {
  class: "lucide lucide-eye-off",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Ole(n, e) {
  return L(), W("svg", Dle, [...e[0] || (e[0] = [
    G("path", { d: "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49" }, null, -1),
    G("path", { d: "M14.084 14.158a3 3 0 0 1-4.242-4.242" }, null, -1),
    G("path", { d: "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143" }, null, -1),
    G("path", { d: "m2 2 20 20" }, null, -1)
  ])]);
}
const Ile = cn({ name: "lucide-eye-off", render: Ole }), Lle = {
  class: "lucide lucide-command",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Nle(n, e) {
  return L(), W("svg", Lle, [...e[0] || (e[0] = [
    G("path", { d: "M15 6v12a3 3 0 1 0 3-3H6a3 3 0 1 0 3 3V6a3 3 0 1 0-3 3h12a3 3 0 1 0-3-3" }, null, -1)
  ])]);
}
const Rle = cn({ name: "lucide-command", render: Nle }), Ple = {
  class: "lucide lucide-arrow-big-up",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function jle(n, e) {
  return L(), W("svg", Ple, [...e[0] || (e[0] = [
    G("path", { d: "M9 13a1 1 0 0 0-1-1H5.061a1 1 0 0 1-.75-1.811l6.836-6.835a1.207 1.207 0 0 1 1.707 0l6.835 6.835a1 1 0 0 1-.75 1.811H16a1 1 0 0 0-1 1v6a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1z" }, null, -1)
  ])]);
}
const Ble = cn({ name: "lucide-arrow-big-up", render: jle }), $le = {
  class: "lucide lucide-option",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function zle(n, e) {
  return L(), W("svg", $le, [...e[0] || (e[0] = [
    G("path", { d: "M3 3h6l6 18h6" }, null, -1),
    G("path", { d: "M14 3h7" }, null, -1)
  ])]);
}
const Fle = cn({ name: "lucide-option", render: zle }), Vle = { key: 0 }, Hle = { key: 1 }, Gle = { key: 1 }, Ule = { key: 2 }, Wle = /* @__PURE__ */ ve({
  __name: "KeyboardShortcut",
  props: {
    meta: Boolean,
    ctrl: Boolean,
    shift: Boolean,
    alt: Boolean,
    shortcut: String,
    bg: Boolean
  },
  setup(n) {
    const e = navigator.userAgent.includes("Mac");
    return (t, r) => (L(), W("div", {
      class: _e(["inline-flex items-center gap-0.5 text-sm", {
        "bg-surface-gray-2 rounded-sm text-ink-gray-5 py-0.5 px-1": n.bg,
        "text-ink-gray-4": !n.bg
      }])
    }, [
      n.ctrl || n.meta ? (L(), W("span", Vle, [
        O(e) ? (L(), re(O(Rle), {
          key: 0,
          class: "w-3 h-3"
        })) : (L(), W("span", Hle, "Ctrl"))
      ])) : ge("", !0),
      n.shift ? (L(), W("span", Gle, [
        se(O(Ble), { class: "w-3 h-3" })
      ])) : ge("", !0),
      n.alt ? (L(), W("span", Ule, [
        se(O(Fle), { class: "w-3 h-3" })
      ])) : ge("", !0),
      ue(t.$slots, "default")
    ], 2));
  }
}), qle = { class: "rounded bg-surface-gray-7 py-1.5 px-2 text-xs text-ink-white shadow-xl" }, Yle = { class: "flex items-center gap-1" }, AUe = /* @__PURE__ */ ve({
  __name: "Password",
  props: {
    modelValue: {},
    value: {}
  },
  setup(n) {
    const e = n, t = Z(!1), r = K(() => {
      let i = e.modelValue || e.value;
      return !(i != null && i.includes("*"));
    });
    return (i, a) => (L(), re(Fs, He({
      type: t.value ? "text" : "password",
      value: i.modelValue || i.value
    }, i.$attrs, {
      onKeydown: [
        a[1] || (a[1] = ci(xt((o) => t.value = !t.value, ["meta", "prevent"]), ["i"])),
        a[2] || (a[2] = ci(xt((o) => t.value = !t.value, ["ctrl", "prevent"]), ["i"]))
      ]
    }), Zc({
      suffix: ee(() => [
        se(Ei, null, {
          body: ee(() => [
            G("div", qle, [
              G("span", Yle, [
                gn(ke(t.value ? "Hide Password" : "Show Password") + " ", 1),
                se(Wle, {
                  bg: "",
                  ctrl: "",
                  class: "!bg-surface-gray-5 !text-ink-gray-2 px-1"
                }, {
                  default: ee(() => [...a[3] || (a[3] = [
                    G("span", { class: "font-mono leading-none tracking-widest" }, "+I", -1)
                  ])]),
                  _: 1
                })
              ])
            ])
          ]),
          default: ee(() => [
            G("div", null, [
              ta((L(), re(bn(t.value ? O(Ile) : O(Mle)), {
                class: "h-3 cursor-pointer mr-1",
                onClick: a[0] || (a[0] = (o) => t.value = !t.value)
              }, null, 512)), [
                [hs, r.value]
              ])
            ])
          ]),
          _: 1
        })
      ]),
      _: 2
    }, [
      i.$slots.prefix ? {
        name: "prefix",
        fn: ee(() => [
          ue(i.$slots, "prefix")
        ]),
        key: "0"
      } : void 0
    ]), 1040, ["type", "value"]));
  }
}), Kle = {}, Xle = {
  class: "spinner",
  viewBox: "0 0 50 50"
};
function Zle(n, e) {
  return L(), W("svg", Xle, [...e[0] || (e[0] = [
    G("defs", null, [
      G("linearGradient", {
        id: "gradient",
        x1: "0%",
        y1: "0%",
        x2: "0%",
        y2: "100%"
      }, [
        G("stop", {
          offset: "0%",
          "stop-color": "rgba(0,110,219,1)"
        }),
        G("stop", {
          offset: "100%",
          "stop-color": "rgba(255,255,255,0)"
        })
      ])
    ], -1),
    G("circle", {
      stroke: "url(#gradient)",
      class: "spinner-path",
      cx: "25",
      cy: "25",
      r: "20",
      fill: "none",
      "stroke-width": "5"
    }, null, -1)
  ])]);
}
const MUe = /* @__PURE__ */ zt(Kle, [["render", Zle], ["__scopeId", "data-v-316e5c3b"]]), DUe = /* @__PURE__ */ ve({
  __name: "Switch",
  props: {
    size: { default: "sm" },
    label: { default: "" },
    description: { default: "" },
    disabled: { type: Boolean, default: !1 },
    modelValue: { type: [Boolean, Number, String] }
  },
  emits: ["change", "update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = K(() => t.label && t.description ? 2 : t.label ? 1 : 0), a = K(() => [
      "relative inline-flex flex-shrink-0 cursor-pointer rounded-full border-transparent transition-colors duration-100 ease-in-out items-center",
      "focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-outline-gray-3",
      "disabled:cursor-not-allowed disabled:bg-surface-gray-3",
      t.modelValue ? "bg-surface-gray-7 enabled:hover:bg-surface-gray-6 active:bg-surface-gray-5 group-hover:enabled:bg-surface-gray-6" : "bg-surface-gray-4 enabled:hover:bg-gray-400 active:bg-gray-500 group-hover:enabled:bg-gray-400",
      t.size === "md" ? "h-5 w-8 border-[3px]" : "h-4 w-[26px] border-2"
    ]), o = K(() => [
      "pointer-events-none inline-block transform rounded-full bg-surface-white shadow ring-0 transition duration-100 ease-in-out",
      t.size === "md" ? "h-3.5 w-3.5" : "h-3 w-3",
      t.size === "md" ? t.modelValue ? "translate-x-3 rtl:-translate-x-3" : "translate-x-0" : t.modelValue ? "translate-x-2.5 rtl:-translate-x-2.5" : "translate-x-0"
    ]), s = K(() => [
      "font-medium leading-normal",
      t.disabled && i.value === 1 ? "text-ink-gray-4" : "text-ink-gray-8",
      t.size === "md" ? "text-lg" : "text-base"
    ]), l = K(() => ["max-w-xs text-p-base text-ink-gray-7"]), u = K(() => {
      const d = ["flex justify-between"];
      return i.value === 1 ? (d.push(
        "group items-center space-x-3 cursor-pointer rounded focus-visible:bg-surface-gray-2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-outline-gray-3"
      ), d.push(
        t.disabled ? "cursor-not-allowed" : "hover:bg-surface-gray-3 active:bg-surface-gray-4"
      ), d.push(t.size === "md" ? "px-3 py-1.5" : "px-2.5 py-1.5")) : i.value === 2 && (d.push("items-start"), d.push(t.size === "md" ? "space-x-3.5" : "space-x-2.5")), d;
    }), c = K(() => ["flex flex-col space-y-0.5"]);
    return (d, f) => (L(), re(O(HJ), {
      as: "div",
      tabindex: i.value == 1 ? 0 : -1,
      onKeyup: f[1] || (f[1] = ci(xt((p) => r("update:modelValue", !d.modelValue), ["self"]), ["space"])),
      class: _e(u.value)
    }, {
      default: ee(() => [
        G("span", {
          class: _e(c.value)
        }, [
          t.label ? (L(), re(O(UJ), {
            key: 0,
            as: "span",
            class: _e(s.value)
          }, {
            default: ee(() => [
              gn(ke(t.label), 1)
            ]),
            _: 1
          }, 8, ["class"])) : ge("", !0),
          t.description ? (L(), re(O(WJ), {
            key: 1,
            as: "span",
            class: _e(l.value)
          }, {
            default: ee(() => [
              gn(ke(t.description), 1)
            ]),
            _: 1
          }, 8, ["class"])) : ge("", !0)
        ], 2),
        se(O(GJ), {
          disabled: t.disabled,
          "model-value": !!d.modelValue,
          class: _e(a.value),
          "onUpdate:modelValue": f[0] || (f[0] = (p) => r("update:modelValue", !d.modelValue))
        }, {
          default: ee(() => [
            G("span", {
              "aria-hidden": "true",
              class: _e(o.value)
            }, null, 2)
          ]),
          _: 1
        }, 8, ["disabled", "model-value", "class"])
      ]),
      _: 1
    }, 8, ["tabindex", "class"]));
  }
}), Jle = {
  name: "TabButtons",
  props: {
    buttons: {
      type: Array,
      required: !0
    },
    modelValue: {
      type: [String, Boolean, Number]
    }
  },
  emits: ["update:modelValue"],
  components: {
    Button: fn,
    FeatherIcon: En,
    RadioGroup: $J,
    RadioGroupOption: FJ,
    RadioGroupLabel: VJ
  },
  computed: {
    value: {
      get() {
        return this.modelValue;
      },
      set(n) {
        this.$emit("update:modelValue", n);
      }
    }
  }
}, Qle = { class: "flex space-x-0.5 rounded-md bg-surface-gray-2 h-7 items-center px-[1px] text-sm" };
function eue(n, e, t, r, i, a) {
  const o = ol("RadioGroupLabel"), s = fn, l = ol("RadioGroupOption"), u = ol("RadioGroup");
  return L(), re(u, {
    modelValue: a.value,
    "onUpdate:modelValue": e[0] || (e[0] = (c) => a.value = c)
  }, {
    default: ee(() => [
      G("div", Qle, [
        (L(!0), W(Ke, null, _t(t.buttons, (c) => (L(), re(l, {
          as: "div",
          key: c.label,
          disabled: c.disabled,
          value: c.value ?? c.label
        }, {
          default: ee(({ active: d, checked: f }) => [
            se(s, He({
              onClick: c.onClick
            }, { ref_for: !0 }, c, {
              class: ["!h-6.5", [
                d ? "ring-outline-gray-2 focus-visible:ring" : "",
                f && "!bg-surface-white",
                c.disabled ? "" : f ? " text-ink-gray-9 shadow" : "text-ink-gray-7"
              ]]
            }), {
              default: ee(() => [
                ta(se(o, {
                  as: "span",
                  class: "flex h-4 items-center"
                }, {
                  default: ee(() => [
                    gn(ke(c.label), 1)
                  ]),
                  _: 2
                }, 1536), [
                  [hs, c.label && !c.hideLabel]
                ])
              ]),
              _: 2
            }, 1040, ["onClick", "class"])
          ]),
          _: 2
        }, 1032, ["disabled", "value"]))), 128))
      ])
    ]),
    _: 1
  }, 8, ["modelValue"]);
}
const p6 = /* @__PURE__ */ zt(Jle, [["render", eue]]), tue = {
  __name: "TabList",
  setup(n) {
    const e = Xt("tab"), t = Z([]), r = Z(null), i = K(() => {
      var s;
      return (s = e.value.tabs.value) == null ? void 0 : s.length;
    }), a = Z("");
    function o(s) {
      s >= i.value && (s = i.value - 1);
      const l = t.value[s].el;
      e.value.vertical.value ? (r.value.style.height = `${l.offsetHeight}px`, r.value.style.top = `${l.offsetTop}px`) : (r.value.style.width = `${l.offsetWidth}px`, r.value.style.left = `${l.offsetLeft}px`);
    }
    return et(
      () => e.value.tabIndex.value,
      (s) => {
        s >= i.value && (e.value.tabIndex.value = i.value - 1), a.value = "transition-all duration-300 ease-in-out", Wt(() => o(s));
      }
    ), kt(() => {
      Wt(() => o(e.value.tabIndex.value)), setTimeout(() => o(e.value.tabIndex.value), 100);
    }), (s, l) => (L(), re(O(ZJ), {
      class: _e([
        "relative flex",
        O(e).vertical ? "flex-col border-r overflow-y-auto" : "gap-7.5 border-b overflow-x-auto items-center px-5"
      ])
    }, {
      default: ee(() => [
        (L(!0), W(Ke, null, _t(O(e).tabs, (u, c) => (L(), re(O(JJ), {
          ref_for: !0,
          ref_key: "tabRef",
          ref: t,
          as: "template",
          key: c,
          class: "focus:outline-none focus:transition-none"
        }, {
          default: ee(({ selected: d }) => [
            ue(s.$slots, "default", He({ ref_for: !0 }, { tab: u, selected: d }), () => [
              G("button", {
                class: _e(["flex items-center gap-1.5 text-base text-ink-gray-5 duration-300 ease-in-out hover:text-ink-gray-9", [
                  d ? "text-ink-gray-9" : "",
                  O(e).vertical ? "py-2.5 px-4 border-r border-transparent hover:border-outline-gray-3" : "py-3 border-b border-transparent hover:border-outline-gray-3"
                ]])
              }, [
                u.icon ? (L(), re(bn(u.icon), {
                  key: 0,
                  class: "size-4"
                })) : ge("", !0),
                gn(" " + ke(u.label), 1)
              ], 2)
            ])
          ]),
          _: 2
        }, 1024))), 128)),
        G("div", {
          ref_key: "indicator",
          ref: r,
          class: _e(["tab-indicator absolute bg-surface-gray-7", [O(e).vertical ? "right-0 w-px" : "bottom-0 h-px", a.value]])
        }, null, 2)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}, nue = {
  __name: "TabPanel",
  setup(n) {
    const e = Xt("tab");
    return (t, r) => (L(), re(O(QJ), { class: "flex flex-1 overflow-hidden" }, {
      default: ee(() => [
        (L(!0), W(Ke, null, _t(O(e).tabs, (i, a) => (L(), re(O(eQ), {
          class: "flex flex-1 flex-col overflow-y-auto focus:outline-none",
          key: a
        }, {
          default: ee(() => [
            ue(t.$slots, "default", He({ ref_for: !0 }, { tab: i }))
          ]),
          _: 2
        }, 1024))), 128))
      ]),
      _: 3
    }));
  }
}, OUe = {
  __name: "Tabs",
  props: /* @__PURE__ */ MA({
    as: {
      type: String,
      default: "template"
    },
    tabs: {
      type: Array,
      required: !0
    },
    vertical: {
      type: Boolean,
      default: !1
    }
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(n) {
    const e = n, t = DA(n, "modelValue");
    return zn(
      "tab",
      K(() => ({
        tabIndex: t,
        tabs: e.tabs,
        vertical: e.vertical
      }))
    ), (r, i) => (L(), re(O(XJ), He(
      n.as !== "template" ? {
        as: n.as,
        class: ["flex flex-1 overflow-hidden", n.vertical ? "" : "flex-col "]
      } : {},
      {
        defaultIndex: t.value,
        selectedIndex: t.value,
        onChange: i[0] || (i[0] = (a) => t.value = a)
      }
    ), {
      default: ee(() => [
        ue(r.$slots, "default", {}, () => [
          se(tue, null, {
            default: ee(({ tab: a, selected: o }) => [
              ue(r.$slots, "tab-item", Bt(Jt({ tab: a, selected: o })))
            ]),
            _: 3
          }),
          se(nue, null, {
            default: ee(({ tab: a }) => [
              ue(r.$slots, "tab-panel", Bt(Jt({ tab: a })))
            ]),
            _: 3
          })
        ])
      ]),
      _: 3
    }, 16, ["defaultIndex", "selectedIndex"]));
  }
};
function Wr(n) {
  this.content = n;
}
Wr.prototype = {
  constructor: Wr,
  find: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === n) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(n) {
    var e = this.find(n);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(n, e, t) {
    var r = t && t != n ? this.remove(t) : this, i = r.find(n), a = r.content.slice();
    return i == -1 ? a.push(t || n, e) : (a[i + 1] = e, t && (a[i] = t)), new Wr(a);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(n) {
    var e = this.find(n);
    if (e == -1) return this;
    var t = this.content.slice();
    return t.splice(e, 2), new Wr(t);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(n, e) {
    return new Wr([n, e].concat(this.remove(n).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(n, e) {
    var t = this.remove(n).content.slice();
    return t.push(n, e), new Wr(t);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(n, e, t) {
    var r = this.remove(e), i = r.content.slice(), a = r.find(n);
    return i.splice(a == -1 ? i.length : a, 0, e, t), new Wr(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      n(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(n) {
    return n = Wr.from(n), n.size ? new Wr(n.content.concat(this.subtract(n).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(n) {
    return n = Wr.from(n), n.size ? new Wr(this.subtract(n).content.concat(n.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(n) {
    var e = this;
    n = Wr.from(n);
    for (var t = 0; t < n.content.length; t += 2)
      e = e.remove(n.content[t]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var n = {};
    return this.forEach(function(e, t) {
      n[e] = t;
    }), n;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Wr.from = function(n) {
  if (n instanceof Wr) return n;
  var e = [];
  if (n) for (var t in n) e.push(t, n[t]);
  return new Wr(e);
};
function h6(n, e, t) {
  for (let r = 0; ; r++) {
    if (r == n.childCount || r == e.childCount)
      return n.childCount == e.childCount ? null : t;
    let i = n.child(r), a = e.child(r);
    if (i == a) {
      t += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(a))
      return t;
    if (i.isText && i.text != a.text) {
      for (let o = 0; i.text[o] == a.text[o]; o++)
        t++;
      return t;
    }
    if (i.content.size || a.content.size) {
      let o = h6(i.content, a.content, t + 1);
      if (o != null)
        return o;
    }
    t += i.nodeSize;
  }
}
function v6(n, e, t, r) {
  for (let i = n.childCount, a = e.childCount; ; ) {
    if (i == 0 || a == 0)
      return i == a ? null : { a: t, b: r };
    let o = n.child(--i), s = e.child(--a), l = o.nodeSize;
    if (o == s) {
      t -= l, r -= l;
      continue;
    }
    if (!o.sameMarkup(s))
      return { a: t, b: r };
    if (o.isText && o.text != s.text) {
      let u = 0, c = Math.min(o.text.length, s.text.length);
      for (; u < c && o.text[o.text.length - u - 1] == s.text[s.text.length - u - 1]; )
        u++, t--, r--;
      return { a: t, b: r };
    }
    if (o.content.size || s.content.size) {
      let u = v6(o.content, s.content, t - 1, r - 1);
      if (u)
        return u;
    }
    t -= l, r -= l;
  }
}
class $e {
  /**
  @internal
  */
  constructor(e, t) {
    if (this.content = e, this.size = t || 0, t == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, t, r, i = 0, a) {
    for (let o = 0, s = 0; s < t; o++) {
      let l = this.content[o], u = s + l.nodeSize;
      if (u > e && r(l, i + s, a || null, o) !== !1 && l.content.size) {
        let c = s + 1;
        l.nodesBetween(Math.max(0, e - c), Math.min(l.content.size, t - c), r, i + c);
      }
      s = u;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, t, r, i) {
    let a = "", o = !0;
    return this.nodesBetween(e, t, (s, l) => {
      let u = s.isText ? s.text.slice(Math.max(e, l) - l, t - l) : s.isLeaf ? i ? typeof i == "function" ? i(s) : i : s.type.spec.leafText ? s.type.spec.leafText(s) : "" : "";
      s.isBlock && (s.isLeaf && u || s.isTextblock) && r && (o ? o = !1 : a += r), a += u;
    }, 0), a;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let t = this.lastChild, r = e.firstChild, i = this.content.slice(), a = 0;
    for (t.isText && t.sameMarkup(r) && (i[i.length - 1] = t.withText(t.text + r.text), a = 1); a < e.content.length; a++)
      i.push(e.content[a]);
    return new $e(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, t = this.size) {
    if (e == 0 && t == this.size)
      return this;
    let r = [], i = 0;
    if (t > e)
      for (let a = 0, o = 0; o < t; a++) {
        let s = this.content[a], l = o + s.nodeSize;
        l > e && ((o < e || l > t) && (s.isText ? s = s.cut(Math.max(0, e - o), Math.min(s.text.length, t - o)) : s = s.cut(Math.max(0, e - o - 1), Math.min(s.content.size, t - o - 1))), r.push(s), i += s.nodeSize), o = l;
      }
    return new $e(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, t) {
    return e == t ? $e.empty : e == 0 && t == this.content.length ? this : new $e(this.content.slice(e, t));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, t) {
    let r = this.content[e];
    if (r == t)
      return this;
    let i = this.content.slice(), a = this.size + t.nodeSize - r.nodeSize;
    return i[e] = t, new $e(i, a);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new $e([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new $e(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let t = 0; t < this.content.length; t++)
      if (!this.content[t].eq(e.content[t]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let t = this.content[e];
    if (!t)
      throw new RangeError("Index " + e + " out of range for " + this);
    return t;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let t = 0, r = 0; t < this.content.length; t++) {
      let i = this.content[t];
      e(i, r, t), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, t = 0) {
    return h6(this, e, t);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, t = this.size, r = e.size) {
    return v6(this, e, t, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e) {
    if (e == 0)
      return Ey(0, e);
    if (e == this.size)
      return Ey(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let t = 0, r = 0; ; t++) {
      let i = this.child(t), a = r + i.nodeSize;
      if (a >= e)
        return a == e ? Ey(t + 1, a) : Ey(t, r);
      r = a;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return $e.empty;
    if (!Array.isArray(t))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new $e(t.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return $e.empty;
    let t, r = 0;
    for (let i = 0; i < e.length; i++) {
      let a = e[i];
      r += a.nodeSize, i && a.isText && e[i - 1].sameMarkup(a) ? (t || (t = e.slice(0, i)), t[t.length - 1] = a.withText(t[t.length - 1].text + a.text)) : t && t.push(a);
    }
    return new $e(t || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return $e.empty;
    if (e instanceof $e)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new $e([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
$e.empty = new $e([], 0);
const eS = { index: 0, offset: 0 };
function Ey(n, e) {
  return eS.index = n, eS.offset = e, eS;
}
function U1(n, e) {
  if (n === e)
    return !0;
  if (!(n && typeof n == "object") || !(e && typeof e == "object"))
    return !1;
  let t = Array.isArray(n);
  if (Array.isArray(e) != t)
    return !1;
  if (t) {
    if (n.length != e.length)
      return !1;
    for (let r = 0; r < n.length; r++)
      if (!U1(n[r], e[r]))
        return !1;
  } else {
    for (let r in n)
      if (!(r in e) || !U1(n[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in n))
        return !1;
  }
  return !0;
}
let Hn = class jT {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.attrs = t;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let t, r = !1;
    for (let i = 0; i < e.length; i++) {
      let a = e[i];
      if (this.eq(a))
        return e;
      if (this.type.excludes(a.type))
        t || (t = e.slice(0, i));
      else {
        if (a.type.excludes(this.type))
          return e;
        !r && a.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), r = !0), t && t.push(a);
      }
    }
    return t || (t = e.slice()), r || t.push(this), t;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return e.slice(0, t).concat(e.slice(t + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && U1(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[t.type];
    if (!r)
      throw new RangeError(`There is no mark type ${t.type} in this schema`);
    let i = r.create(t.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, t) {
    if (e == t)
      return !0;
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(t[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return jT.none;
    if (e instanceof jT)
      return [e];
    let t = e.slice();
    return t.sort((r, i) => r.type.rank - i.type.rank), t;
  }
};
Hn.none = [];
class W1 extends Error {
}
class nt {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, t, r) {
    this.content = e, this.openStart = t, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, t) {
    let r = g6(this.content, e + this.openStart, t);
    return r && new nt(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, t) {
    return new nt(m6(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return nt.empty;
    let r = t.openStart || 0, i = t.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new nt($e.fromJSON(e, t.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, t = !0) {
    let r = 0, i = 0;
    for (let a = e.firstChild; a && !a.isLeaf && (t || !a.type.spec.isolating); a = a.firstChild)
      r++;
    for (let a = e.lastChild; a && !a.isLeaf && (t || !a.type.spec.isolating); a = a.lastChild)
      i++;
    return new nt(e, r, i);
  }
}
nt.empty = new nt($e.empty, 0, 0);
function m6(n, e, t) {
  let { index: r, offset: i } = n.findIndex(e), a = n.maybeChild(r), { index: o, offset: s } = n.findIndex(t);
  if (i == e || a.isText) {
    if (s != t && !n.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return n.cut(0, e).append(n.cut(t));
  }
  if (r != o)
    throw new RangeError("Removing non-flat range");
  return n.replaceChild(r, a.copy(m6(a.content, e - i - 1, t - i - 1)));
}
function g6(n, e, t, r) {
  let { index: i, offset: a } = n.findIndex(e), o = n.maybeChild(i);
  if (a == e || o.isText)
    return n.cut(0, e).append(t).append(n.cut(e));
  let s = g6(o.content, e - a - 1, t);
  return s && n.replaceChild(i, o.copy(s));
}
function rue(n, e, t) {
  if (t.openStart > n.depth)
    throw new W1("Inserted content deeper than insertion position");
  if (n.depth - t.openStart != e.depth - t.openEnd)
    throw new W1("Inconsistent open depths");
  return y6(n, e, t, 0);
}
function y6(n, e, t, r) {
  let i = n.index(r), a = n.node(r);
  if (i == e.index(r) && r < n.depth - t.openStart) {
    let o = y6(n, e, t, r + 1);
    return a.copy(a.content.replaceChild(i, o));
  } else if (t.content.size)
    if (!t.openStart && !t.openEnd && n.depth == r && e.depth == r) {
      let o = n.parent, s = o.content;
      return td(o, s.cut(0, n.parentOffset).append(t.content).append(s.cut(e.parentOffset)));
    } else {
      let { start: o, end: s } = iue(t, n);
      return td(a, _6(n, o, s, e, r));
    }
  else return td(a, q1(n, e, r));
}
function b6(n, e) {
  if (!e.type.compatibleContent(n.type))
    throw new W1("Cannot join " + e.type.name + " onto " + n.type.name);
}
function BT(n, e, t) {
  let r = n.node(t);
  return b6(r, e.node(t)), r;
}
function ed(n, e) {
  let t = e.length - 1;
  t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n);
}
function Vv(n, e, t, r) {
  let i = (e || n).node(t), a = 0, o = e ? e.index(t) : i.childCount;
  n && (a = n.index(t), n.depth > t ? a++ : n.textOffset && (ed(n.nodeAfter, r), a++));
  for (let s = a; s < o; s++)
    ed(i.child(s), r);
  e && e.depth == t && e.textOffset && ed(e.nodeBefore, r);
}
function td(n, e) {
  return n.type.checkContent(e), n.copy(e);
}
function _6(n, e, t, r, i) {
  let a = n.depth > i && BT(n, e, i + 1), o = r.depth > i && BT(t, r, i + 1), s = [];
  return Vv(null, n, i, s), a && o && e.index(i) == t.index(i) ? (b6(a, o), ed(td(a, _6(n, e, t, r, i + 1)), s)) : (a && ed(td(a, q1(n, e, i + 1)), s), Vv(e, t, i, s), o && ed(td(o, q1(t, r, i + 1)), s)), Vv(r, null, i, s), new $e(s);
}
function q1(n, e, t) {
  let r = [];
  if (Vv(null, n, t, r), n.depth > t) {
    let i = BT(n, e, t + 1);
    ed(td(i, q1(n, e, t + 1)), r);
  }
  return Vv(e, null, t, r), new $e(r);
}
function iue(n, e) {
  let t = e.depth - n.openStart, i = e.node(t).copy(n.content);
  for (let a = t - 1; a >= 0; a--)
    i = e.node(a).copy($e.from(i));
  return {
    start: i.resolveNoCache(n.openStart + t),
    end: i.resolveNoCache(i.content.size - n.openEnd - t)
  };
}
class km {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.path = t, this.parentOffset = r, this.depth = t.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, t = this.index(this.depth);
    if (t == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(t);
    return r ? e.child(t).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
    return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, t) {
    t = this.resolveDepth(t);
    let r = this.path[t * 3], i = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
    for (let a = 0; a < e; a++)
      i += r.child(a).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, t = this.index();
    if (e.content.size == 0)
      return Hn.none;
    if (this.textOffset)
      return e.child(t).marks;
    let r = e.maybeChild(t - 1), i = e.maybeChild(t);
    if (!r) {
      let s = r;
      r = i, i = s;
    }
    let a = r.marks;
    for (var o = 0; o < a.length; o++)
      a[o].type.spec.inclusive === !1 && (!i || !a[o].isInSet(i.marks)) && (a = a[o--].removeFromSet(a));
    return a;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let t = this.parent.maybeChild(this.index());
    if (!t || !t.isInline)
      return null;
    let r = t.marks, i = e.parent.maybeChild(e.index());
    for (var a = 0; a < r.length; a++)
      r[a].type.spec.inclusive === !1 && (!i || !r[a].isInSet(i.marks)) && (r = r[a--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let t = this.depth; t > 0; t--)
      if (this.start(t) <= e && this.end(t) >= e)
        return t;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, t) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!t || t(this.node(r))))
        return new Y1(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 1; t <= this.depth; t++)
      e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, t) {
    if (!(t >= 0 && t <= e.content.size))
      throw new RangeError("Position " + t + " out of range");
    let r = [], i = 0, a = t;
    for (let o = e; ; ) {
      let { index: s, offset: l } = o.content.findIndex(a), u = a - l;
      if (r.push(o, s, i + l), !u || (o = o.child(s), o.isText))
        break;
      a = u - 1, i += l + 1;
    }
    return new km(t, r, a);
  }
  /**
  @internal
  */
  static resolveCached(e, t) {
    let r = VL.get(e);
    if (r)
      for (let a = 0; a < r.elts.length; a++) {
        let o = r.elts[a];
        if (o.pos == t)
          return o;
      }
    else
      VL.set(e, r = new aue());
    let i = r.elts[r.i] = km.resolve(e, t);
    return r.i = (r.i + 1) % oue, i;
  }
}
class aue {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const oue = 12, VL = /* @__PURE__ */ new WeakMap();
class Y1 {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const sue = /* @__PURE__ */ Object.create(null);
let _u = class $T {
  /**
  @internal
  */
  constructor(e, t, r, i = Hn.none) {
    this.type = e, this.attrs = t, this.marks = i, this.content = r || $e.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, t, r, i = 0) {
    this.content.nodesBetween(e, t, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(e, t, r, i) {
    return this.content.textBetween(e, t, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, t, r) {
    return this.type == e && U1(this.attrs, t || e.defaultAttrs || sue) && Hn.sameSet(this.marks, r || Hn.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new $T(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new $T(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, t = this.content.size) {
    return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, t = this.content.size, r = !1) {
    if (e == t)
      return nt.empty;
    let i = this.resolve(e), a = this.resolve(t), o = r ? 0 : i.sharedDepth(t), s = i.start(o), u = i.node(o).content.cut(i.pos - s, a.pos - s);
    return new nt(u, i.depth - o, a.depth - o);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, t, r) {
    return rue(this.resolve(e), this.resolve(t), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let t = this; ; ) {
      let { index: r, offset: i } = t.content.findIndex(e);
      if (t = t.maybeChild(r), !t)
        return null;
      if (i == e || t.isText)
        return t;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: t, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(t), index: t, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: t, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(t), index: t, offset: r };
    let i = this.content.child(t - 1);
    return { node: i, index: t - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return km.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return km.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, t, r) {
    let i = !1;
    return t > e && this.nodesBetween(e, t, (a) => (r.isInSet(a.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), x6(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let t = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!t)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return t;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, t, r = $e.empty, i = 0, a = r.childCount) {
    let o = this.contentMatchAt(e).matchFragment(r, i, a), s = o && o.matchFragment(this.content, t);
    if (!s || !s.validEnd)
      return !1;
    for (let l = i; l < a; l++)
      if (!this.type.allowsMarks(r.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, t, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let a = this.contentMatchAt(e).matchType(r), o = a && a.matchFragment(this.content, t);
    return o ? o.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = Hn.none;
    for (let t = 0; t < this.marks.length; t++) {
      let r = this.marks[t];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!Hn.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
    this.content.forEach((t) => t.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (t.marks) {
      if (!Array.isArray(t.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = t.marks.map(e.markFromJSON);
    }
    if (t.type == "text") {
      if (typeof t.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(t.text, r);
    }
    let i = $e.fromJSON(e, t.content), a = e.nodeType(t.type).create(t.attrs, i, r);
    return a.type.checkAttrs(a.attrs), a;
  }
};
_u.prototype.text = void 0;
class K1 extends _u {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    if (super(e, t, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : x6(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, t) {
    return this.text.slice(e, t);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new K1(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new K1(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, t = this.text.length) {
    return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function x6(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    e = n[t].type.name + "(" + e + ")";
  return e;
}
class xd {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, t) {
    let r = new lue(e, t);
    if (r.next == null)
      return xd.empty;
    let i = w6(r);
    r.next && r.err("Unexpected trailing text");
    let a = vue(hue(i));
    return mue(a, r), a;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let t = 0; t < this.next.length; t++)
      if (this.next[t].type == e)
        return this.next[t].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, t = 0, r = e.childCount) {
    let i = this;
    for (let a = t; i && a < r; a++)
      i = i.matchType(e.child(a).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: t } = this.next[e];
      if (!(t.isText || t.hasRequiredAttrs()))
        return t;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let t = 0; t < this.next.length; t++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[t].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, t = !1, r = 0) {
    let i = [this];
    function a(o, s) {
      let l = o.matchFragment(e, r);
      if (l && (!t || l.validEnd))
        return $e.from(s.map((u) => u.createAndFill()));
      for (let u = 0; u < o.next.length; u++) {
        let { type: c, next: d } = o.next[u];
        if (!(c.isText || c.hasRequiredAttrs()) && i.indexOf(d) == -1) {
          i.push(d);
          let f = a(d, s.concat(c));
          if (f)
            return f;
        }
      }
      return null;
    }
    return a(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let t = this.computeWrapping(e);
    return this.wrapCache.push(e, t), t;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let t = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), a = i.match;
      if (a.matchType(e)) {
        let o = [];
        for (let s = i; s.type; s = s.via)
          o.push(s.type);
        return o.reverse();
      }
      for (let o = 0; o < a.next.length; o++) {
        let { type: s, next: l } = a.next[o];
        !s.isLeaf && !s.hasRequiredAttrs() && !(s.name in t) && (!i.type || l.validEnd) && (r.push({ match: s.contentMatch, type: s, via: i }), t[s.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function t(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && t(r.next[i].next);
    }
    return t(this), e.map((r, i) => {
      let a = i + (r.validEnd ? "*" : " ") + " ";
      for (let o = 0; o < r.next.length; o++)
        a += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next);
      return a;
    }).join(`
`);
  }
}
xd.empty = new xd(!0);
class lue {
  constructor(e, t) {
    this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function w6(n) {
  let e = [];
  do
    e.push(uue(n));
  while (n.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function uue(n) {
  let e = [];
  do
    e.push(cue(n));
  while (n.next && n.next != ")" && n.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function cue(n) {
  let e = pue(n);
  for (; ; )
    if (n.eat("+"))
      e = { type: "plus", expr: e };
    else if (n.eat("*"))
      e = { type: "star", expr: e };
    else if (n.eat("?"))
      e = { type: "opt", expr: e };
    else if (n.eat("{"))
      e = due(n, e);
    else
      break;
  return e;
}
function HL(n) {
  /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'");
  let e = Number(n.next);
  return n.pos++, e;
}
function due(n, e) {
  let t = HL(n), r = t;
  return n.eat(",") && (n.next != "}" ? r = HL(n) : r = -1), n.eat("}") || n.err("Unclosed braced range"), { type: "range", min: t, max: r, expr: e };
}
function fue(n, e) {
  let t = n.nodeTypes, r = t[e];
  if (r)
    return [r];
  let i = [];
  for (let a in t) {
    let o = t[a];
    o.isInGroup(e) && i.push(o);
  }
  return i.length == 0 && n.err("No node type or group '" + e + "' found"), i;
}
function pue(n) {
  if (n.eat("(")) {
    let e = w6(n);
    return n.eat(")") || n.err("Missing closing paren"), e;
  } else if (/\W/.test(n.next))
    n.err("Unexpected token '" + n.next + "'");
  else {
    let e = fue(n, n.next).map((t) => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), { type: "name", value: t }));
    return n.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function hue(n) {
  let e = [[]];
  return i(a(n, 0), t()), e;
  function t() {
    return e.push([]) - 1;
  }
  function r(o, s, l) {
    let u = { term: l, to: s };
    return e[o].push(u), u;
  }
  function i(o, s) {
    o.forEach((l) => l.to = s);
  }
  function a(o, s) {
    if (o.type == "choice")
      return o.exprs.reduce((l, u) => l.concat(a(u, s)), []);
    if (o.type == "seq")
      for (let l = 0; ; l++) {
        let u = a(o.exprs[l], s);
        if (l == o.exprs.length - 1)
          return u;
        i(u, s = t());
      }
    else if (o.type == "star") {
      let l = t();
      return r(s, l), i(a(o.expr, l), l), [r(l)];
    } else if (o.type == "plus") {
      let l = t();
      return i(a(o.expr, s), l), i(a(o.expr, l), l), [r(l)];
    } else {
      if (o.type == "opt")
        return [r(s)].concat(a(o.expr, s));
      if (o.type == "range") {
        let l = s;
        for (let u = 0; u < o.min; u++) {
          let c = t();
          i(a(o.expr, l), c), l = c;
        }
        if (o.max == -1)
          i(a(o.expr, l), l);
        else
          for (let u = o.min; u < o.max; u++) {
            let c = t();
            r(l, c), i(a(o.expr, l), c), l = c;
          }
        return [r(l)];
      } else {
        if (o.type == "name")
          return [r(s, void 0, o.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function S6(n, e) {
  return e - n;
}
function GL(n, e) {
  let t = [];
  return r(e), t.sort(S6);
  function r(i) {
    let a = n[i];
    if (a.length == 1 && !a[0].term)
      return r(a[0].to);
    t.push(i);
    for (let o = 0; o < a.length; o++) {
      let { term: s, to: l } = a[o];
      !s && t.indexOf(l) == -1 && r(l);
    }
  }
}
function vue(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return t(GL(n, 0));
  function t(r) {
    let i = [];
    r.forEach((o) => {
      n[o].forEach(({ term: s, to: l }) => {
        if (!s)
          return;
        let u;
        for (let c = 0; c < i.length; c++)
          i[c][0] == s && (u = i[c][1]);
        GL(n, l).forEach((c) => {
          u || i.push([s, u = []]), u.indexOf(c) == -1 && u.push(c);
        });
      });
    });
    let a = e[r.join(",")] = new xd(r.indexOf(n.length - 1) > -1);
    for (let o = 0; o < i.length; o++) {
      let s = i[o][1].sort(S6);
      a.next.push({ type: i[o][0], next: e[s.join(",")] || t(s) });
    }
    return a;
  }
}
function mue(n, e) {
  for (let t = 0, r = [n]; t < r.length; t++) {
    let i = r[t], a = !i.validEnd, o = [];
    for (let s = 0; s < i.next.length; s++) {
      let { type: l, next: u } = i.next[s];
      o.push(l.name), a && !(l.isText || l.hasRequiredAttrs()) && (a = !1), r.indexOf(u) == -1 && r.push(u);
    }
    a && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function E6(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    if (!r.hasDefault)
      return null;
    e[t] = r.default;
  }
  return e;
}
function T6(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r in n) {
    let i = e && e[r];
    if (i === void 0) {
      let a = n[r];
      if (a.hasDefault)
        i = a.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    t[r] = i;
  }
  return t;
}
function C6(n, e, t, r) {
  for (let i in e)
    if (!(i in n))
      throw new RangeError(`Unsupported attribute ${i} for ${t} of type ${i}`);
  for (let i in n) {
    let a = n[i];
    a.validate && a.validate(e[i]);
  }
}
function k6(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      t[r] = new yue(n, r, e[r]);
  return t;
}
let UL = class A6 {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.name = e, this.schema = t, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = k6(e, r.attrs), this.defaultAttrs = E6(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == xd.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : T6(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, t, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new _u(this, this.computeAttrs(e), $e.from(t), Hn.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, t, r) {
    return t = $e.from(t), this.checkContent(t), new _u(this, this.computeAttrs(e), t, Hn.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, t, r) {
    if (e = this.computeAttrs(e), t = $e.from(t), t.size) {
      let o = this.contentMatch.fillBefore(t);
      if (!o)
        return null;
      t = o.append(t);
    }
    let i = this.contentMatch.matchFragment(t), a = i && i.fillBefore($e.empty, !0);
    return a ? new _u(this, e, t.append(a), Hn.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let t = this.contentMatch.matchFragment(e);
    if (!t || !t.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    C6(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let t = 0; t < e.length; t++)
      if (!this.allowsMarkType(e[t].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let t;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? t && t.push(e[r]) : t || (t = e.slice(0, r));
    return t ? t.length ? t : Hn.none : e;
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((a, o) => r[a] = new A6(a, t, o));
    let i = t.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let a in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function gue(n, e, t) {
  let r = t.split("|");
  return (i) => {
    let a = i === null ? "null" : typeof i;
    if (r.indexOf(a) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${n}, got ${a}`);
  };
}
class yue {
  constructor(e, t, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? gue(e, t, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class vx {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.name = e, this.rank = t, this.schema = r, this.spec = i, this.attrs = k6(e, i.attrs), this.excluded = null;
    let a = E6(this.attrs);
    this.instance = a ? new Hn(this, a) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new Hn(this, T6(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((a, o) => r[a] = new vx(a, i++, t, o)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var t = 0; t < e.length; t++)
      e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].type == this)
        return e[t];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    C6(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class M6 {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let t = this.spec = {};
    for (let i in e)
      t[i] = e[i];
    t.nodes = Wr.from(e.nodes), t.marks = Wr.from(e.marks || {}), this.nodes = UL.compile(this.spec.nodes, this), this.marks = vx.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let a = this.nodes[i], o = a.spec.content || "", s = a.spec.marks;
      if (a.contentMatch = r[o] || (r[o] = xd.parse(o, this.nodes)), a.inlineContent = a.contentMatch.inlineContent, a.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!a.isInline || !a.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = a;
      }
      a.markSet = s == "_" ? null : s ? WL(this, s.split(" ")) : s == "" || !a.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let a = this.marks[i], o = a.spec.excludes;
      a.excluded = o == null ? [a] : o == "" ? [] : WL(this, o.split(" "));
    }
    this.nodeFromJSON = (i) => _u.fromJSON(this, i), this.markFromJSON = (i) => Hn.fromJSON(this, i), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, t = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof UL) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(t, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, t) {
    let r = this.nodes.text;
    return new K1(r, r.defaultAttrs, e, Hn.setFrom(t));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, t) {
    return typeof e == "string" && (e = this.marks[e]), e.create(t);
  }
  /**
  @internal
  */
  nodeType(e) {
    let t = this.nodes[e];
    if (!t)
      throw new RangeError("Unknown node type: " + e);
    return t;
  }
}
function WL(n, e) {
  let t = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], a = n.marks[i], o = a;
    if (a)
      t.push(a);
    else
      for (let s in n.marks) {
        let l = n.marks[s];
        (i == "_" || l.spec.group && l.spec.group.split(" ").indexOf(i) > -1) && t.push(o = l);
      }
    if (!o)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return t;
}
function bue(n) {
  return n.tag != null;
}
function _ue(n) {
  return n.style != null;
}
let hp = class zT {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, t) {
    this.schema = e, this.rules = t, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    t.forEach((i) => {
      if (bue(i))
        this.tags.push(i);
      else if (_ue(i)) {
        let a = /[^=]*/.exec(i.style)[0];
        r.indexOf(a) < 0 && r.push(a), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let a = e.nodes[i.node];
      return a.contentMatch.matchType(a);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, t = {}) {
    let r = new YL(this, t, !1);
    return r.addAll(e, Hn.none, t.from, t.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, t = {}) {
    let r = new YL(this, t, !0);
    return r.addAll(e, Hn.none, t.from, t.to), nt.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, t, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let a = this.tags[i];
      if (Sue(e, a.tag) && (a.namespace === void 0 || e.namespaceURI == a.namespace) && (!a.context || t.matchesContext(a.context))) {
        if (a.getAttrs) {
          let o = a.getAttrs(e);
          if (o === !1)
            continue;
          a.attrs = o || void 0;
        }
        return a;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, t, r, i) {
    for (let a = i ? this.styles.indexOf(i) + 1 : 0; a < this.styles.length; a++) {
      let o = this.styles[a], s = o.style;
      if (!(s.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      s.length > e.length && (s.charCodeAt(e.length) != 61 || s.slice(e.length + 1) != t))) {
        if (o.getAttrs) {
          let l = o.getAttrs(t);
          if (l === !1)
            continue;
          o.attrs = l || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let t = [];
    function r(i) {
      let a = i.priority == null ? 50 : i.priority, o = 0;
      for (; o < t.length; o++) {
        let s = t[o];
        if ((s.priority == null ? 50 : s.priority) < a)
          break;
      }
      t.splice(o, 0, i);
    }
    for (let i in e.marks) {
      let a = e.marks[i].spec.parseDOM;
      a && a.forEach((o) => {
        r(o = KL(o)), o.mark || o.ignore || o.clearMark || (o.mark = i);
      });
    }
    for (let i in e.nodes) {
      let a = e.nodes[i].spec.parseDOM;
      a && a.forEach((o) => {
        r(o = KL(o)), o.node || o.ignore || o.mark || (o.node = i);
      });
    }
    return t;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new zT(e, zT.schemaRules(e)));
  }
};
const D6 = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, xue = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, O6 = { ol: !0, ul: !0 }, Am = 1, FT = 2, Hv = 4;
function qL(n, e, t) {
  return e != null ? (e ? Am : 0) | (e === "full" ? FT : 0) : n && n.whitespace == "pre" ? Am | FT : t & ~Hv;
}
class Ty {
  constructor(e, t, r, i, a, o) {
    this.type = e, this.attrs = t, this.marks = r, this.solid = i, this.options = o, this.content = [], this.activeMarks = Hn.none, this.match = a || (o & Hv ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let t = this.type.contentMatch.fillBefore($e.from(e));
      if (t)
        this.match = this.type.contentMatch.matchFragment(t);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & Am)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let a = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = a.withText(a.text.slice(0, a.text.length - i[0].length));
      }
    }
    let t = $e.from(this.content);
    return !e && this.match && (t = t.append(this.match.fillBefore($e.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !D6.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class YL {
  constructor(e, t, r) {
    this.parser = e, this.options = t, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let i = t.topNode, a, o = qL(null, t.preserveWhitespace, 0) | (r ? Hv : 0);
    i ? a = new Ty(i.type, i.attrs, Hn.none, !0, t.topMatch || i.type.contentMatch, o) : r ? a = new Ty(null, null, Hn.none, !0, null, o) : a = new Ty(e.schema.topNodeType, null, Hn.none, !0, null, o), this.nodes = [a], this.find = t.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, t) {
    e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
  }
  addTextNode(e, t) {
    let r = e.nodeValue, i = this.top, a = i.options & FT ? "full" : this.localPreserveWS || (i.options & Am) > 0;
    if (a === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (a)
        a !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let o = i.content[i.content.length - 1], s = e.previousSibling;
        (!o || s && s.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), t, !/\S/.test(r)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, t, r) {
    let i = this.localPreserveWS, a = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let o = e.nodeName.toLowerCase(), s;
    O6.hasOwnProperty(o) && this.parser.normalizeLists && wue(e);
    let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (s = this.parser.matchTag(e, this, r));
    e: if (l ? l.ignore : xue.hasOwnProperty(o))
      this.findInside(e), this.ignoreFallback(e, t);
    else if (!l || l.skip || l.closeParent) {
      l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
      let u, c = this.needsBlock;
      if (D6.hasOwnProperty(o))
        a.content.length && a.content[0].isInline && this.open && (this.open--, a = this.top), u = !0, a.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, t);
        break e;
      }
      let d = l && l.skip ? t : this.readStyles(e, t);
      d && this.addAll(e, d), u && this.sync(a), this.needsBlock = c;
    } else {
      let u = this.readStyles(e, t);
      u && this.addElementByRule(e, l, u, l.consuming === !1 ? s : void 0);
    }
    this.localPreserveWS = i;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, t) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
  }
  // Called for ignored nodes
  ignoreFallback(e, t) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, t) {
    let r = e.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let a = this.parser.matchedStyles[i], o = r.getPropertyValue(a);
        if (o)
          for (let s = void 0; ; ) {
            let l = this.parser.matchStyle(a, o, this, s);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? t = t.filter((u) => !l.clearMark(u)) : t = t.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              s = l;
            else
              break;
          }
      }
    return t;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, t, r, i) {
    let a, o;
    if (t.node)
      if (o = this.parser.schema.nodes[t.node], o.isLeaf)
        this.insertNode(o.create(t.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r);
      else {
        let l = this.enter(o, t.attrs || null, r, t.preserveWhitespace);
        l && (a = !0, r = l);
      }
    else {
      let l = this.parser.schema.marks[t.mark];
      r = r.concat(l.create(t.attrs));
    }
    let s = this.top;
    if (o && o.isLeaf)
      this.findInside(e);
    else if (i)
      this.addElement(e, r, i);
    else if (t.getContent)
      this.findInside(e), t.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, r, !1));
    else {
      let l = e;
      typeof t.contentElement == "string" ? l = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? l = t.contentElement(e) : t.contentElement && (l = t.contentElement), this.findAround(e, l, !0), this.addAll(l, r), this.findAround(e, l, !1);
    }
    a && this.sync(s) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, t, r, i) {
    let a = r || 0;
    for (let o = r ? e.childNodes[r] : e.firstChild, s = i == null ? null : e.childNodes[i]; o != s; o = o.nextSibling, ++a)
      this.findAtPoint(e, a), this.addDOM(o, t);
    this.findAtPoint(e, a);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, t, r) {
    let i, a;
    for (let o = this.open, s = 0; o >= 0; o--) {
      let l = this.nodes[o], u = l.findWrapping(e);
      if (u && (!i || i.length > u.length + s) && (i = u, a = l, !u.length))
        break;
      if (l.solid) {
        if (r)
          break;
        s += 2;
      }
    }
    if (!i)
      return null;
    this.sync(a);
    for (let o = 0; o < i.length; o++)
      t = this.enterInner(i[o], null, t, !1);
    return t;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, t, r) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let a = this.textblockFromContext();
      a && (t = this.enterInner(a, null, t));
    }
    let i = this.findPlace(e, t, r);
    if (i) {
      this.closeExtra();
      let a = this.top;
      a.match && (a.match = a.match.matchType(e.type));
      let o = Hn.none;
      for (let s of i.concat(e.marks))
        (a.type ? a.type.allowsMarkType(s.type) : XL(s.type, e.type)) && (o = s.addToSet(o));
      return a.content.push(e.mark(o)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, t, r, i) {
    let a = this.findPlace(e.create(t), r, !1);
    return a && (a = this.enterInner(e, t, r, !0, i)), a;
  }
  // Open a node of the given type
  enterInner(e, t, r, i = !1, a) {
    this.closeExtra();
    let o = this.top;
    o.match = o.match && o.match.matchType(e);
    let s = qL(e, a, o.options);
    o.options & Hv && o.content.length == 0 && (s |= Hv);
    let l = Hn.none;
    return r = r.filter((u) => (o.type ? o.type.allowsMarkType(u.type) : XL(u.type, e)) ? (l = u.addToSet(l), !1) : !0), this.nodes.push(new Ty(e, t, l, i, null, s)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let t = this.nodes.length - 1;
    if (t > this.open) {
      for (; t > this.open; t--)
        this.nodes[t - 1].content.push(this.nodes[t].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let t = this.open; t >= 0; t--) {
      if (this.nodes[t] == e)
        return this.open = t, !0;
      this.localPreserveWS && (this.nodes[t].options |= Am);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let t = this.open; t >= 0; t--) {
      let r = this.nodes[t].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      t && e++;
    }
    return e;
  }
  findAtPoint(e, t) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
  }
  findAround(e, t, r) {
    if (e != t && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let t = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), a = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (s, l) => {
      for (; s >= 0; s--) {
        let u = t[s];
        if (u == "") {
          if (s == t.length - 1 || s == 0)
            continue;
          for (; l >= a; l--)
            if (o(s - 1, l))
              return !0;
          return !1;
        } else {
          let c = l > 0 || l == 0 && i ? this.nodes[l].type : r && l >= a ? r.node(l - a).type : null;
          if (!c || c.name != u && !c.isInGroup(u))
            return !1;
          l--;
        }
      }
      return !0;
    };
    return o(t.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let t = e.depth; t >= 0; t--) {
        let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let t in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[t];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function wue(n) {
  for (let e = n.firstChild, t = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && O6.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null);
  }
}
function Sue(n, e) {
  return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e);
}
function KL(n) {
  let e = {};
  for (let t in n)
    e[t] = n[t];
  return e;
}
function XL(n, e) {
  let t = e.schema.nodes;
  for (let r in t) {
    let i = t[r];
    if (!i.allowsMarkType(n))
      continue;
    let a = [], o = (s) => {
      a.push(s);
      for (let l = 0; l < s.edgeCount; l++) {
        let { type: u, next: c } = s.edge(l);
        if (u == e || a.indexOf(c) < 0 && o(c))
          return !0;
      }
    };
    if (o(i.contentMatch))
      return !0;
  }
}
class Ud {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, t) {
    this.nodes = e, this.marks = t;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, t = {}, r) {
    r || (r = tS(t).createDocumentFragment());
    let i = r, a = [];
    return e.forEach((o) => {
      if (a.length || o.marks.length) {
        let s = 0, l = 0;
        for (; s < a.length && l < o.marks.length; ) {
          let u = o.marks[l];
          if (!this.marks[u.type.name]) {
            l++;
            continue;
          }
          if (!u.eq(a[s][0]) || u.type.spec.spanning === !1)
            break;
          s++, l++;
        }
        for (; s < a.length; )
          i = a.pop()[1];
        for (; l < o.marks.length; ) {
          let u = o.marks[l++], c = this.serializeMark(u, o.isInline, t);
          c && (a.push([u, i]), i.appendChild(c.dom), i = c.contentDOM || c.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(o, t));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, t) {
    let { dom: r, contentDOM: i } = i1(tS(t), this.nodes[e.type.name](e), null, e.attrs);
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, t, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, t = {}) {
    let r = this.serializeNodeInner(e, t);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let a = this.serializeMark(e.marks[i], e.isInline, t);
      a && ((a.contentDOM || a.dom).appendChild(r), r = a.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, t, r = {}) {
    let i = this.marks[e.type.name];
    return i && i1(tS(r), i(e, t), null, e.attrs);
  }
  static renderSpec(e, t, r = null, i) {
    return i1(e, t, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Ud(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let t = ZL(e.nodes);
    return t.text || (t.text = (r) => r.text), t;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return ZL(e.marks);
  }
}
function ZL(n) {
  let e = {};
  for (let t in n) {
    let r = n[t].spec.toDOM;
    r && (e[t] = r);
  }
  return e;
}
function tS(n) {
  return n.document || window.document;
}
const JL = /* @__PURE__ */ new WeakMap();
function Eue(n) {
  let e = JL.get(n);
  return e === void 0 && JL.set(n, e = Tue(n)), e;
}
function Tue(n) {
  let e = null;
  function t(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let i = 0; i < r.length; i++)
            t(r[i]);
      else
        for (let i in r)
          t(r[i]);
  }
  return t(n), e;
}
function i1(n, e, t, r) {
  if (typeof e == "string")
    return { dom: n.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let i = e[0], a;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (a = Eue(r)) && a.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let o = i.indexOf(" ");
  o > 0 && (t = i.slice(0, o), i = i.slice(o + 1));
  let s, l = t ? n.createElementNS(t, i) : n.createElement(i), u = e[1], c = 1;
  if (u && typeof u == "object" && u.nodeType == null && !Array.isArray(u)) {
    c = 2;
    for (let d in u)
      if (u[d] != null) {
        let f = d.indexOf(" ");
        f > 0 ? l.setAttributeNS(d.slice(0, f), d.slice(f + 1), u[d]) : d == "style" && l.style ? l.style.cssText = u[d] : l.setAttribute(d, u[d]);
      }
  }
  for (let d = c; d < e.length; d++) {
    let f = e[d];
    if (f === 0) {
      if (d < e.length - 1 || d > c)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: p, contentDOM: h } = i1(n, f, t, r);
      if (l.appendChild(p), h) {
        if (s)
          throw new RangeError("Multiple content holes");
        s = h;
      }
    }
  }
  return { dom: l, contentDOM: s };
}
const I6 = 65535, L6 = Math.pow(2, 16);
function Cue(n, e) {
  return n + e * L6;
}
function QL(n) {
  return n & I6;
}
function kue(n) {
  return (n - (n & I6)) / L6;
}
const N6 = 1, R6 = 2, a1 = 4, P6 = 8;
class VT {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.delInfo = t, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & P6) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (N6 | a1)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (R6 | a1)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & a1) > 0;
  }
}
class ca {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, t = !1) {
    if (this.ranges = e, this.inverted = t, !e.length && ca.empty)
      return ca.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let t = 0, r = QL(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + t + kue(e);
  }
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  map(e, t = 1) {
    return this._map(e, t, !0);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0, a = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let s = 0; s < this.ranges.length; s += 3) {
      let l = this.ranges[s] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let u = this.ranges[s + a], c = this.ranges[s + o], d = l + u;
      if (e <= d) {
        let f = u ? e == l ? -1 : e == d ? 1 : t : t, p = l + i + (f < 0 ? 0 : c);
        if (r)
          return p;
        let h = e == (t < 0 ? l : d) ? null : Cue(s / 3, e - l), v = e == l ? R6 : e == d ? N6 : a1;
        return (t < 0 ? e != l : e != d) && (v |= P6), new VT(p, v, h);
      }
      i += c - u;
    }
    return r ? e + i : new VT(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, t) {
    let r = 0, i = QL(t), a = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let s = 0; s < this.ranges.length; s += 3) {
      let l = this.ranges[s] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let u = this.ranges[s + a], c = l + u;
      if (e <= c && s == i * 3)
        return !0;
      r += this.ranges[s + o] - u;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, a = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i], s = o - (this.inverted ? a : 0), l = o + (this.inverted ? 0 : a), u = this.ranges[i + t], c = this.ranges[i + r];
      e(s, s + u, l, l + c), a += c - u;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new ca(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? ca.empty : new ca(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
ca.empty = new ca([]);
class Mm {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, t, r = 0, i = e ? e.length : 0) {
    this.mirror = t, this.from = r, this.to = i, this._maps = e || [], this.ownData = !(e || t);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, t = this.maps.length) {
    return new Mm(this._maps, this.mirror, e, t);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, t) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), t != null && this.setMirror(this._maps.length - 1, t);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let t = 0, r = this._maps.length; t < e._maps.length; t++) {
      let i = e.getMirror(t);
      this.appendMap(e._maps[t], i != null && i < t ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let t = 0; t < this.mirror.length; t++)
        if (this.mirror[t] == e)
          return this.mirror[t + (t % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, t) {
    this.mirror || (this.mirror = []), this.mirror.push(e, t);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let t = e.maps.length - 1, r = this._maps.length + e._maps.length; t >= 0; t--) {
      let i = e.getMirror(t);
      this.appendMap(e._maps[t].invert(), i != null && i > t ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new Mm();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, t = 1) {
    if (this.mirror)
      return this._map(e, t, !0);
    for (let r = this.from; r < this.to; r++)
      e = this._maps[r].map(e, t);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0;
    for (let a = this.from; a < this.to; a++) {
      let o = this._maps[a], s = o.mapResult(e, t);
      if (s.recover != null) {
        let l = this.getMirror(a);
        if (l != null && l > a && l < this.to) {
          a = l, e = this._maps[l].recover(s.recover);
          continue;
        }
      }
      i |= s.delInfo, e = s.pos;
    }
    return r ? e : new VT(e, i, null);
  }
}
const nS = /* @__PURE__ */ Object.create(null);
class mi {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return ca.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, t) {
    if (!t || !t.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = nS[t.stepType];
    if (!r)
      throw new RangeError(`No step type ${t.stepType} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, t) {
    if (e in nS)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return nS[e] = t, t.prototype.jsonID = e, t;
  }
}
class xr {
  /**
  @internal
  */
  constructor(e, t) {
    this.doc = e, this.failed = t;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new xr(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new xr(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, t, r, i) {
    try {
      return xr.ok(e.replace(t, r, i));
    } catch (a) {
      if (a instanceof W1)
        return xr.fail(a.message);
      throw a;
    }
  }
}
function sM(n, e, t) {
  let r = [];
  for (let i = 0; i < n.childCount; i++) {
    let a = n.child(i);
    a.content.size && (a = a.copy(sM(a.content, e, a))), a.isInline && (a = e(a, t, i)), r.push(a);
  }
  return $e.fromArray(r);
}
class ou extends mi {
  /**
  Create a mark step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), a = new nt(sM(t.content, (o, s) => !o.isAtom || !s.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), t.openStart, t.openEnd);
    return xr.fromReplace(e, this.from, this.to, a);
  }
  invert() {
    return new as(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new ou(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof ou && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ou(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new ou(t.from, t.to, e.markFromJSON(t.mark));
  }
}
mi.jsonID("addMark", ou);
class as extends mi {
  /**
  Create a mark-removing step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = new nt(sM(t.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), t.openStart, t.openEnd);
    return xr.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new ou(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new as(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof as && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new as(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new as(t.from, t.to, e.markFromJSON(t.mark));
  }
}
mi.jsonID("removeMark", as);
class su extends mi {
  /**
  Create a node mark step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return xr.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
    return xr.fromReplace(e, this.pos, this.pos + 1, new nt($e.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    if (t) {
      let r = this.mark.addToSet(t.marks);
      if (r.length == t.marks.length) {
        for (let i = 0; i < t.marks.length; i++)
          if (!t.marks[i].isInSet(r))
            return new su(this.pos, t.marks[i]);
        return new su(this.pos, this.mark);
      }
    }
    return new wd(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new su(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new su(t.pos, e.markFromJSON(t.mark));
  }
}
mi.jsonID("addNodeMark", su);
class wd extends mi {
  /**
  Create a mark-removing step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return xr.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
    return xr.fromReplace(e, this.pos, this.pos + 1, new nt($e.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    return !t || !this.mark.isInSet(t.marks) ? this : new su(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new wd(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new wd(t.pos, e.markFromJSON(t.mark));
  }
}
mi.jsonID("removeNodeMark", wd);
class $r extends mi {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, t, r, i = !1) {
    super(), this.from = e, this.to = t, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && HT(e, this.from, this.to) ? xr.fail("Structure replace would overwrite content") : xr.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new ca([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new $r(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deletedAcross && r.deletedAcross ? null : new $r(t.pos, Math.max(t.pos, r.pos), this.slice, this.structure);
  }
  merge(e) {
    if (!(e instanceof $r) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let t = this.slice.size + e.slice.size == 0 ? nt.empty : new nt(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new $r(this.from, this.to + (e.to - e.from), t, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let t = this.slice.size + e.slice.size == 0 ? nt.empty : new nt(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new $r(e.from, this.to, t, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new $r(t.from, t.to, nt.fromJSON(e, t.slice), !!t.structure);
  }
}
mi.jsonID("replace", $r);
class Vr extends mi {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, t, r, i, a, o, s = !1) {
    super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = i, this.slice = a, this.insert = o, this.structure = s;
  }
  apply(e) {
    if (this.structure && (HT(e, this.from, this.gapFrom) || HT(e, this.gapTo, this.to)))
      return xr.fail("Structure gap-replace would overwrite content");
    let t = e.slice(this.gapFrom, this.gapTo);
    if (t.openStart || t.openEnd)
      return xr.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, t.content);
    return r ? xr.fromReplace(e, this.from, this.to, r) : xr.fail("Content does not fit in gap");
  }
  getMap() {
    return new ca([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let t = this.gapTo - this.gapFrom;
    return new Vr(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), a = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return t.deletedAcross && r.deletedAcross || i < t.pos || a > r.pos ? null : new Vr(t.pos, r.pos, i, a, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Vr(t.from, t.to, t.gapFrom, t.gapTo, nt.fromJSON(e, t.slice), t.insert, !!t.structure);
  }
}
mi.jsonID("replaceAround", Vr);
function HT(n, e, t) {
  let r = n.resolve(e), i = t - e, a = r.depth;
  for (; i > 0 && a > 0 && r.indexAfter(a) == r.node(a).childCount; )
    a--, i--;
  if (i > 0) {
    let o = r.node(a).maybeChild(r.indexAfter(a));
    for (; i > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, i--;
    }
  }
  return !1;
}
function Aue(n, e, t, r) {
  let i = [], a = [], o, s;
  n.doc.nodesBetween(e, t, (l, u, c) => {
    if (!l.isInline)
      return;
    let d = l.marks;
    if (!r.isInSet(d) && c.type.allowsMarkType(r.type)) {
      let f = Math.max(u, e), p = Math.min(u + l.nodeSize, t), h = r.addToSet(d);
      for (let v = 0; v < d.length; v++)
        d[v].isInSet(h) || (o && o.to == f && o.mark.eq(d[v]) ? o.to = p : i.push(o = new as(f, p, d[v])));
      s && s.to == f ? s.to = p : a.push(s = new ou(f, p, r));
    }
  }), i.forEach((l) => n.step(l)), a.forEach((l) => n.step(l));
}
function Mue(n, e, t, r) {
  let i = [], a = 0;
  n.doc.nodesBetween(e, t, (o, s) => {
    if (!o.isInline)
      return;
    a++;
    let l = null;
    if (r instanceof vx) {
      let u = o.marks, c;
      for (; c = r.isInSet(u); )
        (l || (l = [])).push(c), u = c.removeFromSet(u);
    } else r ? r.isInSet(o.marks) && (l = [r]) : l = o.marks;
    if (l && l.length) {
      let u = Math.min(s + o.nodeSize, t);
      for (let c = 0; c < l.length; c++) {
        let d = l[c], f;
        for (let p = 0; p < i.length; p++) {
          let h = i[p];
          h.step == a - 1 && d.eq(i[p].style) && (f = h);
        }
        f ? (f.to = u, f.step = a) : i.push({ style: d, from: Math.max(s, e), to: u, step: a });
      }
    }
  }), i.forEach((o) => n.step(new as(o.from, o.to, o.style)));
}
function lM(n, e, t, r = t.contentMatch, i = !0) {
  let a = n.doc.nodeAt(e), o = [], s = e + 1;
  for (let l = 0; l < a.childCount; l++) {
    let u = a.child(l), c = s + u.nodeSize, d = r.matchType(u.type);
    if (!d)
      o.push(new $r(s, c, nt.empty));
    else {
      r = d;
      for (let f = 0; f < u.marks.length; f++)
        t.allowsMarkType(u.marks[f].type) || n.step(new as(s, c, u.marks[f]));
      if (i && u.isText && t.whitespace != "pre") {
        let f, p = /\r?\n|\r/g, h;
        for (; f = p.exec(u.text); )
          h || (h = new nt($e.from(t.schema.text(" ", t.allowedMarks(u.marks))), 0, 0)), o.push(new $r(s + f.index, s + f.index + f[0].length, h));
      }
    }
    s = c;
  }
  if (!r.validEnd) {
    let l = r.fillBefore($e.empty, !0);
    n.replace(s, s, new nt(l, 0, 0));
  }
  for (let l = o.length - 1; l >= 0; l--)
    n.step(o[l]);
}
function Due(n, e, t) {
  return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t));
}
function ih(n) {
  let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex);
  for (let r = n.depth; ; --r) {
    let i = n.$from.node(r), a = n.$from.index(r), o = n.$to.indexAfter(r);
    if (r < n.depth && i.canReplace(a, o, t))
      return r;
    if (r == 0 || i.type.spec.isolating || !Due(i, a, o))
      break;
  }
  return null;
}
function Oue(n, e, t) {
  let { $from: r, $to: i, depth: a } = e, o = r.before(a + 1), s = i.after(a + 1), l = o, u = s, c = $e.empty, d = 0;
  for (let h = a, v = !1; h > t; h--)
    v || r.index(h) > 0 ? (v = !0, c = $e.from(r.node(h).copy(c)), d++) : l--;
  let f = $e.empty, p = 0;
  for (let h = a, v = !1; h > t; h--)
    v || i.after(h + 1) < i.end(h) ? (v = !0, f = $e.from(i.node(h).copy(f)), p++) : u++;
  n.step(new Vr(l, u, o, s, new nt(c.append(f), d, p), c.size - d, !0));
}
function uM(n, e, t = null, r = n) {
  let i = Iue(n, e), a = i && Lue(r, e);
  return a ? i.map(eN).concat({ type: e, attrs: t }).concat(a.map(eN)) : null;
}
function eN(n) {
  return { type: n, attrs: null };
}
function Iue(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, a = t.contentMatchAt(r).findWrapping(e);
  if (!a)
    return null;
  let o = a.length ? a[0] : e;
  return t.canReplaceWith(r, i, o) ? a : null;
}
function Lue(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, a = t.child(r), o = e.contentMatch.findWrapping(a.type);
  if (!o)
    return null;
  let l = (o.length ? o[o.length - 1] : e).contentMatch;
  for (let u = r; l && u < i; u++)
    l = l.matchType(t.child(u).type);
  return !l || !l.validEnd ? null : o;
}
function Nue(n, e, t) {
  let r = $e.empty;
  for (let o = t.length - 1; o >= 0; o--) {
    if (r.size) {
      let s = t[o].type.contentMatch.matchFragment(r);
      if (!s || !s.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = $e.from(t[o].type.create(t[o].attrs, r));
  }
  let i = e.start, a = e.end;
  n.step(new Vr(i, a, i, a, new nt(r, 0, 0), t.length, !0));
}
function Rue(n, e, t, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let a = n.steps.length;
  n.doc.nodesBetween(e, t, (o, s) => {
    let l = typeof i == "function" ? i(o) : i;
    if (o.isTextblock && !o.hasMarkup(r, l) && Pue(n.doc, n.mapping.slice(a).map(s), r)) {
      let u = null;
      if (r.schema.linebreakReplacement) {
        let p = r.whitespace == "pre", h = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        p && !h ? u = !1 : !p && h && (u = !0);
      }
      u === !1 && B6(n, o, s, a), lM(n, n.mapping.slice(a).map(s, 1), r, void 0, u === null);
      let c = n.mapping.slice(a), d = c.map(s, 1), f = c.map(s + o.nodeSize, 1);
      return n.step(new Vr(d, f, d + 1, f - 1, new nt($e.from(r.create(l, null, o.marks)), 0, 0), 1, !0)), u === !0 && j6(n, o, s, a), !1;
    }
  });
}
function j6(n, e, t, r) {
  e.forEach((i, a) => {
    if (i.isText) {
      let o, s = /\r?\n|\r/g;
      for (; o = s.exec(i.text); ) {
        let l = n.mapping.slice(r).map(t + 1 + a + o.index);
        n.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function B6(n, e, t, r) {
  e.forEach((i, a) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let o = n.mapping.slice(r).map(t + 1 + a);
      n.replaceWith(o, o + 1, e.type.schema.text(`
`));
    }
  });
}
function Pue(n, e, t) {
  let r = n.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, t);
}
function jue(n, e, t, r, i) {
  let a = n.doc.nodeAt(e);
  if (!a)
    throw new RangeError("No node at given position");
  t || (t = a.type);
  let o = t.create(r, null, i || a.marks);
  if (a.isLeaf)
    return n.replaceWith(e, e + a.nodeSize, o);
  if (!t.validContent(a.content))
    throw new RangeError("Invalid content for node type " + t.name);
  n.step(new Vr(e, e + a.nodeSize, e + 1, e + a.nodeSize - 1, new nt($e.from(o), 0, 0), 1, !0));
}
function sl(n, e, t = 1, r) {
  let i = n.resolve(e), a = i.depth - t, o = r && r[r.length - 1] || i.parent;
  if (a < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let u = i.depth - 1, c = t - 2; u > a; u--, c--) {
    let d = i.node(u), f = i.index(u);
    if (d.type.spec.isolating)
      return !1;
    let p = d.content.cutByIndex(f, d.childCount), h = r && r[c + 1];
    h && (p = p.replaceChild(0, h.type.create(h.attrs)));
    let v = r && r[c] || d;
    if (!d.canReplace(f + 1, d.childCount) || !v.type.validContent(p))
      return !1;
  }
  let s = i.indexAfter(a), l = r && r[0];
  return i.node(a).canReplaceWith(s, s, l ? l.type : i.node(a + 1).type);
}
function Bue(n, e, t = 1, r) {
  let i = n.doc.resolve(e), a = $e.empty, o = $e.empty;
  for (let s = i.depth, l = i.depth - t, u = t - 1; s > l; s--, u--) {
    a = $e.from(i.node(s).copy(a));
    let c = r && r[u];
    o = $e.from(c ? c.type.create(c.attrs, o) : i.node(s).copy(o));
  }
  n.step(new $r(e, e, new nt(a.append(o), t, t), !0));
}
function Hu(n, e) {
  let t = n.resolve(e), r = t.index();
  return $6(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1);
}
function $ue(n, e) {
  e.content.size || n.type.compatibleContent(e.type);
  let t = n.contentMatchAt(n.childCount), { linebreakReplacement: r } = n.type.schema;
  for (let i = 0; i < e.childCount; i++) {
    let a = e.child(i), o = a.type == r ? n.type.schema.nodes.text : a.type;
    if (t = t.matchType(o), !t || !n.type.allowsMarks(a.marks))
      return !1;
  }
  return t.validEnd;
}
function $6(n, e) {
  return !!(n && e && !n.isLeaf && $ue(n, e));
}
function mx(n, e, t = -1) {
  let r = n.resolve(e);
  for (let i = r.depth; ; i--) {
    let a, o, s = r.index(i);
    if (i == r.depth ? (a = r.nodeBefore, o = r.nodeAfter) : t > 0 ? (a = r.node(i + 1), s++, o = r.node(i).maybeChild(s)) : (a = r.node(i).maybeChild(s - 1), o = r.node(i + 1)), a && !a.isTextblock && $6(a, o) && r.node(i).canReplace(s, s + 1))
      return e;
    if (i == 0)
      break;
    e = t < 0 ? r.before(i) : r.after(i);
  }
}
function zue(n, e, t) {
  let r = null, { linebreakReplacement: i } = n.doc.type.schema, a = n.doc.resolve(e - t), o = a.node().type;
  if (i && o.inlineContent) {
    let c = o.whitespace == "pre", d = !!o.contentMatch.matchType(i);
    c && !d ? r = !1 : !c && d && (r = !0);
  }
  let s = n.steps.length;
  if (r === !1) {
    let c = n.doc.resolve(e + t);
    B6(n, c.node(), c.before(), s);
  }
  o.inlineContent && lM(n, e + t - 1, o, a.node().contentMatchAt(a.index()), r == null);
  let l = n.mapping.slice(s), u = l.map(e - t);
  if (n.step(new $r(u, l.map(e + t, -1), nt.empty, !0)), r === !0) {
    let c = n.doc.resolve(u);
    j6(n, c.node(), c.before(), n.steps.length);
  }
  return n;
}
function Fue(n, e, t) {
  let r = n.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), t))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let a = r.index(i);
      if (r.node(i).canReplaceWith(a, a, t))
        return r.before(i + 1);
      if (a > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let a = r.indexAfter(i);
      if (r.node(i).canReplaceWith(a, a, t))
        return r.after(i + 1);
      if (a < r.node(i).childCount)
        return null;
    }
  return null;
}
function z6(n, e, t) {
  let r = n.resolve(e);
  if (!t.content.size)
    return e;
  let i = t.content;
  for (let a = 0; a < t.openStart; a++)
    i = i.firstChild.content;
  for (let a = 1; a <= (t.openStart == 0 && t.size ? 2 : 1); a++)
    for (let o = r.depth; o >= 0; o--) {
      let s = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, l = r.index(o) + (s > 0 ? 1 : 0), u = r.node(o), c = !1;
      if (a == 1)
        c = u.canReplace(l, l, i);
      else {
        let d = u.contentMatchAt(l).findWrapping(i.firstChild.type);
        c = d && u.canReplaceWith(l, l, d[0]);
      }
      if (c)
        return s == 0 ? r.pos : s < 0 ? r.before(o + 1) : r.after(o + 1);
    }
  return null;
}
function gx(n, e, t = e, r = nt.empty) {
  if (e == t && !r.size)
    return null;
  let i = n.resolve(e), a = n.resolve(t);
  return F6(i, a, r) ? new $r(e, t, r) : new Vue(i, a, r).fit();
}
function F6(n, e, t) {
  return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content);
}
class Vue {
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = $e.empty;
    for (let i = 0; i <= e.depth; i++) {
      let a = e.node(i);
      this.frontier.push({
        type: a.type,
        match: a.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = $e.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let u = this.findFittable();
      u ? this.placeNodes(u) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let a = this.placed, o = r.depth, s = i.depth;
    for (; o && s && a.childCount == 1; )
      a = a.firstChild.content, o--, s--;
    let l = new nt(a, o, s);
    return e > -1 ? new Vr(r.pos, e, this.$to.pos, this.$to.end(), l, t) : l.size || r.pos != this.$to.pos ? new $r(r.pos, i.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let t = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let a = t.firstChild;
      if (t.childCount > 1 && (i = 0), a.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      t = a.content;
    }
    for (let t = 1; t <= 2; t++)
      for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, a = null;
        r ? (a = rS(this.unplaced.content, r - 1).firstChild, i = a.content) : i = this.unplaced.content;
        let o = i.firstChild;
        for (let s = this.depth; s >= 0; s--) {
          let { type: l, match: u } = this.frontier[s], c, d = null;
          if (t == 1 && (o ? u.matchType(o.type) || (d = u.fillBefore($e.from(o), !1)) : a && l.compatibleContent(a.type)))
            return { sliceDepth: r, frontierDepth: s, parent: a, inject: d };
          if (t == 2 && o && (c = u.findWrapping(o.type)))
            return { sliceDepth: r, frontierDepth: s, parent: a, wrap: c };
          if (a && u.matchType(a.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = rS(e, t);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new nt(e, t + 1, Math.max(r, i.size + t >= e.size - r ? t + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = rS(e, t);
    if (i.childCount <= 1 && t > 0) {
      let a = e.size - t <= t + i.size;
      this.unplaced = new nt(wv(e, t - 1, 1), t - 1, a ? t - 1 : r);
    } else
      this.unplaced = new nt(wv(e, t, 1), t, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: i, wrap: a }) {
    for (; this.depth > t; )
      this.closeFrontierNode();
    if (a)
      for (let v = 0; v < a.length; v++)
        this.openFrontierNode(a[v]);
    let o = this.unplaced, s = r ? r.content : o.content, l = o.openStart - e, u = 0, c = [], { match: d, type: f } = this.frontier[t];
    if (i) {
      for (let v = 0; v < i.childCount; v++)
        c.push(i.child(v));
      d = d.matchFragment(i);
    }
    let p = s.size + e - (o.content.size - o.openEnd);
    for (; u < s.childCount; ) {
      let v = s.child(u), m = d.matchType(v.type);
      if (!m)
        break;
      u++, (u > 1 || l == 0 || v.content.size) && (d = m, c.push(V6(v.mark(f.allowedMarks(v.marks)), u == 1 ? l : 0, u == s.childCount ? p : -1)));
    }
    let h = u == s.childCount;
    h || (p = -1), this.placed = Sv(this.placed, t, $e.from(c)), this.frontier[t].match = d, h && p < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let v = 0, m = s; v < p; v++) {
      let g = m.lastChild;
      this.frontier.push({ type: g.type, match: g.contentMatchAt(g.childCount) }), m = g.content;
    }
    this.unplaced = h ? e == 0 ? nt.empty : new nt(wv(o.content, e - 1, 1), e - 1, p < 0 ? o.openEnd : e - 1) : new nt(wv(o.content, e, u), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], t;
    if (!e.type.isTextblock || !iS(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
      let { match: r, type: i } = this.frontier[t], a = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), o = iS(e, t, i, r, a);
      if (o) {
        for (let s = t - 1; s >= 0; s--) {
          let { match: l, type: u } = this.frontier[s], c = iS(e, s, u, l, !0);
          if (!c || c.childCount)
            continue e;
        }
        return { depth: t, fit: o, move: a ? e.doc.resolve(e.after(t + 1)) : e };
      }
    }
  }
  close(e) {
    let t = this.findCloseLevel(e);
    if (!t)
      return null;
    for (; this.depth > t.depth; )
      this.closeFrontierNode();
    t.fit.childCount && (this.placed = Sv(this.placed, t.depth, t.fit)), e = t.move;
    for (let r = t.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), a = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, a);
    }
    return e;
  }
  openFrontierNode(e, t = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = Sv(this.placed, this.depth, $e.from(e.create(t, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let t = this.frontier.pop().match.fillBefore($e.empty, !0);
    t.childCount && (this.placed = Sv(this.placed, this.frontier.length, t));
  }
}
function wv(n, e, t) {
  return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy(wv(n.firstChild.content, e - 1, t)));
}
function Sv(n, e, t) {
  return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(Sv(n.lastChild.content, e - 1, t)));
}
function rS(n, e) {
  for (let t = 0; t < e; t++)
    n = n.firstChild.content;
  return n;
}
function V6(n, e, t) {
  if (e <= 0)
    return n;
  let r = n.content;
  return e > 1 && (r = r.replaceChild(0, V6(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n.type.contentMatch.matchFragment(r).fillBefore($e.empty, !0)))), n.copy(r);
}
function iS(n, e, t, r, i) {
  let a = n.node(e), o = i ? n.indexAfter(e) : n.index(e);
  if (o == a.childCount && !t.compatibleContent(a.type))
    return null;
  let s = r.fillBefore(a.content, !0, o);
  return s && !Hue(t, a.content, o) ? s : null;
}
function Hue(n, e, t) {
  for (let r = t; r < e.childCount; r++)
    if (!n.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function Gue(n) {
  return n.spec.defining || n.spec.definingForContent;
}
function Uue(n, e, t, r) {
  if (!r.size)
    return n.deleteRange(e, t);
  let i = n.doc.resolve(e), a = n.doc.resolve(t);
  if (F6(i, a, r))
    return n.step(new $r(e, t, r));
  let o = G6(i, n.doc.resolve(t));
  o[o.length - 1] == 0 && o.pop();
  let s = -(i.depth + 1);
  o.unshift(s);
  for (let f = i.depth, p = i.pos - 1; f > 0; f--, p--) {
    let h = i.node(f).type.spec;
    if (h.defining || h.definingAsContext || h.isolating)
      break;
    o.indexOf(f) > -1 ? s = f : i.before(f) == p && o.splice(1, 0, -f);
  }
  let l = o.indexOf(s), u = [], c = r.openStart;
  for (let f = r.content, p = 0; ; p++) {
    let h = f.firstChild;
    if (u.push(h), p == r.openStart)
      break;
    f = h.content;
  }
  for (let f = c - 1; f >= 0; f--) {
    let p = u[f], h = Gue(p.type);
    if (h && !p.sameMarkup(i.node(Math.abs(s) - 1)))
      c = f;
    else if (h || !p.type.isTextblock)
      break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let p = (f + c + 1) % (r.openStart + 1), h = u[p];
    if (h)
      for (let v = 0; v < o.length; v++) {
        let m = o[(v + l) % o.length], g = !0;
        m < 0 && (g = !1, m = -m);
        let y = i.node(m - 1), b = i.index(m - 1);
        if (y.canReplaceWith(b, b, h.type, h.marks))
          return n.replace(i.before(m), g ? a.after(m) : t, new nt(H6(r.content, 0, r.openStart, p), p, r.openEnd));
      }
  }
  let d = n.steps.length;
  for (let f = o.length - 1; f >= 0 && (n.replace(e, t, r), !(n.steps.length > d)); f--) {
    let p = o[f];
    p < 0 || (e = i.before(p), t = a.after(p));
  }
}
function H6(n, e, t, r, i) {
  if (e < t) {
    let a = n.firstChild;
    n = n.replaceChild(0, a.copy(H6(a.content, e + 1, t, r, a)));
  }
  if (e > r) {
    let a = i.contentMatchAt(0), o = a.fillBefore(n).append(n);
    n = o.append(a.matchFragment(o).fillBefore($e.empty, !0));
  }
  return n;
}
function Wue(n, e, t, r) {
  if (!r.isInline && e == t && n.doc.resolve(e).parent.content.size) {
    let i = Fue(n.doc, e, r.type);
    i != null && (e = t = i);
  }
  n.replaceRange(e, t, new nt($e.from(r), 0, 0));
}
function que(n, e, t) {
  let r = n.doc.resolve(e), i = n.doc.resolve(t), a = G6(r, i);
  for (let o = 0; o < a.length; o++) {
    let s = a[o], l = o == a.length - 1;
    if (l && s == 0 || r.node(s).type.contentMatch.validEnd)
      return n.delete(r.start(s), i.end(s));
    if (s > 0 && (l || r.node(s - 1).canReplace(r.index(s - 1), i.indexAfter(s - 1))))
      return n.delete(r.before(s), i.after(s));
  }
  for (let o = 1; o <= r.depth && o <= i.depth; o++)
    if (e - r.start(o) == r.depth - o && t > r.end(o) && i.end(o) - t != i.depth - o && r.start(o - 1) == i.start(o - 1) && r.node(o - 1).canReplace(r.index(o - 1), i.index(o - 1)))
      return n.delete(r.before(o), t);
  n.delete(e, t);
}
function G6(n, e) {
  let t = [], r = Math.min(n.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let a = n.start(i);
    if (a < n.pos - (n.depth - i) || e.end(i) > e.pos + (e.depth - i) || n.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (a == e.start(i) || i == n.depth && i == e.depth && n.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == a - 1) && t.push(i);
  }
  return t;
}
class vp extends mi {
  /**
  Construct an attribute step.
  */
  constructor(e, t, r) {
    super(), this.pos = e, this.attr = t, this.value = r;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return xr.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let a in t.attrs)
      r[a] = t.attrs[a];
    r[this.attr] = this.value;
    let i = t.type.create(r, null, t.marks);
    return xr.fromReplace(e, this.pos, this.pos + 1, new nt($e.from(i), 0, t.isLeaf ? 0 : 1));
  }
  getMap() {
    return ca.empty;
  }
  invert(e) {
    return new vp(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new vp(t.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number" || typeof t.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new vp(t.pos, t.attr, t.value);
  }
}
mi.jsonID("attr", vp);
class Dm extends mi {
  /**
  Construct an attribute step.
  */
  constructor(e, t) {
    super(), this.attr = e, this.value = t;
  }
  apply(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      t[i] = e.attrs[i];
    t[this.attr] = this.value;
    let r = e.type.create(t, e.content, e.marks);
    return xr.ok(r);
  }
  getMap() {
    return ca.empty;
  }
  invert(e) {
    return new Dm(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new Dm(t.attr, t.value);
  }
}
mi.jsonID("docAttr", Dm);
let Cp = class extends Error {
};
Cp = function n(e) {
  let t = Error.call(this, e);
  return t.__proto__ = n.prototype, t;
};
Cp.prototype = Object.create(Error.prototype);
Cp.prototype.constructor = Cp;
Cp.prototype.name = "TransformError";
class cM {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new Mm();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let t = this.maybeStep(e);
    if (t.failed)
      throw new Cp(t.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let t = e.apply(this.doc);
    return t.failed || this.addStep(e, t.doc), t;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, t = e, r = nt.empty) {
    let i = gx(this.doc, e, t, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, t, r) {
    return this.replace(e, t, new nt($e.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, t) {
    return this.replace(e, t, nt.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, t) {
    return this.replaceWith(e, e, t);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, t, r) {
    return Uue(this, e, t, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, t, r) {
    return Wue(this, e, t, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, t) {
    return que(this, e, t), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, t) {
    return Oue(this, e, t), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, t = 1) {
    return zue(this, e, t), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, t) {
    return Nue(this, e, t), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, t = e, r, i = null) {
    return Rue(this, e, t, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, t, r = null, i) {
    return jue(this, e, t, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, t, r) {
    return this.step(new vp(e, t, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, t) {
    return this.step(new Dm(e, t)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, t) {
    return this.step(new su(e, t)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, t) {
    let r = this.doc.nodeAt(e);
    if (!r)
      throw new RangeError("No node at position " + e);
    if (t instanceof Hn)
      t.isInSet(r.marks) && this.step(new wd(e, t));
    else {
      let i = r.marks, a, o = [];
      for (; a = t.isInSet(i); )
        o.push(new wd(e, a)), i = a.removeFromSet(i);
      for (let s = o.length - 1; s >= 0; s--)
        this.step(o[s]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, t = 1, r) {
    return Bue(this, e, t, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, t, r) {
    return Aue(this, e, t, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, t, r) {
    return Mue(this, e, t, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, t, r) {
    return lM(this, e, t, r), this;
  }
}
const aS = /* @__PURE__ */ Object.create(null);
class It {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, t, r) {
    this.$anchor = e, this.$head = t, this.ranges = r || [new U6(e.min(t), e.max(t))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let t = 0; t < e.length; t++)
      if (e[t].$from.pos != e[t].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, t = nt.empty) {
    let r = t.content.lastChild, i = null;
    for (let s = 0; s < t.openEnd; s++)
      i = r, r = r.lastChild;
    let a = e.steps.length, o = this.ranges;
    for (let s = 0; s < o.length; s++) {
      let { $from: l, $to: u } = o[s], c = e.mapping.slice(a);
      e.replaceRange(c.map(l.pos), c.map(u.pos), s ? nt.empty : t), s == 0 && rN(e, a, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, t) {
    let r = e.steps.length, i = this.ranges;
    for (let a = 0; a < i.length; a++) {
      let { $from: o, $to: s } = i[a], l = e.mapping.slice(r), u = l.map(o.pos), c = l.map(s.pos);
      a ? e.deleteRange(u, c) : (e.replaceRangeWith(u, c, t), rN(e, r, t.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, t, r = !1) {
    let i = e.parent.inlineContent ? new Dt(e) : Uf(e.node(0), e.parent, e.pos, e.index(), t, r);
    if (i)
      return i;
    for (let a = e.depth - 1; a >= 0; a--) {
      let o = t < 0 ? Uf(e.node(0), e.node(a), e.before(a + 1), e.index(a), t, r) : Uf(e.node(0), e.node(a), e.after(a + 1), e.index(a) + 1, t, r);
      if (o)
        return o;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, t = 1) {
    return this.findFrom(e, t) || this.findFrom(e, -t) || new ga(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Uf(e, e, 0, 0, 1) || new ga(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Uf(e, e, e.content.size, e.childCount, -1) || new ga(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, t) {
    if (!t || !t.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = aS[t.type];
    if (!r)
      throw new RangeError(`No selection type ${t.type} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, t) {
    if (e in aS)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return aS[e] = t, t.prototype.jsonID = e, t;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return Dt.between(this.$anchor, this.$head).getBookmark();
  }
}
It.prototype.visible = !0;
class U6 {
  /**
  Create a range.
  */
  constructor(e, t) {
    this.$from = e, this.$to = t;
  }
}
let tN = !1;
function nN(n) {
  !tN && !n.parent.inlineContent && (tN = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")"));
}
class Dt extends It {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, t = e) {
    nN(e), nN(t), super(e, t);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    if (!r.parent.inlineContent)
      return It.near(r);
    let i = e.resolve(t.map(this.anchor));
    return new Dt(i.parent.inlineContent ? i : r, r);
  }
  replace(e, t = nt.empty) {
    if (super.replace(e, t), t == nt.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof Dt && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new yx(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new Dt(e.resolve(t.anchor), e.resolve(t.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, t, r = t) {
    let i = e.resolve(t);
    return new this(i, r == t ? i : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, t, r) {
    let i = e.pos - t.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !t.parent.inlineContent) {
      let a = It.findFrom(t, r, !0) || It.findFrom(t, -r, !0);
      if (a)
        t = a.$head;
      else
        return It.near(t, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = t : (e = (It.findFrom(e, -r, !0) || It.findFrom(e, r, !0)).$anchor, e.pos < t.pos != i < 0 && (e = t))), new Dt(e, t);
  }
}
It.jsonID("text", Dt);
class yx {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new yx(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return Dt.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class Ct extends It {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let t = e.nodeAfter, r = e.node(0).resolve(e.pos + t.nodeSize);
    super(e, r), this.node = t;
  }
  map(e, t) {
    let { deleted: r, pos: i } = t.mapResult(this.anchor), a = e.resolve(i);
    return r ? It.near(a) : new Ct(a);
  }
  content() {
    return new nt($e.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof Ct && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new dM(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new Ct(e.resolve(t.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, t) {
    return new Ct(e.resolve(t));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
Ct.prototype.visible = !1;
It.jsonID("node", Ct);
class dM {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: t, pos: r } = e.mapResult(this.anchor);
    return t ? new yx(r, r) : new dM(r);
  }
  resolve(e) {
    let t = e.resolve(this.anchor), r = t.nodeAfter;
    return r && Ct.isSelectable(r) ? new Ct(t) : It.near(t);
  }
}
class ga extends It {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, t = nt.empty) {
    if (t == nt.empty) {
      e.delete(0, e.doc.content.size);
      let r = It.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, t);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new ga(e);
  }
  map(e) {
    return new ga(e);
  }
  eq(e) {
    return e instanceof ga;
  }
  getBookmark() {
    return Yue;
  }
}
It.jsonID("all", ga);
const Yue = {
  map() {
    return this;
  },
  resolve(n) {
    return new ga(n);
  }
};
function Uf(n, e, t, r, i, a = !1) {
  if (e.inlineContent)
    return Dt.create(n, t);
  for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) {
    let s = e.child(o);
    if (s.isAtom) {
      if (!a && Ct.isSelectable(s))
        return Ct.create(n, t - (i < 0 ? s.nodeSize : 0));
    } else {
      let l = Uf(n, s, t + i, i < 0 ? s.childCount : 0, i, a);
      if (l)
        return l;
    }
    t += s.nodeSize * i;
  }
  return null;
}
function rN(n, e, t) {
  let r = n.steps.length - 1;
  if (r < e)
    return;
  let i = n.steps[r];
  if (!(i instanceof $r || i instanceof Vr))
    return;
  let a = n.mapping.maps[r], o;
  a.forEach((s, l, u, c) => {
    o == null && (o = c);
  }), n.setSelection(It.near(n.doc.resolve(o), t));
}
const iN = 1, Cy = 2, aN = 4;
class Kue extends cM {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | iN) & ~Cy, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & iN) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= Cy, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return Hn.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & Cy) > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    super.addStep(e, t), this.updated = this.updated & ~Cy, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, t = !0) {
    let r = this.selection;
    return t && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Hn.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, t, r) {
    let i = this.doc.type.schema;
    if (t == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = t), r = r ?? t, !e)
        return this.deleteRange(t, r);
      let a = this.storedMarks;
      if (!a) {
        let o = this.doc.resolve(t);
        a = r == t ? o.marks() : o.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(t, r, i.text(e, a)), this.selection.empty || this.setSelection(It.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, t) {
    return this.meta[typeof e == "string" ? e : e.key] = t, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= aN, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & aN) > 0;
  }
}
function oN(n, e) {
  return !e || !n ? n : n.bind(e);
}
class Ev {
  constructor(e, t, r) {
    this.name = e, this.init = oN(t.init, r), this.apply = oN(t.apply, r);
  }
}
const Xue = [
  new Ev("doc", {
    init(n) {
      return n.doc || n.schema.topNodeType.createAndFill();
    },
    apply(n) {
      return n.doc;
    }
  }),
  new Ev("selection", {
    init(n, e) {
      return n.selection || It.atStart(e.doc);
    },
    apply(n) {
      return n.selection;
    }
  }),
  new Ev("storedMarks", {
    init(n) {
      return n.storedMarks || null;
    },
    apply(n, e, t, r) {
      return r.selection.$cursor ? n.storedMarks : null;
    }
  }),
  new Ev("scrollToSelection", {
    init() {
      return 0;
    },
    apply(n, e) {
      return n.scrolledIntoView ? e + 1 : e;
    }
  })
];
class oS {
  constructor(e, t) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = Xue.slice(), t && t.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new Ev(r.key, r.spec.state, r));
    });
  }
}
class ap {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, t = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != t) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let t = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let a = !1;
      for (let o = 0; o < this.config.plugins.length; o++) {
        let s = this.config.plugins[o];
        if (s.spec.appendTransaction) {
          let l = i ? i[o].n : 0, u = i ? i[o].state : this, c = l < t.length && s.spec.appendTransaction.call(s, l ? t.slice(l) : t, u, r);
          if (c && r.filterTransaction(c, o)) {
            if (c.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let d = 0; d < this.config.plugins.length; d++)
                i.push(d < o ? { state: r, n: t.length } : { state: this, n: 0 });
            }
            t.push(c), r = r.applyInner(c), a = !0;
          }
          i && (i[o] = { state: r, n: t.length });
        }
      }
      if (!a)
        return { state: r, transactions: t };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let t = new ap(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let a = r[i];
      t[a.name] = a.apply(e, this[a.name], this, t);
    }
    return t;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Kue(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let t = new oS(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new ap(t);
    for (let i = 0; i < t.fields.length; i++)
      r[t.fields[i].name] = t.fields[i].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let t = new oS(this.schema, e.plugins), r = t.fields, i = new ap(t);
    for (let a = 0; a < r.length; a++) {
      let o = r[a].name;
      i[o] = this.hasOwnProperty(o) ? this[o] : r[a].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (t.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], a = i.spec.state;
        a && a.toJSON && (t[r] = a.toJSON.call(i, this[i.key]));
      }
    return t;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, t, r) {
    if (!t)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new oS(e.schema, e.plugins), a = new ap(i);
    return i.fields.forEach((o) => {
      if (o.name == "doc")
        a.doc = _u.fromJSON(e.schema, t.doc);
      else if (o.name == "selection")
        a.selection = It.fromJSON(a.doc, t.selection);
      else if (o.name == "storedMarks")
        t.storedMarks && (a.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let s in r) {
            let l = r[s], u = l.spec.state;
            if (l.key == o.name && u && u.fromJSON && Object.prototype.hasOwnProperty.call(t, s)) {
              a[o.name] = u.fromJSON.call(l, e, t[s], a);
              return;
            }
          }
        a[o.name] = o.init(e, a);
      }
    }), a;
  }
}
function W6(n, e, t) {
  for (let r in n) {
    let i = n[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = W6(i, e, {})), t[r] = i;
  }
  return t;
}
class Pn {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && W6(e.props, this, this.props), this.key = e.key ? e.key.key : q6("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const sS = /* @__PURE__ */ Object.create(null);
function q6(n) {
  return n in sS ? n + "$" + ++sS[n] : (sS[n] = 0, n + "$");
}
class jn {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = q6(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Kr = function(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}, kp = function(n) {
  let e = n.assignedSlot || n.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let GT = null;
const Us = function(n, e, t) {
  let r = GT || (GT = document.createRange());
  return r.setEnd(n, t ?? n.nodeValue.length), r.setStart(n, e || 0), r;
}, Zue = function() {
  GT = null;
}, Sd = function(n, e, t, r) {
  return t && (sN(n, e, t, r, -1) || sN(n, e, t, r, 1));
}, Jue = /^(img|br|input|textarea|hr)$/i;
function sN(n, e, t, r, i) {
  for (var a; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : Ua(n))) {
      let o = n.parentNode;
      if (!o || o.nodeType != 1 || Ig(n) || Jue.test(n.nodeName) || n.contentEditable == "false")
        return !1;
      e = Kr(n) + (i < 0 ? 0 : 1), n = o;
    } else if (n.nodeType == 1) {
      let o = n.childNodes[e + (i < 0 ? -1 : 0)];
      if (o.nodeType == 1 && o.contentEditable == "false")
        if (!((a = o.pmViewDesc) === null || a === void 0) && a.ignoreForSelection)
          e += i;
        else
          return !1;
      else
        n = o, e = i < 0 ? Ua(n) : 0;
    } else
      return !1;
  }
}
function Ua(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function Que(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e)
      return n;
    if (n.nodeType == 1 && e > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e - 1], e = Ua(n);
    } else if (n.parentNode && !Ig(n))
      e = Kr(n), n = n.parentNode;
    else
      return null;
  }
}
function ece(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e < n.nodeValue.length)
      return n;
    if (n.nodeType == 1 && e < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e], e = 0;
    } else if (n.parentNode && !Ig(n))
      e = Kr(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
function tce(n, e, t) {
  for (let r = e == 0, i = e == Ua(n); r || i; ) {
    if (n == t)
      return !0;
    let a = Kr(n);
    if (n = n.parentNode, !n)
      return !1;
    r = r && a == 0, i = i && a == Ua(n);
  }
}
function Ig(n) {
  let e;
  for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n);
}
const bx = function(n) {
  return n.focusNode && Sd(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset);
};
function Oc(n, e) {
  let t = document.createEvent("Event");
  return t.initEvent("keydown", !0, !0), t.keyCode = n, t.key = t.code = e, t;
}
function nce(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function rce(n, e, t) {
  if (n.caretPositionFromPoint)
    try {
      let r = n.caretPositionFromPoint(e, t);
      if (r)
        return { node: r.offsetNode, offset: Math.min(Ua(r.offsetNode), r.offset) };
    } catch {
    }
  if (n.caretRangeFromPoint) {
    let r = n.caretRangeFromPoint(e, t);
    if (r)
      return { node: r.startContainer, offset: Math.min(Ua(r.startContainer), r.startOffset) };
  }
}
const ys = typeof navigator < "u" ? navigator : null, lN = typeof document < "u" ? document : null, Gu = ys && ys.userAgent || "", UT = /Edge\/(\d+)/.exec(Gu), Y6 = /MSIE \d/.exec(Gu), WT = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Gu), Ji = !!(Y6 || WT || UT), xu = Y6 ? document.documentMode : WT ? +WT[1] : UT ? +UT[1] : 0, ko = !Ji && /gecko\/(\d+)/i.test(Gu);
ko && +(/Firefox\/(\d+)/.exec(Gu) || [0, 0])[1];
const qT = !Ji && /Chrome\/(\d+)/.exec(Gu), di = !!qT, K6 = qT ? +qT[1] : 0, Li = !Ji && !!ys && /Apple Computer/.test(ys.vendor), Ap = Li && (/Mobile\/\w+/.test(Gu) || !!ys && ys.maxTouchPoints > 2), Fa = Ap || (ys ? /Mac/.test(ys.platform) : !1), ice = ys ? /Win/.test(ys.platform) : !1, Js = /Android \d/.test(Gu), Lg = !!lN && "webkitFontSmoothing" in lN.documentElement.style, ace = Lg ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function oce(n) {
  let e = n.defaultView && n.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.documentElement.clientWidth,
    top: 0,
    bottom: n.documentElement.clientHeight
  };
}
function Rs(n, e) {
  return typeof n == "number" ? n : n[e];
}
function sce(n) {
  let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, r = e.height / n.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + n.clientWidth * t,
    top: e.top,
    bottom: e.top + n.clientHeight * r
  };
}
function uN(n, e, t) {
  let r = n.someProp("scrollThreshold") || 0, i = n.someProp("scrollMargin") || 5, a = n.dom.ownerDocument;
  for (let o = t || n.dom; o; ) {
    if (o.nodeType != 1) {
      o = kp(o);
      continue;
    }
    let s = o, l = s == a.body, u = l ? oce(a) : sce(s), c = 0, d = 0;
    if (e.top < u.top + Rs(r, "top") ? d = -(u.top - e.top + Rs(i, "top")) : e.bottom > u.bottom - Rs(r, "bottom") && (d = e.bottom - e.top > u.bottom - u.top ? e.top + Rs(i, "top") - u.top : e.bottom - u.bottom + Rs(i, "bottom")), e.left < u.left + Rs(r, "left") ? c = -(u.left - e.left + Rs(i, "left")) : e.right > u.right - Rs(r, "right") && (c = e.right - u.right + Rs(i, "right")), c || d)
      if (l)
        a.defaultView.scrollBy(c, d);
      else {
        let p = s.scrollLeft, h = s.scrollTop;
        d && (s.scrollTop += d), c && (s.scrollLeft += c);
        let v = s.scrollLeft - p, m = s.scrollTop - h;
        e = { left: e.left - v, top: e.top - m, right: e.right - v, bottom: e.bottom - m };
      }
    let f = l ? "fixed" : getComputedStyle(o).position;
    if (/^(fixed|sticky)$/.test(f))
      break;
    o = f == "absolute" ? o.offsetParent : kp(o);
  }
}
function lce(n) {
  let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), r, i;
  for (let a = (e.left + e.right) / 2, o = t + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let s = n.root.elementFromPoint(a, o);
    if (!s || s == n.dom || !n.dom.contains(s))
      continue;
    let l = s.getBoundingClientRect();
    if (l.top >= t - 20) {
      r = s, i = l.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: X6(n.dom) };
}
function X6(n) {
  let e = [], t = n.ownerDocument;
  for (let r = n; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), n != t); r = kp(r))
    ;
  return e;
}
function uce({ refDOM: n, refTop: e, stack: t }) {
  let r = n ? n.getBoundingClientRect().top : 0;
  Z6(t, r == 0 ? 0 : r - e);
}
function Z6(n, e) {
  for (let t = 0; t < n.length; t++) {
    let { dom: r, top: i, left: a } = n[t];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != a && (r.scrollLeft = a);
  }
}
let hf = null;
function cce(n) {
  if (n.setActive)
    return n.setActive();
  if (hf)
    return n.focus(hf);
  let e = X6(n);
  n.focus(hf == null ? {
    get preventScroll() {
      return hf = { preventScroll: !0 }, !0;
    }
  } : void 0), hf || (hf = !1, Z6(e, 0));
}
function J6(n, e) {
  let t, r = 2e8, i, a = 0, o = e.top, s = e.top, l, u;
  for (let c = n.firstChild, d = 0; c; c = c.nextSibling, d++) {
    let f;
    if (c.nodeType == 1)
      f = c.getClientRects();
    else if (c.nodeType == 3)
      f = Us(c).getClientRects();
    else
      continue;
    for (let p = 0; p < f.length; p++) {
      let h = f[p];
      if (h.top <= o && h.bottom >= s) {
        o = Math.max(h.bottom, o), s = Math.min(h.top, s);
        let v = h.left > e.left ? h.left - e.left : h.right < e.left ? e.left - h.right : 0;
        if (v < r) {
          t = c, r = v, i = v && t.nodeType == 3 ? {
            left: h.right < e.left ? h.right : h.left,
            top: e.top
          } : e, c.nodeType == 1 && v && (a = d + (e.left >= (h.left + h.right) / 2 ? 1 : 0));
          continue;
        }
      } else h.top > e.top && !l && h.left <= e.left && h.right >= e.left && (l = c, u = { left: Math.max(h.left, Math.min(h.right, e.left)), top: h.top });
      !t && (e.left >= h.right && e.top >= h.top || e.left >= h.left && e.top >= h.bottom) && (a = d + 1);
    }
  }
  return !t && l && (t = l, i = u, r = 0), t && t.nodeType == 3 ? dce(t, i) : !t || r && t.nodeType == 1 ? { node: n, offset: a } : J6(t, i);
}
function dce(n, e) {
  let t = n.nodeValue.length, r = document.createRange();
  for (let i = 0; i < t; i++) {
    r.setEnd(n, i + 1), r.setStart(n, i);
    let a = Yl(r, 1);
    if (a.top != a.bottom && fM(e, a))
      return { node: n, offset: i + (e.left >= (a.left + a.right) / 2 ? 1 : 0) };
  }
  return { node: n, offset: 0 };
}
function fM(n, e) {
  return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1;
}
function fce(n, e) {
  let t = n.parentNode;
  return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n;
}
function pce(n, e, t) {
  let { node: r, offset: i } = J6(e, t), a = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let o = r.getBoundingClientRect();
    a = o.left != o.right && t.left > (o.left + o.right) / 2 ? 1 : -1;
  }
  return n.docView.posFromDOM(r, i, a);
}
function hce(n, e, t, r) {
  let i = -1;
  for (let a = e, o = !1; a != n.dom; ) {
    let s = n.docView.nearestDesc(a, !0), l;
    if (!s)
      return null;
    if (s.dom.nodeType == 1 && (s.node.isBlock && s.parent || !s.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((l = s.dom.getBoundingClientRect()).width || l.height) && (s.node.isBlock && s.parent && (!o && l.left > r.left || l.top > r.top ? i = s.posBefore : (!o && l.right < r.left || l.bottom < r.top) && (i = s.posAfter), o = !0), !s.contentDOM && i < 0 && !s.node.isText))
      return (s.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? s.posBefore : s.posAfter;
    a = s.dom.parentNode;
  }
  return i > -1 ? i : n.docView.posFromDOM(e, t, -1);
}
function Q6(n, e, t) {
  let r = n.childNodes.length;
  if (r && t.top < t.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - t.top) / (t.bottom - t.top)) - 2)), a = i; ; ) {
      let o = n.childNodes[a];
      if (o.nodeType == 1) {
        let s = o.getClientRects();
        for (let l = 0; l < s.length; l++) {
          let u = s[l];
          if (fM(e, u))
            return Q6(o, e, u);
        }
      }
      if ((a = (a + 1) % r) == i)
        break;
    }
  return n;
}
function vce(n, e) {
  let t = n.dom.ownerDocument, r, i = 0, a = rce(t, e.left, e.top);
  a && ({ node: r, offset: i } = a);
  let o = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), s;
  if (!o || !n.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
    let u = n.dom.getBoundingClientRect();
    if (!fM(e, u) || (o = Q6(n.dom, e, u), !o))
      return null;
  }
  if (Li)
    for (let u = o; r && u; u = kp(u))
      u.draggable && (r = void 0);
  if (o = fce(o, e), r) {
    if (ko && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let c = r.childNodes[i], d;
      c.nodeName == "IMG" && (d = c.getBoundingClientRect()).right <= e.left && d.bottom > e.top && i++;
    }
    let u;
    Lg && i && r.nodeType == 1 && (u = r.childNodes[i - 1]).nodeType == 1 && u.contentEditable == "false" && u.getBoundingClientRect().top >= e.top && i--, r == n.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? s = n.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (s = hce(n, r, i, e));
  }
  s == null && (s = pce(n, o, e));
  let l = n.docView.nearestDesc(o, !0);
  return { pos: s, inside: l ? l.posAtStart - l.border : -1 };
}
function cN(n) {
  return n.top < n.bottom || n.left < n.right;
}
function Yl(n, e) {
  let t = n.getClientRects();
  if (t.length) {
    let r = t[e < 0 ? 0 : t.length - 1];
    if (cN(r))
      return r;
  }
  return Array.prototype.find.call(t, cN) || n.getBoundingClientRect();
}
const mce = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function e8(n, e, t) {
  let { node: r, offset: i, atom: a } = n.docView.domFromPos(e, t < 0 ? -1 : 1), o = Lg || ko;
  if (r.nodeType == 3)
    if (o && (mce.test(r.nodeValue) || (t < 0 ? !i : i == r.nodeValue.length))) {
      let l = Yl(Us(r, i, i), t);
      if (ko && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let u = Yl(Us(r, i - 1, i - 1), -1);
        if (u.top == l.top) {
          let c = Yl(Us(r, i, i + 1), -1);
          if (c.top != l.top)
            return Rh(c, c.left < u.left);
        }
      }
      return l;
    } else {
      let l = i, u = i, c = t < 0 ? 1 : -1;
      return t < 0 && !i ? (u++, c = -1) : t >= 0 && i == r.nodeValue.length ? (l--, c = 1) : t < 0 ? l-- : u++, Rh(Yl(Us(r, l, u), c), c < 0);
    }
  if (!n.state.doc.resolve(e - (a || 0)).parent.inlineContent) {
    if (a == null && i && (t < 0 || i == Ua(r))) {
      let l = r.childNodes[i - 1];
      if (l.nodeType == 1)
        return lS(l.getBoundingClientRect(), !1);
    }
    if (a == null && i < Ua(r)) {
      let l = r.childNodes[i];
      if (l.nodeType == 1)
        return lS(l.getBoundingClientRect(), !0);
    }
    return lS(r.getBoundingClientRect(), t >= 0);
  }
  if (a == null && i && (t < 0 || i == Ua(r))) {
    let l = r.childNodes[i - 1], u = l.nodeType == 3 ? Us(l, Ua(l) - (o ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (u)
      return Rh(Yl(u, 1), !1);
  }
  if (a == null && i < Ua(r)) {
    let l = r.childNodes[i];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let u = l ? l.nodeType == 3 ? Us(l, 0, o ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (u)
      return Rh(Yl(u, -1), !0);
  }
  return Rh(Yl(r.nodeType == 3 ? Us(r) : r, -t), t >= 0);
}
function Rh(n, e) {
  if (n.width == 0)
    return n;
  let t = e ? n.left : n.right;
  return { top: n.top, bottom: n.bottom, left: t, right: t };
}
function lS(n, e) {
  if (n.height == 0)
    return n;
  let t = e ? n.top : n.bottom;
  return { top: t, bottom: t, left: n.left, right: n.right };
}
function t8(n, e, t) {
  let r = n.state, i = n.root.activeElement;
  r != e && n.updateState(e), i != n.dom && n.focus();
  try {
    return t();
  } finally {
    r != e && n.updateState(r), i != n.dom && i && i.focus();
  }
}
function gce(n, e, t) {
  let r = e.selection, i = t == "up" ? r.$from : r.$to;
  return t8(n, e, () => {
    let { node: a } = n.docView.domFromPos(i.pos, t == "up" ? -1 : 1);
    for (; ; ) {
      let s = n.docView.nearestDesc(a, !0);
      if (!s)
        break;
      if (s.node.isBlock) {
        a = s.contentDOM || s.dom;
        break;
      }
      a = s.dom.parentNode;
    }
    let o = e8(n, i.pos, 1);
    for (let s = a.firstChild; s; s = s.nextSibling) {
      let l;
      if (s.nodeType == 1)
        l = s.getClientRects();
      else if (s.nodeType == 3)
        l = Us(s, 0, s.nodeValue.length).getClientRects();
      else
        continue;
      for (let u = 0; u < l.length; u++) {
        let c = l[u];
        if (c.bottom > c.top + 1 && (t == "up" ? o.top - c.top > (c.bottom - o.top) * 2 : c.bottom - o.bottom > (o.bottom - c.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const yce = /[\u0590-\u08ac]/;
function bce(n, e, t) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, a = !i, o = i == r.parent.content.size, s = n.domSelection();
  return s ? !yce.test(r.parent.textContent) || !s.modify ? t == "left" || t == "backward" ? a : o : t8(n, e, () => {
    let { focusNode: l, focusOffset: u, anchorNode: c, anchorOffset: d } = n.domSelectionRange(), f = s.caretBidiLevel;
    s.modify("move", t, "character");
    let p = r.depth ? n.docView.domAfterPos(r.before()) : n.dom, { focusNode: h, focusOffset: v } = n.domSelectionRange(), m = h && !p.contains(h.nodeType == 1 ? h : h.parentNode) || l == h && u == v;
    try {
      s.collapse(c, d), l && (l != c || u != d) && s.extend && s.extend(l, u);
    } catch {
    }
    return f != null && (s.caretBidiLevel = f), m;
  }) : r.pos == r.start() || r.pos == r.end();
}
let dN = null, fN = null, pN = !1;
function _ce(n, e, t) {
  return dN == e && fN == t ? pN : (dN = e, fN = t, pN = t == "up" || t == "down" ? gce(n, e, t) : bce(n, e, t));
}
const Ka = 0, hN = 1, zc = 2, bs = 3;
class Ng {
  constructor(e, t, r, i) {
    this.parent = e, this.children = t, this.dom = r, this.contentDOM = i, this.dirty = Ka, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, t, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let t = 0; t < this.children.length; t++)
      e += this.children[t].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let t = 0, r = this.posAtStart; ; t++) {
      let i = this.children[t];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, t, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let a, o;
        if (e == this.contentDOM)
          a = e.childNodes[t - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          a = e.previousSibling;
        }
        for (; a && !((o = a.pmViewDesc) && o.parent == this); )
          a = a.previousSibling;
        return a ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let a, o;
        if (e == this.contentDOM)
          a = e.childNodes[t];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          a = e.nextSibling;
        }
        for (; a && !((o = a.pmViewDesc) && o.parent == this); )
          a = a.nextSibling;
        return a ? this.posBeforeChild(o) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = t > Kr(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (t == 0)
        for (let a = e; ; a = a.parentNode) {
          if (a == this.dom) {
            i = !1;
            break;
          }
          if (a.previousSibling)
            break;
        }
      if (i == null && t == e.childNodes.length)
        for (let a = e; ; a = a.parentNode) {
          if (a == this.dom) {
            i = !0;
            break;
          }
          if (a.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, t = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let a = this.getDesc(i), o;
      if (a && (!t || a.node))
        if (r && (o = a.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
          r = !1;
        else
          return a;
    }
  }
  getDesc(e) {
    let t = e.pmViewDesc;
    for (let r = t; r; r = r.parent)
      if (r == this)
        return t;
  }
  posFromDOM(e, t, r) {
    for (let i = e; i; i = i.parentNode) {
      let a = this.getDesc(i);
      if (a)
        return a.localPosFromDOM(e, t, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let t = 0, r = 0; t < this.children.length; t++) {
      let i = this.children[t], a = r + i.size;
      if (r == e && a != r) {
        for (; !i.border && i.children.length; )
          for (let o = 0; o < i.children.length; o++) {
            let s = i.children[o];
            if (s.size) {
              i = s;
              break;
            }
          }
        return i;
      }
      if (e < a)
        return i.descAt(e - r - i.border);
      r = a;
    }
  }
  domFromPos(e, t) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let a = 0; r < this.children.length; r++) {
      let o = this.children[r], s = a + o.size;
      if (s > e || o instanceof r8) {
        i = e - a;
        break;
      }
      a = s;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, t);
    for (let a; r && !(a = this.children[r - 1]).size && a instanceof n8 && a.side >= 0; r--)
      ;
    if (t <= 0) {
      let a, o = !0;
      for (; a = r ? this.children[r - 1] : null, !(!a || a.dom.parentNode == this.contentDOM); r--, o = !1)
        ;
      return a && t && o && !a.border && !a.domAtom ? a.domFromPos(a.size, t) : { node: this.contentDOM, offset: a ? Kr(a.dom) + 1 : 0 };
    } else {
      let a, o = !0;
      for (; a = r < this.children.length ? this.children[r] : null, !(!a || a.dom.parentNode == this.contentDOM); r++, o = !1)
        ;
      return a && o && !a.border && !a.domAtom ? a.domFromPos(0, t) : { node: this.contentDOM, offset: a ? Kr(a.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, t, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, a = -1;
    for (let o = r, s = 0; ; s++) {
      let l = this.children[s], u = o + l.size;
      if (i == -1 && e <= u) {
        let c = o + l.border;
        if (e >= c && t <= u - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, t, c);
        e = o;
        for (let d = s; d > 0; d--) {
          let f = this.children[d - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            i = Kr(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (u > t || s == this.children.length - 1)) {
        t = u;
        for (let c = s + 1; c < this.children.length; c++) {
          let d = this.children[c];
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
            a = Kr(d.dom);
            break;
          }
          t += d.size;
        }
        a == -1 && (a = this.contentDOM.childNodes.length);
        break;
      }
      o = u;
    }
    return { node: this.contentDOM, from: e, to: t, fromOffset: i, toOffset: a };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let t = this.children[e < 0 ? 0 : this.children.length - 1];
    return t.size == 0 || t.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: t, offset: r } = this.domFromPos(e, 0);
    if (t.nodeType != 1 || r == t.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return t.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, t, r, i = !1) {
    let a = Math.min(e, t), o = Math.max(e, t);
    for (let p = 0, h = 0; p < this.children.length; p++) {
      let v = this.children[p], m = h + v.size;
      if (a > h && o < m)
        return v.setSelection(e - h - v.border, t - h - v.border, r, i);
      h = m;
    }
    let s = this.domFromPos(e, e ? -1 : 1), l = t == e ? s : this.domFromPos(t, t ? -1 : 1), u = r.root.getSelection(), c = r.domSelectionRange(), d = !1;
    if ((ko || Li) && e == t) {
      let { node: p, offset: h } = s;
      if (p.nodeType == 3) {
        if (d = !!(h && p.nodeValue[h - 1] == `
`), d && h == p.nodeValue.length)
          for (let v = p, m; v; v = v.parentNode) {
            if (m = v.nextSibling) {
              m.nodeName == "BR" && (s = l = { node: m.parentNode, offset: Kr(m) + 1 });
              break;
            }
            let g = v.pmViewDesc;
            if (g && g.node && g.node.isBlock)
              break;
          }
      } else {
        let v = p.childNodes[h - 1];
        d = v && (v.nodeName == "BR" || v.contentEditable == "false");
      }
    }
    if (ko && c.focusNode && c.focusNode != l.node && c.focusNode.nodeType == 1) {
      let p = c.focusNode.childNodes[c.focusOffset];
      p && p.contentEditable == "false" && (i = !0);
    }
    if (!(i || d && Li) && Sd(s.node, s.offset, c.anchorNode, c.anchorOffset) && Sd(l.node, l.offset, c.focusNode, c.focusOffset))
      return;
    let f = !1;
    if ((u.extend || e == t) && !d) {
      u.collapse(s.node, s.offset);
      try {
        e != t && u.extend(l.node, l.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > t) {
        let h = s;
        s = l, l = h;
      }
      let p = document.createRange();
      p.setEnd(l.node, l.offset), p.setStart(s.node, s.offset), u.removeAllRanges(), u.addRange(p);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, t) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let a = this.children[i], o = r + a.size;
      if (r == o ? e <= o && t >= r : e < o && t > r) {
        let s = r + a.border, l = o - a.border;
        if (e >= s && t <= l) {
          this.dirty = e == r || t == o ? zc : hN, e == s && t == l && (a.contentLost || a.dom.parentNode != this.contentDOM) ? a.dirty = bs : a.markDirty(e - s, t - s);
          return;
        } else
          a.dirty = a.dom == a.contentDOM && a.dom.parentNode == this.contentDOM && !a.children.length ? zc : bs;
      }
      r = o;
    }
    this.dirty = zc;
  }
  markParentsDirty() {
    let e = 1;
    for (let t = this.parent; t; t = t.parent, e++) {
      let r = e == 1 ? zc : hN;
      t.dirty < r && (t.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class n8 extends Ng {
  constructor(e, t, r, i) {
    let a, o = t.type.toDOM;
    if (typeof o == "function" && (o = o(r, () => {
      if (!a)
        return i;
      if (a.parent)
        return a.parent.posBeforeChild(a);
    })), !t.type.spec.raw) {
      if (o.nodeType != 1) {
        let s = document.createElement("span");
        s.appendChild(o), o = s;
      }
      o.contentEditable = "false", o.classList.add("ProseMirror-widget");
    }
    super(e, [], o, null), this.widget = t, this.widget = t, a = this;
  }
  matchesWidget(e) {
    return this.dirty == Ka && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let t = this.widget.spec.stopEvent;
    return t ? t(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class xce extends Ng {
  constructor(e, t, r, i) {
    super(e, [], t, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, t) {
    return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Ed extends Ng {
  constructor(e, t, r, i, a) {
    super(e, [], r, i), this.mark = t, this.spec = a;
  }
  static create(e, t, r, i) {
    let a = i.nodeViews[t.type.name], o = a && a(t, i, r);
    return (!o || !o.dom) && (o = Ud.renderSpec(document, t.type.spec.toDOM(t, r), null, t.attrs)), new Ed(e, t, o.dom, o.contentDOM || o.dom, o);
  }
  parseRule() {
    return this.dirty & bs || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != bs && this.mark.eq(e);
  }
  markDirty(e, t) {
    if (super.markDirty(e, t), this.dirty != Ka) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Ka;
    }
  }
  slice(e, t, r) {
    let i = Ed.create(this.parent, this.mark, !0, r), a = this.children, o = this.size;
    t < o && (a = KT(a, t, o, r)), e > 0 && (a = KT(a, 0, e, r));
    for (let s = 0; s < a.length; s++)
      a[s].parent = i;
    return i.children = a, i;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class wu extends Ng {
  constructor(e, t, r, i, a, o, s, l, u) {
    super(e, [], a, o), this.node = t, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = s;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, t, r, i, a, o) {
    let s = a.nodeViews[t.type.name], l, u = s && s(t, a, () => {
      if (!l)
        return o;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, r, i), c = u && u.dom, d = u && u.contentDOM;
    if (t.isText) {
      if (!c)
        c = document.createTextNode(t.text);
      else if (c.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else c || ({ dom: c, contentDOM: d } = Ud.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs));
    !d && !t.isText && c.nodeName != "BR" && (c.hasAttribute("contenteditable") || (c.contentEditable = "false"), t.type.spec.draggable && (c.draggable = !0));
    let f = c;
    return c = o8(c, r, t), u ? l = new wce(e, t, r, i, c, d || null, f, u, a, o + 1) : t.isText ? new _x(e, t, r, i, c, f, a) : new wu(e, t, r, i, c, d || null, f, a, o + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let t = this.children.length - 1; t >= 0; t--) {
        let r = this.children[t];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => $e.empty);
    }
    return e;
  }
  matchesNode(e, t, r) {
    return this.dirty == Ka && e.eq(this.node) && X1(t, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, t) {
    let r = this.node.inlineContent, i = t, a = e.composing ? this.localCompositionInfo(e, t) : null, o = a && a.pos > -1 ? a : null, s = a && a.pos < 0, l = new Ece(this, o && o.node, e);
    kce(this.node, this.innerDeco, (u, c, d) => {
      u.spec.marks ? l.syncToMarks(u.spec.marks, r, e) : u.type.side >= 0 && !d && l.syncToMarks(c == this.node.childCount ? Hn.none : this.node.child(c).marks, r, e), l.placeWidget(u, e, i);
    }, (u, c, d, f) => {
      l.syncToMarks(u.marks, r, e);
      let p;
      l.findNodeMatch(u, c, d, f) || s && e.state.selection.from > i && e.state.selection.to < i + u.nodeSize && (p = l.findIndexWithChild(a.node)) > -1 && l.updateNodeAt(u, c, d, p, e) || l.updateNextNode(u, c, d, e, f, i) || l.addNode(u, c, d, e, i), i += u.nodeSize;
    }), l.syncToMarks([], r, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == zc) && (o && this.protectLocalComposition(e, o), i8(this.contentDOM, this.children, e), Ap && Ace(this.dom));
  }
  localCompositionInfo(e, t) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof Dt) || r < t || i > t + this.node.content.size)
      return null;
    let a = e.input.compositionNode;
    if (!a || !this.dom.contains(a.parentNode))
      return null;
    if (this.node.inlineContent) {
      let o = a.nodeValue, s = Mce(this.node.content, o, r - t, i - t);
      return s < 0 ? null : { node: a, pos: s, text: o };
    } else
      return { node: a, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: t, pos: r, text: i }) {
    if (this.getDesc(t))
      return;
    let a = t;
    for (; a.parentNode != this.contentDOM; a = a.parentNode) {
      for (; a.previousSibling; )
        a.parentNode.removeChild(a.previousSibling);
      for (; a.nextSibling; )
        a.parentNode.removeChild(a.nextSibling);
      a.pmViewDesc && (a.pmViewDesc = void 0);
    }
    let o = new xce(this, a, t, i);
    e.input.compositionNodes.push(o), this.children = KT(this.children, r, r + i.length, e, o);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, t, r, i) {
    return this.dirty == bs || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, r, i), !0);
  }
  updateInner(e, t, r, i) {
    this.updateOuterDeco(t), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Ka;
  }
  updateOuterDeco(e) {
    if (X1(e, this.outerDeco))
      return;
    let t = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = a8(this.dom, this.nodeDOM, YT(this.outerDeco, this.node, t), YT(e, this.node, t)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function vN(n, e, t, r, i) {
  o8(r, e, n);
  let a = new wu(void 0, n, e, t, r, r, r, i, 0);
  return a.contentDOM && a.updateChildren(i, 0), a;
}
class _x extends wu {
  constructor(e, t, r, i, a, o, s) {
    super(e, t, r, i, a, null, o, s, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, t, r, i) {
    return this.dirty == bs || this.dirty != Ka && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != Ka || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = Ka, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let t = this.nodeDOM; t; t = t.parentNode)
      if (t == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, t, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, t, r) {
    let i = this.node.cut(e, t), a = document.createTextNode(i.text);
    return new _x(this.parent, i, this.outerDeco, this.innerDeco, a, a, r);
  }
  markDirty(e, t) {
    super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = bs);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class r8 extends Ng {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == Ka && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class wce extends wu {
  constructor(e, t, r, i, a, o, s, l, u, c) {
    super(e, t, r, i, a, o, s, u, c), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, t, r, i) {
    if (this.dirty == bs)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let a = this.spec.update(e, t, r);
      return a && this.updateInner(e, t, r, i), a;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, t, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, t, r.root) : super.setSelection(e, t, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function i8(n, e, t) {
  let r = n.firstChild, i = !1;
  for (let a = 0; a < e.length; a++) {
    let o = e[a], s = o.dom;
    if (s.parentNode == n) {
      for (; s != r; )
        r = mN(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, n.insertBefore(s, r);
    if (o instanceof Ed) {
      let l = r ? r.previousSibling : n.lastChild;
      i8(o.contentDOM, o.children, t), r = l ? l.nextSibling : n.firstChild;
    }
  }
  for (; r; )
    r = mN(r), i = !0;
  i && t.trackWrites == n && (t.trackWrites = null);
}
const Gv = function(n) {
  n && (this.nodeName = n);
};
Gv.prototype = /* @__PURE__ */ Object.create(null);
const Fc = [new Gv()];
function YT(n, e, t) {
  if (n.length == 0)
    return Fc;
  let r = t ? Fc[0] : new Gv(), i = [r];
  for (let a = 0; a < n.length; a++) {
    let o = n[a].type.attrs;
    if (o) {
      o.nodeName && i.push(r = new Gv(o.nodeName));
      for (let s in o) {
        let l = o[s];
        l != null && (t && i.length == 1 && i.push(r = new Gv(e.isInline ? "span" : "div")), s == "class" ? r.class = (r.class ? r.class + " " : "") + l : s == "style" ? r.style = (r.style ? r.style + ";" : "") + l : s != "nodeName" && (r[s] = l));
      }
    }
  }
  return i;
}
function a8(n, e, t, r) {
  if (t == Fc && r == Fc)
    return e;
  let i = e;
  for (let a = 0; a < r.length; a++) {
    let o = r[a], s = t[a];
    if (a) {
      let l;
      s && s.nodeName == o.nodeName && i != n && (l = i.parentNode) && l.nodeName.toLowerCase() == o.nodeName || (l = document.createElement(o.nodeName), l.pmIsDeco = !0, l.appendChild(i), s = Fc[0]), i = l;
    }
    Sce(i, s || Fc[0], o);
  }
  return i;
}
function Sce(n, e, t) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in t) && n.removeAttribute(r);
  for (let r in t)
    r != "class" && r != "style" && r != "nodeName" && t[r] != e[r] && n.setAttribute(r, t[r]);
  if (e.class != t.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = t.class ? t.class.split(" ").filter(Boolean) : [];
    for (let a = 0; a < r.length; a++)
      i.indexOf(r[a]) == -1 && n.classList.remove(r[a]);
    for (let a = 0; a < i.length; a++)
      r.indexOf(i[a]) == -1 && n.classList.add(i[a]);
    n.classList.length == 0 && n.removeAttribute("class");
  }
  if (e.style != t.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        n.style.removeProperty(i[1]);
    }
    t.style && (n.style.cssText += t.style);
  }
}
function o8(n, e, t) {
  return a8(n, n, Fc, YT(e, t, n.nodeType != 1));
}
function X1(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].type.eq(e[t].type))
      return !1;
  return !0;
}
function mN(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class Ece {
  constructor(e, t, r) {
    this.lock = t, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = Tce(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, t) {
    if (e != t) {
      for (let r = e; r < t; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, t - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, t, r) {
    let i = 0, a = this.stack.length >> 1, o = Math.min(a, e.length);
    for (; i < o && (i == a - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < a; )
      this.destroyRest(), this.top.dirty = Ka, this.index = this.stack.pop(), this.top = this.stack.pop(), a--;
    for (; a < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let s = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let u = this.top.children[l];
        if (u.matchesMark(e[a]) && !this.isLocked(u.dom)) {
          s = l;
          break;
        }
      }
      if (s > -1)
        s > this.index && (this.changed = !0, this.destroyBetween(this.index, s)), this.top = this.top.children[this.index];
      else {
        let l = Ed.create(this.top, e[a], t, r);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, a++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, t, r, i) {
    let a = -1, o;
    if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, r))
      a = this.top.children.indexOf(o, this.index);
    else
      for (let s = this.index, l = Math.min(this.top.children.length, s + 5); s < l; s++) {
        let u = this.top.children[s];
        if (u.matchesNode(e, t, r) && !this.preMatch.matched.has(u)) {
          a = s;
          break;
        }
      }
    return a < 0 ? !1 : (this.destroyBetween(this.index, a), this.index++, !0);
  }
  updateNodeAt(e, t, r, i, a) {
    let o = this.top.children[i];
    return o.dirty == bs && o.dom == o.contentDOM && (o.dirty = zc), o.update(e, t, r, a) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let t = e.parentNode;
      if (!t)
        return -1;
      if (t == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = t;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, t, r, i, a, o) {
    for (let s = this.index; s < this.top.children.length; s++) {
      let l = this.top.children[s];
      if (l instanceof wu) {
        let u = this.preMatch.matched.get(l);
        if (u != null && u != a)
          return !1;
        let c = l.dom, d, f = this.isLocked(c) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != bs && X1(t, l.outerDeco));
        if (!f && l.update(e, t, r, i))
          return this.destroyBetween(this.index, s), l.dom != c && (this.changed = !0), this.index++, !0;
        if (!f && (d = this.recreateWrapper(l, e, t, r, i, o)))
          return this.destroyBetween(this.index, s), this.top.children[this.index] = d, d.contentDOM && (d.dirty = zc, d.updateChildren(i, o + 1), d.dirty = Ka), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, t, r, i, a, o) {
    if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !X1(r, e.outerDeco) || !i.eq(e.innerDeco))
      return null;
    let s = wu.create(this.top, t, r, i, a, o);
    if (s.contentDOM) {
      s.children = e.children, e.children = [];
      for (let l of s.children)
        l.parent = s;
    }
    return e.destroy(), s;
  }
  // Insert the node as a newly created node desc.
  addNode(e, t, r, i, a) {
    let o = wu.create(this.top, e, t, r, i, a);
    o.contentDOM && o.updateChildren(i, a + 1), this.top.children.splice(this.index++, 0, o), this.changed = !0;
  }
  placeWidget(e, t, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let a = new n8(this.top, e, t, r);
      this.top.children.splice(this.index++, 0, a), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], t = this.top;
    for (; e instanceof Ed; )
      t = e, e = t.children[t.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof _x) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Li || di) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
  }
  addHackNode(e, t) {
    if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new r8(this.top, [], r, null);
      t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function Tce(n, e) {
  let t = e, r = t.children.length, i = n.childCount, a = /* @__PURE__ */ new Map(), o = [];
  e: for (; i > 0; ) {
    let s;
    for (; ; )
      if (r) {
        let u = t.children[r - 1];
        if (u instanceof Ed)
          t = u, r = u.children.length;
        else {
          s = u, r--;
          break;
        }
      } else {
        if (t == e)
          break e;
        r = t.parent.children.indexOf(t), t = t.parent;
      }
    let l = s.node;
    if (l) {
      if (l != n.child(i - 1))
        break;
      --i, a.set(s, i), o.push(s);
    }
  }
  return { index: i, matched: a, matches: o.reverse() };
}
function Cce(n, e) {
  return n.type.side - e.type.side;
}
function kce(n, e, t, r) {
  let i = e.locals(n), a = 0;
  if (i.length == 0) {
    for (let u = 0; u < n.childCount; u++) {
      let c = n.child(u);
      r(c, i, e.forChild(a, c), u), a += c.nodeSize;
    }
    return;
  }
  let o = 0, s = [], l = null;
  for (let u = 0; ; ) {
    let c, d;
    for (; o < i.length && i[o].to == a; ) {
      let m = i[o++];
      m.widget && (c ? (d || (d = [c])).push(m) : c = m);
    }
    if (c)
      if (d) {
        d.sort(Cce);
        for (let m = 0; m < d.length; m++)
          t(d[m], u, !!l);
      } else
        t(c, u, !!l);
    let f, p;
    if (l)
      p = -1, f = l, l = null;
    else if (u < n.childCount)
      p = u, f = n.child(u++);
    else
      break;
    for (let m = 0; m < s.length; m++)
      s[m].to <= a && s.splice(m--, 1);
    for (; o < i.length && i[o].from <= a && i[o].to > a; )
      s.push(i[o++]);
    let h = a + f.nodeSize;
    if (f.isText) {
      let m = h;
      o < i.length && i[o].from < m && (m = i[o].from);
      for (let g = 0; g < s.length; g++)
        s[g].to < m && (m = s[g].to);
      m < h && (l = f.cut(m - a), f = f.cut(0, m - a), h = m, p = -1);
    } else
      for (; o < i.length && i[o].to < h; )
        o++;
    let v = f.isInline && !f.isLeaf ? s.filter((m) => !m.inline) : s.slice();
    r(f, v, e.forChild(a, f), p), a = h;
  }
}
function Ace(n) {
  if (n.nodeName == "UL" || n.nodeName == "OL") {
    let e = n.style.cssText;
    n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e;
  }
}
function Mce(n, e, t, r) {
  for (let i = 0, a = 0; i < n.childCount && a <= r; ) {
    let o = n.child(i++), s = a;
    if (a += o.nodeSize, !o.isText)
      continue;
    let l = o.text;
    for (; i < n.childCount; ) {
      let u = n.child(i++);
      if (a += u.nodeSize, !u.isText)
        break;
      l += u.text;
    }
    if (a >= t) {
      if (a >= r && l.slice(r - e.length - s, r - s) == e)
        return r - e.length;
      let u = s < r ? l.lastIndexOf(e, r - s - 1) : -1;
      if (u >= 0 && u + e.length + s >= t)
        return s + u;
      if (t == r && l.length >= r + e.length - s && l.slice(r - s, r - s + e.length) == e)
        return r;
    }
  }
  return -1;
}
function KT(n, e, t, r, i) {
  let a = [];
  for (let o = 0, s = 0; o < n.length; o++) {
    let l = n[o], u = s, c = s += l.size;
    u >= t || c <= e ? a.push(l) : (u < e && a.push(l.slice(0, e - u, r)), i && (a.push(i), i = void 0), c > t && a.push(l.slice(t - u, l.size, r)));
  }
  return a;
}
function pM(n, e = null) {
  let t = n.domSelectionRange(), r = n.state.doc;
  if (!t.focusNode)
    return null;
  let i = n.docView.nearestDesc(t.focusNode), a = i && i.size == 0, o = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
  if (o < 0)
    return null;
  let s = r.resolve(o), l, u;
  if (bx(t)) {
    for (l = o; i && !i.node; )
      i = i.parent;
    let d = i.node;
    if (i && d.isAtom && Ct.isSelectable(d) && i.parent && !(d.isInline && tce(t.focusNode, t.focusOffset, i.dom))) {
      let f = i.posBefore;
      u = new Ct(o == f ? s : r.resolve(f));
    }
  } else {
    if (t instanceof n.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) {
      let d = o, f = o;
      for (let p = 0; p < t.rangeCount; p++) {
        let h = t.getRangeAt(p);
        d = Math.min(d, n.docView.posFromDOM(h.startContainer, h.startOffset, 1)), f = Math.max(f, n.docView.posFromDOM(h.endContainer, h.endOffset, -1));
      }
      if (d < 0)
        return null;
      [l, o] = f == n.state.selection.anchor ? [f, d] : [d, f], s = r.resolve(o);
    } else
      l = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let c = r.resolve(l);
  if (!u) {
    let d = e == "pointer" || n.state.selection.head < s.pos && !a ? 1 : -1;
    u = hM(n, c, s, d);
  }
  return u;
}
function s8(n) {
  return n.editable ? n.hasFocus() : u8(n) && document.activeElement && document.activeElement.contains(n.dom);
}
function ll(n, e = !1) {
  let t = n.state.selection;
  if (l8(n, t), !!s8(n)) {
    if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && di) {
      let r = n.domSelectionRange(), i = n.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && Sd(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        n.input.mouseDown.delayedSelectionSync = !0, n.domObserver.setCurSelection();
        return;
      }
    }
    if (n.domObserver.disconnectSelection(), n.cursorWrapper)
      Oce(n);
    else {
      let { anchor: r, head: i } = t, a, o;
      gN && !(t instanceof Dt) && (t.$from.parent.inlineContent || (a = yN(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (o = yN(n, t.to))), n.docView.setSelection(r, i, n, e), gN && (a && bN(a), o && bN(o)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && Dce(n));
    }
    n.domObserver.setCurSelection(), n.domObserver.connectSelection();
  }
}
const gN = Li || di && K6 < 63;
function yN(n, e) {
  let { node: t, offset: r } = n.docView.domFromPos(e, 0), i = r < t.childNodes.length ? t.childNodes[r] : null, a = r ? t.childNodes[r - 1] : null;
  if (Li && i && i.contentEditable == "false")
    return uS(i);
  if ((!i || i.contentEditable == "false") && (!a || a.contentEditable == "false")) {
    if (i)
      return uS(i);
    if (a)
      return uS(a);
  }
}
function uS(n) {
  return n.contentEditable = "true", Li && n.draggable && (n.draggable = !1, n.wasDraggable = !0), n;
}
function bN(n) {
  n.contentEditable = "false", n.wasDraggable && (n.draggable = !0, n.wasDraggable = null);
}
function Dce(n) {
  let e = n.dom.ownerDocument;
  e.removeEventListener("selectionchange", n.input.hideSelectionGuard);
  let t = n.domSelectionRange(), r = t.anchorNode, i = t.anchorOffset;
  e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => {
    (t.anchorNode != r || t.anchorOffset != i) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => {
      (!s8(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function Oce(n) {
  let e = n.domSelection(), t = document.createRange();
  if (!e)
    return;
  let r = n.cursorWrapper.dom, i = r.nodeName == "IMG";
  i ? t.setStart(r.parentNode, Kr(r) + 1) : t.setStart(r, 0), t.collapse(!0), e.removeAllRanges(), e.addRange(t), !i && !n.state.selection.visible && Ji && xu <= 11 && (r.disabled = !0, r.disabled = !1);
}
function l8(n, e) {
  if (e instanceof Ct) {
    let t = n.docView.descAt(e.from);
    t != n.lastSelectedViewDesc && (_N(n), t && t.selectNode(), n.lastSelectedViewDesc = t);
  } else
    _N(n);
}
function _N(n) {
  n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0);
}
function hM(n, e, t, r) {
  return n.someProp("createSelectionBetween", (i) => i(n, e, t)) || Dt.between(e, t, r);
}
function xN(n) {
  return n.editable && !n.hasFocus() ? !1 : u8(n);
}
function u8(n) {
  let e = n.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function Ice(n) {
  let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange();
  return Sd(e.node, e.offset, t.anchorNode, t.anchorOffset);
}
function XT(n, e) {
  let { $anchor: t, $head: r } = n.selection, i = e > 0 ? t.max(r) : t.min(r), a = i.parent.inlineContent ? i.depth ? n.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return a && It.findFrom(a, e);
}
function Zl(n, e) {
  return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0;
}
function wN(n, e, t) {
  let r = n.state.selection;
  if (r instanceof Dt)
    if (t.indexOf("s") > -1) {
      let { $head: i } = r, a = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!a || a.isText || !a.isLeaf)
        return !1;
      let o = n.state.doc.resolve(i.pos + a.nodeSize * (e < 0 ? -1 : 1));
      return Zl(n, new Dt(r.$anchor, o));
    } else if (r.empty) {
      if (n.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = XT(n.state, e);
        return i && i instanceof Ct ? Zl(n, i) : !1;
      } else if (!(Fa && t.indexOf("m") > -1)) {
        let i = r.$head, a = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o;
        if (!a || a.isText)
          return !1;
        let s = e < 0 ? i.pos - a.nodeSize : i.pos;
        return a.isAtom || (o = n.docView.descAt(s)) && !o.contentDOM ? Ct.isSelectable(a) ? Zl(n, new Ct(e < 0 ? n.state.doc.resolve(i.pos - a.nodeSize) : i)) : Lg ? Zl(n, new Dt(n.state.doc.resolve(e < 0 ? s : s + a.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof Ct && r.node.isInline)
      return Zl(n, new Dt(e > 0 ? r.$to : r.$from));
    {
      let i = XT(n.state, e);
      return i ? Zl(n, i) : !1;
    }
  }
}
function Z1(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function Uv(n, e) {
  let t = n.pmViewDesc;
  return t && t.size == 0 && (e < 0 || n.nextSibling || n.nodeName != "BR");
}
function vf(n, e) {
  return e < 0 ? Lce(n) : Nce(n);
}
function Lce(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i, a, o = !1;
  for (ko && t.nodeType == 1 && r < Z1(t) && Uv(t.childNodes[r], -1) && (o = !0); ; )
    if (r > 0) {
      if (t.nodeType != 1)
        break;
      {
        let s = t.childNodes[r - 1];
        if (Uv(s, -1))
          i = t, a = --r;
        else if (s.nodeType == 3)
          t = s, r = t.nodeValue.length;
        else
          break;
      }
    } else {
      if (c8(t))
        break;
      {
        let s = t.previousSibling;
        for (; s && Uv(s, -1); )
          i = t.parentNode, a = Kr(s), s = s.previousSibling;
        if (s)
          t = s, r = Z1(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = 0;
        }
      }
    }
  o ? ZT(n, t, r) : i && ZT(n, i, a);
}
function Nce(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i = Z1(t), a, o;
  for (; ; )
    if (r < i) {
      if (t.nodeType != 1)
        break;
      let s = t.childNodes[r];
      if (Uv(s, 1))
        a = t, o = ++r;
      else
        break;
    } else {
      if (c8(t))
        break;
      {
        let s = t.nextSibling;
        for (; s && Uv(s, 1); )
          a = s.parentNode, o = Kr(s) + 1, s = s.nextSibling;
        if (s)
          t = s, r = 0, i = Z1(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = i = 0;
        }
      }
    }
  a && ZT(n, a, o);
}
function c8(n) {
  let e = n.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function Rce(n, e) {
  for (; n && e == n.childNodes.length && !Ig(n); )
    e = Kr(n) + 1, n = n.parentNode;
  for (; n && e < n.childNodes.length; ) {
    let t = n.childNodes[e];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = 0;
  }
}
function Pce(n, e) {
  for (; n && !e && !Ig(n); )
    e = Kr(n), n = n.parentNode;
  for (; n && e; ) {
    let t = n.childNodes[e - 1];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = n.childNodes.length;
  }
}
function ZT(n, e, t) {
  if (e.nodeType != 3) {
    let a, o;
    (o = Rce(e, t)) ? (e = o, t = 0) : (a = Pce(e, t)) && (e = a, t = a.nodeValue.length);
  }
  let r = n.domSelection();
  if (!r)
    return;
  if (bx(r)) {
    let a = document.createRange();
    a.setEnd(e, t), a.setStart(e, t), r.removeAllRanges(), r.addRange(a);
  } else r.extend && r.extend(e, t);
  n.domObserver.setCurSelection();
  let { state: i } = n;
  setTimeout(() => {
    n.state == i && ll(n);
  }, 50);
}
function SN(n, e) {
  let t = n.state.doc.resolve(e);
  if (!(di || ice) && t.parent.inlineContent) {
    let i = n.coordsAtPos(e);
    if (e > t.start()) {
      let a = n.coordsAtPos(e - 1), o = (a.top + a.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(a.left - i.left) > 1)
        return a.left < i.left ? "ltr" : "rtl";
    }
    if (e < t.end()) {
      let a = n.coordsAtPos(e + 1), o = (a.top + a.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(a.left - i.left) > 1)
        return a.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(n.dom).direction == "rtl" ? "rtl" : "ltr";
}
function EN(n, e, t) {
  let r = n.state.selection;
  if (r instanceof Dt && !r.empty || t.indexOf("s") > -1 || Fa && t.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: a } = r;
  if (!i.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = XT(n.state, e);
    if (o && o instanceof Ct)
      return Zl(n, o);
  }
  if (!i.parent.inlineContent) {
    let o = e < 0 ? i : a, s = r instanceof ga ? It.near(o, e) : It.findFrom(o, e);
    return s ? Zl(n, s) : !1;
  }
  return !1;
}
function TN(n, e) {
  if (!(n.state.selection instanceof Dt))
    return !0;
  let { $head: t, $anchor: r, empty: i } = n.state.selection;
  if (!t.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (n.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let a = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
  if (a && !a.isText) {
    let o = n.state.tr;
    return e < 0 ? o.delete(t.pos - a.nodeSize, t.pos) : o.delete(t.pos, t.pos + a.nodeSize), n.dispatch(o), !0;
  }
  return !1;
}
function CN(n, e, t) {
  n.domObserver.stop(), e.contentEditable = t, n.domObserver.start();
}
function jce(n) {
  if (!Li || n.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: t } = n.domSelectionRange();
  if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    CN(n, r, "true"), setTimeout(() => CN(n, r, "false"), 20);
  }
  return !1;
}
function Bce(n) {
  let e = "";
  return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e;
}
function $ce(n, e) {
  let t = e.keyCode, r = Bce(e);
  if (t == 8 || Fa && t == 72 && r == "c")
    return TN(n, -1) || vf(n, -1);
  if (t == 46 && !e.shiftKey || Fa && t == 68 && r == "c")
    return TN(n, 1) || vf(n, 1);
  if (t == 13 || t == 27)
    return !0;
  if (t == 37 || Fa && t == 66 && r == "c") {
    let i = t == 37 ? SN(n, n.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return wN(n, i, r) || vf(n, i);
  } else if (t == 39 || Fa && t == 70 && r == "c") {
    let i = t == 39 ? SN(n, n.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return wN(n, i, r) || vf(n, i);
  } else {
    if (t == 38 || Fa && t == 80 && r == "c")
      return EN(n, -1, r) || vf(n, -1);
    if (t == 40 || Fa && t == 78 && r == "c")
      return jce(n) || EN(n, 1, r) || vf(n, 1);
    if (r == (Fa ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90))
      return !0;
  }
  return !1;
}
function vM(n, e) {
  n.someProp("transformCopied", (p) => {
    e = p(e, n);
  });
  let t = [], { content: r, openStart: i, openEnd: a } = e;
  for (; i > 1 && a > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, a--;
    let p = r.firstChild;
    t.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null), r = p.content;
  }
  let o = n.someProp("clipboardSerializer") || Ud.fromSchema(n.state.schema), s = m8(), l = s.createElement("div");
  l.appendChild(o.serializeFragment(r, { document: s }));
  let u = l.firstChild, c, d = 0;
  for (; u && u.nodeType == 1 && (c = v8[u.nodeName.toLowerCase()]); ) {
    for (let p = c.length - 1; p >= 0; p--) {
      let h = s.createElement(c[p]);
      for (; l.firstChild; )
        h.appendChild(l.firstChild);
      l.appendChild(h), d++;
    }
    u = l.firstChild;
  }
  u && u.nodeType == 1 && u.setAttribute("data-pm-slice", `${i} ${a}${d ? ` -${d}` : ""} ${JSON.stringify(t)}`);
  let f = n.someProp("clipboardTextSerializer", (p) => p(e, n)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: f, slice: e };
}
function d8(n, e, t, r, i) {
  let a = i.parent.type.spec.code, o, s;
  if (!t && !e)
    return null;
  let l = e && (r || a || !t);
  if (l) {
    if (n.someProp("transformPastedText", (f) => {
      e = f(e, a || r, n);
    }), a)
      return e ? new nt($e.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : nt.empty;
    let d = n.someProp("clipboardTextParser", (f) => f(e, i, r, n));
    if (d)
      s = d;
    else {
      let f = i.marks(), { schema: p } = n.state, h = Ud.fromSchema(p);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((v) => {
        let m = o.appendChild(document.createElement("p"));
        v && m.appendChild(h.serializeNode(p.text(v, f)));
      });
    }
  } else
    n.someProp("transformPastedHTML", (d) => {
      t = d(t, n);
    }), o = Hce(t), Lg && Gce(o);
  let u = o && o.querySelector("[data-pm-slice]"), c = u && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(u.getAttribute("data-pm-slice") || "");
  if (c && c[3])
    for (let d = +c[3]; d > 0; d--) {
      let f = o.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      o = f;
    }
  if (s || (s = (n.someProp("clipboardParser") || n.someProp("domParser") || hp.fromSchema(n.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(l || c),
    context: i,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !zce.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), c)
    s = Uce(kN(s, +c[1], +c[2]), c[4]);
  else if (s = nt.maxOpen(Fce(s.content, i), !0), s.openStart || s.openEnd) {
    let d = 0, f = 0;
    for (let p = s.content.firstChild; d < s.openStart && !p.type.spec.isolating; d++, p = p.firstChild)
      ;
    for (let p = s.content.lastChild; f < s.openEnd && !p.type.spec.isolating; f++, p = p.lastChild)
      ;
    s = kN(s, d, f);
  }
  return n.someProp("transformPasted", (d) => {
    s = d(s, n);
  }), s;
}
const zce = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function Fce(n, e) {
  if (n.childCount < 2)
    return n;
  for (let t = e.depth; t >= 0; t--) {
    let i = e.node(t).contentMatchAt(e.index(t)), a, o = [];
    if (n.forEach((s) => {
      if (!o)
        return;
      let l = i.findWrapping(s.type), u;
      if (!l)
        return o = null;
      if (u = o.length && a.length && p8(l, a, s, o[o.length - 1], 0))
        o[o.length - 1] = u;
      else {
        o.length && (o[o.length - 1] = h8(o[o.length - 1], a.length));
        let c = f8(s, l);
        o.push(c), i = i.matchType(c.type), a = l;
      }
    }), o)
      return $e.from(o);
  }
  return n;
}
function f8(n, e, t = 0) {
  for (let r = e.length - 1; r >= t; r--)
    n = e[r].create(null, $e.from(n));
  return n;
}
function p8(n, e, t, r, i) {
  if (i < n.length && i < e.length && n[i] == e[i]) {
    let a = p8(n, e, t, r.lastChild, i + 1);
    if (a)
      return r.copy(r.content.replaceChild(r.childCount - 1, a));
    if (r.contentMatchAt(r.childCount).matchType(i == n.length - 1 ? t.type : n[i + 1]))
      return r.copy(r.content.append($e.from(f8(t, n, i + 1))));
  }
}
function h8(n, e) {
  if (e == 0)
    return n;
  let t = n.content.replaceChild(n.childCount - 1, h8(n.lastChild, e - 1)), r = n.contentMatchAt(n.childCount).fillBefore($e.empty, !0);
  return n.copy(t.append(r));
}
function JT(n, e, t, r, i, a) {
  let o = e < 0 ? n.firstChild : n.lastChild, s = o.content;
  return n.childCount > 1 && (a = 0), i < r - 1 && (s = JT(s, e, t, r, i + 1, a)), i >= t && (s = e < 0 ? o.contentMatchAt(0).fillBefore(s, a <= i).append(s) : s.append(o.contentMatchAt(o.childCount).fillBefore($e.empty, !0))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, o.copy(s));
}
function kN(n, e, t) {
  return e < n.openStart && (n = new nt(JT(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new nt(JT(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n;
}
const v8 = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let AN = null;
function m8() {
  return AN || (AN = document.implementation.createHTMLDocument("title"));
}
let cS = null;
function Vce(n) {
  let e = window.trustedTypes;
  return e ? (cS || (cS = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: (t) => t })), cS.createHTML(n)) : n;
}
function Hce(n) {
  let e = /^(\s*<meta [^>]*>)*/.exec(n);
  e && (n = n.slice(e[0].length));
  let t = m8().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(n), i;
  if ((i = r && v8[r[1].toLowerCase()]) && (n = i.map((a) => "<" + a + ">").join("") + n + i.map((a) => "</" + a + ">").reverse().join("")), t.innerHTML = Vce(n), i)
    for (let a = 0; a < i.length; a++)
      t = t.querySelector(i[a]) || t;
  return t;
}
function Gce(n) {
  let e = n.querySelectorAll(di ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), r);
  }
}
function Uce(n, e) {
  if (!n.size)
    return n;
  let t = n.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return n;
  }
  let { content: i, openStart: a, openEnd: o } = n;
  for (let s = r.length - 2; s >= 0; s -= 2) {
    let l = t.nodes[r[s]];
    if (!l || l.hasRequiredAttrs())
      break;
    i = $e.from(l.create(r[s + 1], i)), a++, o++;
  }
  return new nt(i, a, o);
}
const Ni = {}, Ri = {}, Wce = { touchstart: !0, touchmove: !0 };
class qce {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function Yce(n) {
  for (let e in Ni) {
    let t = Ni[e];
    n.dom.addEventListener(e, n.input.eventHandlers[e] = (r) => {
      Xce(n, r) && !mM(n, r) && (n.editable || !(r.type in Ri)) && t(n, r);
    }, Wce[e] ? { passive: !0 } : void 0);
  }
  Li && n.dom.addEventListener("input", () => null), QT(n);
}
function lu(n, e) {
  n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now();
}
function Kce(n) {
  n.domObserver.stop();
  for (let e in n.input.eventHandlers)
    n.dom.removeEventListener(e, n.input.eventHandlers[e]);
  clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout);
}
function QT(n) {
  n.someProp("handleDOMEvents", (e) => {
    for (let t in e)
      n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = (r) => mM(n, r));
  });
}
function mM(n, e) {
  return n.someProp("handleDOMEvents", (t) => {
    let r = t[e.type];
    return r ? r(n, e) || e.defaultPrevented : !1;
  });
}
function Xce(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target; t != n.dom; t = t.parentNode)
    if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function Zce(n, e) {
  !mM(n, e) && Ni[e.type] && (n.editable || !(e.type in Ri)) && Ni[e.type](n, e);
}
Ri.keydown = (n, e) => {
  let t = e;
  if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !y8(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !(Js && di && t.keyCode == 13)))
    if (t.keyCode != 229 && n.domObserver.forceFlush(), Ap && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
      let r = Date.now();
      n.input.lastIOSEnter = r, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        n.input.lastIOSEnter == r && (n.someProp("handleKeyDown", (i) => i(n, Oc(13, "Enter"))), n.input.lastIOSEnter = 0);
      }, 200);
    } else n.someProp("handleKeyDown", (r) => r(n, t)) || $ce(n, t) ? t.preventDefault() : lu(n, "key");
};
Ri.keyup = (n, e) => {
  e.keyCode == 16 && (n.input.shiftKey = !1);
};
Ri.keypress = (n, e) => {
  let t = e;
  if (y8(n, t) || !t.charCode || t.ctrlKey && !t.altKey || Fa && t.metaKey)
    return;
  if (n.someProp("handleKeyPress", (i) => i(n, t))) {
    t.preventDefault();
    return;
  }
  let r = n.state.selection;
  if (!(r instanceof Dt) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(t.charCode), a = () => n.state.tr.insertText(i).scrollIntoView();
    !/[\r\n]/.test(i) && !n.someProp("handleTextInput", (o) => o(n, r.$from.pos, r.$to.pos, i, a)) && n.dispatch(a()), t.preventDefault();
  }
};
function xx(n) {
  return { left: n.clientX, top: n.clientY };
}
function Jce(n, e) {
  let t = e.x - n.clientX, r = e.y - n.clientY;
  return t * t + r * r < 100;
}
function gM(n, e, t, r, i) {
  if (r == -1)
    return !1;
  let a = n.state.doc.resolve(r);
  for (let o = a.depth + 1; o > 0; o--)
    if (n.someProp(e, (s) => o > a.depth ? s(n, t, a.nodeAfter, a.before(o), i, !0) : s(n, t, a.node(o), a.before(o), i, !1)))
      return !0;
  return !1;
}
function mp(n, e, t) {
  if (n.focused || n.focus(), n.state.selection.eq(e))
    return;
  let r = n.state.tr.setSelection(e);
  r.setMeta("pointer", !0), n.dispatch(r);
}
function Qce(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.doc.resolve(e), r = t.nodeAfter;
  return r && r.isAtom && Ct.isSelectable(r) ? (mp(n, new Ct(t)), !0) : !1;
}
function ede(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.selection, r, i;
  t instanceof Ct && (r = t.node);
  let a = n.state.doc.resolve(e);
  for (let o = a.depth + 1; o > 0; o--) {
    let s = o > a.depth ? a.nodeAfter : a.node(o);
    if (Ct.isSelectable(s)) {
      r && t.$from.depth > 0 && o >= t.$from.depth && a.before(t.$from.depth + 1) == t.$from.pos ? i = a.before(t.$from.depth) : i = a.before(o);
      break;
    }
  }
  return i != null ? (mp(n, Ct.create(n.state.doc, i)), !0) : !1;
}
function tde(n, e, t, r, i) {
  return gM(n, "handleClickOn", e, t, r) || n.someProp("handleClick", (a) => a(n, e, r)) || (i ? ede(n, t) : Qce(n, t));
}
function nde(n, e, t, r) {
  return gM(n, "handleDoubleClickOn", e, t, r) || n.someProp("handleDoubleClick", (i) => i(n, e, r));
}
function rde(n, e, t, r) {
  return gM(n, "handleTripleClickOn", e, t, r) || n.someProp("handleTripleClick", (i) => i(n, e, r)) || ide(n, t, r);
}
function ide(n, e, t) {
  if (t.button != 0)
    return !1;
  let r = n.state.doc;
  if (e == -1)
    return r.inlineContent ? (mp(n, Dt.create(r, 0, r.content.size)), !0) : !1;
  let i = r.resolve(e);
  for (let a = i.depth + 1; a > 0; a--) {
    let o = a > i.depth ? i.nodeAfter : i.node(a), s = i.before(a);
    if (o.inlineContent)
      mp(n, Dt.create(r, s + 1, s + 1 + o.content.size));
    else if (Ct.isSelectable(o))
      mp(n, Ct.create(r, s));
    else
      continue;
    return !0;
  }
}
function yM(n) {
  return J1(n);
}
const g8 = Fa ? "metaKey" : "ctrlKey";
Ni.mousedown = (n, e) => {
  let t = e;
  n.input.shiftKey = t.shiftKey;
  let r = yM(n), i = Date.now(), a = "singleClick";
  i - n.input.lastClick.time < 500 && Jce(t, n.input.lastClick) && !t[g8] && n.input.lastClick.button == t.button && (n.input.lastClick.type == "singleClick" ? a = "doubleClick" : n.input.lastClick.type == "doubleClick" && (a = "tripleClick")), n.input.lastClick = { time: i, x: t.clientX, y: t.clientY, type: a, button: t.button };
  let o = n.posAtCoords(xx(t));
  o && (a == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new ade(n, o, t, !!r)) : (a == "doubleClick" ? nde : rde)(n, o.pos, o.inside, t) ? t.preventDefault() : lu(n, "pointer"));
};
class ade {
  constructor(e, t, r, i) {
    this.view = e, this.pos = t, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[g8], this.allowDefault = r.shiftKey;
    let a, o;
    if (t.inside > -1)
      a = e.state.doc.nodeAt(t.inside), o = t.inside;
    else {
      let c = e.state.doc.resolve(t.pos);
      a = c.parent, o = c.depth ? c.before() : 0;
    }
    const s = i ? null : r.target, l = s ? e.docView.nearestDesc(s, !0) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: u } = e.state;
    (r.button == 0 && a.type.spec.draggable && a.type.spec.selectable !== !1 || u instanceof Ct && u.from <= o && u.to > o) && (this.mightDrag = {
      node: a,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && ko && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), lu(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => ll(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let t = this.pos;
    this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(xx(e))), this.updateAllowDefault(e), this.allowDefault || !t ? lu(this.view, "pointer") : tde(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    Li && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    di && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (mp(this.view, It.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : lu(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), lu(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
Ni.touchstart = (n) => {
  n.input.lastTouch = Date.now(), yM(n), lu(n, "pointer");
};
Ni.touchmove = (n) => {
  n.input.lastTouch = Date.now(), lu(n, "pointer");
};
Ni.contextmenu = (n) => yM(n);
function y8(n, e) {
  return n.composing ? !0 : Li && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, !0) : !1;
}
const ode = Js ? 5e3 : -1;
Ri.compositionstart = Ri.compositionupdate = (n) => {
  if (!n.composing) {
    n.domObserver.flush();
    let { state: e } = n, t = e.selection.$to;
    if (e.selection instanceof Dt && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      n.markCursor = n.state.storedMarks || t.marks(), J1(n, !0), n.markCursor = null;
    else if (J1(n, !e.selection.empty), ko && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
      let r = n.domSelectionRange();
      for (let i = r.focusNode, a = r.focusOffset; i && i.nodeType == 1 && a != 0; ) {
        let o = a < 0 ? i.lastChild : i.childNodes[a - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          let s = n.domSelection();
          s && s.collapse(o, o.nodeValue.length);
          break;
        } else
          i = o, a = -1;
      }
    }
    n.input.composing = !0;
  }
  b8(n, ode);
};
Ri.compositionend = (n, e) => {
  n.composing && (n.input.composing = !1, n.input.compositionEndedAt = e.timeStamp, n.input.compositionPendingChanges = n.domObserver.pendingRecords().length ? n.input.compositionID : 0, n.input.compositionNode = null, n.input.compositionPendingChanges && Promise.resolve().then(() => n.domObserver.flush()), n.input.compositionID++, b8(n, 20));
};
function b8(n, e) {
  clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => J1(n), e));
}
function _8(n) {
  for (n.composing && (n.input.composing = !1, n.input.compositionEndedAt = lde()); n.input.compositionNodes.length > 0; )
    n.input.compositionNodes.pop().markParentsDirty();
}
function sde(n) {
  let e = n.domSelectionRange();
  if (!e.focusNode)
    return null;
  let t = Que(e.focusNode, e.focusOffset), r = ece(e.focusNode, e.focusOffset);
  if (t && r && t != r) {
    let i = r.pmViewDesc, a = n.domObserver.lastChangedTextNode;
    if (t == a || r == a)
      return a;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (n.input.compositionNode == r) {
      let o = t.pmViewDesc;
      if (!(!o || !o.isText(t.nodeValue)))
        return r;
    }
  }
  return t || r;
}
function lde() {
  let n = document.createEvent("Event");
  return n.initEvent("event", !0, !0), n.timeStamp;
}
function J1(n, e = !1) {
  if (!(Js && n.domObserver.flushingSoon >= 0)) {
    if (n.domObserver.forceFlush(), _8(n), e || n.docView && n.docView.dirty) {
      let t = pM(n), r = n.state.selection;
      return t && !t.eq(r) ? n.dispatch(n.state.tr.setSelection(t)) : (n.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? n.dispatch(n.state.tr.deleteSelection()) : n.updateState(n.state), !0;
    }
    return !1;
  }
}
function ude(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.dom.parentNode.appendChild(document.createElement("div"));
  t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), n.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    t.parentNode && t.parentNode.removeChild(t), n.focus();
  }, 50);
}
const Om = Ji && xu < 15 || Ap && ace < 604;
Ni.copy = Ri.cut = (n, e) => {
  let t = e, r = n.state.selection, i = t.type == "cut";
  if (r.empty)
    return;
  let a = Om ? null : t.clipboardData, o = r.content(), { dom: s, text: l } = vM(n, o);
  a ? (t.preventDefault(), a.clearData(), a.setData("text/html", s.innerHTML), a.setData("text/plain", l)) : ude(n, s), i && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function cde(n) {
  return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null;
}
function dde(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, r = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
  t || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = n.input.shiftKey && n.input.lastKeyCode != 45;
  setTimeout(() => {
    n.focus(), r.parentNode && r.parentNode.removeChild(r), t ? Im(n, r.value, null, i, e) : Im(n, r.textContent, r.innerHTML, i, e);
  }, 50);
}
function Im(n, e, t, r, i) {
  let a = d8(n, e, t, r, n.state.selection.$from);
  if (n.someProp("handlePaste", (l) => l(n, i, a || nt.empty)))
    return !0;
  if (!a)
    return !1;
  let o = cde(a), s = o ? n.state.tr.replaceSelectionWith(o, r) : n.state.tr.replaceSelection(a);
  return n.dispatch(s.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function x8(n) {
  let e = n.getData("text/plain") || n.getData("Text");
  if (e)
    return e;
  let t = n.getData("text/uri-list");
  return t ? t.replace(/\r?\n/g, " ") : "";
}
Ri.paste = (n, e) => {
  let t = e;
  if (n.composing && !Js)
    return;
  let r = Om ? null : t.clipboardData, i = n.input.shiftKey && n.input.lastKeyCode != 45;
  r && Im(n, x8(r), r.getData("text/html"), i, t) ? t.preventDefault() : dde(n, t);
};
class w8 {
  constructor(e, t, r) {
    this.slice = e, this.move = t, this.node = r;
  }
}
const fde = Fa ? "altKey" : "ctrlKey";
function S8(n, e) {
  let t = n.someProp("dragCopies", (r) => !r(e));
  return t ?? !e[fde];
}
Ni.dragstart = (n, e) => {
  let t = e, r = n.input.mouseDown;
  if (r && r.done(), !t.dataTransfer)
    return;
  let i = n.state.selection, a = i.empty ? null : n.posAtCoords(xx(t)), o;
  if (!(a && a.pos >= i.from && a.pos <= (i instanceof Ct ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      o = Ct.create(n.state.doc, r.mightDrag.pos);
    else if (t.target && t.target.nodeType == 1) {
      let d = n.docView.nearestDesc(t.target, !0);
      d && d.node.type.spec.draggable && d != n.docView && (o = Ct.create(n.state.doc, d.posBefore));
    }
  }
  let s = (o || n.state.selection).content(), { dom: l, text: u, slice: c } = vM(n, s);
  (!t.dataTransfer.files.length || !di || K6 > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(Om ? "Text" : "text/html", l.innerHTML), t.dataTransfer.effectAllowed = "copyMove", Om || t.dataTransfer.setData("text/plain", u), n.dragging = new w8(c, S8(n, t), o);
};
Ni.dragend = (n) => {
  let e = n.dragging;
  window.setTimeout(() => {
    n.dragging == e && (n.dragging = null);
  }, 50);
};
Ri.dragover = Ri.dragenter = (n, e) => e.preventDefault();
Ri.drop = (n, e) => {
  let t = e, r = n.dragging;
  if (n.dragging = null, !t.dataTransfer)
    return;
  let i = n.posAtCoords(xx(t));
  if (!i)
    return;
  let a = n.state.doc.resolve(i.pos), o = r && r.slice;
  o ? n.someProp("transformPasted", (h) => {
    o = h(o, n);
  }) : o = d8(n, x8(t.dataTransfer), Om ? null : t.dataTransfer.getData("text/html"), !1, a);
  let s = !!(r && S8(n, t));
  if (n.someProp("handleDrop", (h) => h(n, t, o || nt.empty, s))) {
    t.preventDefault();
    return;
  }
  if (!o)
    return;
  t.preventDefault();
  let l = o ? z6(n.state.doc, a.pos, o) : a.pos;
  l == null && (l = a.pos);
  let u = n.state.tr;
  if (s) {
    let { node: h } = r;
    h ? h.replace(u) : u.deleteSelection();
  }
  let c = u.mapping.map(l), d = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, f = u.doc;
  if (d ? u.replaceRangeWith(c, c, o.content.firstChild) : u.replaceRange(c, c, o), u.doc.eq(f))
    return;
  let p = u.doc.resolve(c);
  if (d && Ct.isSelectable(o.content.firstChild) && p.nodeAfter && p.nodeAfter.sameMarkup(o.content.firstChild))
    u.setSelection(new Ct(p));
  else {
    let h = u.mapping.map(l);
    u.mapping.maps[u.mapping.maps.length - 1].forEach((v, m, g, y) => h = y), u.setSelection(hM(n, p, u.doc.resolve(h)));
  }
  n.focus(), n.dispatch(u.setMeta("uiEvent", "drop"));
};
Ni.focus = (n) => {
  n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = !0, setTimeout(() => {
    n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && ll(n);
  }, 20));
};
Ni.blur = (n, e) => {
  let t = e;
  n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = !1);
};
Ni.beforeinput = (n, e) => {
  if (di && Js && e.inputType == "deleteContentBackward") {
    n.domObserver.flushSoon();
    let { domChangeCount: r } = n.input;
    setTimeout(() => {
      if (n.input.domChangeCount != r || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", (a) => a(n, Oc(8, "Backspace")))))
        return;
      let { $cursor: i } = n.state.selection;
      i && i.pos > 0 && n.dispatch(n.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let n in Ri)
  Ni[n] = Ri[n];
function Lm(n, e) {
  if (n == e)
    return !0;
  for (let t in n)
    if (n[t] !== e[t])
      return !1;
  for (let t in e)
    if (!(t in n))
      return !1;
  return !0;
}
class Q1 {
  constructor(e, t) {
    this.toDOM = e, this.spec = t || nd, this.side = this.spec.side || 0;
  }
  map(e, t, r, i) {
    let { pos: a, deleted: o } = e.mapResult(t.from + i, this.side < 0 ? -1 : 1);
    return o ? null : new zr(a - r, a - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof Q1 && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Lm(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Su {
  constructor(e, t) {
    this.attrs = e, this.spec = t || nd;
  }
  map(e, t, r, i) {
    let a = e.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return a >= o ? null : new zr(a, o, this);
  }
  valid(e, t) {
    return t.from < t.to;
  }
  eq(e) {
    return this == e || e instanceof Su && Lm(this.attrs, e.attrs) && Lm(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Su;
  }
  destroy() {
  }
}
class bM {
  constructor(e, t) {
    this.attrs = e, this.spec = t || nd;
  }
  map(e, t, r, i) {
    let a = e.mapResult(t.from + i, 1);
    if (a.deleted)
      return null;
    let o = e.mapResult(t.to + i, -1);
    return o.deleted || o.pos <= a.pos ? null : new zr(a.pos - r, o.pos - r, this);
  }
  valid(e, t) {
    let { index: r, offset: i } = e.content.findIndex(t.from), a;
    return i == t.from && !(a = e.child(r)).isText && i + a.nodeSize == t.to;
  }
  eq(e) {
    return this == e || e instanceof bM && Lm(this.attrs, e.attrs) && Lm(this.spec, e.spec);
  }
  destroy() {
  }
}
class zr {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.type = r;
  }
  /**
  @internal
  */
  copy(e, t) {
    return new zr(e, t, this.type);
  }
  /**
  @internal
  */
  eq(e, t = 0) {
    return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
  }
  /**
  @internal
  */
  map(e, t, r) {
    return this.type.map(e, this, t, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, t, r) {
    return new zr(e, e, new Q1(t, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, t, r, i) {
    return new zr(e, t, new Su(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, t, r, i) {
    return new zr(e, t, new bM(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Su;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof Q1;
  }
}
const Wf = [], nd = {};
class Zn {
  /**
  @internal
  */
  constructor(e, t) {
    this.local = e.length ? e : Wf, this.children = t.length ? t : Wf;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, t) {
    return t.length ? eb(t, e, 0, nd) : si;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, t, r) {
    let i = [];
    return this.findInner(e ?? 0, t ?? 1e9, i, 0, r), i;
  }
  findInner(e, t, r, i, a) {
    for (let o = 0; o < this.local.length; o++) {
      let s = this.local[o];
      s.from <= t && s.to >= e && (!a || a(s.spec)) && r.push(s.copy(s.from + i, s.to + i));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < t && this.children[o + 1] > e) {
        let s = this.children[o] + 1;
        this.children[o + 2].findInner(e - s, t - s, r, i + s, a);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, t, r) {
    return this == si || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, r || nd);
  }
  /**
  @internal
  */
  mapInner(e, t, r, i, a) {
    let o;
    for (let s = 0; s < this.local.length; s++) {
      let l = this.local[s].map(e, r, i);
      l && l.type.valid(t, l) ? (o || (o = [])).push(l) : a.onRemove && a.onRemove(this.local[s].spec);
    }
    return this.children.length ? pde(this.children, o || [], e, t, r, i, a) : o ? new Zn(o.sort(rd), Wf) : si;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, t) {
    return t.length ? this == si ? Zn.create(e, t) : this.addInner(e, t, 0) : this;
  }
  addInner(e, t, r) {
    let i, a = 0;
    e.forEach((s, l) => {
      let u = l + r, c;
      if (c = T8(t, s, u)) {
        for (i || (i = this.children.slice()); a < i.length && i[a] < l; )
          a += 3;
        i[a] == l ? i[a + 2] = i[a + 2].addInner(s, c, u + 1) : i.splice(a, 0, l, l + s.nodeSize, eb(c, s, u + 1, nd)), a += 3;
      }
    });
    let o = E8(a ? C8(t) : t, -r);
    for (let s = 0; s < o.length; s++)
      o[s].type.valid(e, o[s]) || o.splice(s--, 1);
    return new Zn(o.length ? this.local.concat(o).sort(rd) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == si ? this : this.removeInner(e, 0);
  }
  removeInner(e, t) {
    let r = this.children, i = this.local;
    for (let a = 0; a < r.length; a += 3) {
      let o, s = r[a] + t, l = r[a + 1] + t;
      for (let c = 0, d; c < e.length; c++)
        (d = e[c]) && d.from > s && d.to < l && (e[c] = null, (o || (o = [])).push(d));
      if (!o)
        continue;
      r == this.children && (r = this.children.slice());
      let u = r[a + 2].removeInner(o, s + 1);
      u != si ? r[a + 2] = u : (r.splice(a, 3), a -= 3);
    }
    if (i.length) {
      for (let a = 0, o; a < e.length; a++)
        if (o = e[a])
          for (let s = 0; s < i.length; s++)
            i[s].eq(o, t) && (i == this.local && (i = this.local.slice()), i.splice(s--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new Zn(i, r) : si;
  }
  forChild(e, t) {
    if (this == si)
      return this;
    if (t.isLeaf)
      return Zn.empty;
    let r, i;
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] >= e) {
        this.children[s] == e && (r = this.children[s + 2]);
        break;
      }
    let a = e + 1, o = a + t.content.size;
    for (let s = 0; s < this.local.length; s++) {
      let l = this.local[s];
      if (l.from < o && l.to > a && l.type instanceof Su) {
        let u = Math.max(a, l.from) - a, c = Math.min(o, l.to) - a;
        u < c && (i || (i = [])).push(l.copy(u, c));
      }
    }
    if (i) {
      let s = new Zn(i.sort(rd), Wf);
      return r ? new ru([s, r]) : s;
    }
    return r || si;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Zn) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let t = 0; t < this.local.length; t++)
      if (!this.local[t].eq(e.local[t]))
        return !1;
    for (let t = 0; t < this.children.length; t += 3)
      if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return _M(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == si)
      return Wf;
    if (e.inlineContent || !this.local.some(Su.is))
      return this.local;
    let t = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof Su || t.push(this.local[r]);
    return t;
  }
  forEachSet(e) {
    e(this);
  }
}
Zn.empty = new Zn([], []);
Zn.removeOverlap = _M;
const si = Zn.empty;
class ru {
  constructor(e) {
    this.members = e;
  }
  map(e, t) {
    const r = this.members.map((i) => i.map(e, t, nd));
    return ru.from(r);
  }
  forChild(e, t) {
    if (t.isLeaf)
      return Zn.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let a = this.members[i].forChild(e, t);
      a != si && (a instanceof ru ? r = r.concat(a.members) : r.push(a));
    }
    return ru.from(r);
  }
  eq(e) {
    if (!(e instanceof ru) || e.members.length != this.members.length)
      return !1;
    for (let t = 0; t < this.members.length; t++)
      if (!this.members[t].eq(e.members[t]))
        return !1;
    return !0;
  }
  locals(e) {
    let t, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let a = this.members[i].localsInner(e);
      if (a.length)
        if (!t)
          t = a;
        else {
          r && (t = t.slice(), r = !1);
          for (let o = 0; o < a.length; o++)
            t.push(a[o]);
        }
    }
    return t ? _M(r ? t : t.sort(rd)) : Wf;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return si;
      case 1:
        return e[0];
      default:
        return new ru(e.every((t) => t instanceof Zn) ? e : e.reduce((t, r) => t.concat(r instanceof Zn ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let t = 0; t < this.members.length; t++)
      this.members[t].forEachSet(e);
  }
}
function pde(n, e, t, r, i, a, o) {
  let s = n.slice();
  for (let u = 0, c = a; u < t.maps.length; u++) {
    let d = 0;
    t.maps[u].forEach((f, p, h, v) => {
      let m = v - h - (p - f);
      for (let g = 0; g < s.length; g += 3) {
        let y = s[g + 1];
        if (y < 0 || f > y + c - d)
          continue;
        let b = s[g] + c - d;
        p >= b ? s[g + 1] = f <= b ? -2 : -1 : f >= c && m && (s[g] += m, s[g + 1] += m);
      }
      d += m;
    }), c = t.maps[u].map(c, -1);
  }
  let l = !1;
  for (let u = 0; u < s.length; u += 3)
    if (s[u + 1] < 0) {
      if (s[u + 1] == -2) {
        l = !0, s[u + 1] = -1;
        continue;
      }
      let c = t.map(n[u] + a), d = c - i;
      if (d < 0 || d >= r.content.size) {
        l = !0;
        continue;
      }
      let f = t.map(n[u + 1] + a, -1), p = f - i, { index: h, offset: v } = r.content.findIndex(d), m = r.maybeChild(h);
      if (m && v == d && v + m.nodeSize == p) {
        let g = s[u + 2].mapInner(t, m, c + 1, n[u] + a + 1, o);
        g != si ? (s[u] = d, s[u + 1] = p, s[u + 2] = g) : (s[u + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let u = hde(s, n, e, t, i, a, o), c = eb(u, r, 0, o);
    e = c.local;
    for (let d = 0; d < s.length; d += 3)
      s[d + 1] < 0 && (s.splice(d, 3), d -= 3);
    for (let d = 0, f = 0; d < c.children.length; d += 3) {
      let p = c.children[d];
      for (; f < s.length && s[f] < p; )
        f += 3;
      s.splice(f, 0, c.children[d], c.children[d + 1], c.children[d + 2]);
    }
  }
  return new Zn(e.sort(rd), s);
}
function E8(n, e) {
  if (!e || !n.length)
    return n;
  let t = [];
  for (let r = 0; r < n.length; r++) {
    let i = n[r];
    t.push(new zr(i.from + e, i.to + e, i.type));
  }
  return t;
}
function hde(n, e, t, r, i, a, o) {
  function s(l, u) {
    for (let c = 0; c < l.local.length; c++) {
      let d = l.local[c].map(r, i, u);
      d ? t.push(d) : o.onRemove && o.onRemove(l.local[c].spec);
    }
    for (let c = 0; c < l.children.length; c += 3)
      s(l.children[c + 2], l.children[c] + u + 1);
  }
  for (let l = 0; l < n.length; l += 3)
    n[l + 1] == -1 && s(n[l + 2], e[l] + a + 1);
  return t;
}
function T8(n, e, t) {
  if (e.isLeaf)
    return null;
  let r = t + e.nodeSize, i = null;
  for (let a = 0, o; a < n.length; a++)
    (o = n[a]) && o.from > t && o.to < r && ((i || (i = [])).push(o), n[a] = null);
  return i;
}
function C8(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    n[t] != null && e.push(n[t]);
  return e;
}
function eb(n, e, t, r) {
  let i = [], a = !1;
  e.forEach((s, l) => {
    let u = T8(n, s, l + t);
    if (u) {
      a = !0;
      let c = eb(u, s, t + l + 1, r);
      c != si && i.push(l, l + s.nodeSize, c);
    }
  });
  let o = E8(a ? C8(n) : n, -t).sort(rd);
  for (let s = 0; s < o.length; s++)
    o[s].type.valid(e, o[s]) || (r.onRemove && r.onRemove(o[s].spec), o.splice(s--, 1));
  return o.length || i.length ? new Zn(o, i) : si;
}
function rd(n, e) {
  return n.from - e.from || n.to - e.to;
}
function _M(n) {
  let e = n;
  for (let t = 0; t < e.length - 1; t++) {
    let r = e[t];
    if (r.from != r.to)
      for (let i = t + 1; i < e.length; i++) {
        let a = e[i];
        if (a.from == r.from) {
          a.to != r.to && (e == n && (e = n.slice()), e[i] = a.copy(a.from, r.to), MN(e, i + 1, a.copy(r.to, a.to)));
          continue;
        } else {
          a.from < r.to && (e == n && (e = n.slice()), e[t] = r.copy(r.from, a.from), MN(e, i, r.copy(a.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function MN(n, e, t) {
  for (; e < n.length && rd(t, n[e]) > 0; )
    e++;
  n.splice(e, 0, t);
}
function dS(n) {
  let e = [];
  return n.someProp("decorations", (t) => {
    let r = t(n.state);
    r && r != si && e.push(r);
  }), n.cursorWrapper && e.push(Zn.create(n.state.doc, [n.cursorWrapper.deco])), ru.from(e);
}
const vde = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, mde = Ji && xu <= 11;
class gde {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class yde {
  constructor(e, t) {
    this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new gde(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      Ji && xu <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), mde && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, vde)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let t = 0; t < e.length; t++)
          this.queue.push(e[t]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (xN(this.view)) {
      if (this.suppressingSelectionUpdates)
        return ll(this.view);
      if (Ji && xu <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Sd(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let t = /* @__PURE__ */ new Set(), r;
    for (let a = e.focusNode; a; a = kp(a))
      t.add(a);
    for (let a = e.anchorNode; a; a = kp(a))
      if (t.has(a)) {
        r = a;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && xN(e) && !this.ignoreSelectionChange(r), a = -1, o = -1, s = !1, l = [];
    if (e.editable)
      for (let c = 0; c < t.length; c++) {
        let d = this.registerMutation(t[c], l);
        d && (a = a < 0 ? d.from : Math.min(d.from, a), o = o < 0 ? d.to : Math.max(d.to, o), d.typeOver && (s = !0));
      }
    if (ko && l.length) {
      let c = l.filter((d) => d.nodeName == "BR");
      if (c.length == 2) {
        let [d, f] = c;
        d.parentNode && d.parentNode.parentNode == f.parentNode ? f.remove() : d.remove();
      } else {
        let { focusNode: d } = this.currentSelection;
        for (let f of c) {
          let p = f.parentNode;
          p && p.nodeName == "LI" && (!d || xde(e, d) != p) && f.remove();
        }
      }
    }
    let u = null;
    a < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && bx(r) && (u = pM(e)) && u.eq(It.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, ll(e), this.currentSelection.set(r), e.scrollToSelection()) : (a > -1 || i) && (a > -1 && (e.docView.markDirty(a, o), bde(e)), this.handleDOMChange(a, o, s, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || ll(e), this.currentSelection.set(r));
  }
  registerMutation(e, t) {
    if (t.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let c = 0; c < e.addedNodes.length; c++) {
        let d = e.addedNodes[c];
        t.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, a = e.nextSibling;
      if (Ji && xu <= 11 && e.addedNodes.length)
        for (let c = 0; c < e.addedNodes.length; c++) {
          let { previousSibling: d, nextSibling: f } = e.addedNodes[c];
          (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (i = d), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (a = f);
        }
      let o = i && i.parentNode == e.target ? Kr(i) + 1 : 0, s = r.localPosFromDOM(e.target, o, -1), l = a && a.parentNode == e.target ? Kr(a) : e.target.childNodes.length, u = r.localPosFromDOM(e.target, l, 1);
      return { from: s, to: u };
    } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let DN = /* @__PURE__ */ new WeakMap(), ON = !1;
function bde(n) {
  if (!DN.has(n) && (DN.set(n, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) {
    if (n.requiresGeckoHackNode = ko, ON)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), ON = !0;
  }
}
function IN(n, e) {
  let t = e.startContainer, r = e.startOffset, i = e.endContainer, a = e.endOffset, o = n.domAtPos(n.state.selection.anchor);
  return Sd(o.node, o.offset, i, a) && ([t, r, i, a] = [i, a, t, r]), { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: a };
}
function _de(n, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(n.root)[0];
    if (i)
      return IN(n, i);
  }
  let t;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0];
  }
  return n.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", r, !0), t ? IN(n, t) : null;
}
function xde(n, e) {
  for (let t = e.parentNode; t && t != n.dom; t = t.parentNode) {
    let r = n.docView.nearestDesc(t, !0);
    if (r && r.node.isBlock)
      return t;
  }
  return null;
}
function wde(n, e, t) {
  let { node: r, fromOffset: i, toOffset: a, from: o, to: s } = n.docView.parseRange(e, t), l = n.domSelectionRange(), u, c = l.anchorNode;
  if (c && n.dom.contains(c.nodeType == 1 ? c : c.parentNode) && (u = [{ node: c, offset: l.anchorOffset }], bx(l) || u.push({ node: l.focusNode, offset: l.focusOffset })), di && n.input.lastKeyCode === 8)
    for (let m = a; m > i; m--) {
      let g = r.childNodes[m - 1], y = g.pmViewDesc;
      if (g.nodeName == "BR" && !y) {
        a = m;
        break;
      }
      if (!y || y.size)
        break;
    }
  let d = n.state.doc, f = n.someProp("domParser") || hp.fromSchema(n.state.schema), p = d.resolve(o), h = null, v = f.parse(r, {
    topNode: p.parent,
    topMatch: p.parent.contentMatchAt(p.index()),
    topOpen: !0,
    from: i,
    to: a,
    preserveWhitespace: p.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: u,
    ruleFromNode: Sde,
    context: p
  });
  if (u && u[0].pos != null) {
    let m = u[0].pos, g = u[1] && u[1].pos;
    g == null && (g = m), h = { anchor: m + o, head: g + o };
  }
  return { doc: v, sel: h, from: o, to: s };
}
function Sde(n) {
  let e = n.pmViewDesc;
  if (e)
    return e.parseRule();
  if (n.nodeName == "BR" && n.parentNode) {
    if (Li && /^(ul|ol)$/i.test(n.parentNode.nodeName)) {
      let t = document.createElement("div");
      return t.appendChild(document.createElement("li")), { skip: t };
    } else if (n.parentNode.lastChild == n || Li && /^(tr|table)$/i.test(n.parentNode.nodeName))
      return { ignore: !0 };
  } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const Ede = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function Tde(n, e, t, r, i) {
  let a = n.input.compositionPendingChanges || (n.composing ? n.input.compositionID : 0);
  if (n.input.compositionPendingChanges = 0, e < 0) {
    let C = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, k = pM(n, C);
    if (k && !n.state.selection.eq(k)) {
      if (di && Js && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", (D) => D(n, Oc(13, "Enter"))))
        return;
      let M = n.state.tr.setSelection(k);
      C == "pointer" ? M.setMeta("pointer", !0) : C == "key" && M.scrollIntoView(), a && M.setMeta("composition", a), n.dispatch(M);
    }
    return;
  }
  let o = n.state.doc.resolve(e), s = o.sharedDepth(t);
  e = o.before(s + 1), t = n.state.doc.resolve(t).after(s + 1);
  let l = n.state.selection, u = wde(n, e, t), c = n.state.doc, d = c.slice(u.from, u.to), f, p;
  n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (f = n.state.selection.to, p = "end") : (f = n.state.selection.from, p = "start"), n.input.lastKeyCode = null;
  let h = Ade(d.content, u.doc.content, u.from, f, p);
  if (h && n.input.domChangeCount++, (Ap && n.input.lastIOSEnter > Date.now() - 225 || Js) && i.some((C) => C.nodeType == 1 && !Ede.test(C.nodeName)) && (!h || h.endA >= h.endB) && n.someProp("handleKeyDown", (C) => C(n, Oc(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (!h)
    if (r && l instanceof Dt && !l.empty && l.$head.sameParent(l.$anchor) && !n.composing && !(u.sel && u.sel.anchor != u.sel.head))
      h = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (u.sel) {
        let C = LN(n, n.state.doc, u.sel);
        if (C && !C.eq(n.state.selection)) {
          let k = n.state.tr.setSelection(C);
          a && k.setMeta("composition", a), n.dispatch(k);
        }
      }
      return;
    }
  n.state.selection.from < n.state.selection.to && h.start == h.endB && n.state.selection instanceof Dt && (h.start > n.state.selection.from && h.start <= n.state.selection.from + 2 && n.state.selection.from >= u.from ? h.start = n.state.selection.from : h.endA < n.state.selection.to && h.endA >= n.state.selection.to - 2 && n.state.selection.to <= u.to && (h.endB += n.state.selection.to - h.endA, h.endA = n.state.selection.to)), Ji && xu <= 11 && h.endB == h.start + 1 && h.endA == h.start && h.start > u.from && u.doc.textBetween(h.start - u.from - 1, h.start - u.from + 1) == "  " && (h.start--, h.endA--, h.endB--);
  let v = u.doc.resolveNoCache(h.start - u.from), m = u.doc.resolveNoCache(h.endB - u.from), g = c.resolve(h.start), y = v.sameParent(m) && v.parent.inlineContent && g.end() >= h.endA, b;
  if ((Ap && n.input.lastIOSEnter > Date.now() - 225 && (!y || i.some((C) => C.nodeName == "DIV" || C.nodeName == "P")) || !y && v.pos < u.doc.content.size && (!v.sameParent(m) || !v.parent.inlineContent) && !/\S/.test(u.doc.textBetween(v.pos, m.pos, "", "")) && (b = It.findFrom(u.doc.resolve(v.pos + 1), 1, !0)) && b.head > v.pos) && n.someProp("handleKeyDown", (C) => C(n, Oc(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (n.state.selection.anchor > h.start && kde(c, h.start, h.endA, v, m) && n.someProp("handleKeyDown", (C) => C(n, Oc(8, "Backspace")))) {
    Js && di && n.domObserver.suppressSelectionUpdates();
    return;
  }
  di && h.endB == h.start && (n.input.lastChromeDelete = Date.now()), Js && !y && v.start() != m.start() && m.parentOffset == 0 && v.depth == m.depth && u.sel && u.sel.anchor == u.sel.head && u.sel.head == h.endA && (h.endB -= 2, m = u.doc.resolveNoCache(h.endB - u.from), setTimeout(() => {
    n.someProp("handleKeyDown", function(C) {
      return C(n, Oc(13, "Enter"));
    });
  }, 20));
  let _ = h.start, x = h.endA, w = (C) => {
    let k = C || n.state.tr.replace(_, x, u.doc.slice(h.start - u.from, h.endB - u.from));
    if (u.sel) {
      let M = LN(n, k.doc, u.sel);
      M && !(di && n.composing && M.empty && (h.start != h.endB || n.input.lastChromeDelete < Date.now() - 100) && (M.head == _ || M.head == k.mapping.map(x) - 1) || Ji && M.empty && M.head == _) && k.setSelection(M);
    }
    return a && k.setMeta("composition", a), k.scrollIntoView();
  }, S;
  if (y) {
    if (v.pos == m.pos) {
      Ji && xu <= 11 && v.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => ll(n), 20));
      let C = w(n.state.tr.delete(_, x)), k = c.resolve(h.start).marksAcross(c.resolve(h.endA));
      k && C.ensureMarks(k), n.dispatch(C);
    } else if (
      // Adding or removing a mark
      h.endA == h.endB && (S = Cde(v.parent.content.cut(v.parentOffset, m.parentOffset), g.parent.content.cut(g.parentOffset, h.endA - g.start())))
    ) {
      let C = w(n.state.tr);
      S.type == "add" ? C.addMark(_, x, S.mark) : C.removeMark(_, x, S.mark), n.dispatch(C);
    } else if (v.parent.child(v.index()).isText && v.index() == m.index() - (m.textOffset ? 0 : 1)) {
      let C = v.parent.textBetween(v.parentOffset, m.parentOffset), k = () => w(n.state.tr.insertText(C, _, x));
      n.someProp("handleTextInput", (M) => M(n, _, x, C, k)) || n.dispatch(k());
    }
  } else
    n.dispatch(w());
}
function LN(n, e, t) {
  return Math.max(t.anchor, t.head) > e.content.size ? null : hM(n, e.resolve(t.anchor), e.resolve(t.head));
}
function Cde(n, e) {
  let t = n.firstChild.marks, r = e.firstChild.marks, i = t, a = r, o, s, l;
  for (let c = 0; c < r.length; c++)
    i = r[c].removeFromSet(i);
  for (let c = 0; c < t.length; c++)
    a = t[c].removeFromSet(a);
  if (i.length == 1 && a.length == 0)
    s = i[0], o = "add", l = (c) => c.mark(s.addToSet(c.marks));
  else if (i.length == 0 && a.length == 1)
    s = a[0], o = "remove", l = (c) => c.mark(s.removeFromSet(c.marks));
  else
    return null;
  let u = [];
  for (let c = 0; c < e.childCount; c++)
    u.push(l(e.child(c)));
  if ($e.from(u).eq(n))
    return { mark: s, type: o };
}
function kde(n, e, t, r, i) {
  if (
    // The content must have shrunk
    t - e <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    fS(r, !0, !1) < i.pos
  )
    return !1;
  let a = n.resolve(e);
  if (!r.parent.isTextblock) {
    let s = a.nodeAfter;
    return s != null && t == e + s.nodeSize;
  }
  if (a.parentOffset < a.parent.content.size || !a.parent.isTextblock)
    return !1;
  let o = n.resolve(fS(a, !0, !0));
  return !o.parent.isTextblock || o.pos > t || fS(o, !0, !1) < t ? !1 : r.parent.content.cut(r.parentOffset).eq(o.parent.content);
}
function fS(n, e, t) {
  let r = n.depth, i = e ? n.end() : n.pos;
  for (; r > 0 && (e || n.indexAfter(r) == n.node(r).childCount); )
    r--, i++, e = !1;
  if (t) {
    let a = n.node(r).maybeChild(n.indexAfter(r));
    for (; a && !a.isLeaf; )
      a = a.firstChild, i++;
  }
  return i;
}
function Ade(n, e, t, r, i) {
  let a = n.findDiffStart(e, t);
  if (a == null)
    return null;
  let { a: o, b: s } = n.findDiffEnd(e, t + n.size, t + e.size);
  if (i == "end") {
    let l = Math.max(0, a - Math.min(o, s));
    r -= o + l - a;
  }
  if (o < a && n.size < e.size) {
    let l = r <= a && r >= o ? a - r : 0;
    a -= l, a && a < e.size && NN(e.textBetween(a - 1, a + 1)) && (a += l ? 1 : -1), s = a + (s - o), o = a;
  } else if (s < a) {
    let l = r <= a && r >= s ? a - r : 0;
    a -= l, a && a < n.size && NN(n.textBetween(a - 1, a + 1)) && (a += l ? 1 : -1), o = a + (o - s), s = a;
  }
  return { start: a, endA: o, endB: s };
}
function NN(n) {
  if (n.length != 2)
    return !1;
  let e = n.charCodeAt(0), t = n.charCodeAt(1);
  return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319;
}
class k8 {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, t) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new qce(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach($N), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = jN(this), PN(this), this.nodeViews = BN(this), this.docView = vN(this.state.doc, RN(this), dS(this), this.dom, this), this.domObserver = new yde(this, (r, i, a, o) => Tde(this, r, i, a, o)), this.domObserver.start(), Yce(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let t in e)
        this._props[t] = e[t];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && QT(this);
    let t = this._props;
    this._props = e, e.plugins && (e.plugins.forEach($N), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let t = {};
    for (let r in this._props)
      t[r] = this._props[r];
    t.state = this.state;
    for (let r in e)
      t[r] = e[r];
    this.update(t);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, t) {
    var r;
    let i = this.state, a = !1, o = !1;
    e.storedMarks && this.composing && (_8(this), o = !0), this.state = e;
    let s = i.plugins != e.plugins || this._props.plugins != t.plugins;
    if (s || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
      let p = BN(this);
      Dde(p, this.nodeViews) && (this.nodeViews = p, a = !0);
    }
    (s || t.handleDOMEvents != this._props.handleDOMEvents) && QT(this), this.editable = jN(this), PN(this);
    let l = dS(this), u = RN(this), c = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", d = a || !this.docView.matchesNode(e.doc, u, l);
    (d || !e.selection.eq(i.selection)) && (o = !0);
    let f = c == "preserve" && o && this.dom.style.overflowAnchor == null && lce(this);
    if (o) {
      this.domObserver.stop();
      let p = d && (Ji || di) && !this.composing && !i.selection.empty && !e.selection.empty && Mde(i.selection, e.selection);
      if (d) {
        let h = di ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = sde(this)), (a || !this.docView.update(e.doc, u, l, this)) && (this.docView.updateOuterDeco(u), this.docView.destroy(), this.docView = vN(e.doc, u, l, this.dom, this)), h && !this.trackWrites && (p = !0);
      }
      p || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && Ice(this)) ? ll(this, p) : (l8(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), c == "reset" ? this.dom.scrollTop = 0 : c == "to selection" ? this.scrollToSelection() : f && uce(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (t) => t(this))) if (this.state.selection instanceof Ct) {
        let t = this.docView.domAfterPos(this.state.selection.from);
        t.nodeType == 1 && uN(this, t.getBoundingClientRect(), e);
      } else
        uN(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let t = 0; t < this.directPlugins.length; t++) {
        let r = this.directPlugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let t = 0; t < this.state.plugins.length; t++) {
        let r = this.state.plugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let t = 0; t < this.pluginViews.length; t++) {
        let r = this.pluginViews[t];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, t) {
    let r = e.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let a = r.from + (this.state.doc.content.size - t.doc.content.size);
      (a > 0 && this.state.doc.nodeAt(a)) == r.node && (i = a);
    }
    this.dragging = new w8(e.slice, e.move, i < 0 ? void 0 : Ct.create(this.state.doc, i));
  }
  someProp(e, t) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = t ? t(r) : r))
      return i;
    for (let o = 0; o < this.directPlugins.length; o++) {
      let s = this.directPlugins[o].props[e];
      if (s != null && (i = t ? t(s) : s))
        return i;
    }
    let a = this.state.plugins;
    if (a)
      for (let o = 0; o < a.length; o++) {
        let s = a[o].props[e];
        if (s != null && (i = t ? t(s) : s))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Ji) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && cce(this.dom), ll(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let t = this.dom.parentNode; t; t = t.parentNode)
        if (t.nodeType == 9 || t.nodeType == 11 && t.host)
          return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return vce(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, t = 1) {
    return e8(this, e, t);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, t = 0) {
    return this.docView.domFromPos(e, t);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let t = this.docView.descAt(e);
    return t ? t.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, t, r = -1) {
    let i = this.docView.posFromDOM(e, t, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, t) {
    return _ce(this, t || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, t) {
    return Im(this, "", e, !1, t || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, t) {
    return Im(this, e, null, !0, t || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return vM(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (Kce(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], dS(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, Zue());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return Zce(this, e);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? Li && this.root.nodeType === 11 && nce(this.dom.ownerDocument) == this.dom && _de(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
k8.prototype.dispatch = function(n) {
  let e = this._props.dispatchTransaction;
  e ? e.call(this, n) : this.updateState(this.state.apply(n));
};
function RN(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(n.editable), n.someProp("attributes", (t) => {
    if (typeof t == "function" && (t = t(n.state)), t)
      for (let r in t)
        r == "class" ? e.class += " " + t[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + t[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(t[r]));
  }), e.translate || (e.translate = "no"), [zr.node(0, n.state.doc.content.size, e)];
}
function PN(n) {
  if (n.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = { dom: e, deco: zr.widget(n.state.selection.from, e, { raw: !0, marks: n.markCursor }) };
  } else
    n.cursorWrapper = null;
}
function jN(n) {
  return !n.someProp("editable", (e) => e(n.state) === !1);
}
function Mde(n, e) {
  let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head));
  return n.$anchor.start(t) != e.$anchor.start(t);
}
function BN(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return n.someProp("nodeViews", t), n.someProp("markViews", t), e;
}
function Dde(n, e) {
  let t = 0, r = 0;
  for (let i in n) {
    if (n[i] != e[i])
      return !0;
    t++;
  }
  for (let i in e)
    r++;
  return t != r;
}
function $N(n) {
  if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Ou = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, tb = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, Ode = typeof navigator < "u" && /Mac/.test(navigator.platform), Ide = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Xr = 0; Xr < 10; Xr++) Ou[48 + Xr] = Ou[96 + Xr] = String(Xr);
for (var Xr = 1; Xr <= 24; Xr++) Ou[Xr + 111] = "F" + Xr;
for (var Xr = 65; Xr <= 90; Xr++)
  Ou[Xr] = String.fromCharCode(Xr + 32), tb[Xr] = String.fromCharCode(Xr);
for (var pS in Ou) tb.hasOwnProperty(pS) || (tb[pS] = Ou[pS]);
function Lde(n) {
  var e = Ode && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || Ide && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? tb : Ou)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
const Nde = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), Rde = typeof navigator < "u" && /Win/.test(navigator.platform);
function Pde(n) {
  let e = n.split(/-(?!$)/), t = e[e.length - 1];
  t == "Space" && (t = " ");
  let r, i, a, o;
  for (let s = 0; s < e.length - 1; s++) {
    let l = e[s];
    if (/^(cmd|meta|m)$/i.test(l))
      o = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      a = !0;
    else if (/^mod$/i.test(l))
      Nde ? o = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return r && (t = "Alt-" + t), i && (t = "Ctrl-" + t), o && (t = "Meta-" + t), a && (t = "Shift-" + t), t;
}
function jde(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n)
    e[Pde(t)] = n[t];
  return e;
}
function hS(n, e, t = !0) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t && e.shiftKey && (n = "Shift-" + n), n;
}
function Bde(n) {
  return new Pn({ props: { handleKeyDown: xM(n) } });
}
function xM(n) {
  let e = jde(n);
  return function(t, r) {
    let i = Lde(r), a, o = e[hS(i, r)];
    if (o && o(t.state, t.dispatch, t))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let s = e[hS(i, r, !1)];
        if (s && s(t.state, t.dispatch, t))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(Rde && r.ctrlKey && r.altKey) && (a = Ou[r.keyCode]) && a != i) {
        let s = e[hS(a, r)];
        if (s && s(t.state, t.dispatch, t))
          return !0;
      }
    }
    return !1;
  };
}
const wM = (n, e) => n.selection.empty ? !1 : (e && e(n.tr.deleteSelection().scrollIntoView()), !0);
function A8(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t;
}
const M8 = (n, e, t) => {
  let r = A8(n, t);
  if (!r)
    return !1;
  let i = SM(r);
  if (!i) {
    let o = r.blockRange(), s = o && ih(o);
    return s == null ? !1 : (e && e(n.tr.lift(o, s).scrollIntoView()), !0);
  }
  let a = i.nodeBefore;
  if (B8(n, i, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (Mp(a, "end") || Ct.isSelectable(a)))
    for (let o = r.depth; ; o--) {
      let s = gx(n.doc, r.before(o), r.after(o), nt.empty);
      if (s && s.slice.size < s.to - s.from) {
        if (e) {
          let l = n.tr.step(s);
          l.setSelection(Mp(a, "end") ? It.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1) : Ct.create(l.doc, i.pos - a.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (o == 1 || r.node(o - 1).childCount > 1)
        break;
    }
  return a.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos - a.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, $de = (n, e, t) => {
  let r = A8(n, t);
  if (!r)
    return !1;
  let i = SM(r);
  return i ? D8(n, i, e) : !1;
}, zde = (n, e, t) => {
  let r = I8(n, t);
  if (!r)
    return !1;
  let i = EM(r);
  return i ? D8(n, i, e) : !1;
};
function D8(n, e, t) {
  let r = e.nodeBefore, i = r, a = e.pos - 1;
  for (; !i.isTextblock; a--) {
    if (i.type.spec.isolating)
      return !1;
    let c = i.lastChild;
    if (!c)
      return !1;
    i = c;
  }
  let o = e.nodeAfter, s = o, l = e.pos + 1;
  for (; !s.isTextblock; l++) {
    if (s.type.spec.isolating)
      return !1;
    let c = s.firstChild;
    if (!c)
      return !1;
    s = c;
  }
  let u = gx(n.doc, a, l, nt.empty);
  if (!u || u.from != a || u instanceof $r && u.slice.size >= l - a)
    return !1;
  if (t) {
    let c = n.tr.step(u);
    c.setSelection(Dt.create(c.doc, a)), t(c.scrollIntoView());
  }
  return !0;
}
function Mp(n, e, t = !1) {
  for (let r = n; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (t && r.childCount != 1)
      return !1;
  }
  return !1;
}
const O8 = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, a = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("backward", n) : r.parentOffset > 0)
      return !1;
    a = SM(r);
  }
  let o = a && a.nodeBefore;
  return !o || !Ct.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(Ct.create(n.doc, a.pos - o.nodeSize)).scrollIntoView()), !0);
};
function SM(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      if (n.index(e) > 0)
        return n.doc.resolve(n.before(e + 1));
      if (n.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function I8(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t;
}
const L8 = (n, e, t) => {
  let r = I8(n, t);
  if (!r)
    return !1;
  let i = EM(r);
  if (!i)
    return !1;
  let a = i.nodeAfter;
  if (B8(n, i, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (Mp(a, "start") || Ct.isSelectable(a))) {
    let o = gx(n.doc, r.before(), r.after(), nt.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let s = n.tr.step(o);
        s.setSelection(Mp(a, "start") ? It.findFrom(s.doc.resolve(s.mapping.map(i.pos)), 1) : Ct.create(s.doc, s.mapping.map(i.pos))), e(s.scrollIntoView());
      }
      return !0;
    }
  }
  return a.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos, i.pos + a.nodeSize).scrollIntoView()), !0) : !1;
}, N8 = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, a = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("forward", n) : r.parentOffset < r.parent.content.size)
      return !1;
    a = EM(r);
  }
  let o = a && a.nodeAfter;
  return !o || !Ct.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(Ct.create(n.doc, a.pos)).scrollIntoView()), !0);
};
function EM(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      let t = n.node(e);
      if (n.index(e) + 1 < t.childCount)
        return n.doc.resolve(n.after(e + 1));
      if (t.type.spec.isolating)
        break;
    }
  return null;
}
const Fde = (n, e) => {
  let t = n.selection, r = t instanceof Ct, i;
  if (r) {
    if (t.node.isTextblock || !Hu(n.doc, t.from))
      return !1;
    i = t.from;
  } else if (i = mx(n.doc, t.from, -1), i == null)
    return !1;
  if (e) {
    let a = n.tr.join(i);
    r && a.setSelection(Ct.create(a.doc, i - n.doc.resolve(i).nodeBefore.nodeSize)), e(a.scrollIntoView());
  }
  return !0;
}, Vde = (n, e) => {
  let t = n.selection, r;
  if (t instanceof Ct) {
    if (t.node.isTextblock || !Hu(n.doc, t.to))
      return !1;
    r = t.to;
  } else if (r = mx(n.doc, t.to, 1), r == null)
    return !1;
  return e && e(n.tr.join(r).scrollIntoView()), !0;
}, Hde = (n, e) => {
  let { $from: t, $to: r } = n.selection, i = t.blockRange(r), a = i && ih(i);
  return a == null ? !1 : (e && e(n.tr.lift(i, a).scrollIntoView()), !0);
}, R8 = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  return !t.parent.type.spec.code || !t.sameParent(r) ? !1 : (e && e(n.tr.insertText(`
`).scrollIntoView()), !0);
};
function TM(n) {
  for (let e = 0; e < n.edgeCount; e++) {
    let { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
const Gde = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  if (!t.parent.type.spec.code || !t.sameParent(r))
    return !1;
  let i = t.node(-1), a = t.indexAfter(-1), o = TM(i.contentMatchAt(a));
  if (!o || !i.canReplaceWith(a, a, o))
    return !1;
  if (e) {
    let s = t.after(), l = n.tr.replaceWith(s, s, o.createAndFill());
    l.setSelection(It.near(l.doc.resolve(s), 1)), e(l.scrollIntoView());
  }
  return !0;
}, P8 = (n, e) => {
  let t = n.selection, { $from: r, $to: i } = t;
  if (t instanceof ga || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let a = TM(i.parent.contentMatchAt(i.indexAfter()));
  if (!a || !a.isTextblock)
    return !1;
  if (e) {
    let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, s = n.tr.insert(o, a.createAndFill());
    s.setSelection(Dt.create(s.doc, o + 1)), e(s.scrollIntoView());
  }
  return !0;
}, j8 = (n, e) => {
  let { $cursor: t } = n.selection;
  if (!t || t.parent.content.size)
    return !1;
  if (t.depth > 1 && t.after() != t.end(-1)) {
    let a = t.before();
    if (sl(n.doc, a))
      return e && e(n.tr.split(a).scrollIntoView()), !0;
  }
  let r = t.blockRange(), i = r && ih(r);
  return i == null ? !1 : (e && e(n.tr.lift(r, i).scrollIntoView()), !0);
};
function Ude(n) {
  return (e, t) => {
    let { $from: r, $to: i } = e.selection;
    if (e.selection instanceof Ct && e.selection.node.isBlock)
      return !r.parentOffset || !sl(e.doc, r.pos) ? !1 : (t && t(e.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth)
      return !1;
    let a = [], o, s, l = !1, u = !1;
    for (let p = r.depth; ; p--)
      if (r.node(p).isBlock) {
        l = r.end(p) == r.pos + (r.depth - p), u = r.start(p) == r.pos - (r.depth - p), s = TM(r.node(p - 1).contentMatchAt(r.indexAfter(p - 1))), a.unshift(l && s ? { type: s } : null), o = p;
        break;
      } else {
        if (p == 1)
          return !1;
        a.unshift(null);
      }
    let c = e.tr;
    (e.selection instanceof Dt || e.selection instanceof ga) && c.deleteSelection();
    let d = c.mapping.map(r.pos), f = sl(c.doc, d, a.length, a);
    if (f || (a[0] = s ? { type: s } : null, f = sl(c.doc, d, a.length, a)), !f)
      return !1;
    if (c.split(d, a.length, a), !l && u && r.node(o).type != s) {
      let p = c.mapping.map(r.before(o)), h = c.doc.resolve(p);
      s && r.node(o - 1).canReplaceWith(h.index(), h.index() + 1, s) && c.setNodeMarkup(c.mapping.map(r.before(o)), s);
    }
    return t && t(c.scrollIntoView()), !0;
  };
}
const Wde = Ude(), qde = (n, e) => {
  let { $from: t, to: r } = n.selection, i, a = t.sharedDepth(r);
  return a == 0 ? !1 : (i = t.before(a), e && e(n.tr.setSelection(Ct.create(n.doc, i))), !0);
};
function Yde(n, e, t) {
  let r = e.nodeBefore, i = e.nodeAfter, a = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(a - 1, a) ? (t && t(n.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(a, a + 1) || !(i.isTextblock || Hu(n.doc, e.pos)) ? !1 : (t && t(n.tr.join(e.pos).scrollIntoView()), !0);
}
function B8(n, e, t, r) {
  let i = e.nodeBefore, a = e.nodeAfter, o, s, l = i.type.spec.isolating || a.type.spec.isolating;
  if (!l && Yde(n, e, t))
    return !0;
  let u = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (u && (o = (s = i.contentMatchAt(i.childCount)).findWrapping(a.type)) && s.matchType(o[0] || a.type).validEnd) {
    if (t) {
      let p = e.pos + a.nodeSize, h = $e.empty;
      for (let g = o.length - 1; g >= 0; g--)
        h = $e.from(o[g].create(null, h));
      h = $e.from(i.copy(h));
      let v = n.tr.step(new Vr(e.pos - 1, p, e.pos, p, new nt(h, 1, 0), o.length, !0)), m = v.doc.resolve(p + 2 * o.length);
      m.nodeAfter && m.nodeAfter.type == i.type && Hu(v.doc, m.pos) && v.join(m.pos), t(v.scrollIntoView());
    }
    return !0;
  }
  let c = a.type.spec.isolating || r > 0 && l ? null : It.findFrom(e, 1), d = c && c.$from.blockRange(c.$to), f = d && ih(d);
  if (f != null && f >= e.depth)
    return t && t(n.tr.lift(d, f).scrollIntoView()), !0;
  if (u && Mp(a, "start", !0) && Mp(i, "end")) {
    let p = i, h = [];
    for (; h.push(p), !p.isTextblock; )
      p = p.lastChild;
    let v = a, m = 1;
    for (; !v.isTextblock; v = v.firstChild)
      m++;
    if (p.canReplace(p.childCount, p.childCount, v.content)) {
      if (t) {
        let g = $e.empty;
        for (let b = h.length - 1; b >= 0; b--)
          g = $e.from(h[b].copy(g));
        let y = n.tr.step(new Vr(e.pos - h.length, e.pos + a.nodeSize, e.pos + m, e.pos + a.nodeSize - m, new nt(g, h.length, 0), 0, !0));
        t(y.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function $8(n) {
  return function(e, t) {
    let r = e.selection, i = n < 0 ? r.$from : r.$to, a = i.depth;
    for (; i.node(a).isInline; ) {
      if (!a)
        return !1;
      a--;
    }
    return i.node(a).isTextblock ? (t && t(e.tr.setSelection(Dt.create(e.doc, n < 0 ? i.start(a) : i.end(a)))), !0) : !1;
  };
}
const Kde = $8(-1), Xde = $8(1);
function Zde(n, e = null) {
  return function(t, r) {
    let { $from: i, $to: a } = t.selection, o = i.blockRange(a), s = o && uM(o, n, e);
    return s ? (r && r(t.tr.wrap(o, s).scrollIntoView()), !0) : !1;
  };
}
function zN(n, e = null) {
  return function(t, r) {
    let i = !1;
    for (let a = 0; a < t.selection.ranges.length && !i; a++) {
      let { $from: { pos: o }, $to: { pos: s } } = t.selection.ranges[a];
      t.doc.nodesBetween(o, s, (l, u) => {
        if (i)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(n, e)))
          if (l.type == n)
            i = !0;
          else {
            let c = t.doc.resolve(u), d = c.index();
            i = c.parent.canReplaceWith(d, d + 1, n);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let a = t.tr;
      for (let o = 0; o < t.selection.ranges.length; o++) {
        let { $from: { pos: s }, $to: { pos: l } } = t.selection.ranges[o];
        a.setBlockType(s, l, n, e);
      }
      r(a.scrollIntoView());
    }
    return !0;
  };
}
function CM(...n) {
  return function(e, t, r) {
    for (let i = 0; i < n.length; i++)
      if (n[i](e, t, r))
        return !0;
    return !1;
  };
}
CM(wM, M8, O8);
CM(wM, L8, N8);
CM(R8, P8, j8, Wde);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function Jde(n, e = null) {
  return function(t, r) {
    let { $from: i, $to: a } = t.selection, o = i.blockRange(a);
    if (!o)
      return !1;
    let s = r ? t.tr : null;
    return Qde(s, o, n, e) ? (r && r(s.scrollIntoView()), !0) : !1;
  };
}
function Qde(n, e, t, r = null) {
  let i = !1, a = e, o = e.$from.doc;
  if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(t) && e.startIndex == 0) {
    if (e.$from.index(e.depth - 1) == 0)
      return !1;
    let l = o.resolve(e.start - 2);
    a = new Y1(l, l, e.depth), e.endIndex < e.parent.childCount && (e = new Y1(e.$from, o.resolve(e.$to.end(e.depth)), e.depth)), i = !0;
  }
  let s = uM(a, t, r, e);
  return s ? (n && efe(n, e, s, i, t), !0) : !1;
}
function efe(n, e, t, r, i) {
  let a = $e.empty;
  for (let c = t.length - 1; c >= 0; c--)
    a = $e.from(t[c].type.create(t[c].attrs, a));
  n.step(new Vr(e.start - (r ? 2 : 0), e.end, e.start, e.end, new nt(a, 0, 0), t.length, !0));
  let o = 0;
  for (let c = 0; c < t.length; c++)
    t[c].type == i && (o = c + 1);
  let s = t.length - o, l = e.start + t.length - (r ? 2 : 0), u = e.parent;
  for (let c = e.startIndex, d = e.endIndex, f = !0; c < d; c++, f = !1)
    !f && sl(n.doc, l, s) && (n.split(l, s), l += 2 * s), l += u.child(c).nodeSize;
  return n;
}
function tfe(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, a = r.blockRange(i, (o) => o.childCount > 0 && o.firstChild.type == n);
    return a ? t ? r.node(a.depth - 1).type == n ? nfe(e, t, n, a) : rfe(e, t, a) : !0 : !1;
  };
}
function nfe(n, e, t, r) {
  let i = n.tr, a = r.end, o = r.$to.end(r.depth);
  a < o && (i.step(new Vr(a - 1, o, a, o, new nt($e.from(t.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new Y1(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth));
  const s = ih(r);
  if (s == null)
    return !1;
  i.lift(r, s);
  let l = i.doc.resolve(i.mapping.map(a, -1) - 1);
  return Hu(i.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type && i.join(l.pos), e(i.scrollIntoView()), !0;
}
function rfe(n, e, t) {
  let r = n.tr, i = t.parent;
  for (let p = t.end, h = t.endIndex - 1, v = t.startIndex; h > v; h--)
    p -= i.child(h).nodeSize, r.delete(p - 1, p + 1);
  let a = r.doc.resolve(t.start), o = a.nodeAfter;
  if (r.mapping.map(t.end) != t.start + a.nodeAfter.nodeSize)
    return !1;
  let s = t.startIndex == 0, l = t.endIndex == i.childCount, u = a.node(-1), c = a.index(-1);
  if (!u.canReplace(c + (s ? 0 : 1), c + 1, o.content.append(l ? $e.empty : $e.from(i))))
    return !1;
  let d = a.pos, f = d + o.nodeSize;
  return r.step(new Vr(d - (s ? 1 : 0), f + (l ? 1 : 0), d + 1, f - 1, new nt((s ? $e.empty : $e.from(i.copy($e.empty))).append(l ? $e.empty : $e.from(i.copy($e.empty))), s ? 0 : 1, l ? 0 : 1), s ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function ife(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, a = r.blockRange(i, (u) => u.childCount > 0 && u.firstChild.type == n);
    if (!a)
      return !1;
    let o = a.startIndex;
    if (o == 0)
      return !1;
    let s = a.parent, l = s.child(o - 1);
    if (l.type != n)
      return !1;
    if (t) {
      let u = l.lastChild && l.lastChild.type == s.type, c = $e.from(u ? n.create() : null), d = new nt($e.from(n.create(null, $e.from(s.type.create(null, c)))), u ? 3 : 1, 0), f = a.start, p = a.end;
      t(e.tr.step(new Vr(f - (u ? 3 : 1), p, f, p, d, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function Sx(n) {
  const { state: e, transaction: t } = n;
  let { selection: r } = t, { doc: i } = t, { storedMarks: a } = t;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return a;
    },
    get selection() {
      return r;
    },
    get doc() {
      return i;
    },
    get tr() {
      return r = t.selection, i = t.doc, a = t.storedMarks, t;
    }
  };
}
class Ex {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: t, state: r } = this, { view: i } = t, { tr: a } = r, o = this.buildProps(a);
    return Object.fromEntries(Object.entries(e).map(([s, l]) => [s, (...c) => {
      const d = l(...c)(o);
      return !a.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(a), d;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, t = !0) {
    const { rawCommands: r, editor: i, state: a } = this, { view: o } = i, s = [], l = !!e, u = e || a.tr, c = () => (!l && t && !u.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(u), s.every((f) => f === !0)), d = {
      ...Object.fromEntries(Object.entries(r).map(([f, p]) => [f, (...v) => {
        const m = this.buildProps(u, t), g = p(...v)(m);
        return s.push(g), d;
      }])),
      run: c
    };
    return d;
  }
  createCan(e) {
    const { rawCommands: t, state: r } = this, i = !1, a = e || r.tr, o = this.buildProps(a, i);
    return {
      ...Object.fromEntries(Object.entries(t).map(([l, u]) => [l, (...c) => u(...c)({ ...o, dispatch: void 0 })])),
      chain: () => this.createChain(a, i)
    };
  }
  buildProps(e, t = !0) {
    const { rawCommands: r, editor: i, state: a } = this, { view: o } = i, s = {
      tr: e,
      editor: i,
      view: o,
      state: Sx({
        state: a,
        transaction: e
      }),
      dispatch: t ? () => {
      } : void 0,
      chain: () => this.createChain(e, t),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(r).map(([l, u]) => [l, (...c) => u(...c)(s)]));
      }
    };
    return s;
  }
}
class afe {
  constructor() {
    this.callbacks = {};
  }
  on(e, t) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this;
  }
  emit(e, ...t) {
    const r = this.callbacks[e];
    return r && r.forEach((i) => i.apply(this, t)), this;
  }
  off(e, t) {
    const r = this.callbacks[e];
    return r && (t ? this.callbacks[e] = r.filter((i) => i !== t) : delete this.callbacks[e]), this;
  }
  once(e, t) {
    const r = (...i) => {
      this.off(e, r), t.apply(this, i);
    };
    return this.on(e, r);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function vt(n, e, t) {
  return n.config[e] === void 0 && n.parent ? vt(n.parent, e, t) : typeof n.config[e] == "function" ? n.config[e].bind({
    ...t,
    parent: n.parent ? vt(n.parent, e, t) : null
  }) : n.config[e];
}
function Tx(n) {
  const e = n.filter((i) => i.type === "extension"), t = n.filter((i) => i.type === "node"), r = n.filter((i) => i.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: t,
    markExtensions: r
  };
}
function z8(n) {
  const e = [], { nodeExtensions: t, markExtensions: r } = Tx(n), i = [...t, ...r], a = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return n.forEach((o) => {
    const s = {
      name: o.name,
      options: o.options,
      storage: o.storage,
      extensions: i
    }, l = vt(o, "addGlobalAttributes", s);
    if (!l)
      return;
    l().forEach((c) => {
      c.types.forEach((d) => {
        Object.entries(c.attributes).forEach(([f, p]) => {
          e.push({
            type: d,
            name: f,
            attribute: {
              ...a,
              ...p
            }
          });
        });
      });
    });
  }), i.forEach((o) => {
    const s = {
      name: o.name,
      options: o.options,
      storage: o.storage
    }, l = vt(o, "addAttributes", s);
    if (!l)
      return;
    const u = l();
    Object.entries(u).forEach(([c, d]) => {
      const f = {
        ...a,
        ...d
      };
      typeof (f == null ? void 0 : f.default) == "function" && (f.default = f.default()), f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete f.default, e.push({
        type: o.name,
        name: c,
        attribute: f
      });
    });
  }), e;
}
function Gr(n, e) {
  if (typeof n == "string") {
    if (!e.nodes[n])
      throw Error(`There is no node type named '${n}'. Maybe you forgot to add the extension?`);
    return e.nodes[n];
  }
  return n;
}
function Mn(...n) {
  return n.filter((e) => !!e).reduce((e, t) => {
    const r = { ...e };
    return Object.entries(t).forEach(([i, a]) => {
      if (!r[i]) {
        r[i] = a;
        return;
      }
      if (i === "class") {
        const s = a ? String(a).split(" ") : [], l = r[i] ? r[i].split(" ") : [], u = s.filter((c) => !l.includes(c));
        r[i] = [...l, ...u].join(" ");
      } else if (i === "style") {
        const s = a ? a.split(";").map((c) => c.trim()).filter(Boolean) : [], l = r[i] ? r[i].split(";").map((c) => c.trim()).filter(Boolean) : [], u = /* @__PURE__ */ new Map();
        l.forEach((c) => {
          const [d, f] = c.split(":").map((p) => p.trim());
          u.set(d, f);
        }), s.forEach((c) => {
          const [d, f] = c.split(":").map((p) => p.trim());
          u.set(d, f);
        }), r[i] = Array.from(u.entries()).map(([c, d]) => `${c}: ${d}`).join("; ");
      } else
        r[i] = a;
    }), r;
  }, {});
}
function eC(n, e) {
  return e.filter((t) => t.type === n.type.name).filter((t) => t.attribute.rendered).map((t) => t.attribute.renderHTML ? t.attribute.renderHTML(n.attrs) || {} : {
    [t.name]: n.attrs[t.name]
  }).reduce((t, r) => Mn(t, r), {});
}
function F8(n) {
  return typeof n == "function";
}
function on(n, e = void 0, ...t) {
  return F8(n) ? e ? n.bind(e)(...t) : n(...t) : n;
}
function ofe(n = {}) {
  return Object.keys(n).length === 0 && n.constructor === Object;
}
function sfe(n) {
  return typeof n != "string" ? n : n.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(n) : n === "true" ? !0 : n === "false" ? !1 : n;
}
function FN(n, e) {
  return "style" in n ? n : {
    ...n,
    getAttrs: (t) => {
      const r = n.getAttrs ? n.getAttrs(t) : n.attrs;
      if (r === !1)
        return !1;
      const i = e.reduce((a, o) => {
        const s = o.attribute.parseHTML ? o.attribute.parseHTML(t) : sfe(t.getAttribute(o.name));
        return s == null ? a : {
          ...a,
          [o.name]: s
        };
      }, {});
      return { ...r, ...i };
    }
  };
}
function VN(n) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(n).filter(([e, t]) => e === "attrs" && ofe(t) ? !1 : t != null)
  );
}
function lfe(n, e) {
  var t;
  const r = z8(n), { nodeExtensions: i, markExtensions: a } = Tx(n), o = (t = i.find((u) => vt(u, "topNode"))) === null || t === void 0 ? void 0 : t.name, s = Object.fromEntries(i.map((u) => {
    const c = r.filter((g) => g.type === u.name), d = {
      name: u.name,
      options: u.options,
      storage: u.storage,
      editor: e
    }, f = n.reduce((g, y) => {
      const b = vt(y, "extendNodeSchema", d);
      return {
        ...g,
        ...b ? b(u) : {}
      };
    }, {}), p = VN({
      ...f,
      content: on(vt(u, "content", d)),
      marks: on(vt(u, "marks", d)),
      group: on(vt(u, "group", d)),
      inline: on(vt(u, "inline", d)),
      atom: on(vt(u, "atom", d)),
      selectable: on(vt(u, "selectable", d)),
      draggable: on(vt(u, "draggable", d)),
      code: on(vt(u, "code", d)),
      whitespace: on(vt(u, "whitespace", d)),
      linebreakReplacement: on(vt(u, "linebreakReplacement", d)),
      defining: on(vt(u, "defining", d)),
      isolating: on(vt(u, "isolating", d)),
      attrs: Object.fromEntries(c.map((g) => {
        var y;
        return [g.name, { default: (y = g == null ? void 0 : g.attribute) === null || y === void 0 ? void 0 : y.default }];
      }))
    }), h = on(vt(u, "parseHTML", d));
    h && (p.parseDOM = h.map((g) => FN(g, c)));
    const v = vt(u, "renderHTML", d);
    v && (p.toDOM = (g) => v({
      node: g,
      HTMLAttributes: eC(g, c)
    }));
    const m = vt(u, "renderText", d);
    return m && (p.toText = m), [u.name, p];
  })), l = Object.fromEntries(a.map((u) => {
    const c = r.filter((m) => m.type === u.name), d = {
      name: u.name,
      options: u.options,
      storage: u.storage,
      editor: e
    }, f = n.reduce((m, g) => {
      const y = vt(g, "extendMarkSchema", d);
      return {
        ...m,
        ...y ? y(u) : {}
      };
    }, {}), p = VN({
      ...f,
      inclusive: on(vt(u, "inclusive", d)),
      excludes: on(vt(u, "excludes", d)),
      group: on(vt(u, "group", d)),
      spanning: on(vt(u, "spanning", d)),
      code: on(vt(u, "code", d)),
      attrs: Object.fromEntries(c.map((m) => {
        var g;
        return [m.name, { default: (g = m == null ? void 0 : m.attribute) === null || g === void 0 ? void 0 : g.default }];
      }))
    }), h = on(vt(u, "parseHTML", d));
    h && (p.parseDOM = h.map((m) => FN(m, c)));
    const v = vt(u, "renderHTML", d);
    return v && (p.toDOM = (m) => v({
      mark: m,
      HTMLAttributes: eC(m, c)
    })), [u.name, p];
  }));
  return new M6({
    topNode: o,
    nodes: s,
    marks: l
  });
}
function vS(n, e) {
  return e.nodes[n] || e.marks[n] || null;
}
function HN(n, e) {
  return Array.isArray(e) ? e.some((t) => (typeof t == "string" ? t : t.name) === n.name) : e;
}
function kM(n, e) {
  const t = Ud.fromSchema(e).serializeFragment(n), i = document.implementation.createHTMLDocument().createElement("div");
  return i.appendChild(t), i.innerHTML;
}
const ufe = (n, e = 500) => {
  let t = "";
  const r = n.parentOffset;
  return n.parent.nodesBetween(Math.max(0, r - e), r, (i, a, o, s) => {
    var l, u;
    const c = ((u = (l = i.type.spec).toText) === null || u === void 0 ? void 0 : u.call(l, {
      node: i,
      pos: a,
      parent: o,
      index: s
    })) || i.textContent || "%leaf%";
    t += i.isAtom && !i.isText ? c : c.slice(0, Math.max(0, r - a));
  }), t;
};
function AM(n) {
  return Object.prototype.toString.call(n) === "[object RegExp]";
}
class Rg {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const cfe = (n, e) => {
  if (AM(e))
    return e.exec(n);
  const t = e(n);
  if (!t)
    return null;
  const r = [t.text];
  return r.index = t.index, r.input = n, r.data = t.data, t.replaceWith && (t.text.includes(t.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(t.replaceWith)), r;
};
function ky(n) {
  var e;
  const { editor: t, from: r, to: i, text: a, rules: o, plugin: s } = n, { view: l } = t;
  if (l.composing)
    return !1;
  const u = l.state.doc.resolve(r);
  if (
    // check for code node
    u.parent.type.spec.code || !((e = u.nodeBefore || u.nodeAfter) === null || e === void 0) && e.marks.find((f) => f.type.spec.code)
  )
    return !1;
  let c = !1;
  const d = ufe(u) + a;
  return o.forEach((f) => {
    if (c)
      return;
    const p = cfe(d, f.find);
    if (!p)
      return;
    const h = l.state.tr, v = Sx({
      state: l.state,
      transaction: h
    }), m = {
      from: r - (p[0].length - a.length),
      to: i
    }, { commands: g, chain: y, can: b } = new Ex({
      editor: t,
      state: v
    });
    f.handler({
      state: v,
      range: m,
      match: p,
      commands: g,
      chain: y,
      can: b
    }) === null || !h.steps.length || (h.setMeta(s, {
      transform: h,
      from: r,
      to: i,
      text: a
    }), l.dispatch(h), c = !0);
  }), c;
}
function dfe(n) {
  const { editor: e, rules: t } = n, r = new Pn({
    state: {
      init() {
        return null;
      },
      apply(i, a, o) {
        const s = i.getMeta(r);
        if (s)
          return s;
        const l = i.getMeta("applyInputRules");
        return !!l && setTimeout(() => {
          let { text: c } = l;
          typeof c == "string" ? c = c : c = kM($e.from(c), o.schema);
          const { from: d } = l, f = d + c.length;
          ky({
            editor: e,
            from: d,
            to: f,
            text: c,
            rules: t,
            plugin: r
          });
        }), i.selectionSet || i.docChanged ? null : a;
      }
    },
    props: {
      handleTextInput(i, a, o, s) {
        return ky({
          editor: e,
          from: a,
          to: o,
          text: s,
          rules: t,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (i) => (setTimeout(() => {
          const { $cursor: a } = i.state.selection;
          a && ky({
            editor: e,
            from: a.pos,
            to: a.pos,
            text: "",
            rules: t,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(i, a) {
        if (a.key !== "Enter")
          return !1;
        const { $cursor: o } = i.state.selection;
        return o ? ky({
          editor: e,
          from: o.pos,
          to: o.pos,
          text: `
`,
          rules: t,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function ffe(n) {
  return Object.prototype.toString.call(n).slice(8, -1);
}
function Ay(n) {
  return ffe(n) !== "Object" ? !1 : n.constructor === Object && Object.getPrototypeOf(n) === Object.prototype;
}
function Cx(n, e) {
  const t = { ...n };
  return Ay(n) && Ay(e) && Object.keys(e).forEach((r) => {
    Ay(e[r]) && Ay(n[r]) ? t[r] = Cx(n[r], e[r]) : t[r] = e[r];
  }), t;
}
class Ao {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = on(vt(this, "addOptions", {
      name: this.name
    }))), this.storage = on(vt(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Ao(e);
  }
  configure(e = {}) {
    const t = this.extend({
      ...this.config,
      addOptions: () => Cx(this.options, e)
    });
    return t.name = this.name, t.parent = this.parent, t;
  }
  extend(e = {}) {
    const t = new Ao(e);
    return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = on(vt(t, "addOptions", {
      name: t.name
    })), t.storage = on(vt(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
  static handleExit({ editor: e, mark: t }) {
    const { tr: r } = e.state, i = e.state.selection.$from;
    if (i.pos === i.end()) {
      const o = i.marks();
      if (!!!o.find((u) => (u == null ? void 0 : u.type.name) === t.name))
        return !1;
      const l = o.find((u) => (u == null ? void 0 : u.type.name) === t.name);
      return l && r.removeStoredMark(l), r.insertText(" ", i.pos), e.view.dispatch(r), !0;
    }
    return !1;
  }
}
function pfe(n) {
  return typeof n == "number";
}
class hfe {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const vfe = (n, e, t) => {
  if (AM(e))
    return [...n.matchAll(e)];
  const r = e(n, t);
  return r ? r.map((i) => {
    const a = [i.text];
    return a.index = i.index, a.input = n, a.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), a.push(i.replaceWith)), a;
  }) : [];
};
function mfe(n) {
  const { editor: e, state: t, from: r, to: i, rule: a, pasteEvent: o, dropEvent: s } = n, { commands: l, chain: u, can: c } = new Ex({
    editor: e,
    state: t
  }), d = [];
  return t.doc.nodesBetween(r, i, (p, h) => {
    if (!p.isTextblock || p.type.spec.code)
      return;
    const v = Math.max(r, h), m = Math.min(i, h + p.content.size), g = p.textBetween(v - h, m - h, void 0, "￼");
    vfe(g, a.find, o).forEach((b) => {
      if (b.index === void 0)
        return;
      const _ = v + b.index + 1, x = _ + b[0].length, w = {
        from: t.tr.mapping.map(_),
        to: t.tr.mapping.map(x)
      }, S = a.handler({
        state: t,
        range: w,
        match: b,
        commands: l,
        chain: u,
        can: c,
        pasteEvent: o,
        dropEvent: s
      });
      d.push(S);
    });
  }), d.every((p) => p !== null);
}
let My = null;
const gfe = (n) => {
  var e;
  const t = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = t.clipboardData) === null || e === void 0 || e.setData("text/html", n), t;
};
function yfe(n) {
  const { editor: e, rules: t } = n;
  let r = null, i = !1, a = !1, o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, s;
  try {
    s = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    s = null;
  }
  const l = ({ state: c, from: d, to: f, rule: p, pasteEvt: h }) => {
    const v = c.tr, m = Sx({
      state: c,
      transaction: v
    });
    if (!(!mfe({
      editor: e,
      state: m,
      from: Math.max(d - 1, 0),
      to: f.b - 1,
      rule: p,
      pasteEvent: h,
      dropEvent: s
    }) || !v.steps.length)) {
      try {
        s = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        s = null;
      }
      return o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, v;
    }
  };
  return t.map((c) => new Pn({
    // we register a global drag handler to track the current drag source element
    view(d) {
      const f = (h) => {
        var v;
        r = !((v = d.dom.parentElement) === null || v === void 0) && v.contains(h.target) ? d.dom.parentElement : null, r && (My = e);
      }, p = () => {
        My && (My = null);
      };
      return window.addEventListener("dragstart", f), window.addEventListener("dragend", p), {
        destroy() {
          window.removeEventListener("dragstart", f), window.removeEventListener("dragend", p);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (d, f) => {
          if (a = r === d.dom.parentElement, s = f, !a) {
            const p = My;
            p != null && p.isEditable && setTimeout(() => {
              const h = p.state.selection;
              h && p.commands.deleteRange({ from: h.from, to: h.to });
            }, 10);
          }
          return !1;
        },
        paste: (d, f) => {
          var p;
          const h = (p = f.clipboardData) === null || p === void 0 ? void 0 : p.getData("text/html");
          return o = f, i = !!(h != null && h.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (d, f, p) => {
      const h = d[0], v = h.getMeta("uiEvent") === "paste" && !i, m = h.getMeta("uiEvent") === "drop" && !a, g = h.getMeta("applyPasteRules"), y = !!g;
      if (!v && !m && !y)
        return;
      if (y) {
        let { text: x } = g;
        typeof x == "string" ? x = x : x = kM($e.from(x), p.schema);
        const { from: w } = g, S = w + x.length, C = gfe(x);
        return l({
          rule: c,
          state: p,
          from: w,
          to: { b: S },
          pasteEvt: C
        });
      }
      const b = f.doc.content.findDiffStart(p.doc.content), _ = f.doc.content.findDiffEnd(p.doc.content);
      if (!(!pfe(b) || !_ || b === _.b))
        return l({
          rule: c,
          state: p,
          from: b,
          to: _,
          pasteEvt: o
        });
    }
  }));
}
function bfe(n) {
  const e = n.filter((t, r) => n.indexOf(t) !== r);
  return Array.from(new Set(e));
}
class op {
  constructor(e, t) {
    this.splittableMarks = [], this.editor = t, this.extensions = op.resolve(e), this.schema = lfe(this.extensions, t), this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(e) {
    const t = op.sort(op.flatten(e)), r = bfe(t.map((i) => i.name));
    return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map((i) => `'${i}'`).join(", ")}]. This can lead to issues.`), t;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(e) {
    return e.map((t) => {
      const r = {
        name: t.name,
        options: t.options,
        storage: t.storage
      }, i = vt(t, "addExtensions", r);
      return i ? [t, ...this.flatten(i())] : t;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(e) {
    return e.sort((r, i) => {
      const a = vt(r, "priority") || 100, o = vt(i, "priority") || 100;
      return a > o ? -1 : a < o ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, t) => {
      const r = {
        name: t.name,
        options: t.options,
        storage: t.storage,
        editor: this.editor,
        type: vS(t.name, this.schema)
      }, i = vt(t, "addCommands", r);
      return i ? {
        ...e,
        ...i()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this, t = op.sort([...this.extensions].reverse()), r = [], i = [], a = t.map((o) => {
      const s = {
        name: o.name,
        options: o.options,
        storage: o.storage,
        editor: e,
        type: vS(o.name, this.schema)
      }, l = [], u = vt(o, "addKeyboardShortcuts", s);
      let c = {};
      if (o.type === "mark" && vt(o, "exitable", s) && (c.ArrowRight = () => Ao.handleExit({ editor: e, mark: o })), u) {
        const v = Object.fromEntries(Object.entries(u()).map(([m, g]) => [m, () => g({ editor: e })]));
        c = { ...c, ...v };
      }
      const d = Bde(c);
      l.push(d);
      const f = vt(o, "addInputRules", s);
      HN(o, e.options.enableInputRules) && f && r.push(...f());
      const p = vt(o, "addPasteRules", s);
      HN(o, e.options.enablePasteRules) && p && i.push(...p());
      const h = vt(o, "addProseMirrorPlugins", s);
      if (h) {
        const v = h();
        l.push(...v);
      }
      return l;
    }).flat();
    return [
      dfe({
        editor: e,
        rules: r
      }),
      ...yfe({
        editor: e,
        rules: i
      }),
      ...a
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return z8(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: t } = Tx(this.extensions);
    return Object.fromEntries(t.filter((r) => !!vt(r, "addNodeView")).map((r) => {
      const i = this.attributes.filter((l) => l.type === r.name), a = {
        name: r.name,
        options: r.options,
        storage: r.storage,
        editor: e,
        type: Gr(r.name, this.schema)
      }, o = vt(r, "addNodeView", a);
      if (!o)
        return [];
      const s = (l, u, c, d, f) => {
        const p = eC(l, i);
        return o()({
          // pass-through
          node: l,
          view: u,
          getPos: c,
          decorations: d,
          innerDecorations: f,
          // tiptap-specific
          editor: e,
          extension: r,
          HTMLAttributes: p
        });
      };
      return [r.name, s];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((e) => {
      var t;
      this.editor.extensionStorage[e.name] = e.storage;
      const r = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: vS(e.name, this.schema)
      };
      e.type === "mark" && (!((t = on(vt(e, "keepOnSplit", r))) !== null && t !== void 0) || t) && this.splittableMarks.push(e.name);
      const i = vt(e, "onBeforeCreate", r), a = vt(e, "onCreate", r), o = vt(e, "onUpdate", r), s = vt(e, "onSelectionUpdate", r), l = vt(e, "onTransaction", r), u = vt(e, "onFocus", r), c = vt(e, "onBlur", r), d = vt(e, "onDestroy", r);
      i && this.editor.on("beforeCreate", i), a && this.editor.on("create", a), o && this.editor.on("update", o), s && this.editor.on("selectionUpdate", s), l && this.editor.on("transaction", l), u && this.editor.on("focus", u), c && this.editor.on("blur", c), d && this.editor.on("destroy", d);
    });
  }
}
class Qn {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = on(vt(this, "addOptions", {
      name: this.name
    }))), this.storage = on(vt(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Qn(e);
  }
  configure(e = {}) {
    const t = this.extend({
      ...this.config,
      addOptions: () => Cx(this.options, e)
    });
    return t.name = this.name, t.parent = this.parent, t;
  }
  extend(e = {}) {
    const t = new Qn({ ...this.config, ...e });
    return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = on(vt(t, "addOptions", {
      name: t.name
    })), t.storage = on(vt(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
}
function V8(n, e, t) {
  const { from: r, to: i } = e, { blockSeparator: a = `

`, textSerializers: o = {} } = t || {};
  let s = "";
  return n.nodesBetween(r, i, (l, u, c, d) => {
    var f;
    l.isBlock && u > r && (s += a);
    const p = o == null ? void 0 : o[l.type.name];
    if (p)
      return c && (s += p({
        node: l,
        pos: u,
        parent: c,
        index: d,
        range: e
      })), !1;
    l.isText && (s += (f = l == null ? void 0 : l.text) === null || f === void 0 ? void 0 : f.slice(Math.max(r, u) - u, i - u));
  }), s;
}
function MM(n) {
  return Object.fromEntries(Object.entries(n.nodes).filter(([, e]) => e.spec.toText).map(([e, t]) => [e, t.spec.toText]));
}
const _fe = Qn.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Pn({
        key: new jn("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: n } = this, { state: e, schema: t } = n, { doc: r, selection: i } = e, { ranges: a } = i, o = Math.min(...a.map((c) => c.$from.pos)), s = Math.max(...a.map((c) => c.$to.pos)), l = MM(t);
            return V8(r, { from: o, to: s }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), xfe = () => ({ editor: n, view: e }) => (requestAnimationFrame(() => {
  var t;
  n.isDestroyed || (e.dom.blur(), (t = window == null ? void 0 : window.getSelection()) === null || t === void 0 || t.removeAllRanges());
}), !0), wfe = (n = !1) => ({ commands: e }) => e.setContent("", n), Sfe = () => ({ state: n, tr: e, dispatch: t }) => {
  const { selection: r } = e, { ranges: i } = r;
  return t && i.forEach(({ $from: a, $to: o }) => {
    n.doc.nodesBetween(a.pos, o.pos, (s, l) => {
      if (s.type.isText)
        return;
      const { doc: u, mapping: c } = e, d = u.resolve(c.map(l)), f = u.resolve(c.map(l + s.nodeSize)), p = d.blockRange(f);
      if (!p)
        return;
      const h = ih(p);
      if (s.type.isTextblock) {
        const { defaultType: v } = d.parent.contentMatchAt(d.index());
        e.setNodeMarkup(p.start, v);
      }
      (h || h === 0) && e.lift(p, h);
    });
  }), !0;
}, Efe = (n) => (e) => n(e), Tfe = () => ({ state: n, dispatch: e }) => P8(n, e), Cfe = (n, e) => ({ editor: t, tr: r }) => {
  const { state: i } = t, a = i.doc.slice(n.from, n.to);
  r.deleteRange(n.from, n.to);
  const o = r.mapping.map(e);
  return r.insert(o, a.content), r.setSelection(new Dt(r.doc.resolve(Math.max(o - 1, 0)))), !0;
}, kfe = () => ({ tr: n, dispatch: e }) => {
  const { selection: t } = n, r = t.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const i = n.selection.$anchor;
  for (let a = i.depth; a > 0; a -= 1)
    if (i.node(a).type === r.type) {
      if (e) {
        const s = i.before(a), l = i.after(a);
        n.delete(s, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, Afe = (n) => ({ tr: e, state: t, dispatch: r }) => {
  const i = Gr(n, t.schema), a = e.selection.$anchor;
  for (let o = a.depth; o > 0; o -= 1)
    if (a.node(o).type === i) {
      if (r) {
        const l = a.before(o), u = a.after(o);
        e.delete(l, u).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, Mfe = (n) => ({ tr: e, dispatch: t }) => {
  const { from: r, to: i } = n;
  return t && e.delete(r, i), !0;
}, Dfe = () => ({ state: n, dispatch: e }) => wM(n, e), Ofe = () => ({ commands: n }) => n.keyboardShortcut("Enter"), Ife = () => ({ state: n, dispatch: e }) => Gde(n, e);
function nb(n, e, t = { strict: !0 }) {
  const r = Object.keys(e);
  return r.length ? r.every((i) => t.strict ? e[i] === n[i] : AM(e[i]) ? e[i].test(n[i]) : e[i] === n[i]) : !0;
}
function H8(n, e, t = {}) {
  return n.find((r) => r.type === e && nb(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(t).map((i) => [i, r.attrs[i]])),
    t
  ));
}
function GN(n, e, t = {}) {
  return !!H8(n, e, t);
}
function kx(n, e, t) {
  var r;
  if (!n || !e)
    return;
  let i = n.parent.childAfter(n.parentOffset);
  if ((!i.node || !i.node.marks.some((c) => c.type === e)) && (i = n.parent.childBefore(n.parentOffset)), !i.node || !i.node.marks.some((c) => c.type === e) || (t = t || ((r = i.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs), !H8([...i.node.marks], e, t)))
    return;
  let o = i.index, s = n.start() + i.offset, l = o + 1, u = s + i.node.nodeSize;
  for (; o > 0 && GN([...n.parent.child(o - 1).marks], e, t); )
    o -= 1, s -= n.parent.child(o).nodeSize;
  for (; l < n.parent.childCount && GN([...n.parent.child(l).marks], e, t); )
    u += n.parent.child(l).nodeSize, l += 1;
  return {
    from: s,
    to: u
  };
}
function Uu(n, e) {
  if (typeof n == "string") {
    if (!e.marks[n])
      throw Error(`There is no mark type named '${n}'. Maybe you forgot to add the extension?`);
    return e.marks[n];
  }
  return n;
}
const Lfe = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => {
  const a = Uu(n, r.schema), { doc: o, selection: s } = t, { $from: l, from: u, to: c } = s;
  if (i) {
    const d = kx(l, a, e);
    if (d && d.from <= u && d.to >= c) {
      const f = Dt.create(o, d.from, d.to);
      t.setSelection(f);
    }
  }
  return !0;
}, Nfe = (n) => (e) => {
  const t = typeof n == "function" ? n(e) : n;
  for (let r = 0; r < t.length; r += 1)
    if (t[r](e))
      return !0;
  return !1;
};
function DM(n) {
  return n instanceof Dt;
}
function Qs(n = 0, e = 0, t = 0) {
  return Math.min(Math.max(n, e), t);
}
function G8(n, e = null) {
  if (!e)
    return null;
  const t = It.atStart(n), r = It.atEnd(n);
  if (e === "start" || e === !0)
    return t;
  if (e === "end")
    return r;
  const i = t.from, a = r.to;
  return e === "all" ? Dt.create(n, Qs(0, i, a), Qs(n.content.size, i, a)) : Dt.create(n, Qs(e, i, a), Qs(e, i, a));
}
function U8() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function Ax() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const Rfe = (n = null, e = {}) => ({ editor: t, view: r, tr: i, dispatch: a }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const o = () => {
    (Ax() || U8()) && r.dom.focus(), requestAnimationFrame(() => {
      t.isDestroyed || (r.focus(), e != null && e.scrollIntoView && t.commands.scrollIntoView());
    });
  };
  if (r.hasFocus() && n === null || n === !1)
    return !0;
  if (a && n === null && !DM(t.state.selection))
    return o(), !0;
  const s = G8(i.doc, n) || t.state.selection, l = t.state.selection.eq(s);
  return a && (l || i.setSelection(s), l && i.storedMarks && i.setStoredMarks(i.storedMarks), o()), !0;
}, Pfe = (n, e) => (t) => n.every((r, i) => e(r, { ...t, index: i })), jfe = (n, e) => ({ tr: t, commands: r }) => r.insertContentAt({ from: t.selection.from, to: t.selection.to }, n, e), W8 = (n) => {
  const e = n.childNodes;
  for (let t = e.length - 1; t >= 0; t -= 1) {
    const r = e[t];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? n.removeChild(r) : r.nodeType === 1 && W8(r);
  }
  return n;
};
function Dy(n) {
  const e = `<body>${n}</body>`, t = new window.DOMParser().parseFromString(e, "text/html").body;
  return W8(t);
}
function Nm(n, e, t) {
  if (n instanceof _u || n instanceof $e)
    return n;
  t = {
    slice: !0,
    parseOptions: {},
    ...t
  };
  const r = typeof n == "object" && n !== null, i = typeof n == "string";
  if (r)
    try {
      if (Array.isArray(n) && n.length > 0)
        return $e.fromArray(n.map((s) => e.nodeFromJSON(s)));
      const o = e.nodeFromJSON(n);
      return t.errorOnInvalidContent && o.check(), o;
    } catch (a) {
      if (t.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: a });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", n, "Error:", a), Nm("", e, t);
    }
  if (i) {
    if (t.errorOnInvalidContent) {
      let o = !1, s = "";
      const l = new M6({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (u) => (o = !0, s = typeof u == "string" ? u : u.outerHTML, null)
              }
            ]
          }
        })
      });
      if (t.slice ? hp.fromSchema(l).parseSlice(Dy(n), t.parseOptions) : hp.fromSchema(l).parse(Dy(n), t.parseOptions), t.errorOnInvalidContent && o)
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${s}`) });
    }
    const a = hp.fromSchema(e);
    return t.slice ? a.parseSlice(Dy(n), t.parseOptions).content : a.parse(Dy(n), t.parseOptions);
  }
  return Nm("", e, t);
}
function Bfe(n, e, t) {
  const r = n.steps.length - 1;
  if (r < e)
    return;
  const i = n.steps[r];
  if (!(i instanceof $r || i instanceof Vr))
    return;
  const a = n.mapping.maps[r];
  let o = 0;
  a.forEach((s, l, u, c) => {
    o === 0 && (o = c);
  }), n.setSelection(It.near(n.doc.resolve(o), t));
}
const $fe = (n) => !("type" in n), zfe = (n, e, t) => ({ tr: r, dispatch: i, editor: a }) => {
  var o;
  if (i) {
    t = {
      parseOptions: a.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...t
    };
    let s;
    const l = (m) => {
      a.emit("contentError", {
        editor: a,
        error: m,
        disableCollaboration: () => {
          a.storage.collaboration && (a.storage.collaboration.isDisabled = !0);
        }
      });
    }, u = {
      preserveWhitespace: "full",
      ...t.parseOptions
    };
    if (!t.errorOnInvalidContent && !a.options.enableContentCheck && a.options.emitContentError)
      try {
        Nm(e, a.schema, {
          parseOptions: u,
          errorOnInvalidContent: !0
        });
      } catch (m) {
        l(m);
      }
    try {
      s = Nm(e, a.schema, {
        parseOptions: u,
        errorOnInvalidContent: (o = t.errorOnInvalidContent) !== null && o !== void 0 ? o : a.options.enableContentCheck
      });
    } catch (m) {
      return l(m), !1;
    }
    let { from: c, to: d } = typeof n == "number" ? { from: n, to: n } : { from: n.from, to: n.to }, f = !0, p = !0;
    if (($fe(s) ? s : [s]).forEach((m) => {
      m.check(), f = f ? m.isText && m.marks.length === 0 : !1, p = p ? m.isBlock : !1;
    }), c === d && p) {
      const { parent: m } = r.doc.resolve(c);
      m.isTextblock && !m.type.spec.code && !m.childCount && (c -= 1, d += 1);
    }
    let v;
    if (f) {
      if (Array.isArray(e))
        v = e.map((m) => m.text || "").join("");
      else if (e instanceof $e) {
        let m = "";
        e.forEach((g) => {
          g.text && (m += g.text);
        }), v = m;
      } else typeof e == "object" && e && e.text ? v = e.text : v = e;
      r.insertText(v, c, d);
    } else
      v = s, r.replaceWith(c, d, v);
    t.updateSelection && Bfe(r, r.steps.length - 1, -1), t.applyInputRules && r.setMeta("applyInputRules", { from: c, text: v }), t.applyPasteRules && r.setMeta("applyPasteRules", { from: c, text: v });
  }
  return !0;
}, Ffe = () => ({ state: n, dispatch: e }) => Fde(n, e), Vfe = () => ({ state: n, dispatch: e }) => Vde(n, e), Hfe = () => ({ state: n, dispatch: e }) => M8(n, e), Gfe = () => ({ state: n, dispatch: e }) => L8(n, e), Ufe = () => ({ state: n, dispatch: e, tr: t }) => {
  try {
    const r = mx(n.doc, n.selection.$from.pos, -1);
    return r == null ? !1 : (t.join(r, 2), e && e(t), !0);
  } catch {
    return !1;
  }
}, Wfe = () => ({ state: n, dispatch: e, tr: t }) => {
  try {
    const r = mx(n.doc, n.selection.$from.pos, 1);
    return r == null ? !1 : (t.join(r, 2), e && e(t), !0);
  } catch {
    return !1;
  }
}, qfe = () => ({ state: n, dispatch: e }) => $de(n, e), Yfe = () => ({ state: n, dispatch: e }) => zde(n, e);
function q8() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function Kfe(n) {
  const e = n.split(/-(?!$)/);
  let t = e[e.length - 1];
  t === "Space" && (t = " ");
  let r, i, a, o;
  for (let s = 0; s < e.length - 1; s += 1) {
    const l = e[s];
    if (/^(cmd|meta|m)$/i.test(l))
      o = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      a = !0;
    else if (/^mod$/i.test(l))
      Ax() || q8() ? o = !0 : i = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return r && (t = `Alt-${t}`), i && (t = `Ctrl-${t}`), o && (t = `Meta-${t}`), a && (t = `Shift-${t}`), t;
}
const Xfe = (n) => ({ editor: e, view: t, tr: r, dispatch: i }) => {
  const a = Kfe(n).split(/-(?!$)/), o = a.find((u) => !["Alt", "Ctrl", "Meta", "Shift"].includes(u)), s = new KeyboardEvent("keydown", {
    key: o === "Space" ? " " : o,
    altKey: a.includes("Alt"),
    ctrlKey: a.includes("Ctrl"),
    metaKey: a.includes("Meta"),
    shiftKey: a.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    t.someProp("handleKeyDown", (u) => u(t, s));
  });
  return l == null || l.steps.forEach((u) => {
    const c = u.map(r.mapping);
    c && i && r.maybeStep(c);
  }), !0;
};
function Rm(n, e, t = {}) {
  const { from: r, to: i, empty: a } = n.selection, o = e ? Gr(e, n.schema) : null, s = [];
  n.doc.nodesBetween(r, i, (d, f) => {
    if (d.isText)
      return;
    const p = Math.max(r, f), h = Math.min(i, f + d.nodeSize);
    s.push({
      node: d,
      from: p,
      to: h
    });
  });
  const l = i - r, u = s.filter((d) => o ? o.name === d.node.type.name : !0).filter((d) => nb(d.node.attrs, t, { strict: !1 }));
  return a ? !!u.length : u.reduce((d, f) => d + f.to - f.from, 0) >= l;
}
const Zfe = (n, e = {}) => ({ state: t, dispatch: r }) => {
  const i = Gr(n, t.schema);
  return Rm(t, i, e) ? Hde(t, r) : !1;
}, Jfe = () => ({ state: n, dispatch: e }) => j8(n, e), Qfe = (n) => ({ state: e, dispatch: t }) => {
  const r = Gr(n, e.schema);
  return tfe(r)(e, t);
}, epe = () => ({ state: n, dispatch: e }) => R8(n, e);
function Mx(n, e) {
  return e.nodes[n] ? "node" : e.marks[n] ? "mark" : null;
}
function UN(n, e) {
  const t = typeof e == "string" ? [e] : e;
  return Object.keys(n).reduce((r, i) => (t.includes(i) || (r[i] = n[i]), r), {});
}
const tpe = (n, e) => ({ tr: t, state: r, dispatch: i }) => {
  let a = null, o = null;
  const s = Mx(typeof n == "string" ? n : n.name, r.schema);
  return s ? (s === "node" && (a = Gr(n, r.schema)), s === "mark" && (o = Uu(n, r.schema)), i && t.selection.ranges.forEach((l) => {
    r.doc.nodesBetween(l.$from.pos, l.$to.pos, (u, c) => {
      a && a === u.type && t.setNodeMarkup(c, void 0, UN(u.attrs, e)), o && u.marks.length && u.marks.forEach((d) => {
        o === d.type && t.addMark(c, c + u.nodeSize, o.create(UN(d.attrs, e)));
      });
    });
  }), !0) : !1;
}, npe = () => ({ tr: n, dispatch: e }) => (e && n.scrollIntoView(), !0), rpe = () => ({ tr: n, dispatch: e }) => {
  if (e) {
    const t = new ga(n.doc);
    n.setSelection(t);
  }
  return !0;
}, ipe = () => ({ state: n, dispatch: e }) => O8(n, e), ape = () => ({ state: n, dispatch: e }) => N8(n, e), ope = () => ({ state: n, dispatch: e }) => qde(n, e), spe = () => ({ state: n, dispatch: e }) => Xde(n, e), lpe = () => ({ state: n, dispatch: e }) => Kde(n, e);
function tC(n, e, t = {}, r = {}) {
  return Nm(n, e, {
    slice: !1,
    parseOptions: t,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
const upe = (n, e = !1, t = {}, r = {}) => ({ editor: i, tr: a, dispatch: o, commands: s }) => {
  var l, u;
  const { doc: c } = a;
  if (t.preserveWhitespace !== "full") {
    const d = tC(n, i.schema, t, {
      errorOnInvalidContent: (l = r.errorOnInvalidContent) !== null && l !== void 0 ? l : i.options.enableContentCheck
    });
    return o && a.replaceWith(0, c.content.size, d).setMeta("preventUpdate", !e), !0;
  }
  return o && a.setMeta("preventUpdate", !e), s.insertContentAt({ from: 0, to: c.content.size }, n, {
    parseOptions: t,
    errorOnInvalidContent: (u = r.errorOnInvalidContent) !== null && u !== void 0 ? u : i.options.enableContentCheck
  });
};
function Y8(n, e) {
  const t = Uu(e, n.schema), { from: r, to: i, empty: a } = n.selection, o = [];
  a ? (n.storedMarks && o.push(...n.storedMarks), o.push(...n.selection.$head.marks())) : n.doc.nodesBetween(r, i, (l) => {
    o.push(...l.marks);
  });
  const s = o.find((l) => l.type.name === t.name);
  return s ? { ...s.attrs } : {};
}
function cpe(n, e) {
  const t = new cM(n);
  return e.forEach((r) => {
    r.steps.forEach((i) => {
      t.step(i);
    });
  }), t;
}
function dpe(n) {
  for (let e = 0; e < n.edgeCount; e += 1) {
    const { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
function nC(n, e) {
  const t = [];
  return n.descendants((r, i) => {
    e(r) && t.push({
      node: r,
      pos: i
    });
  }), t;
}
function fpe(n, e, t) {
  const r = [];
  return n.nodesBetween(e.from, e.to, (i, a) => {
    t(i) && r.push({
      node: i,
      pos: a
    });
  }), r;
}
function K8(n, e) {
  for (let t = n.depth; t > 0; t -= 1) {
    const r = n.node(t);
    if (e(r))
      return {
        pos: t > 0 ? n.before(t) : 0,
        start: n.start(t),
        depth: t,
        node: r
      };
  }
}
function OM(n) {
  return (e) => K8(e.$from, n);
}
function X8(n, e) {
  const t = {
    from: 0,
    to: n.content.size
  };
  return V8(n, t, e);
}
function ppe(n, e) {
  const t = Gr(e, n.schema), { from: r, to: i } = n.selection, a = [];
  n.doc.nodesBetween(r, i, (s) => {
    a.push(s);
  });
  const o = a.reverse().find((s) => s.type.name === t.name);
  return o ? { ...o.attrs } : {};
}
function Z8(n, e) {
  const t = Mx(typeof e == "string" ? e : e.name, n.schema);
  return t === "node" ? ppe(n, e) : t === "mark" ? Y8(n, e) : {};
}
function hpe(n, e = JSON.stringify) {
  const t = {};
  return n.filter((r) => {
    const i = e(r);
    return Object.prototype.hasOwnProperty.call(t, i) ? !1 : t[i] = !0;
  });
}
function vpe(n) {
  const e = hpe(n);
  return e.length === 1 ? e : e.filter((t, r) => !e.filter((a, o) => o !== r).some((a) => t.oldRange.from >= a.oldRange.from && t.oldRange.to <= a.oldRange.to && t.newRange.from >= a.newRange.from && t.newRange.to <= a.newRange.to));
}
function mpe(n) {
  const { mapping: e, steps: t } = n, r = [];
  return e.maps.forEach((i, a) => {
    const o = [];
    if (i.ranges.length)
      i.forEach((s, l) => {
        o.push({ from: s, to: l });
      });
    else {
      const { from: s, to: l } = t[a];
      if (s === void 0 || l === void 0)
        return;
      o.push({ from: s, to: l });
    }
    o.forEach(({ from: s, to: l }) => {
      const u = e.slice(a).map(s, -1), c = e.slice(a).map(l), d = e.invert().map(u, -1), f = e.invert().map(c);
      r.push({
        oldRange: {
          from: d,
          to: f
        },
        newRange: {
          from: u,
          to: c
        }
      });
    });
  }), vpe(r);
}
function IM(n, e, t) {
  const r = [];
  return n === e ? t.resolve(n).marks().forEach((i) => {
    const a = t.resolve(n), o = kx(a, i.type);
    o && r.push({
      mark: i,
      ...o
    });
  }) : t.nodesBetween(n, e, (i, a) => {
    !i || (i == null ? void 0 : i.nodeSize) === void 0 || r.push(...i.marks.map((o) => ({
      from: a,
      to: a + i.nodeSize,
      mark: o
    })));
  }), r;
}
function o1(n, e, t) {
  return Object.fromEntries(Object.entries(t).filter(([r]) => {
    const i = n.find((a) => a.type === e && a.name === r);
    return i ? i.attribute.keepOnSplit : !1;
  }));
}
function rC(n, e, t = {}) {
  const { empty: r, ranges: i } = n.selection, a = e ? Uu(e, n.schema) : null;
  if (r)
    return !!(n.storedMarks || n.selection.$from.marks()).filter((d) => a ? a.name === d.type.name : !0).find((d) => nb(d.attrs, t, { strict: !1 }));
  let o = 0;
  const s = [];
  if (i.forEach(({ $from: d, $to: f }) => {
    const p = d.pos, h = f.pos;
    n.doc.nodesBetween(p, h, (v, m) => {
      if (!v.isText && !v.marks.length)
        return;
      const g = Math.max(p, m), y = Math.min(h, m + v.nodeSize), b = y - g;
      o += b, s.push(...v.marks.map((_) => ({
        mark: _,
        from: g,
        to: y
      })));
    });
  }), o === 0)
    return !1;
  const l = s.filter((d) => a ? a.name === d.mark.type.name : !0).filter((d) => nb(d.mark.attrs, t, { strict: !1 })).reduce((d, f) => d + f.to - f.from, 0), u = s.filter((d) => a ? d.mark.type !== a && d.mark.type.excludes(a) : !0).reduce((d, f) => d + f.to - f.from, 0);
  return (l > 0 ? l + u : l) >= o;
}
function gpe(n, e, t = {}) {
  if (!e)
    return Rm(n, null, t) || rC(n, null, t);
  const r = Mx(e, n.schema);
  return r === "node" ? Rm(n, e, t) : r === "mark" ? rC(n, e, t) : !1;
}
function WN(n, e) {
  const { nodeExtensions: t } = Tx(e), r = t.find((o) => o.name === n);
  if (!r)
    return !1;
  const i = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, a = on(vt(r, "group", i));
  return typeof a != "string" ? !1 : a.split(" ").includes("list");
}
function Dx(n, { checkChildren: e = !0, ignoreWhitespace: t = !1 } = {}) {
  var r;
  if (t) {
    if (n.type.name === "hardBreak")
      return !0;
    if (n.isText)
      return /^\s*$/m.test((r = n.text) !== null && r !== void 0 ? r : "");
  }
  if (n.isText)
    return !n.text;
  if (n.isAtom || n.isLeaf)
    return !1;
  if (n.content.childCount === 0)
    return !0;
  if (e) {
    let i = !0;
    return n.content.forEach((a) => {
      i !== !1 && (Dx(a, { ignoreWhitespace: t, checkChildren: e }) || (i = !1));
    }), i;
  }
  return !1;
}
function J8(n) {
  return n instanceof Ct;
}
function Q8(n, e, t) {
  const i = n.state.doc.content.size, a = Qs(e, 0, i), o = Qs(t, 0, i), s = n.coordsAtPos(a), l = n.coordsAtPos(o, -1), u = Math.min(s.top, l.top), c = Math.max(s.bottom, l.bottom), d = Math.min(s.left, l.left), f = Math.max(s.right, l.right), p = f - d, h = c - u, g = {
    top: u,
    bottom: c,
    left: d,
    right: f,
    width: p,
    height: h,
    x: d,
    y: u
  };
  return {
    ...g,
    toJSON: () => g
  };
}
function ype(n, e, t) {
  var r;
  const { selection: i } = e;
  let a = null;
  if (DM(i) && (a = i.$cursor), a) {
    const s = (r = n.storedMarks) !== null && r !== void 0 ? r : a.marks();
    return !!t.isInSet(s) || !s.some((l) => l.type.excludes(t));
  }
  const { ranges: o } = i;
  return o.some(({ $from: s, $to: l }) => {
    let u = s.depth === 0 ? n.doc.inlineContent && n.doc.type.allowsMarkType(t) : !1;
    return n.doc.nodesBetween(s.pos, l.pos, (c, d, f) => {
      if (u)
        return !1;
      if (c.isInline) {
        const p = !f || f.type.allowsMarkType(t), h = !!t.isInSet(c.marks) || !c.marks.some((v) => v.type.excludes(t));
        u = p && h;
      }
      return !u;
    }), u;
  });
}
const bpe = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => {
  const { selection: a } = t, { empty: o, ranges: s } = a, l = Uu(n, r.schema);
  if (i)
    if (o) {
      const u = Y8(r, l);
      t.addStoredMark(l.create({
        ...u,
        ...e
      }));
    } else
      s.forEach((u) => {
        const c = u.$from.pos, d = u.$to.pos;
        r.doc.nodesBetween(c, d, (f, p) => {
          const h = Math.max(p, c), v = Math.min(p + f.nodeSize, d);
          f.marks.find((g) => g.type === l) ? f.marks.forEach((g) => {
            l === g.type && t.addMark(h, v, l.create({
              ...g.attrs,
              ...e
            }));
          }) : t.addMark(h, v, l.create(e));
        });
      });
  return ype(r, t, l);
}, _pe = (n, e) => ({ tr: t }) => (t.setMeta(n, e), !0), xpe = (n, e = {}) => ({ state: t, dispatch: r, chain: i }) => {
  const a = Gr(n, t.schema);
  let o;
  return t.selection.$anchor.sameParent(t.selection.$head) && (o = t.selection.$anchor.parent.attrs), a.isTextblock ? i().command(({ commands: s }) => zN(a, { ...o, ...e })(t) ? !0 : s.clearNodes()).command(({ state: s }) => zN(a, { ...o, ...e })(s, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, wpe = (n) => ({ tr: e, dispatch: t }) => {
  if (t) {
    const { doc: r } = e, i = Qs(n, 0, r.content.size), a = Ct.create(r, i);
    e.setSelection(a);
  }
  return !0;
}, Spe = (n) => ({ tr: e, dispatch: t }) => {
  if (t) {
    const { doc: r } = e, { from: i, to: a } = typeof n == "number" ? { from: n, to: n } : n, o = Dt.atStart(r).from, s = Dt.atEnd(r).to, l = Qs(i, o, s), u = Qs(a, o, s), c = Dt.create(r, l, u);
    e.setSelection(c);
  }
  return !0;
}, Epe = (n) => ({ state: e, dispatch: t }) => {
  const r = Gr(n, e.schema);
  return ife(r)(e, t);
};
function qN(n, e) {
  const t = n.storedMarks || n.selection.$to.parentOffset && n.selection.$from.marks();
  if (t) {
    const r = t.filter((i) => e == null ? void 0 : e.includes(i.type.name));
    n.tr.ensureMarks(r);
  }
}
const Tpe = ({ keepMarks: n = !0 } = {}) => ({ tr: e, state: t, dispatch: r, editor: i }) => {
  const { selection: a, doc: o } = e, { $from: s, $to: l } = a, u = i.extensionManager.attributes, c = o1(u, s.node().type.name, s.node().attrs);
  if (a instanceof Ct && a.node.isBlock)
    return !s.parentOffset || !sl(o, s.pos) ? !1 : (r && (n && qN(t, i.extensionManager.splittableMarks), e.split(s.pos).scrollIntoView()), !0);
  if (!s.parent.isBlock)
    return !1;
  const d = l.parentOffset === l.parent.content.size, f = s.depth === 0 ? void 0 : dpe(s.node(-1).contentMatchAt(s.indexAfter(-1)));
  let p = d && f ? [
    {
      type: f,
      attrs: c
    }
  ] : void 0, h = sl(e.doc, e.mapping.map(s.pos), 1, p);
  if (!p && !h && sl(e.doc, e.mapping.map(s.pos), 1, f ? [{ type: f }] : void 0) && (h = !0, p = f ? [
    {
      type: f,
      attrs: c
    }
  ] : void 0), r) {
    if (h && (a instanceof Dt && e.deleteSelection(), e.split(e.mapping.map(s.pos), 1, p), f && !d && !s.parentOffset && s.parent.type !== f)) {
      const v = e.mapping.map(s.before()), m = e.doc.resolve(v);
      s.node(-1).canReplaceWith(m.index(), m.index() + 1, f) && e.setNodeMarkup(e.mapping.map(s.before()), f);
    }
    n && qN(t, i.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return h;
}, Cpe = (n, e = {}) => ({ tr: t, state: r, dispatch: i, editor: a }) => {
  var o;
  const s = Gr(n, r.schema), { $from: l, $to: u } = r.selection, c = r.selection.node;
  if (c && c.isBlock || l.depth < 2 || !l.sameParent(u))
    return !1;
  const d = l.node(-1);
  if (d.type !== s)
    return !1;
  const f = a.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== s || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (i) {
      let g = $e.empty;
      const y = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let C = l.depth - y; C >= l.depth - 3; C -= 1)
        g = $e.from(l.node(C).copy(g));
      const b = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, _ = {
        ...o1(f, l.node().type.name, l.node().attrs),
        ...e
      }, x = ((o = s.contentMatch.defaultType) === null || o === void 0 ? void 0 : o.createAndFill(_)) || void 0;
      g = g.append($e.from(s.createAndFill(null, x) || void 0));
      const w = l.before(l.depth - (y - 1));
      t.replace(w, l.after(-b), new nt(g, 4 - y, 0));
      let S = -1;
      t.doc.nodesBetween(w, t.doc.content.size, (C, k) => {
        if (S > -1)
          return !1;
        C.isTextblock && C.content.size === 0 && (S = k + 1);
      }), S > -1 && t.setSelection(Dt.near(t.doc.resolve(S))), t.scrollIntoView();
    }
    return !0;
  }
  const p = u.pos === l.end() ? d.contentMatchAt(0).defaultType : null, h = {
    ...o1(f, d.type.name, d.attrs),
    ...e
  }, v = {
    ...o1(f, l.node().type.name, l.node().attrs),
    ...e
  };
  t.delete(l.pos, u.pos);
  const m = p ? [
    { type: s, attrs: h },
    { type: p, attrs: v }
  ] : [{ type: s, attrs: h }];
  if (!sl(t.doc, l.pos, 2))
    return !1;
  if (i) {
    const { selection: g, storedMarks: y } = r, { splittableMarks: b } = a.extensionManager, _ = y || g.$to.parentOffset && g.$from.marks();
    if (t.split(l.pos, 2, m).scrollIntoView(), !_ || !i)
      return !0;
    const x = _.filter((w) => b.includes(w.type.name));
    t.ensureMarks(x);
  }
  return !0;
}, mS = (n, e) => {
  const t = OM((o) => o.type === e)(n.selection);
  if (!t)
    return !0;
  const r = n.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth);
  if (r === void 0)
    return !0;
  const i = n.doc.nodeAt(r);
  return t.node.type === (i == null ? void 0 : i.type) && Hu(n.doc, t.pos) && n.join(t.pos), !0;
}, gS = (n, e) => {
  const t = OM((o) => o.type === e)(n.selection);
  if (!t)
    return !0;
  const r = n.doc.resolve(t.start).after(t.depth);
  if (r === void 0)
    return !0;
  const i = n.doc.nodeAt(r);
  return t.node.type === (i == null ? void 0 : i.type) && Hu(n.doc, r) && n.join(r), !0;
}, kpe = (n, e, t, r = {}) => ({ editor: i, tr: a, state: o, dispatch: s, chain: l, commands: u, can: c }) => {
  const { extensions: d, splittableMarks: f } = i.extensionManager, p = Gr(n, o.schema), h = Gr(e, o.schema), { selection: v, storedMarks: m } = o, { $from: g, $to: y } = v, b = g.blockRange(y), _ = m || v.$to.parentOffset && v.$from.marks();
  if (!b)
    return !1;
  const x = OM((w) => WN(w.type.name, d))(v);
  if (b.depth >= 1 && x && b.depth - x.depth <= 1) {
    if (x.node.type === p)
      return u.liftListItem(h);
    if (WN(x.node.type.name, d) && p.validContent(x.node.content) && s)
      return l().command(() => (a.setNodeMarkup(x.pos, p), !0)).command(() => mS(a, p)).command(() => gS(a, p)).run();
  }
  return !t || !_ || !s ? l().command(() => c().wrapInList(p, r) ? !0 : u.clearNodes()).wrapInList(p, r).command(() => mS(a, p)).command(() => gS(a, p)).run() : l().command(() => {
    const w = c().wrapInList(p, r), S = _.filter((C) => f.includes(C.type.name));
    return a.ensureMarks(S), w ? !0 : u.clearNodes();
  }).wrapInList(p, r).command(() => mS(a, p)).command(() => gS(a, p)).run();
}, Ape = (n, e = {}, t = {}) => ({ state: r, commands: i }) => {
  const { extendEmptyMarkRange: a = !1 } = t, o = Uu(n, r.schema);
  return rC(r, o, e) ? i.unsetMark(o, { extendEmptyMarkRange: a }) : i.setMark(o, e);
}, Mpe = (n, e, t = {}) => ({ state: r, commands: i }) => {
  const a = Gr(n, r.schema), o = Gr(e, r.schema), s = Rm(r, a, t);
  let l;
  return r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs), s ? i.setNode(o, l) : i.setNode(a, { ...l, ...t });
}, Dpe = (n, e = {}) => ({ state: t, commands: r }) => {
  const i = Gr(n, t.schema);
  return Rm(t, i, e) ? r.lift(i) : r.wrapIn(i, e);
}, Ope = () => ({ state: n, dispatch: e }) => {
  const t = n.plugins;
  for (let r = 0; r < t.length; r += 1) {
    const i = t[r];
    let a;
    if (i.spec.isInputRules && (a = i.getState(n))) {
      if (e) {
        const o = n.tr, s = a.transform;
        for (let l = s.steps.length - 1; l >= 0; l -= 1)
          o.step(s.steps[l].invert(s.docs[l]));
        if (a.text) {
          const l = o.doc.resolve(a.from).marks();
          o.replaceWith(a.from, a.to, n.schema.text(a.text, l));
        } else
          o.delete(a.from, a.to);
      }
      return !0;
    }
  }
  return !1;
}, Ipe = () => ({ tr: n, dispatch: e }) => {
  const { selection: t } = n, { empty: r, ranges: i } = t;
  return r || e && i.forEach((a) => {
    n.removeMark(a.$from.pos, a.$to.pos);
  }), !0;
}, Lpe = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => {
  var a;
  const { extendEmptyMarkRange: o = !1 } = e, { selection: s } = t, l = Uu(n, r.schema), { $from: u, empty: c, ranges: d } = s;
  if (!i)
    return !0;
  if (c && o) {
    let { from: f, to: p } = s;
    const h = (a = u.marks().find((m) => m.type === l)) === null || a === void 0 ? void 0 : a.attrs, v = kx(u, l, h);
    v && (f = v.from, p = v.to), t.removeMark(f, p, l);
  } else
    d.forEach((f) => {
      t.removeMark(f.$from.pos, f.$to.pos, l);
    });
  return t.removeStoredMark(l), !0;
}, Npe = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => {
  let a = null, o = null;
  const s = Mx(typeof n == "string" ? n : n.name, r.schema);
  return s ? (s === "node" && (a = Gr(n, r.schema)), s === "mark" && (o = Uu(n, r.schema)), i && t.selection.ranges.forEach((l) => {
    const u = l.$from.pos, c = l.$to.pos;
    let d, f, p, h;
    t.selection.empty ? r.doc.nodesBetween(u, c, (v, m) => {
      a && a === v.type && (p = Math.max(m, u), h = Math.min(m + v.nodeSize, c), d = m, f = v);
    }) : r.doc.nodesBetween(u, c, (v, m) => {
      m < u && a && a === v.type && (p = Math.max(m, u), h = Math.min(m + v.nodeSize, c), d = m, f = v), m >= u && m <= c && (a && a === v.type && t.setNodeMarkup(m, void 0, {
        ...v.attrs,
        ...e
      }), o && v.marks.length && v.marks.forEach((g) => {
        if (o === g.type) {
          const y = Math.max(m, u), b = Math.min(m + v.nodeSize, c);
          t.addMark(y, b, o.create({
            ...g.attrs,
            ...e
          }));
        }
      }));
    }), f && (d !== void 0 && t.setNodeMarkup(d, void 0, {
      ...f.attrs,
      ...e
    }), o && f.marks.length && f.marks.forEach((v) => {
      o === v.type && t.addMark(p, h, o.create({
        ...v.attrs,
        ...e
      }));
    }));
  }), !0) : !1;
}, Rpe = (n, e = {}) => ({ state: t, dispatch: r }) => {
  const i = Gr(n, t.schema);
  return Zde(i, e)(t, r);
}, Ppe = (n, e = {}) => ({ state: t, dispatch: r }) => {
  const i = Gr(n, t.schema);
  return Jde(i, e)(t, r);
};
var jpe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: xfe,
  clearContent: wfe,
  clearNodes: Sfe,
  command: Efe,
  createParagraphNear: Tfe,
  cut: Cfe,
  deleteCurrentNode: kfe,
  deleteNode: Afe,
  deleteRange: Mfe,
  deleteSelection: Dfe,
  enter: Ofe,
  exitCode: Ife,
  extendMarkRange: Lfe,
  first: Nfe,
  focus: Rfe,
  forEach: Pfe,
  insertContent: jfe,
  insertContentAt: zfe,
  joinBackward: Hfe,
  joinDown: Vfe,
  joinForward: Gfe,
  joinItemBackward: Ufe,
  joinItemForward: Wfe,
  joinTextblockBackward: qfe,
  joinTextblockForward: Yfe,
  joinUp: Ffe,
  keyboardShortcut: Xfe,
  lift: Zfe,
  liftEmptyBlock: Jfe,
  liftListItem: Qfe,
  newlineInCode: epe,
  resetAttributes: tpe,
  scrollIntoView: npe,
  selectAll: rpe,
  selectNodeBackward: ipe,
  selectNodeForward: ape,
  selectParentNode: ope,
  selectTextblockEnd: spe,
  selectTextblockStart: lpe,
  setContent: upe,
  setMark: bpe,
  setMeta: _pe,
  setNode: xpe,
  setNodeSelection: wpe,
  setTextSelection: Spe,
  sinkListItem: Epe,
  splitBlock: Tpe,
  splitListItem: Cpe,
  toggleList: kpe,
  toggleMark: Ape,
  toggleNode: Mpe,
  toggleWrap: Dpe,
  undoInputRule: Ope,
  unsetAllMarks: Ipe,
  unsetMark: Lpe,
  updateAttributes: Npe,
  wrapIn: Rpe,
  wrapInList: Ppe
});
const Bpe = Qn.create({
  name: "commands",
  addCommands() {
    return {
      ...jpe
    };
  }
}), $pe = Qn.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Pn({
        key: new jn("tiptapDrop"),
        props: {
          handleDrop: (n, e, t, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: t,
              moved: r
            });
          }
        }
      })
    ];
  }
}), zpe = Qn.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Pn({
        key: new jn("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), Fpe = new jn("focusEvents"), Vpe = Qn.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: n } = this;
    return [
      new Pn({
        key: Fpe,
        props: {
          handleDOMEvents: {
            focus: (e, t) => {
              n.isFocused = !0;
              const r = n.state.tr.setMeta("focus", { event: t }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            },
            blur: (e, t) => {
              n.isFocused = !1;
              const r = n.state.tr.setMeta("blur", { event: t }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), Hpe = Qn.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const n = () => this.editor.commands.first(({ commands: o }) => [
      () => o.undoInputRule(),
      // maybe convert first text block node to default node
      () => o.command(({ tr: s }) => {
        const { selection: l, doc: u } = s, { empty: c, $anchor: d } = l, { pos: f, parent: p } = d, h = d.parent.isTextblock && f > 0 ? s.doc.resolve(f - 1) : d, v = h.parent.type.spec.isolating, m = d.pos - d.parentOffset, g = v && h.parent.childCount === 1 ? m === d.pos : It.atStart(u).from === f;
        return !c || !p.type.isTextblock || p.textContent.length || !g || g && d.parent.type.name === "paragraph" ? !1 : o.clearNodes();
      }),
      () => o.deleteSelection(),
      () => o.joinBackward(),
      () => o.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: o }) => [
      () => o.deleteSelection(),
      () => o.deleteCurrentNode(),
      () => o.joinForward(),
      () => o.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: o }) => [
        () => o.newlineInCode(),
        () => o.createParagraphNear(),
        () => o.liftEmptyBlock(),
        () => o.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: n,
      "Mod-Backspace": n,
      "Shift-Backspace": n,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, i = {
      ...r
    }, a = {
      ...r,
      "Ctrl-h": n,
      "Alt-Backspace": n,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return Ax() || q8() ? a : i;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Pn({
        key: new jn("clearDocument"),
        appendTransaction: (n, e, t) => {
          if (n.some((v) => v.getMeta("composition")))
            return;
          const r = n.some((v) => v.docChanged) && !e.doc.eq(t.doc), i = n.some((v) => v.getMeta("preventClearDocument"));
          if (!r || i)
            return;
          const { empty: a, from: o, to: s } = e.selection, l = It.atStart(e.doc).from, u = It.atEnd(e.doc).to;
          if (a || !(o === l && s === u) || !Dx(t.doc))
            return;
          const f = t.tr, p = Sx({
            state: t,
            transaction: f
          }), { commands: h } = new Ex({
            editor: this.editor,
            state: p
          });
          if (h.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), Gpe = Qn.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Pn({
        key: new jn("tiptapPaste"),
        props: {
          handlePaste: (n, e, t) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: t
            });
          }
        }
      })
    ];
  }
}), Upe = Qn.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Pn({
        key: new jn("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
class Ic {
  get name() {
    return this.node.type.name;
  }
  constructor(e, t, r = !1, i = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = t, this.currentNode = i;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let t = this.from, r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      t = this.from + 1, r = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: t, to: r }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), t = this.resolvedPos.doc.resolve(e);
    return new Ic(t, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new Ic(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new Ic(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((t, r) => {
      const i = t.isBlock && !t.isTextblock, a = t.isAtom && !t.isText, o = this.pos + r + (a ? 0 : 1);
      if (o < 0 || o > this.resolvedPos.doc.nodeSize - 2)
        return;
      const s = this.resolvedPos.doc.resolve(o);
      if (!i && s.depth <= this.depth)
        return;
      const l = new Ic(s, this.editor, i, i ? t : null);
      i && (l.actualDepth = this.depth + 1), e.push(new Ic(s, this.editor, i, i ? t : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, t = {}) {
    let r = null, i = this.parent;
    for (; i && !r; ) {
      if (i.node.type.name === e)
        if (Object.keys(t).length > 0) {
          const a = i.node.attrs, o = Object.keys(t);
          for (let s = 0; s < o.length; s += 1) {
            const l = o[s];
            if (a[l] !== t[l])
              break;
          }
        } else
          r = i;
      i = i.parent;
    }
    return r;
  }
  querySelector(e, t = {}) {
    return this.querySelectorAll(e, t, !0)[0] || null;
  }
  querySelectorAll(e, t = {}, r = !1) {
    let i = [];
    if (!this.children || this.children.length === 0)
      return i;
    const a = Object.keys(t);
    return this.children.forEach((o) => {
      r && i.length > 0 || (o.node.type.name === e && a.every((l) => t[l] === o.node.attrs[l]) && i.push(o), !(r && i.length > 0) && (i = i.concat(o.querySelectorAll(e, t, r))));
    }), i;
  }
  setAttribute(e) {
    const { tr: t } = this.editor.state;
    t.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(t);
  }
}
const Wpe = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function qpe(n, e, t) {
  const r = document.querySelector("style[data-tiptap-style]");
  if (r !== null)
    return r;
  const i = document.createElement("style");
  return e && i.setAttribute("nonce", e), i.setAttribute("data-tiptap-style", ""), i.innerHTML = n, document.getElementsByTagName("head")[0].appendChild(i), i;
}
let Ype = class extends afe {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      emitContentError: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: t }) => {
        throw t;
      },
      onPaste: () => null,
      onDrop: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: t, slice: r, moved: i }) => this.options.onDrop(t, r, i)), this.on("paste", ({ event: t, slice: r }) => this.options.onPaste(t, r)), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = qpe(Wpe, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, t = !0) {
    this.setOptions({ editable: e }), t && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, t) {
    const r = F8(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], i = this.state.reconfigure({ plugins: r });
    return this.view.updateState(i), i;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const t = this.state.plugins;
    let r = t;
    if ([].concat(e).forEach((a) => {
      const o = typeof a == "string" ? `${a}$` : a.key;
      r = r.filter((s) => !s.key.startsWith(o));
    }), t.length === r.length)
      return;
    const i = this.state.reconfigure({
      plugins: r
    });
    return this.view.updateState(i), i;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, t;
    const i = [...this.options.enableCoreExtensions ? [
      zpe,
      _fe.configure({
        blockSeparator: (t = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || t === void 0 ? void 0 : t.blockSeparator
      }),
      Bpe,
      Vpe,
      Hpe,
      Upe,
      $pe,
      Gpe
    ].filter((a) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[a.name] !== !1 : !0) : [], ...this.options.extensions].filter((a) => ["extension", "node", "mark"].includes(a == null ? void 0 : a.type));
    this.extensionManager = new op(i, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new Ex({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var e;
    let t;
    try {
      t = tC(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (o) {
      if (!(o instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(o.message))
        throw o;
      this.emit("contentError", {
        editor: this,
        error: o,
        disableCollaboration: () => {
          this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((s) => s.name !== "collaboration"), this.createExtensionManager();
        }
      }), t = tC(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 });
    }
    const r = G8(t, this.options.autofocus);
    this.view = new k8(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: ap.create({
        doc: t,
        selection: r || void 0
      })
    });
    const i = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(i), this.createNodeViews(), this.prependClass();
    const a = this.view.dom;
    a.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const t = this.capturedTransaction;
    return this.capturedTransaction = null, t;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((o) => {
        var s;
        return (s = this.capturedTransaction) === null || s === void 0 ? void 0 : s.step(o);
      });
      return;
    }
    const t = this.state.apply(e), r = !this.state.selection.eq(t.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: t
    }), this.view.updateState(t), this.emit("transaction", {
      editor: this,
      transaction: e
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const i = e.getMeta("focus"), a = e.getMeta("blur");
    i && this.emit("focus", {
      editor: this,
      event: i.event,
      transaction: e
    }), a && this.emit("blur", {
      editor: this,
      event: a.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return Z8(this.state, e);
  }
  isActive(e, t) {
    const r = typeof e == "string" ? e : null, i = typeof e == "string" ? t : e;
    return gpe(this.state, r, i);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return kM(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: t = `

`, textSerializers: r = {} } = e || {};
    return X8(this.state.doc, {
      blockSeparator: t,
      textSerializers: {
        ...MM(this.schema),
        ...r
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return Dx(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    if (this.emit("destroy"), this.view) {
      const e = this.view.dom;
      e && e.editor && delete e.editor, this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, t) {
    var r;
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, t)) || null;
  }
  $nodes(e, t) {
    var r;
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, t)) || null;
  }
  $pos(e) {
    const t = this.state.doc.resolve(e);
    return new Ic(t, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function Dp(n) {
  return new Rg({
    find: n.find,
    handler: ({ state: e, range: t, match: r }) => {
      const i = on(n.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: a } = e, o = r[r.length - 1], s = r[0];
      if (o) {
        const l = s.search(/\S/), u = t.from + s.indexOf(o), c = u + o.length;
        if (IM(t.from, t.to, e.doc).filter((p) => p.mark.type.excluded.find((v) => v === n.type && v !== p.mark.type)).filter((p) => p.to > u).length)
          return null;
        c < t.to && a.delete(c, t.to), u > t.from && a.delete(t.from + l, u);
        const f = t.from + l + o.length;
        a.addMark(t.from + l, f, n.type.create(i || {})), a.removeStoredMark(n.type);
      }
    }
  });
}
function eH(n) {
  return new Rg({
    find: n.find,
    handler: ({ state: e, range: t, match: r }) => {
      const i = on(n.getAttributes, void 0, r) || {}, { tr: a } = e, o = t.from;
      let s = t.to;
      const l = n.type.create(i);
      if (r[1]) {
        const u = r[0].lastIndexOf(r[1]);
        let c = o + u;
        c > s ? c = s : s = c + r[1].length;
        const d = r[0][r[0].length - 1];
        a.insertText(d, o + r[0].length - 1), a.replaceWith(c, s, l);
      } else if (r[0]) {
        const u = n.type.isInline ? o : o - 1;
        a.insert(u, n.type.create(i)).delete(a.mapping.map(o), a.mapping.map(s));
      }
      a.scrollIntoView();
    }
  });
}
function rb(n) {
  return new Rg({
    find: n.find,
    handler: ({ state: e, range: t, match: r }) => {
      const i = e.doc.resolve(t.from), a = on(n.getAttributes, void 0, r) || {};
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), n.type))
        return null;
      e.tr.delete(t.from, t.to).setBlockType(t.from, t.from, n.type, a);
    }
  });
}
function fr(n) {
  return new Rg({
    find: n.find,
    handler: ({ state: e, range: t, match: r }) => {
      let i = n.replace, a = t.from;
      const o = t.to;
      if (r[1]) {
        const s = r[0].lastIndexOf(r[1]);
        i += r[0].slice(s + r[1].length), a += s;
        const l = a - o;
        l > 0 && (i = r[0].slice(s - l, s) + i, a = o);
      }
      e.tr.insertText(i, a, o);
    }
  });
}
function Op(n) {
  return new Rg({
    find: n.find,
    handler: ({ state: e, range: t, match: r, chain: i }) => {
      const a = on(n.getAttributes, void 0, r) || {}, o = e.tr.delete(t.from, t.to), l = o.doc.resolve(t.from).blockRange(), u = l && uM(l, n.type, a);
      if (!u)
        return null;
      if (o.wrap(l, u), n.keepMarks && n.editor) {
        const { selection: d, storedMarks: f } = e, { splittableMarks: p } = n.editor.extensionManager, h = f || d.$to.parentOffset && d.$from.marks();
        if (h) {
          const v = h.filter((m) => p.includes(m.type.name));
          o.ensureMarks(v);
        }
      }
      if (n.keepAttributes) {
        const d = n.type.name === "bulletList" || n.type.name === "orderedList" ? "listItem" : "taskList";
        i().updateAttributes(d, a).run();
      }
      const c = o.doc.resolve(t.from - 1).nodeBefore;
      c && c.type === n.type && Hu(o.doc, t.from - 1) && (!n.joinPredicate || n.joinPredicate(r, c)) && o.join(t.from - 1);
    }
  });
}
let pr = class iC {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = on(vt(this, "addOptions", {
      name: this.name
    }))), this.storage = on(vt(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new iC(e);
  }
  configure(e = {}) {
    const t = this.extend({
      ...this.config,
      addOptions: () => Cx(this.options, e)
    });
    return t.name = this.name, t.parent = this.parent, t;
  }
  extend(e = {}) {
    const t = new iC(e);
    return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = on(vt(t, "addOptions", {
      name: t.name
    })), t.storage = on(vt(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
};
class Kpe {
  constructor(e, t, r) {
    this.isDragging = !1, this.component = e, this.editor = t.editor, this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...r
    }, this.extension = t.extension, this.node = t.node, this.decorations = t.decorations, this.innerDecorations = t.innerDecorations, this.view = t.view, this.HTMLAttributes = t.HTMLAttributes, this.getPos = t.getPos, this.mount();
  }
  mount() {
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(e) {
    var t, r, i, a, o, s, l;
    const { view: u } = this.editor, c = e.target, d = c.nodeType === 3 ? (t = c.parentElement) === null || t === void 0 ? void 0 : t.closest("[data-drag-handle]") : c.closest("[data-drag-handle]");
    if (!this.dom || !((r = this.contentDOM) === null || r === void 0) && r.contains(c) || !d)
      return;
    let f = 0, p = 0;
    if (this.dom !== d) {
      const y = this.dom.getBoundingClientRect(), b = d.getBoundingClientRect(), _ = (i = e.offsetX) !== null && i !== void 0 ? i : (a = e.nativeEvent) === null || a === void 0 ? void 0 : a.offsetX, x = (o = e.offsetY) !== null && o !== void 0 ? o : (s = e.nativeEvent) === null || s === void 0 ? void 0 : s.offsetY;
      f = b.x - y.x + _, p = b.y - y.y + x;
    }
    const h = this.dom.cloneNode(!0);
    (l = e.dataTransfer) === null || l === void 0 || l.setDragImage(h, f, p);
    const v = this.getPos();
    if (typeof v != "number")
      return;
    const m = Ct.create(u.state.doc, v), g = u.state.tr.setSelection(m);
    u.dispatch(g);
  }
  stopEvent(e) {
    var t;
    if (!this.dom)
      return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: e });
    const r = e.target;
    if (!(this.dom.contains(r) && !(!((t = this.contentDOM) === null || t === void 0) && t.contains(r))))
      return !1;
    const a = e.type.startsWith("drag"), o = e.type === "drop";
    if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(r.tagName) || r.isContentEditable) && !o && !a)
      return !0;
    const { isEditable: l } = this.editor, { isDragging: u } = this, c = !!this.node.type.spec.draggable, d = Ct.isSelectable(this.node), f = e.type === "copy", p = e.type === "paste", h = e.type === "cut", v = e.type === "mousedown";
    if (!c && d && a && e.target === this.dom && e.preventDefault(), c && a && !u && e.target === this.dom)
      return e.preventDefault(), !1;
    if (c && l && !u && v) {
      const m = r.closest("[data-drag-handle]");
      m && (this.dom === m || this.dom.contains(m)) && (this.isDragging = !0, document.addEventListener("dragend", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("drop", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("mouseup", () => {
        this.isDragging = !1;
      }, { once: !0 }));
    }
    return !(u || o || f || p || h || v && d);
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? !0 : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (Ax() || U8()) && this.editor.isFocused && [
      ...Array.from(e.addedNodes),
      ...Array.from(e.removedNodes)
    ].every((r) => r.isContentEditable) ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(e) {
    this.editor.commands.command(({ tr: t }) => {
      const r = this.getPos();
      return typeof r != "number" ? !1 : (t.setNodeMarkup(r, void 0, {
        ...this.node.attrs,
        ...e
      }), !0);
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const e = this.getPos();
    if (typeof e != "number")
      return;
    const t = e + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: e, to: t });
  }
}
function Td(n) {
  return new hfe({
    find: n.find,
    handler: ({ state: e, range: t, match: r, pasteEvent: i }) => {
      const a = on(n.getAttributes, void 0, r, i);
      if (a === !1 || a === null)
        return null;
      const { tr: o } = e, s = r[r.length - 1], l = r[0];
      let u = t.to;
      if (s) {
        const c = l.search(/\S/), d = t.from + l.indexOf(s), f = d + s.length;
        if (IM(t.from, t.to, e.doc).filter((h) => h.mark.type.excluded.find((m) => m === n.type && m !== h.mark.type)).filter((h) => h.to > d).length)
          return null;
        f < t.to && o.delete(f, t.to), d > t.from && o.delete(t.from + c, d), u = t.from + c + s.length, o.addMark(t.from + c, u, n.type.create(a || {})), o.removeStoredMark(n.type);
      }
    }
  });
}
function Xpe(n, e) {
  const { selection: t } = n, { $from: r } = t;
  if (t instanceof Ct) {
    const a = r.index();
    return r.parent.canReplaceWith(a, a + 1, e);
  }
  let i = r.depth;
  for (; i >= 0; ) {
    const a = r.index(i);
    if (r.node(i).contentMatchAt(a).matchType(e))
      return !0;
    i -= 1;
  }
  return !1;
}
function Zpe(n) {
  return n.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var Qi = "top", Qa = "bottom", eo = "right", ea = "left", LM = "auto", Pg = [Qi, Qa, eo, ea], Ip = "start", Pm = "end", Jpe = "clippingParents", tH = "viewport", Ph = "popper", Qpe = "reference", YN = /* @__PURE__ */ Pg.reduce(function(n, e) {
  return n.concat([e + "-" + Ip, e + "-" + Pm]);
}, []), nH = /* @__PURE__ */ [].concat(Pg, [LM]).reduce(function(n, e) {
  return n.concat([e, e + "-" + Ip, e + "-" + Pm]);
}, []), ehe = "beforeRead", the = "read", nhe = "afterRead", rhe = "beforeMain", ihe = "main", ahe = "afterMain", ohe = "beforeWrite", she = "write", lhe = "afterWrite", uhe = [ehe, the, nhe, rhe, ihe, ahe, ohe, she, lhe];
function _s(n) {
  return n ? (n.nodeName || "").toLowerCase() : null;
}
function xa(n) {
  if (n == null)
    return window;
  if (n.toString() !== "[object Window]") {
    var e = n.ownerDocument;
    return e && e.defaultView || window;
  }
  return n;
}
function Cd(n) {
  var e = xa(n).Element;
  return n instanceof e || n instanceof Element;
}
function Xa(n) {
  var e = xa(n).HTMLElement;
  return n instanceof e || n instanceof HTMLElement;
}
function NM(n) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = xa(n).ShadowRoot;
  return n instanceof e || n instanceof ShadowRoot;
}
function che(n) {
  var e = n.state;
  Object.keys(e.elements).forEach(function(t) {
    var r = e.styles[t] || {}, i = e.attributes[t] || {}, a = e.elements[t];
    !Xa(a) || !_s(a) || (Object.assign(a.style, r), Object.keys(i).forEach(function(o) {
      var s = i[o];
      s === !1 ? a.removeAttribute(o) : a.setAttribute(o, s === !0 ? "" : s);
    }));
  });
}
function dhe(n) {
  var e = n.state, t = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var i = e.elements[r], a = e.attributes[r] || {}, o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : t[r]), s = o.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !Xa(i) || !_s(i) || (Object.assign(i.style, s), Object.keys(a).forEach(function(l) {
        i.removeAttribute(l);
      }));
    });
  };
}
const rH = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: che,
  effect: dhe,
  requires: ["computeStyles"]
};
function fs(n) {
  return n.split("-")[0];
}
var id = Math.max, ib = Math.min, Lp = Math.round;
function aC() {
  var n = navigator.userAgentData;
  return n != null && n.brands && Array.isArray(n.brands) ? n.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function iH() {
  return !/^((?!chrome|android).)*safari/i.test(aC());
}
function Np(n, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  var r = n.getBoundingClientRect(), i = 1, a = 1;
  e && Xa(n) && (i = n.offsetWidth > 0 && Lp(r.width) / n.offsetWidth || 1, a = n.offsetHeight > 0 && Lp(r.height) / n.offsetHeight || 1);
  var o = Cd(n) ? xa(n) : window, s = o.visualViewport, l = !iH() && t, u = (r.left + (l && s ? s.offsetLeft : 0)) / i, c = (r.top + (l && s ? s.offsetTop : 0)) / a, d = r.width / i, f = r.height / a;
  return {
    width: d,
    height: f,
    top: c,
    right: u + d,
    bottom: c + f,
    left: u,
    x: u,
    y: c
  };
}
function RM(n) {
  var e = Np(n), t = n.offsetWidth, r = n.offsetHeight;
  return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
    x: n.offsetLeft,
    y: n.offsetTop,
    width: t,
    height: r
  };
}
function aH(n, e) {
  var t = e.getRootNode && e.getRootNode();
  if (n.contains(e))
    return !0;
  if (t && NM(t)) {
    var r = e;
    do {
      if (r && n.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function yl(n) {
  return xa(n).getComputedStyle(n);
}
function fhe(n) {
  return ["table", "td", "th"].indexOf(_s(n)) >= 0;
}
function Wu(n) {
  return ((Cd(n) ? n.ownerDocument : (
    // $FlowFixMe[prop-missing]
    n.document
  )) || window.document).documentElement;
}
function Ox(n) {
  return _s(n) === "html" ? n : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    n.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    n.parentNode || // DOM Element detected
    (NM(n) ? n.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Wu(n)
  );
}
function KN(n) {
  return !Xa(n) || // https://github.com/popperjs/popper-core/issues/837
  yl(n).position === "fixed" ? null : n.offsetParent;
}
function phe(n) {
  var e = /firefox/i.test(aC()), t = /Trident/i.test(aC());
  if (t && Xa(n)) {
    var r = yl(n);
    if (r.position === "fixed")
      return null;
  }
  var i = Ox(n);
  for (NM(i) && (i = i.host); Xa(i) && ["html", "body"].indexOf(_s(i)) < 0; ) {
    var a = yl(i);
    if (a.transform !== "none" || a.perspective !== "none" || a.contain === "paint" || ["transform", "perspective"].indexOf(a.willChange) !== -1 || e && a.willChange === "filter" || e && a.filter && a.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function jg(n) {
  for (var e = xa(n), t = KN(n); t && fhe(t) && yl(t).position === "static"; )
    t = KN(t);
  return t && (_s(t) === "html" || _s(t) === "body" && yl(t).position === "static") ? e : t || phe(n) || e;
}
function PM(n) {
  return ["top", "bottom"].indexOf(n) >= 0 ? "x" : "y";
}
function Wv(n, e, t) {
  return id(n, ib(e, t));
}
function hhe(n, e, t) {
  var r = Wv(n, e, t);
  return r > t ? t : r;
}
function oH() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function sH(n) {
  return Object.assign({}, oH(), n);
}
function lH(n, e) {
  return e.reduce(function(t, r) {
    return t[r] = n, t;
  }, {});
}
var vhe = function(e, t) {
  return e = typeof e == "function" ? e(Object.assign({}, t.rects, {
    placement: t.placement
  })) : e, sH(typeof e != "number" ? e : lH(e, Pg));
};
function mhe(n) {
  var e, t = n.state, r = n.name, i = n.options, a = t.elements.arrow, o = t.modifiersData.popperOffsets, s = fs(t.placement), l = PM(s), u = [ea, eo].indexOf(s) >= 0, c = u ? "height" : "width";
  if (!(!a || !o)) {
    var d = vhe(i.padding, t), f = RM(a), p = l === "y" ? Qi : ea, h = l === "y" ? Qa : eo, v = t.rects.reference[c] + t.rects.reference[l] - o[l] - t.rects.popper[c], m = o[l] - t.rects.reference[l], g = jg(a), y = g ? l === "y" ? g.clientHeight || 0 : g.clientWidth || 0 : 0, b = v / 2 - m / 2, _ = d[p], x = y - f[c] - d[h], w = y / 2 - f[c] / 2 + b, S = Wv(_, w, x), C = l;
    t.modifiersData[r] = (e = {}, e[C] = S, e.centerOffset = S - w, e);
  }
}
function ghe(n) {
  var e = n.state, t = n.options, r = t.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || aH(e.elements.popper, i) && (e.elements.arrow = i));
}
const yhe = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: mhe,
  effect: ghe,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Rp(n) {
  return n.split("-")[1];
}
var bhe = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function _he(n, e) {
  var t = n.x, r = n.y, i = e.devicePixelRatio || 1;
  return {
    x: Lp(t * i) / i || 0,
    y: Lp(r * i) / i || 0
  };
}
function XN(n) {
  var e, t = n.popper, r = n.popperRect, i = n.placement, a = n.variation, o = n.offsets, s = n.position, l = n.gpuAcceleration, u = n.adaptive, c = n.roundOffsets, d = n.isFixed, f = o.x, p = f === void 0 ? 0 : f, h = o.y, v = h === void 0 ? 0 : h, m = typeof c == "function" ? c({
    x: p,
    y: v
  }) : {
    x: p,
    y: v
  };
  p = m.x, v = m.y;
  var g = o.hasOwnProperty("x"), y = o.hasOwnProperty("y"), b = ea, _ = Qi, x = window;
  if (u) {
    var w = jg(t), S = "clientHeight", C = "clientWidth";
    if (w === xa(t) && (w = Wu(t), yl(w).position !== "static" && s === "absolute" && (S = "scrollHeight", C = "scrollWidth")), w = w, i === Qi || (i === ea || i === eo) && a === Pm) {
      _ = Qa;
      var k = d && w === x && x.visualViewport ? x.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        w[S]
      );
      v -= k - r.height, v *= l ? 1 : -1;
    }
    if (i === ea || (i === Qi || i === Qa) && a === Pm) {
      b = eo;
      var M = d && w === x && x.visualViewport ? x.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        w[C]
      );
      p -= M - r.width, p *= l ? 1 : -1;
    }
  }
  var D = Object.assign({
    position: s
  }, u && bhe), N = c === !0 ? _he({
    x: p,
    y: v
  }, xa(t)) : {
    x: p,
    y: v
  };
  if (p = N.x, v = N.y, l) {
    var R;
    return Object.assign({}, D, (R = {}, R[_] = y ? "0" : "", R[b] = g ? "0" : "", R.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + v + "px)" : "translate3d(" + p + "px, " + v + "px, 0)", R));
  }
  return Object.assign({}, D, (e = {}, e[_] = y ? v + "px" : "", e[b] = g ? p + "px" : "", e.transform = "", e));
}
function xhe(n) {
  var e = n.state, t = n.options, r = t.gpuAcceleration, i = r === void 0 ? !0 : r, a = t.adaptive, o = a === void 0 ? !0 : a, s = t.roundOffsets, l = s === void 0 ? !0 : s, u = {
    placement: fs(e.placement),
    variation: Rp(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: i,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, XN(Object.assign({}, u, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: o,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, XN(Object.assign({}, u, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const whe = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: xhe,
  data: {}
};
var Oy = {
  passive: !0
};
function She(n) {
  var e = n.state, t = n.instance, r = n.options, i = r.scroll, a = i === void 0 ? !0 : i, o = r.resize, s = o === void 0 ? !0 : o, l = xa(e.elements.popper), u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return a && u.forEach(function(c) {
    c.addEventListener("scroll", t.update, Oy);
  }), s && l.addEventListener("resize", t.update, Oy), function() {
    a && u.forEach(function(c) {
      c.removeEventListener("scroll", t.update, Oy);
    }), s && l.removeEventListener("resize", t.update, Oy);
  };
}
const Ehe = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: She,
  data: {}
};
var The = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function s1(n) {
  return n.replace(/left|right|bottom|top/g, function(e) {
    return The[e];
  });
}
var Che = {
  start: "end",
  end: "start"
};
function ZN(n) {
  return n.replace(/start|end/g, function(e) {
    return Che[e];
  });
}
function jM(n) {
  var e = xa(n), t = e.pageXOffset, r = e.pageYOffset;
  return {
    scrollLeft: t,
    scrollTop: r
  };
}
function BM(n) {
  return Np(Wu(n)).left + jM(n).scrollLeft;
}
function khe(n, e) {
  var t = xa(n), r = Wu(n), i = t.visualViewport, a = r.clientWidth, o = r.clientHeight, s = 0, l = 0;
  if (i) {
    a = i.width, o = i.height;
    var u = iH();
    (u || !u && e === "fixed") && (s = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: a,
    height: o,
    x: s + BM(n),
    y: l
  };
}
function Ahe(n) {
  var e, t = Wu(n), r = jM(n), i = (e = n.ownerDocument) == null ? void 0 : e.body, a = id(t.scrollWidth, t.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = id(t.scrollHeight, t.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), s = -r.scrollLeft + BM(n), l = -r.scrollTop;
  return yl(i || t).direction === "rtl" && (s += id(t.clientWidth, i ? i.clientWidth : 0) - a), {
    width: a,
    height: o,
    x: s,
    y: l
  };
}
function $M(n) {
  var e = yl(n), t = e.overflow, r = e.overflowX, i = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(t + i + r);
}
function uH(n) {
  return ["html", "body", "#document"].indexOf(_s(n)) >= 0 ? n.ownerDocument.body : Xa(n) && $M(n) ? n : uH(Ox(n));
}
function qv(n, e) {
  var t;
  e === void 0 && (e = []);
  var r = uH(n), i = r === ((t = n.ownerDocument) == null ? void 0 : t.body), a = xa(r), o = i ? [a].concat(a.visualViewport || [], $M(r) ? r : []) : r, s = e.concat(o);
  return i ? s : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    s.concat(qv(Ox(o)))
  );
}
function oC(n) {
  return Object.assign({}, n, {
    left: n.x,
    top: n.y,
    right: n.x + n.width,
    bottom: n.y + n.height
  });
}
function Mhe(n, e) {
  var t = Np(n, !1, e === "fixed");
  return t.top = t.top + n.clientTop, t.left = t.left + n.clientLeft, t.bottom = t.top + n.clientHeight, t.right = t.left + n.clientWidth, t.width = n.clientWidth, t.height = n.clientHeight, t.x = t.left, t.y = t.top, t;
}
function JN(n, e, t) {
  return e === tH ? oC(khe(n, t)) : Cd(e) ? Mhe(e, t) : oC(Ahe(Wu(n)));
}
function Dhe(n) {
  var e = qv(Ox(n)), t = ["absolute", "fixed"].indexOf(yl(n).position) >= 0, r = t && Xa(n) ? jg(n) : n;
  return Cd(r) ? e.filter(function(i) {
    return Cd(i) && aH(i, r) && _s(i) !== "body";
  }) : [];
}
function Ohe(n, e, t, r) {
  var i = e === "clippingParents" ? Dhe(n) : [].concat(e), a = [].concat(i, [t]), o = a[0], s = a.reduce(function(l, u) {
    var c = JN(n, u, r);
    return l.top = id(c.top, l.top), l.right = ib(c.right, l.right), l.bottom = ib(c.bottom, l.bottom), l.left = id(c.left, l.left), l;
  }, JN(n, o, r));
  return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s;
}
function cH(n) {
  var e = n.reference, t = n.element, r = n.placement, i = r ? fs(r) : null, a = r ? Rp(r) : null, o = e.x + e.width / 2 - t.width / 2, s = e.y + e.height / 2 - t.height / 2, l;
  switch (i) {
    case Qi:
      l = {
        x: o,
        y: e.y - t.height
      };
      break;
    case Qa:
      l = {
        x: o,
        y: e.y + e.height
      };
      break;
    case eo:
      l = {
        x: e.x + e.width,
        y: s
      };
      break;
    case ea:
      l = {
        x: e.x - t.width,
        y: s
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var u = i ? PM(i) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (a) {
      case Ip:
        l[u] = l[u] - (e[c] / 2 - t[c] / 2);
        break;
      case Pm:
        l[u] = l[u] + (e[c] / 2 - t[c] / 2);
        break;
    }
  }
  return l;
}
function jm(n, e) {
  e === void 0 && (e = {});
  var t = e, r = t.placement, i = r === void 0 ? n.placement : r, a = t.strategy, o = a === void 0 ? n.strategy : a, s = t.boundary, l = s === void 0 ? Jpe : s, u = t.rootBoundary, c = u === void 0 ? tH : u, d = t.elementContext, f = d === void 0 ? Ph : d, p = t.altBoundary, h = p === void 0 ? !1 : p, v = t.padding, m = v === void 0 ? 0 : v, g = sH(typeof m != "number" ? m : lH(m, Pg)), y = f === Ph ? Qpe : Ph, b = n.rects.popper, _ = n.elements[h ? y : f], x = Ohe(Cd(_) ? _ : _.contextElement || Wu(n.elements.popper), l, c, o), w = Np(n.elements.reference), S = cH({
    reference: w,
    element: b,
    placement: i
  }), C = oC(Object.assign({}, b, S)), k = f === Ph ? C : w, M = {
    top: x.top - k.top + g.top,
    bottom: k.bottom - x.bottom + g.bottom,
    left: x.left - k.left + g.left,
    right: k.right - x.right + g.right
  }, D = n.modifiersData.offset;
  if (f === Ph && D) {
    var N = D[i];
    Object.keys(M).forEach(function(R) {
      var j = [eo, Qa].indexOf(R) >= 0 ? 1 : -1, z = [Qi, Qa].indexOf(R) >= 0 ? "y" : "x";
      M[R] += N[z] * j;
    });
  }
  return M;
}
function Ihe(n, e) {
  e === void 0 && (e = {});
  var t = e, r = t.placement, i = t.boundary, a = t.rootBoundary, o = t.padding, s = t.flipVariations, l = t.allowedAutoPlacements, u = l === void 0 ? nH : l, c = Rp(r), d = c ? s ? YN : YN.filter(function(h) {
    return Rp(h) === c;
  }) : Pg, f = d.filter(function(h) {
    return u.indexOf(h) >= 0;
  });
  f.length === 0 && (f = d);
  var p = f.reduce(function(h, v) {
    return h[v] = jm(n, {
      placement: v,
      boundary: i,
      rootBoundary: a,
      padding: o
    })[fs(v)], h;
  }, {});
  return Object.keys(p).sort(function(h, v) {
    return p[h] - p[v];
  });
}
function Lhe(n) {
  if (fs(n) === LM)
    return [];
  var e = s1(n);
  return [ZN(n), e, ZN(e)];
}
function Nhe(n) {
  var e = n.state, t = n.options, r = n.name;
  if (!e.modifiersData[r]._skip) {
    for (var i = t.mainAxis, a = i === void 0 ? !0 : i, o = t.altAxis, s = o === void 0 ? !0 : o, l = t.fallbackPlacements, u = t.padding, c = t.boundary, d = t.rootBoundary, f = t.altBoundary, p = t.flipVariations, h = p === void 0 ? !0 : p, v = t.allowedAutoPlacements, m = e.options.placement, g = fs(m), y = g === m, b = l || (y || !h ? [s1(m)] : Lhe(m)), _ = [m].concat(b).reduce(function(ye, pe) {
      return ye.concat(fs(pe) === LM ? Ihe(e, {
        placement: pe,
        boundary: c,
        rootBoundary: d,
        padding: u,
        flipVariations: h,
        allowedAutoPlacements: v
      }) : pe);
    }, []), x = e.rects.reference, w = e.rects.popper, S = /* @__PURE__ */ new Map(), C = !0, k = _[0], M = 0; M < _.length; M++) {
      var D = _[M], N = fs(D), R = Rp(D) === Ip, j = [Qi, Qa].indexOf(N) >= 0, z = j ? "width" : "height", F = jm(e, {
        placement: D,
        boundary: c,
        rootBoundary: d,
        altBoundary: f,
        padding: u
      }), B = j ? R ? eo : ea : R ? Qa : Qi;
      x[z] > w[z] && (B = s1(B));
      var H = s1(B), Y = [];
      if (a && Y.push(F[N] <= 0), s && Y.push(F[B] <= 0, F[H] <= 0), Y.every(function(ye) {
        return ye;
      })) {
        k = D, C = !1;
        break;
      }
      S.set(D, Y);
    }
    if (C)
      for (var ne = h ? 3 : 1, J = function(pe) {
        var Be = _.find(function(Ce) {
          var Ee = S.get(Ce);
          if (Ee)
            return Ee.slice(0, pe).every(function(ce) {
              return ce;
            });
        });
        if (Be)
          return k = Be, "break";
      }, X = ne; X > 0; X--) {
        var ie = J(X);
        if (ie === "break") break;
      }
    e.placement !== k && (e.modifiersData[r]._skip = !0, e.placement = k, e.reset = !0);
  }
}
const Rhe = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Nhe,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function QN(n, e, t) {
  return t === void 0 && (t = {
    x: 0,
    y: 0
  }), {
    top: n.top - e.height - t.y,
    right: n.right - e.width + t.x,
    bottom: n.bottom - e.height + t.y,
    left: n.left - e.width - t.x
  };
}
function eR(n) {
  return [Qi, eo, Qa, ea].some(function(e) {
    return n[e] >= 0;
  });
}
function Phe(n) {
  var e = n.state, t = n.name, r = e.rects.reference, i = e.rects.popper, a = e.modifiersData.preventOverflow, o = jm(e, {
    elementContext: "reference"
  }), s = jm(e, {
    altBoundary: !0
  }), l = QN(o, r), u = QN(s, i, a), c = eR(l), d = eR(u);
  e.modifiersData[t] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: u,
    isReferenceHidden: c,
    hasPopperEscaped: d
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": c,
    "data-popper-escaped": d
  });
}
const jhe = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Phe
};
function Bhe(n, e, t) {
  var r = fs(n), i = [ea, Qi].indexOf(r) >= 0 ? -1 : 1, a = typeof t == "function" ? t(Object.assign({}, e, {
    placement: n
  })) : t, o = a[0], s = a[1];
  return o = o || 0, s = (s || 0) * i, [ea, eo].indexOf(r) >= 0 ? {
    x: s,
    y: o
  } : {
    x: o,
    y: s
  };
}
function $he(n) {
  var e = n.state, t = n.options, r = n.name, i = t.offset, a = i === void 0 ? [0, 0] : i, o = nH.reduce(function(c, d) {
    return c[d] = Bhe(d, e.rects, a), c;
  }, {}), s = o[e.placement], l = s.x, u = s.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += u), e.modifiersData[r] = o;
}
const zhe = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: $he
};
function Fhe(n) {
  var e = n.state, t = n.name;
  e.modifiersData[t] = cH({
    reference: e.rects.reference,
    element: e.rects.popper,
    placement: e.placement
  });
}
const Vhe = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: Fhe,
  data: {}
};
function Hhe(n) {
  return n === "x" ? "y" : "x";
}
function Ghe(n) {
  var e = n.state, t = n.options, r = n.name, i = t.mainAxis, a = i === void 0 ? !0 : i, o = t.altAxis, s = o === void 0 ? !1 : o, l = t.boundary, u = t.rootBoundary, c = t.altBoundary, d = t.padding, f = t.tether, p = f === void 0 ? !0 : f, h = t.tetherOffset, v = h === void 0 ? 0 : h, m = jm(e, {
    boundary: l,
    rootBoundary: u,
    padding: d,
    altBoundary: c
  }), g = fs(e.placement), y = Rp(e.placement), b = !y, _ = PM(g), x = Hhe(_), w = e.modifiersData.popperOffsets, S = e.rects.reference, C = e.rects.popper, k = typeof v == "function" ? v(Object.assign({}, e.rects, {
    placement: e.placement
  })) : v, M = typeof k == "number" ? {
    mainAxis: k,
    altAxis: k
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, k), D = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, N = {
    x: 0,
    y: 0
  };
  if (w) {
    if (a) {
      var R, j = _ === "y" ? Qi : ea, z = _ === "y" ? Qa : eo, F = _ === "y" ? "height" : "width", B = w[_], H = B + m[j], Y = B - m[z], ne = p ? -C[F] / 2 : 0, J = y === Ip ? S[F] : C[F], X = y === Ip ? -C[F] : -S[F], ie = e.elements.arrow, ye = p && ie ? RM(ie) : {
        width: 0,
        height: 0
      }, pe = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : oH(), Be = pe[j], Ce = pe[z], Ee = Wv(0, S[F], ye[F]), ce = b ? S[F] / 2 - ne - Ee - Be - M.mainAxis : J - Ee - Be - M.mainAxis, Pe = b ? -S[F] / 2 + ne + Ee + Ce + M.mainAxis : X + Ee + Ce + M.mainAxis, Ae = e.elements.arrow && jg(e.elements.arrow), fe = Ae ? _ === "y" ? Ae.clientTop || 0 : Ae.clientLeft || 0 : 0, oe = (R = D == null ? void 0 : D[_]) != null ? R : 0, he = B + ce - oe - fe, Oe = B + Pe - oe, Te = Wv(p ? ib(H, he) : H, B, p ? id(Y, Oe) : Y);
      w[_] = Te, N[_] = Te - B;
    }
    if (s) {
      var Ge, je = _ === "x" ? Qi : ea, Qe = _ === "x" ? Qa : eo, ot = w[x], it = x === "y" ? "height" : "width", Nt = ot + m[je], Le = ot - m[Qe], ft = [Qi, ea].indexOf(g) !== -1, Rt = (Ge = D == null ? void 0 : D[x]) != null ? Ge : 0, Re = ft ? Nt : ot - S[it] - C[it] - Rt + M.altAxis, be = ft ? ot + S[it] + C[it] - Rt - M.altAxis : Le, we = p && ft ? hhe(Re, ot, be) : Wv(p ? Re : Nt, ot, p ? be : Le);
      w[x] = we, N[x] = we - ot;
    }
    e.modifiersData[r] = N;
  }
}
const Uhe = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: Ghe,
  requiresIfExists: ["offset"]
};
function Whe(n) {
  return {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  };
}
function qhe(n) {
  return n === xa(n) || !Xa(n) ? jM(n) : Whe(n);
}
function Yhe(n) {
  var e = n.getBoundingClientRect(), t = Lp(e.width) / n.offsetWidth || 1, r = Lp(e.height) / n.offsetHeight || 1;
  return t !== 1 || r !== 1;
}
function Khe(n, e, t) {
  t === void 0 && (t = !1);
  var r = Xa(e), i = Xa(e) && Yhe(e), a = Wu(e), o = Np(n, i, t), s = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (r || !r && !t) && ((_s(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  $M(a)) && (s = qhe(e)), Xa(e) ? (l = Np(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : a && (l.x = BM(a))), {
    x: o.left + s.scrollLeft - l.x,
    y: o.top + s.scrollTop - l.y,
    width: o.width,
    height: o.height
  };
}
function Xhe(n) {
  var e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set(), r = [];
  n.forEach(function(a) {
    e.set(a.name, a);
  });
  function i(a) {
    t.add(a.name);
    var o = [].concat(a.requires || [], a.requiresIfExists || []);
    o.forEach(function(s) {
      if (!t.has(s)) {
        var l = e.get(s);
        l && i(l);
      }
    }), r.push(a);
  }
  return n.forEach(function(a) {
    t.has(a.name) || i(a);
  }), r;
}
function Zhe(n) {
  var e = Xhe(n);
  return uhe.reduce(function(t, r) {
    return t.concat(e.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function Jhe(n) {
  var e;
  return function() {
    return e || (e = new Promise(function(t) {
      Promise.resolve().then(function() {
        e = void 0, t(n());
      });
    })), e;
  };
}
function Qhe(n) {
  var e = n.reduce(function(t, r) {
    var i = t[r.name];
    return t[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, t;
  }, {});
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}
var tR = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function nR() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function eve(n) {
  n === void 0 && (n = {});
  var e = n, t = e.defaultModifiers, r = t === void 0 ? [] : t, i = e.defaultOptions, a = i === void 0 ? tR : i;
  return function(s, l, u) {
    u === void 0 && (u = a);
    var c = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, tR, a),
      modifiersData: {},
      elements: {
        reference: s,
        popper: l
      },
      attributes: {},
      styles: {}
    }, d = [], f = !1, p = {
      state: c,
      setOptions: function(g) {
        var y = typeof g == "function" ? g(c.options) : g;
        v(), c.options = Object.assign({}, a, c.options, y), c.scrollParents = {
          reference: Cd(s) ? qv(s) : s.contextElement ? qv(s.contextElement) : [],
          popper: qv(l)
        };
        var b = Zhe(Qhe([].concat(r, c.options.modifiers)));
        return c.orderedModifiers = b.filter(function(_) {
          return _.enabled;
        }), h(), p.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var g = c.elements, y = g.reference, b = g.popper;
          if (nR(y, b)) {
            c.rects = {
              reference: Khe(y, jg(b), c.options.strategy === "fixed"),
              popper: RM(b)
            }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(M) {
              return c.modifiersData[M.name] = Object.assign({}, M.data);
            });
            for (var _ = 0; _ < c.orderedModifiers.length; _++) {
              if (c.reset === !0) {
                c.reset = !1, _ = -1;
                continue;
              }
              var x = c.orderedModifiers[_], w = x.fn, S = x.options, C = S === void 0 ? {} : S, k = x.name;
              typeof w == "function" && (c = w({
                state: c,
                options: C,
                name: k,
                instance: p
              }) || c);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: Jhe(function() {
        return new Promise(function(m) {
          p.forceUpdate(), m(c);
        });
      }),
      destroy: function() {
        v(), f = !0;
      }
    };
    if (!nR(s, l))
      return p;
    p.setOptions(u).then(function(m) {
      !f && u.onFirstUpdate && u.onFirstUpdate(m);
    });
    function h() {
      c.orderedModifiers.forEach(function(m) {
        var g = m.name, y = m.options, b = y === void 0 ? {} : y, _ = m.effect;
        if (typeof _ == "function") {
          var x = _({
            state: c,
            name: g,
            instance: p,
            options: b
          }), w = function() {
          };
          d.push(x || w);
        }
      });
    }
    function v() {
      d.forEach(function(m) {
        return m();
      }), d = [];
    }
    return p;
  };
}
var tve = [Ehe, Vhe, whe, rH, zhe, Rhe, Uhe, yhe, jhe], dH = /* @__PURE__ */ eve({
  defaultModifiers: tve
}), nve = "tippy-box", fH = "tippy-content", rve = "tippy-backdrop", pH = "tippy-arrow", hH = "tippy-svg-arrow", Sc = {
  passive: !0,
  capture: !0
}, vH = function() {
  return document.body;
};
function ive(n, e) {
  return {}.hasOwnProperty.call(n, e);
}
function yS(n, e, t) {
  if (Array.isArray(n)) {
    var r = n[e];
    return r ?? (Array.isArray(t) ? t[e] : t);
  }
  return n;
}
function zM(n, e) {
  var t = {}.toString.call(n);
  return t.indexOf("[object") === 0 && t.indexOf(e + "]") > -1;
}
function mH(n, e) {
  return typeof n == "function" ? n.apply(void 0, e) : n;
}
function rR(n, e) {
  if (e === 0)
    return n;
  var t;
  return function(r) {
    clearTimeout(t), t = setTimeout(function() {
      n(r);
    }, e);
  };
}
function ave(n, e) {
  var t = Object.assign({}, n);
  return e.forEach(function(r) {
    delete t[r];
  }), t;
}
function ove(n) {
  return n.split(/\s+/).filter(Boolean);
}
function qf(n) {
  return [].concat(n);
}
function iR(n, e) {
  n.indexOf(e) === -1 && n.push(e);
}
function sve(n) {
  return n.filter(function(e, t) {
    return n.indexOf(e) === t;
  });
}
function lve(n) {
  return n.split("-")[0];
}
function ab(n) {
  return [].slice.call(n);
}
function aR(n) {
  return Object.keys(n).reduce(function(e, t) {
    return n[t] !== void 0 && (e[t] = n[t]), e;
  }, {});
}
function Yv() {
  return document.createElement("div");
}
function Bm(n) {
  return ["Element", "Fragment"].some(function(e) {
    return zM(n, e);
  });
}
function uve(n) {
  return zM(n, "NodeList");
}
function cve(n) {
  return zM(n, "MouseEvent");
}
function dve(n) {
  return !!(n && n._tippy && n._tippy.reference === n);
}
function fve(n) {
  return Bm(n) ? [n] : uve(n) ? ab(n) : Array.isArray(n) ? n : ab(document.querySelectorAll(n));
}
function bS(n, e) {
  n.forEach(function(t) {
    t && (t.style.transitionDuration = e + "ms");
  });
}
function oR(n, e) {
  n.forEach(function(t) {
    t && t.setAttribute("data-state", e);
  });
}
function pve(n) {
  var e, t = qf(n), r = t[0];
  return r != null && (e = r.ownerDocument) != null && e.body ? r.ownerDocument : document;
}
function hve(n, e) {
  var t = e.clientX, r = e.clientY;
  return n.every(function(i) {
    var a = i.popperRect, o = i.popperState, s = i.props, l = s.interactiveBorder, u = lve(o.placement), c = o.modifiersData.offset;
    if (!c)
      return !0;
    var d = u === "bottom" ? c.top.y : 0, f = u === "top" ? c.bottom.y : 0, p = u === "right" ? c.left.x : 0, h = u === "left" ? c.right.x : 0, v = a.top - r + d > l, m = r - a.bottom - f > l, g = a.left - t + p > l, y = t - a.right - h > l;
    return v || m || g || y;
  });
}
function _S(n, e, t) {
  var r = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(i) {
    n[r](i, t);
  });
}
function sR(n, e) {
  for (var t = e; t; ) {
    var r;
    if (n.contains(t))
      return !0;
    t = t.getRootNode == null || (r = t.getRootNode()) == null ? void 0 : r.host;
  }
  return !1;
}
var Qo = {
  isTouch: !1
}, lR = 0;
function vve() {
  Qo.isTouch || (Qo.isTouch = !0, window.performance && document.addEventListener("mousemove", gH));
}
function gH() {
  var n = performance.now();
  n - lR < 20 && (Qo.isTouch = !1, document.removeEventListener("mousemove", gH)), lR = n;
}
function mve() {
  var n = document.activeElement;
  if (dve(n)) {
    var e = n._tippy;
    n.blur && !e.state.isVisible && n.blur();
  }
}
function gve() {
  document.addEventListener("touchstart", vve, Sc), window.addEventListener("blur", mve);
}
var yve = typeof window < "u" && typeof document < "u", bve = yve ? (
  // @ts-ignore
  !!window.msCrypto
) : !1;
function mf(n) {
  var e = n === "destroy" ? "n already-" : " ";
  return [n + "() was called on a" + e + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function uR(n) {
  var e = /[ \t]{2,}/g, t = /^[ \t]*/gm;
  return n.replace(e, " ").replace(t, "").trim();
}
function _ve(n) {
  return uR(`
  %ctippy.js

  %c` + uR(n) + `

  %c👷‍ This is a development-only message. It will be removed in production.
  `);
}
function yH(n) {
  return [
    _ve(n),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var $m;
process.env.NODE_ENV !== "production" && xve();
function xve() {
  $m = /* @__PURE__ */ new Set();
}
function Ws(n, e) {
  if (n && !$m.has(e)) {
    var t;
    $m.add(e), (t = console).warn.apply(t, yH(e));
  }
}
function sC(n, e) {
  if (n && !$m.has(e)) {
    var t;
    $m.add(e), (t = console).error.apply(t, yH(e));
  }
}
function wve(n) {
  var e = !n, t = Object.prototype.toString.call(n) === "[object Object]" && !n.addEventListener;
  sC(e, ["tippy() was passed", "`" + String(n) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), sC(t, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var bH = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, Sve = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, da = Object.assign({
  appendTo: vH,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, bH, Sve), Eve = Object.keys(da), Tve = function(e) {
  process.env.NODE_ENV !== "production" && xH(e, []);
  var t = Object.keys(e);
  t.forEach(function(r) {
    da[r] = e[r];
  });
};
function _H(n) {
  var e = n.plugins || [], t = e.reduce(function(r, i) {
    var a = i.name, o = i.defaultValue;
    if (a) {
      var s;
      r[a] = n[a] !== void 0 ? n[a] : (s = da[a]) != null ? s : o;
    }
    return r;
  }, {});
  return Object.assign({}, n, t);
}
function Cve(n, e) {
  var t = e ? Object.keys(_H(Object.assign({}, da, {
    plugins: e
  }))) : Eve, r = t.reduce(function(i, a) {
    var o = (n.getAttribute("data-tippy-" + a) || "").trim();
    if (!o)
      return i;
    if (a === "content")
      i[a] = o;
    else
      try {
        i[a] = JSON.parse(o);
      } catch {
        i[a] = o;
      }
    return i;
  }, {});
  return r;
}
function cR(n, e) {
  var t = Object.assign({}, e, {
    content: mH(e.content, [n])
  }, e.ignoreAttributes ? {} : Cve(n, e.plugins));
  return t.aria = Object.assign({}, da.aria, t.aria), t.aria = {
    expanded: t.aria.expanded === "auto" ? e.interactive : t.aria.expanded,
    content: t.aria.content === "auto" ? e.interactive ? null : "describedby" : t.aria.content
  }, t;
}
function xH(n, e) {
  n === void 0 && (n = {}), e === void 0 && (e = []);
  var t = Object.keys(n);
  t.forEach(function(r) {
    var i = ave(da, Object.keys(bH)), a = !ive(i, r);
    a && (a = e.filter(function(o) {
      return o.name === r;
    }).length === 0), Ws(a, ["`" + r + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var kve = function() {
  return "innerHTML";
};
function lC(n, e) {
  n[kve()] = e;
}
function dR(n) {
  var e = Yv();
  return n === !0 ? e.className = pH : (e.className = hH, Bm(n) ? e.appendChild(n) : lC(e, n)), e;
}
function fR(n, e) {
  Bm(e.content) ? (lC(n, ""), n.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? lC(n, e.content) : n.textContent = e.content);
}
function uC(n) {
  var e = n.firstElementChild, t = ab(e.children);
  return {
    box: e,
    content: t.find(function(r) {
      return r.classList.contains(fH);
    }),
    arrow: t.find(function(r) {
      return r.classList.contains(pH) || r.classList.contains(hH);
    }),
    backdrop: t.find(function(r) {
      return r.classList.contains(rve);
    })
  };
}
function wH(n) {
  var e = Yv(), t = Yv();
  t.className = nve, t.setAttribute("data-state", "hidden"), t.setAttribute("tabindex", "-1");
  var r = Yv();
  r.className = fH, r.setAttribute("data-state", "hidden"), fR(r, n.props), e.appendChild(t), t.appendChild(r), i(n.props, n.props);
  function i(a, o) {
    var s = uC(e), l = s.box, u = s.content, c = s.arrow;
    o.theme ? l.setAttribute("data-theme", o.theme) : l.removeAttribute("data-theme"), typeof o.animation == "string" ? l.setAttribute("data-animation", o.animation) : l.removeAttribute("data-animation"), o.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof o.maxWidth == "number" ? o.maxWidth + "px" : o.maxWidth, o.role ? l.setAttribute("role", o.role) : l.removeAttribute("role"), (a.content !== o.content || a.allowHTML !== o.allowHTML) && fR(u, n.props), o.arrow ? c ? a.arrow !== o.arrow && (l.removeChild(c), l.appendChild(dR(o.arrow))) : l.appendChild(dR(o.arrow)) : c && l.removeChild(c);
  }
  return {
    popper: e,
    onUpdate: i
  };
}
wH.$$tippy = !0;
var Ave = 1, Iy = [], xS = [];
function Mve(n, e) {
  var t = cR(n, Object.assign({}, da, _H(aR(e)))), r, i, a, o = !1, s = !1, l = !1, u = !1, c, d, f, p = [], h = rR(he, t.interactiveDebounce), v, m = Ave++, g = null, y = sve(t.plugins), b = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, _ = {
    // properties
    id: m,
    reference: n,
    popper: Yv(),
    popperInstance: g,
    props: t,
    state: b,
    plugins: y,
    // methods
    clearDelayTimeouts: Re,
    setProps: be,
    setContent: we,
    show: Ne,
    hide: lt,
    hideWithInteractivity: Gt,
    enable: ft,
    disable: Rt,
    unmount: _n,
    destroy: Tr
  };
  if (!t.render)
    return process.env.NODE_ENV !== "production" && sC(!0, "render() function has not been supplied."), _;
  var x = t.render(_), w = x.popper, S = x.onUpdate;
  w.setAttribute("data-tippy-root", ""), w.id = "tippy-" + _.id, _.popper = w, n._tippy = _, w._tippy = _;
  var C = y.map(function(Se) {
    return Se.fn(_);
  }), k = n.hasAttribute("aria-expanded");
  return Ae(), ne(), B(), H("onCreate", [_]), t.showOnCreate && Nt(), w.addEventListener("mouseenter", function() {
    _.props.interactive && _.state.isVisible && _.clearDelayTimeouts();
  }), w.addEventListener("mouseleave", function() {
    _.props.interactive && _.props.trigger.indexOf("mouseenter") >= 0 && j().addEventListener("mousemove", h);
  }), _;
  function M() {
    var Se = _.props.touch;
    return Array.isArray(Se) ? Se : [Se, 0];
  }
  function D() {
    return M()[0] === "hold";
  }
  function N() {
    var Se;
    return !!((Se = _.props.render) != null && Se.$$tippy);
  }
  function R() {
    return v || n;
  }
  function j() {
    var Se = R().parentNode;
    return Se ? pve(Se) : document;
  }
  function z() {
    return uC(w);
  }
  function F(Se) {
    return _.state.isMounted && !_.state.isVisible || Qo.isTouch || c && c.type === "focus" ? 0 : yS(_.props.delay, Se ? 0 : 1, da.delay);
  }
  function B(Se) {
    Se === void 0 && (Se = !1), w.style.pointerEvents = _.props.interactive && !Se ? "" : "none", w.style.zIndex = "" + _.props.zIndex;
  }
  function H(Se, rt, wt) {
    if (wt === void 0 && (wt = !0), C.forEach(function(Kt) {
      Kt[Se] && Kt[Se].apply(Kt, rt);
    }), wt) {
      var rn;
      (rn = _.props)[Se].apply(rn, rt);
    }
  }
  function Y() {
    var Se = _.props.aria;
    if (Se.content) {
      var rt = "aria-" + Se.content, wt = w.id, rn = qf(_.props.triggerTarget || n);
      rn.forEach(function(Kt) {
        var Un = Kt.getAttribute(rt);
        if (_.state.isVisible)
          Kt.setAttribute(rt, Un ? Un + " " + wt : wt);
        else {
          var tr = Un && Un.replace(wt, "").trim();
          tr ? Kt.setAttribute(rt, tr) : Kt.removeAttribute(rt);
        }
      });
    }
  }
  function ne() {
    if (!(k || !_.props.aria.expanded)) {
      var Se = qf(_.props.triggerTarget || n);
      Se.forEach(function(rt) {
        _.props.interactive ? rt.setAttribute("aria-expanded", _.state.isVisible && rt === R() ? "true" : "false") : rt.removeAttribute("aria-expanded");
      });
    }
  }
  function J() {
    j().removeEventListener("mousemove", h), Iy = Iy.filter(function(Se) {
      return Se !== h;
    });
  }
  function X(Se) {
    if (!(Qo.isTouch && (l || Se.type === "mousedown"))) {
      var rt = Se.composedPath && Se.composedPath()[0] || Se.target;
      if (!(_.props.interactive && sR(w, rt))) {
        if (qf(_.props.triggerTarget || n).some(function(wt) {
          return sR(wt, rt);
        })) {
          if (Qo.isTouch || _.state.isVisible && _.props.trigger.indexOf("click") >= 0)
            return;
        } else
          H("onClickOutside", [_, Se]);
        _.props.hideOnClick === !0 && (_.clearDelayTimeouts(), _.hide(), s = !0, setTimeout(function() {
          s = !1;
        }), _.state.isMounted || Be());
      }
    }
  }
  function ie() {
    l = !0;
  }
  function ye() {
    l = !1;
  }
  function pe() {
    var Se = j();
    Se.addEventListener("mousedown", X, !0), Se.addEventListener("touchend", X, Sc), Se.addEventListener("touchstart", ye, Sc), Se.addEventListener("touchmove", ie, Sc);
  }
  function Be() {
    var Se = j();
    Se.removeEventListener("mousedown", X, !0), Se.removeEventListener("touchend", X, Sc), Se.removeEventListener("touchstart", ye, Sc), Se.removeEventListener("touchmove", ie, Sc);
  }
  function Ce(Se, rt) {
    ce(Se, function() {
      !_.state.isVisible && w.parentNode && w.parentNode.contains(w) && rt();
    });
  }
  function Ee(Se, rt) {
    ce(Se, rt);
  }
  function ce(Se, rt) {
    var wt = z().box;
    function rn(Kt) {
      Kt.target === wt && (_S(wt, "remove", rn), rt());
    }
    if (Se === 0)
      return rt();
    _S(wt, "remove", d), _S(wt, "add", rn), d = rn;
  }
  function Pe(Se, rt, wt) {
    wt === void 0 && (wt = !1);
    var rn = qf(_.props.triggerTarget || n);
    rn.forEach(function(Kt) {
      Kt.addEventListener(Se, rt, wt), p.push({
        node: Kt,
        eventType: Se,
        handler: rt,
        options: wt
      });
    });
  }
  function Ae() {
    D() && (Pe("touchstart", oe, {
      passive: !0
    }), Pe("touchend", Oe, {
      passive: !0
    })), ove(_.props.trigger).forEach(function(Se) {
      if (Se !== "manual")
        switch (Pe(Se, oe), Se) {
          case "mouseenter":
            Pe("mouseleave", Oe);
            break;
          case "focus":
            Pe(bve ? "focusout" : "blur", Te);
            break;
          case "focusin":
            Pe("focusout", Te);
            break;
        }
    });
  }
  function fe() {
    p.forEach(function(Se) {
      var rt = Se.node, wt = Se.eventType, rn = Se.handler, Kt = Se.options;
      rt.removeEventListener(wt, rn, Kt);
    }), p = [];
  }
  function oe(Se) {
    var rt, wt = !1;
    if (!(!_.state.isEnabled || Ge(Se) || s)) {
      var rn = ((rt = c) == null ? void 0 : rt.type) === "focus";
      c = Se, v = Se.currentTarget, ne(), !_.state.isVisible && cve(Se) && Iy.forEach(function(Kt) {
        return Kt(Se);
      }), Se.type === "click" && (_.props.trigger.indexOf("mouseenter") < 0 || o) && _.props.hideOnClick !== !1 && _.state.isVisible ? wt = !0 : Nt(Se), Se.type === "click" && (o = !wt), wt && !rn && Le(Se);
    }
  }
  function he(Se) {
    var rt = Se.target, wt = R().contains(rt) || w.contains(rt);
    if (!(Se.type === "mousemove" && wt)) {
      var rn = it().concat(w).map(function(Kt) {
        var Un, tr = Kt._tippy, so = (Un = tr.popperInstance) == null ? void 0 : Un.state;
        return so ? {
          popperRect: Kt.getBoundingClientRect(),
          popperState: so,
          props: t
        } : null;
      }).filter(Boolean);
      hve(rn, Se) && (J(), Le(Se));
    }
  }
  function Oe(Se) {
    var rt = Ge(Se) || _.props.trigger.indexOf("click") >= 0 && o;
    if (!rt) {
      if (_.props.interactive) {
        _.hideWithInteractivity(Se);
        return;
      }
      Le(Se);
    }
  }
  function Te(Se) {
    _.props.trigger.indexOf("focusin") < 0 && Se.target !== R() || _.props.interactive && Se.relatedTarget && w.contains(Se.relatedTarget) || Le(Se);
  }
  function Ge(Se) {
    return Qo.isTouch ? D() !== Se.type.indexOf("touch") >= 0 : !1;
  }
  function je() {
    Qe();
    var Se = _.props, rt = Se.popperOptions, wt = Se.placement, rn = Se.offset, Kt = Se.getReferenceClientRect, Un = Se.moveTransition, tr = N() ? uC(w).arrow : null, so = Kt ? {
      getBoundingClientRect: Kt,
      contextElement: Kt.contextElement || R()
    } : n, wa = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(Fn) {
        var ti = Fn.state;
        if (N()) {
          var of = z(), Ol = of.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(Ea) {
            Ea === "placement" ? Ol.setAttribute("data-placement", ti.placement) : ti.attributes.popper["data-popper-" + Ea] ? Ol.setAttribute("data-" + Ea, "") : Ol.removeAttribute("data-" + Ea);
          }), ti.attributes.popper = {};
        }
      }
    }, Sa = [{
      name: "offset",
      options: {
        offset: rn
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !Un
      }
    }, wa];
    N() && tr && Sa.push({
      name: "arrow",
      options: {
        element: tr,
        padding: 3
      }
    }), Sa.push.apply(Sa, (rt == null ? void 0 : rt.modifiers) || []), _.popperInstance = dH(so, w, Object.assign({}, rt, {
      placement: wt,
      onFirstUpdate: f,
      modifiers: Sa
    }));
  }
  function Qe() {
    _.popperInstance && (_.popperInstance.destroy(), _.popperInstance = null);
  }
  function ot() {
    var Se = _.props.appendTo, rt, wt = R();
    _.props.interactive && Se === vH || Se === "parent" ? rt = wt.parentNode : rt = mH(Se, [wt]), rt.contains(w) || rt.appendChild(w), _.state.isMounted = !0, je(), process.env.NODE_ENV !== "production" && Ws(_.props.interactive && Se === da.appendTo && wt.nextElementSibling !== w, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function it() {
    return ab(w.querySelectorAll("[data-tippy-root]"));
  }
  function Nt(Se) {
    _.clearDelayTimeouts(), Se && H("onTrigger", [_, Se]), pe();
    var rt = F(!0), wt = M(), rn = wt[0], Kt = wt[1];
    Qo.isTouch && rn === "hold" && Kt && (rt = Kt), rt ? r = setTimeout(function() {
      _.show();
    }, rt) : _.show();
  }
  function Le(Se) {
    if (_.clearDelayTimeouts(), H("onUntrigger", [_, Se]), !_.state.isVisible) {
      Be();
      return;
    }
    if (!(_.props.trigger.indexOf("mouseenter") >= 0 && _.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(Se.type) >= 0 && o)) {
      var rt = F(!1);
      rt ? i = setTimeout(function() {
        _.state.isVisible && _.hide();
      }, rt) : a = requestAnimationFrame(function() {
        _.hide();
      });
    }
  }
  function ft() {
    _.state.isEnabled = !0;
  }
  function Rt() {
    _.hide(), _.state.isEnabled = !1;
  }
  function Re() {
    clearTimeout(r), clearTimeout(i), cancelAnimationFrame(a);
  }
  function be(Se) {
    if (process.env.NODE_ENV !== "production" && Ws(_.state.isDestroyed, mf("setProps")), !_.state.isDestroyed) {
      H("onBeforeUpdate", [_, Se]), fe();
      var rt = _.props, wt = cR(n, Object.assign({}, rt, aR(Se), {
        ignoreAttributes: !0
      }));
      _.props = wt, Ae(), rt.interactiveDebounce !== wt.interactiveDebounce && (J(), h = rR(he, wt.interactiveDebounce)), rt.triggerTarget && !wt.triggerTarget ? qf(rt.triggerTarget).forEach(function(rn) {
        rn.removeAttribute("aria-expanded");
      }) : wt.triggerTarget && n.removeAttribute("aria-expanded"), ne(), B(), S && S(rt, wt), _.popperInstance && (je(), it().forEach(function(rn) {
        requestAnimationFrame(rn._tippy.popperInstance.forceUpdate);
      })), H("onAfterUpdate", [_, Se]);
    }
  }
  function we(Se) {
    _.setProps({
      content: Se
    });
  }
  function Ne() {
    process.env.NODE_ENV !== "production" && Ws(_.state.isDestroyed, mf("show"));
    var Se = _.state.isVisible, rt = _.state.isDestroyed, wt = !_.state.isEnabled, rn = Qo.isTouch && !_.props.touch, Kt = yS(_.props.duration, 0, da.duration);
    if (!(Se || rt || wt || rn) && !R().hasAttribute("disabled") && (H("onShow", [_], !1), _.props.onShow(_) !== !1)) {
      if (_.state.isVisible = !0, N() && (w.style.visibility = "visible"), B(), pe(), _.state.isMounted || (w.style.transition = "none"), N()) {
        var Un = z(), tr = Un.box, so = Un.content;
        bS([tr, so], 0);
      }
      f = function() {
        var Sa;
        if (!(!_.state.isVisible || u)) {
          if (u = !0, w.offsetHeight, w.style.transition = _.props.moveTransition, N() && _.props.animation) {
            var Is = z(), Fn = Is.box, ti = Is.content;
            bS([Fn, ti], Kt), oR([Fn, ti], "visible");
          }
          Y(), ne(), iR(xS, _), (Sa = _.popperInstance) == null || Sa.forceUpdate(), H("onMount", [_]), _.props.animation && N() && Ee(Kt, function() {
            _.state.isShown = !0, H("onShown", [_]);
          });
        }
      }, ot();
    }
  }
  function lt() {
    process.env.NODE_ENV !== "production" && Ws(_.state.isDestroyed, mf("hide"));
    var Se = !_.state.isVisible, rt = _.state.isDestroyed, wt = !_.state.isEnabled, rn = yS(_.props.duration, 1, da.duration);
    if (!(Se || rt || wt) && (H("onHide", [_], !1), _.props.onHide(_) !== !1)) {
      if (_.state.isVisible = !1, _.state.isShown = !1, u = !1, o = !1, N() && (w.style.visibility = "hidden"), J(), Be(), B(!0), N()) {
        var Kt = z(), Un = Kt.box, tr = Kt.content;
        _.props.animation && (bS([Un, tr], rn), oR([Un, tr], "hidden"));
      }
      Y(), ne(), _.props.animation ? N() && Ce(rn, _.unmount) : _.unmount();
    }
  }
  function Gt(Se) {
    process.env.NODE_ENV !== "production" && Ws(_.state.isDestroyed, mf("hideWithInteractivity")), j().addEventListener("mousemove", h), iR(Iy, h), h(Se);
  }
  function _n() {
    process.env.NODE_ENV !== "production" && Ws(_.state.isDestroyed, mf("unmount")), _.state.isVisible && _.hide(), _.state.isMounted && (Qe(), it().forEach(function(Se) {
      Se._tippy.unmount();
    }), w.parentNode && w.parentNode.removeChild(w), xS = xS.filter(function(Se) {
      return Se !== _;
    }), _.state.isMounted = !1, H("onHidden", [_]));
  }
  function Tr() {
    process.env.NODE_ENV !== "production" && Ws(_.state.isDestroyed, mf("destroy")), !_.state.isDestroyed && (_.clearDelayTimeouts(), _.unmount(), fe(), delete n._tippy, _.state.isDestroyed = !0, H("onDestroy", [_]));
  }
}
function qu(n, e) {
  e === void 0 && (e = {});
  var t = da.plugins.concat(e.plugins || []);
  process.env.NODE_ENV !== "production" && (wve(n), xH(e, t)), gve();
  var r = Object.assign({}, e, {
    plugins: t
  }), i = fve(n);
  if (process.env.NODE_ENV !== "production") {
    var a = Bm(r.content), o = i.length > 1;
    Ws(a && o, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var s = i.reduce(function(l, u) {
    var c = u && Mve(u, r);
    return c && l.push(c), l;
  }, []);
  return Bm(n) ? s[0] : s;
}
qu.defaultProps = da;
qu.setDefaultProps = Tve;
qu.currentInput = Qo;
Object.assign({}, rH, {
  effect: function(e) {
    var t = e.state, r = {
      popper: {
        position: t.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(t.elements.popper.style, r.popper), t.styles = r, t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow);
  }
});
qu.setDefaultProps({
  render: wH
});
class Dve {
  constructor({ editor: e, element: t, view: r, tippyOptions: i = {}, updateDelay: a = 250, shouldShow: o }) {
    this.preventHide = !1, this.shouldShow = ({ view: s, state: l, from: u, to: c }) => {
      const { doc: d, selection: f } = l, { empty: p } = f, h = !d.textBetween(u, c).length && DM(l.selection), v = this.element.contains(document.activeElement);
      return !(!(s.hasFocus() || v) || p || h || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: s }) => {
      var l;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      s != null && s.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(s.relatedTarget)) || (s == null ? void 0 : s.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (s) => {
      this.blurHandler({ event: s });
    }, this.handleDebouncedUpdate = (s, l) => {
      const u = !(l != null && l.selection.eq(s.state.selection)), c = !(l != null && l.doc.eq(s.state.doc));
      !u && !c || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(s, u, c, l);
      }, this.updateDelay));
    }, this.updateHandler = (s, l, u, c) => {
      var d, f, p;
      const { state: h, composing: v } = s, { selection: m } = h;
      if (v || !l && !u)
        return;
      this.createTooltip();
      const { ranges: y } = m, b = Math.min(...y.map((w) => w.$from.pos)), _ = Math.max(...y.map((w) => w.$to.pos));
      if (!((d = this.shouldShow) === null || d === void 0 ? void 0 : d.call(this, {
        editor: this.editor,
        element: this.element,
        view: s,
        state: h,
        oldState: c,
        from: b,
        to: _
      }))) {
        this.hide();
        return;
      }
      (f = this.tippy) === null || f === void 0 || f.setProps({
        getReferenceClientRect: ((p = this.tippyOptions) === null || p === void 0 ? void 0 : p.getReferenceClientRect) || (() => {
          if (J8(h.selection)) {
            let w = s.nodeDOM(b);
            if (w) {
              const S = w.dataset.nodeViewWrapper ? w : w.querySelector("[data-node-view-wrapper]");
              if (S && (w = S.firstChild), w)
                return w.getBoundingClientRect();
            }
          }
          return Q8(s, b, _);
        })
      }), this.show();
    }, this.editor = e, this.element = t, this.view = r, this.updateDelay = a, o && (this.shouldShow = o), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, t = !!e.parentElement;
    this.element.tabIndex = 0, !(this.tippy || !t) && (this.tippy = qu(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, t) {
    const { state: r } = e, i = r.selection.from !== r.selection.to;
    if (this.updateDelay > 0 && i) {
      this.handleDebouncedUpdate(e, t);
      return;
    }
    const a = !(t != null && t.selection.eq(e.state.selection)), o = !(t != null && t.doc.eq(e.state.doc));
    this.updateHandler(e, a, o, t);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, t;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (t = this.tippy) === null || t === void 0 || t.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const SH = (n) => new Pn({
  key: typeof n.pluginKey == "string" ? new jn(n.pluginKey) : n.pluginKey,
  view: (e) => new Dve({ view: e, ...n })
});
Qn.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      SH({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
class Ove {
  getTextContent(e) {
    return X8(e, { textSerializers: MM(this.editor.schema) });
  }
  constructor({ editor: e, element: t, view: r, tippyOptions: i = {}, shouldShow: a }) {
    this.preventHide = !1, this.shouldShow = ({ view: o, state: s }) => {
      const { selection: l } = s, { $anchor: u, empty: c } = l, d = u.depth === 1, f = u.parent.isTextblock && !u.parent.type.spec.code && !u.parent.textContent && u.parent.childCount === 0 && !this.getTextContent(u.parent);
      return !(!o.hasFocus() || !c || !d || !f || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: o }) => {
      var s;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      o != null && o.relatedTarget && (!((s = this.element.parentNode) === null || s === void 0) && s.contains(o.relatedTarget)) || (o == null ? void 0 : o.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (o) => {
      this.blurHandler({ event: o });
    }, this.editor = e, this.element = t, this.view = r, a && (this.shouldShow = a), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, t = !!e.parentElement;
    this.element.tabIndex = 0, !(this.tippy || !t) && (this.tippy = qu(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, t) {
    var r, i, a;
    const { state: o } = e, { doc: s, selection: l } = o, { from: u, to: c } = l;
    if (t && t.doc.eq(s) && t.selection.eq(l))
      return;
    if (this.createTooltip(), !((r = this.shouldShow) === null || r === void 0 ? void 0 : r.call(this, {
      editor: this.editor,
      view: e,
      state: o,
      oldState: t
    }))) {
      this.hide();
      return;
    }
    (i = this.tippy) === null || i === void 0 || i.setProps({
      getReferenceClientRect: ((a = this.tippyOptions) === null || a === void 0 ? void 0 : a.getReferenceClientRect) || (() => Q8(e, u, c))
    }), this.show();
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, t;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (t = this.tippy) === null || t === void 0 || t.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const EH = (n) => new Pn({
  key: typeof n.pluginKey == "string" ? new jn(n.pluginKey) : n.pluginKey,
  view: (e) => new Ove({ view: e, ...n })
});
Qn.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      EH({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
const Ive = ve({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: [String, Object],
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    updateDelay: {
      type: Number,
      default: void 0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(n, { slots: e }) {
    const t = Z(null);
    return kt(() => {
      const { updateDelay: r, editor: i, pluginKey: a, shouldShow: o, tippyOptions: s } = n;
      i.registerPlugin(SH({
        updateDelay: r,
        editor: i,
        element: t.value,
        pluginKey: a,
        shouldShow: o,
        tippyOptions: s
      }));
    }), Io(() => {
      const { pluginKey: r, editor: i } = n;
      i.unregisterPlugin(r);
    }), () => {
      var r;
      return qt("div", { ref: t }, (r = e.default) === null || r === void 0 ? void 0 : r.call(e));
    };
  }
});
function pR(n) {
  return pF((e, t) => ({
    get() {
      return e(), n;
    },
    set(r) {
      n = r, requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          t();
        });
      });
    }
  }));
}
class Lve extends Ype {
  constructor(e = {}) {
    return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = pR(this.view.state), this.reactiveExtensionStorage = pR(this.extensionStorage), this.on("beforeTransaction", ({ nextState: t }) => {
      this.reactiveState.value = t, this.reactiveExtensionStorage.value = this.extensionStorage;
    }), cn(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  /**
   * Register a ProseMirror plugin.
   */
  registerPlugin(e, t) {
    const r = super.registerPlugin(e, t);
    return this.reactiveState && (this.reactiveState.value = r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   */
  unregisterPlugin(e) {
    const t = super.unregisterPlugin(e);
    return this.reactiveState && t && (this.reactiveState.value = t), t;
  }
}
const Nve = ve({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(n) {
    const e = Z(), t = ro();
    return Cn(() => {
      const r = n.editor;
      r && r.options.element && e.value && Wt(() => {
        if (!e.value || !r.options.element.firstChild)
          return;
        const i = O(e.value);
        e.value.append(...r.options.element.childNodes), r.contentComponent = t.ctx._, t && (r.appContext = {
          ...t.appContext,
          // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
          // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
          // @ts-expect-error forward instance's 'provides' into appContext
          provides: t.provides
        }), r.setOptions({
          element: i
        }), r.createNodeViews();
      });
    }), Io(() => {
      const r = n.editor;
      r && (r.contentComponent = null, r.appContext = null);
    }), { rootEl: e };
  },
  render() {
    return qt("div", {
      ref: (n) => {
        this.rootEl = n;
      }
    });
  }
}), Rve = ve({
  name: "FloatingMenu",
  props: {
    pluginKey: {
      // TODO: TypeScript breaks :(
      // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
      type: null,
      default: "floatingMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(n, { slots: e }) {
    const t = Z(null);
    return kt(() => {
      const { pluginKey: r, editor: i, tippyOptions: a, shouldShow: o } = n;
      i.registerPlugin(EH({
        pluginKey: r,
        editor: i,
        element: t.value,
        tippyOptions: a,
        shouldShow: o
      }));
    }), Io(() => {
      const { pluginKey: r, editor: i } = n;
      i.unregisterPlugin(r);
    }), () => {
      var r;
      return qt("div", { ref: t }, (r = e.default) === null || r === void 0 ? void 0 : r.call(e));
    };
  }
}), Pve = ve({
  name: "NodeViewContent",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  render() {
    return qt(this.as, {
      style: {
        whiteSpace: "pre-wrap"
      },
      "data-node-view-content": ""
    });
  }
}), FM = ve({
  name: "NodeViewWrapper",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  inject: ["onDragStart", "decorationClasses"],
  render() {
    var n, e;
    return qt(this.as, {
      // @ts-ignore
      class: this.decorationClasses,
      style: {
        whiteSpace: "normal"
      },
      "data-node-view-wrapper": "",
      // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
      onDragstart: this.onDragStart
    }, (e = (n = this.$slots).default) === null || e === void 0 ? void 0 : e.call(n));
  }
});
class TH {
  constructor(e, { props: t = {}, editor: r }) {
    this.editor = r, this.component = cn(e), this.el = document.createElement("div"), this.props = Sr(t), this.renderedComponent = this.renderComponent();
  }
  get element() {
    return this.renderedComponent.el;
  }
  get ref() {
    var e, t, r, i;
    return !((t = (e = this.renderedComponent.vNode) === null || e === void 0 ? void 0 : e.component) === null || t === void 0) && t.exposed ? this.renderedComponent.vNode.component.exposed : (i = (r = this.renderedComponent.vNode) === null || r === void 0 ? void 0 : r.component) === null || i === void 0 ? void 0 : i.proxy;
  }
  renderComponent() {
    let e = qt(this.component, this.props);
    return this.editor.appContext && (e.appContext = this.editor.appContext), typeof document < "u" && this.el && JI(e, this.el), { vNode: e, destroy: () => {
      this.el && JI(null, this.el), this.el = null, e = null;
    }, el: this.el ? this.el.firstElementChild : null };
  }
  updateProps(e = {}) {
    Object.entries(e).forEach(([t, r]) => {
      this.props[t] = r;
    }), this.renderComponent();
  }
  destroy() {
    this.renderedComponent.destroy();
  }
}
const CH = {
  editor: {
    type: Object,
    required: !0
  },
  node: {
    type: Object,
    required: !0
  },
  decorations: {
    type: Object,
    required: !0
  },
  selected: {
    type: Boolean,
    required: !0
  },
  extension: {
    type: Object,
    required: !0
  },
  getPos: {
    type: Function,
    required: !0
  },
  updateAttributes: {
    type: Function,
    required: !0
  },
  deleteNode: {
    type: Function,
    required: !0
  },
  view: {
    type: Object,
    required: !0
  },
  innerDecorations: {
    type: Object,
    required: !0
  },
  HTMLAttributes: {
    type: Object,
    required: !0
  }
};
class jve extends Kpe {
  mount() {
    const e = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: !1,
      extension: this.extension,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (i = {}) => this.updateAttributes(i),
      deleteNode: () => this.deleteNode()
    }, t = this.onDragStart.bind(this);
    this.decorationClasses = Z(this.getDecorationClasses());
    const r = ve({
      extends: { ...this.component },
      props: Object.keys(e),
      template: this.component.template,
      setup: (i) => {
        var a, o;
        return zn("onDragStart", t), zn("decorationClasses", this.decorationClasses), (o = (a = this.component).setup) === null || o === void 0 ? void 0 : o.call(a, i, {
          expose: () => {
          }
        });
      },
      // add support for scoped styles
      // @ts-ignore
      // eslint-disable-next-line
      __scopeId: this.component.__scopeId,
      // add support for CSS Modules
      // @ts-ignore
      // eslint-disable-next-line
      __cssModules: this.component.__cssModules,
      // add support for vue devtools
      // @ts-ignore
      // eslint-disable-next-line
      __name: this.component.__name,
      // @ts-ignore
      // eslint-disable-next-line
      __file: this.component.__file
    });
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.renderer = new TH(r, {
      editor: this.editor,
      props: e
    });
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    if (!this.renderer.element || !this.renderer.element.hasAttribute("data-node-view-wrapper"))
      throw Error("Please use the NodeViewWrapper component for your node view.");
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    return this.node.isLeaf ? null : this.dom.querySelector("[data-node-view-content]");
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    const { from: e, to: t } = this.editor.state.selection, r = this.getPos();
    if (typeof r == "number")
      if (e <= r && t >= r + this.node.nodeSize) {
        if (this.renderer.props.selected)
          return;
        this.selectNode();
      } else {
        if (!this.renderer.props.selected)
          return;
        this.deselectNode();
      }
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(e, t, r) {
    const i = (a) => {
      this.decorationClasses.value = this.getDecorationClasses(), this.renderer.updateProps(a);
    };
    if (typeof this.options.update == "function") {
      const a = this.node, o = this.decorations, s = this.innerDecorations;
      return this.node = e, this.decorations = t, this.innerDecorations = r, this.options.update({
        oldNode: a,
        oldDecorations: o,
        newNode: e,
        newDecorations: t,
        oldInnerDecorations: s,
        innerDecorations: r,
        updateProps: () => i({ node: e, decorations: t, innerDecorations: r })
      });
    }
    return e.type !== this.node.type ? !1 : (e === this.node && this.decorations === t && this.innerDecorations === r || (this.node = e, this.decorations = t, this.innerDecorations = r, i({ node: e, decorations: t, innerDecorations: r })), !0);
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: !0
    }), this.renderer.element && this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: !1
    }), this.renderer.element && this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  getDecorationClasses() {
    return this.decorations.map((e) => e.type.attrs.class).flat().join(" ");
  }
  destroy() {
    this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate);
  }
}
function Ix(n, e) {
  return (t) => {
    if (!t.editor.contentComponent)
      return {};
    const r = typeof n == "function" && "__vccOpts" in n ? n.__vccOpts : n;
    return new jve(r, t, e);
  };
}
const Bve = /^\s*>\s$/, $ve = pr.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["blockquote", Mn(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: n }) => n.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: n }) => n.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: n }) => n.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      Op({
        find: Bve,
        type: this.type
      })
    ];
  }
}), zve = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, Fve = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, Vve = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, Hve = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, Gve = Ao.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (n) => n.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (n) => n.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (n) => /^(bold(er)?|[5-9]\d{2,})$/.test(n) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["strong", Mn(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: n }) => n.setMark(this.name),
      toggleBold: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetBold: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Dp({
        find: zve,
        type: this.type
      }),
      Dp({
        find: Vve,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Td({
        find: Fve,
        type: this.type
      }),
      Td({
        find: Hve,
        type: this.type
      })
    ];
  }
}), Uve = "listItem", hR = "textStyle", vR = /^\s*([-+*])\s$/, Wve = pr.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["ul", Mn(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: n, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Uve, this.editor.getAttributes(hR)).run() : n.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let n = Op({
      find: vR,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (n = Op({
      find: vR,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(hR),
      editor: this.editor
    })), [
      n
    ];
  }
}), qve = /(^|[^`])`([^`]+)`(?!`)/, Yve = /(^|[^`])`([^`]+)`(?!`)/g, Kve = Ao.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["code", Mn(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: n }) => n.setMark(this.name),
      toggleCode: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetCode: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      Dp({
        find: qve,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Td({
        find: Yve,
        type: this.type
      })
    ];
  }
}), Xve = /^```([a-z]+)?[\s\n]$/, Zve = /^~~~([a-z]+)?[\s\n]$/, kH = pr.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (n) => {
          var e;
          const { languageClassPrefix: t } = this.options, a = [...((e = n.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((o) => o.startsWith(t)).map((o) => o.replace(t, ""))[0];
          return a || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: n, HTMLAttributes: e }) {
    return [
      "pre",
      Mn(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: n.attrs.language ? this.options.languageClassPrefix + n.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (n) => ({ commands: e }) => e.setNode(this.name, n),
      toggleCodeBlock: (n) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", n)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: n, $anchor: e } = this.editor.state.selection, t = e.pos === 1;
        return !n || e.parent.type.name !== this.name ? !1 : t || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // exit node on triple enter
      Enter: ({ editor: n }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = n, { selection: t } = e, { $from: r, empty: i } = t;
        if (!i || r.parent.type !== this.type)
          return !1;
        const a = r.parentOffset === r.parent.nodeSize - 2, o = r.parent.textContent.endsWith(`

`);
        return !a || !o ? !1 : n.chain().command(({ tr: s }) => (s.delete(r.pos - 2, r.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: n }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = n, { selection: t, doc: r } = e, { $from: i, empty: a } = t;
        if (!a || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
          return !1;
        const s = i.after();
        return s === void 0 ? !1 : r.nodeAt(s) ? n.commands.command(({ tr: u }) => (u.setSelection(It.near(r.resolve(s))), !0)) : n.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      rb({
        find: Xve,
        type: this.type,
        getAttributes: (n) => ({
          language: n[1]
        })
      }),
      rb({
        find: Zve,
        type: this.type,
        getAttributes: (n) => ({
          language: n[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Pn({
        key: new jn("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (n, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const t = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, a = i == null ? void 0 : i.mode;
            if (!t || !a)
              return !1;
            const { tr: o, schema: s } = n.state, l = s.text(t.replace(/\r\n?/g, `
`));
            return o.replaceSelectionWith(this.type.create({ language: a }, l)), o.selection.$from.parent.type !== this.type && o.setSelection(Dt.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))), o.setMeta("paste", !0), n.dispatch(o), !0;
          }
        }
      })
    ];
  }
}), Jve = pr.create({
  name: "doc",
  topNode: !0,
  content: "block+"
});
function Qve(n = {}) {
  return new Pn({
    view(e) {
      return new eme(e, n);
    }
  });
}
class eme {
  constructor(e, t) {
    var r;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = t.width) !== null && r !== void 0 ? r : 1, this.color = t.color === !1 ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
      let a = (o) => {
        this[i](o);
      };
      return e.dom.addEventListener(i, a), { name: i, handler: a };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t));
  }
  update(e, t) {
    this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, r, i = this.editorView.dom, a = i.getBoundingClientRect(), o = a.width / i.offsetWidth, s = a.height / i.offsetHeight;
    if (t) {
      let d = e.nodeBefore, f = e.nodeAfter;
      if (d || f) {
        let p = this.editorView.nodeDOM(this.cursorPos - (d ? d.nodeSize : 0));
        if (p) {
          let h = p.getBoundingClientRect(), v = d ? h.bottom : h.top;
          d && f && (v = (v + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
          let m = this.width / 2 * s;
          r = { left: h.left, right: h.right, top: v - m, bottom: v + m };
        }
      }
    }
    if (!r) {
      let d = this.editorView.coordsAtPos(this.cursorPos), f = this.width / 2 * o;
      r = { left: d.left - f, right: d.left + f, top: d.top, bottom: d.bottom };
    }
    let l = this.editorView.dom.offsetParent;
    this.element || (this.element = l.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t);
    let u, c;
    if (!l || l == document.body && getComputedStyle(l).position == "static")
      u = -pageXOffset, c = -pageYOffset;
    else {
      let d = l.getBoundingClientRect(), f = d.width / l.offsetWidth, p = d.height / l.offsetHeight;
      u = d.left - l.scrollLeft * f, c = d.top - l.scrollTop * p;
    }
    this.element.style.left = (r.left - u) / o + "px", this.element.style.top = (r.top - c) / s + "px", this.element.style.width = (r.right - r.left) / o + "px", this.element.style.height = (r.bottom - r.top) / s + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), i = r && r.type.spec.disableDropCursor, a = typeof i == "function" ? i(this.editorView, t, e) : i;
    if (t && !a) {
      let o = t.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let s = z6(this.editorView.state.doc, o, this.editorView.dragging.slice);
        s != null && (o = s);
      }
      this.setCursor(o), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null);
  }
}
const tme = Qn.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      Qve(this.options)
    ];
  }
});
class ur extends It {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    return ur.valid(r) ? new ur(r) : It.near(r);
  }
  content() {
    return nt.empty;
  }
  eq(e) {
    return e instanceof ur && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new ur(e.resolve(t.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new VM(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let t = e.parent;
    if (t.isTextblock || !nme(e) || !rme(e))
      return !1;
    let r = t.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = t.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, t, r = !1) {
    e: for (; ; ) {
      if (!r && ur.valid(e))
        return e;
      let i = e.pos, a = null;
      for (let o = e.depth; ; o--) {
        let s = e.node(o);
        if (t > 0 ? e.indexAfter(o) < s.childCount : e.index(o) > 0) {
          a = s.child(t > 0 ? e.indexAfter(o) : e.index(o) - 1);
          break;
        } else if (o == 0)
          return null;
        i += t;
        let l = e.doc.resolve(i);
        if (ur.valid(l))
          return l;
      }
      for (; ; ) {
        let o = t > 0 ? a.firstChild : a.lastChild;
        if (!o) {
          if (a.isAtom && !a.isText && !Ct.isSelectable(a)) {
            e = e.doc.resolve(i + a.nodeSize * t), r = !1;
            continue e;
          }
          break;
        }
        a = o, i += t;
        let s = e.doc.resolve(i);
        if (ur.valid(s))
          return s;
      }
      return null;
    }
  }
}
ur.prototype.visible = !1;
ur.findFrom = ur.findGapCursorFrom;
It.jsonID("gapcursor", ur);
class VM {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new VM(e.map(this.pos));
  }
  resolve(e) {
    let t = e.resolve(this.pos);
    return ur.valid(t) ? new ur(t) : It.near(t);
  }
}
function nme(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.index(e), r = n.node(e);
    if (t == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function rme(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.indexAfter(e), r = n.node(e);
    if (t == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function ime() {
  return new Pn({
    props: {
      decorations: lme,
      createSelectionBetween(n, e, t) {
        return e.pos == t.pos && ur.valid(t) ? new ur(t) : null;
      },
      handleClick: ome,
      handleKeyDown: ame,
      handleDOMEvents: { beforeinput: sme }
    }
  });
}
const ame = xM({
  ArrowLeft: Ly("horiz", -1),
  ArrowRight: Ly("horiz", 1),
  ArrowUp: Ly("vert", -1),
  ArrowDown: Ly("vert", 1)
});
function Ly(n, e) {
  const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, a) {
    let o = r.selection, s = e > 0 ? o.$to : o.$from, l = o.empty;
    if (o instanceof Dt) {
      if (!a.endOfTextblock(t) || s.depth == 0)
        return !1;
      l = !1, s = r.doc.resolve(e > 0 ? s.after() : s.before());
    }
    let u = ur.findGapCursorFrom(s, e, l);
    return u ? (i && i(r.tr.setSelection(new ur(u))), !0) : !1;
  };
}
function ome(n, e, t) {
  if (!n || !n.editable)
    return !1;
  let r = n.state.doc.resolve(e);
  if (!ur.valid(r))
    return !1;
  let i = n.posAtCoords({ left: t.clientX, top: t.clientY });
  return i && i.inside > -1 && Ct.isSelectable(n.state.doc.nodeAt(i.inside)) ? !1 : (n.dispatch(n.state.tr.setSelection(new ur(r))), !0);
}
function sme(n, e) {
  if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof ur))
    return !1;
  let { $from: t } = n.state.selection, r = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = $e.empty;
  for (let o = r.length - 1; o >= 0; o--)
    i = $e.from(r[o].createAndFill(null, i));
  let a = n.state.tr.replace(t.pos, t.pos, new nt(i, 0, 0));
  return a.setSelection(Dt.near(a.doc.resolve(t.pos + 1))), n.dispatch(a), !1;
}
function lme(n) {
  if (!(n.selection instanceof ur))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Zn.create(n.doc, [zr.widget(n.selection.head, e, { key: "gapcursor" })]);
}
const ume = Qn.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      ime()
    ];
  },
  extendNodeSchema(n) {
    var e;
    const t = {
      name: n.name,
      options: n.options,
      storage: n.storage
    };
    return {
      allowGapCursor: (e = on(vt(n, "allowGapCursor", t))) !== null && e !== void 0 ? e : null
    };
  }
}), cme = pr.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["br", Mn(this.options.HTMLAttributes, n)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: n, chain: e, state: t, editor: r }) => n.first([
        () => n.exitCode(),
        () => n.command(() => {
          const { selection: i, storedMarks: a } = t;
          if (i.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: o } = this.options, { splittableMarks: s } = r.extensionManager, l = a || i.$to.parentOffset && i.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: u, dispatch: c }) => {
            if (c && l && o) {
              const d = l.filter((f) => s.includes(f.type.name));
              u.ensureMarks(d);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), AH = pr.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((n) => ({
      tag: `h${n}`,
      attrs: { level: n }
    }));
  },
  renderHTML({ node: n, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(n.attrs.level) ? n.attrs.level : this.options.levels[0]}`, Mn(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (n) => ({ commands: e }) => this.options.levels.includes(n.level) ? e.setNode(this.name, n) : !1,
      toggleHeading: (n) => ({ commands: e }) => this.options.levels.includes(n.level) ? e.toggleNode(this.name, "paragraph", n) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((n, e) => ({
      ...n,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((n) => rb({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${n}})\\s$`),
      type: this.type,
      getAttributes: {
        level: n
      }
    }));
  }
});
var ob = 200, Hr = function() {
};
Hr.prototype.append = function(e) {
  return e.length ? (e = Hr.from(e), !this.length && e || e.length < ob && this.leafAppend(e) || this.length < ob && e.leafPrepend(this) || this.appendInner(e)) : this;
};
Hr.prototype.prepend = function(e) {
  return e.length ? Hr.from(e).append(this) : this;
};
Hr.prototype.appendInner = function(e) {
  return new dme(this, e);
};
Hr.prototype.slice = function(e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? Hr.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
};
Hr.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
Hr.prototype.forEach = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length), t <= r ? this.forEachInner(e, t, r, 0) : this.forEachInvertedInner(e, t, r, 0);
};
Hr.prototype.map = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(a, o) {
    return i.push(e(a, o));
  }, t, r), i;
};
Hr.from = function(e) {
  return e instanceof Hr ? e : e && e.length ? new MH(e) : Hr.empty;
};
var MH = /* @__PURE__ */ function(n) {
  function e(r) {
    n.call(this), this.values = r;
  }
  n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e;
  var t = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, a) {
    return i == 0 && a == this.length ? this : new e(this.values.slice(i, a));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, a, o, s) {
    for (var l = a; l < o; l++)
      if (i(this.values[l], s + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, a, o, s) {
    for (var l = a - 1; l >= o; l--)
      if (i(this.values[l], s + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= ob)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= ob)
      return new e(i.flatten().concat(this.values));
  }, t.length.get = function() {
    return this.values.length;
  }, t.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, t), e;
}(Hr);
Hr.empty = new MH([]);
var dme = /* @__PURE__ */ function(n) {
  function e(t, r) {
    n.call(this), this.left = t, this.right = r, this.length = t.length + r.length, this.depth = Math.max(t.depth, r.depth) + 1;
  }
  return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, a, o) {
    var s = this.left.length;
    if (i < s && this.left.forEachInner(r, i, Math.min(a, s), o) === !1 || a > s && this.right.forEachInner(r, Math.max(i - s, 0), Math.min(this.length, a) - s, o + s) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, a, o) {
    var s = this.left.length;
    if (i > s && this.right.forEachInvertedInner(r, i - s, Math.max(a, s) - s, o + s) === !1 || a < s && this.left.forEachInvertedInner(r, Math.min(i, s), a, o) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var a = this.left.length;
    return i <= a ? this.left.slice(r, i) : r >= a ? this.right.slice(r - a, i - a) : this.left.slice(r, a).append(this.right.slice(0, i - a));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
}(Hr);
const fme = 500;
class go {
  constructor(e, t) {
    this.items = e, this.eventCount = t;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, t) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, a;
    t && (i = this.remapping(r, this.items.length), a = i.maps.length);
    let o = e.tr, s, l, u = [], c = [];
    return this.items.forEach((d, f) => {
      if (!d.step) {
        i || (i = this.remapping(r, f + 1), a = i.maps.length), a--, c.push(d);
        return;
      }
      if (i) {
        c.push(new Ko(d.map));
        let p = d.step.map(i.slice(a)), h;
        p && o.maybeStep(p).doc && (h = o.mapping.maps[o.mapping.maps.length - 1], u.push(new Ko(h, void 0, void 0, u.length + c.length))), a--, h && i.appendMap(h, a);
      } else
        o.maybeStep(d.step);
      if (d.selection)
        return s = i ? d.selection.map(i.slice(a)) : d.selection, l = new go(this.items.slice(0, r).append(c.reverse().concat(u)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: o, selection: s };
  }
  // Create a new branch with the given transform added.
  addTransform(e, t, r, i) {
    let a = [], o = this.eventCount, s = this.items, l = !i && s.length ? s.get(s.length - 1) : null;
    for (let c = 0; c < e.steps.length; c++) {
      let d = e.steps[c].invert(e.docs[c]), f = new Ko(e.mapping.maps[c], d, t), p;
      (p = l && l.merge(f)) && (f = p, c ? a.pop() : s = s.slice(0, s.length - 1)), a.push(f), t && (o++, t = void 0), i || (l = f);
    }
    let u = o - r.depth;
    return u > hme && (s = pme(s, u), o -= u), new go(s.append(a), o);
  }
  remapping(e, t) {
    let r = new Mm();
    return this.items.forEach((i, a) => {
      let o = i.mirrorOffset != null && a - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, o);
    }, e, t), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new go(this.items.append(e.map((t) => new Ko(t))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, t) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - t), a = e.mapping, o = e.steps.length, s = this.eventCount;
    this.items.forEach((f) => {
      f.selection && s--;
    }, i);
    let l = t;
    this.items.forEach((f) => {
      let p = a.getMirror(--l);
      if (p == null)
        return;
      o = Math.min(o, p);
      let h = a.maps[p];
      if (f.step) {
        let v = e.steps[p].invert(e.docs[p]), m = f.selection && f.selection.map(a.slice(l + 1, p));
        m && s++, r.push(new Ko(h, v, m));
      } else
        r.push(new Ko(h));
    }, i);
    let u = [];
    for (let f = t; f < o; f++)
      u.push(new Ko(a.maps[f]));
    let c = this.items.slice(0, i).append(u).append(r), d = new go(c, s);
    return d.emptyItemCount() > fme && (d = d.compress(this.items.length - r.length)), d;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((t) => {
      t.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let t = this.remapping(0, e), r = t.maps.length, i = [], a = 0;
    return this.items.forEach((o, s) => {
      if (s >= e)
        i.push(o), o.selection && a++;
      else if (o.step) {
        let l = o.step.map(t.slice(r)), u = l && l.getMap();
        if (r--, u && t.appendMap(u, r), l) {
          let c = o.selection && o.selection.map(t.slice(r));
          c && a++;
          let d = new Ko(u.invert(), l, c), f, p = i.length - 1;
          (f = i.length && i[p].merge(d)) ? i[p] = f : i.push(d);
        }
      } else o.map && r--;
    }, this.items.length, 0), new go(Hr.from(i.reverse()), a);
  }
}
go.empty = new go(Hr.empty, 0);
function pme(n, e) {
  let t;
  return n.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return t = i, !1;
  }), n.slice(t);
}
class Ko {
  constructor(e, t, r, i) {
    this.map = e, this.step = t, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let t = e.step.merge(this.step);
      if (t)
        return new Ko(t.getMap().invert(), t, this.selection);
    }
  }
}
class Jl {
  constructor(e, t, r, i, a) {
    this.done = e, this.undone = t, this.prevRanges = r, this.prevTime = i, this.prevComposition = a;
  }
}
const hme = 20;
function vme(n, e, t, r) {
  let i = t.getMeta(ad), a;
  if (i)
    return i.historyState;
  t.getMeta(yme) && (n = new Jl(n.done, n.undone, null, 0, -1));
  let o = t.getMeta("appendedTransaction");
  if (t.steps.length == 0)
    return n;
  if (o && o.getMeta(ad))
    return o.getMeta(ad).redo ? new Jl(n.done.addTransform(t, void 0, r, l1(e)), n.undone, mR(t.mapping.maps), n.prevTime, n.prevComposition) : new Jl(n.done, n.undone.addTransform(t, void 0, r, l1(e)), null, n.prevTime, n.prevComposition);
  if (t.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
    let s = t.getMeta("composition"), l = n.prevTime == 0 || !o && n.prevComposition != s && (n.prevTime < (t.time || 0) - r.newGroupDelay || !mme(t, n.prevRanges)), u = o ? wS(n.prevRanges, t.mapping) : mR(t.mapping.maps);
    return new Jl(n.done.addTransform(t, l ? e.selection.getBookmark() : void 0, r, l1(e)), go.empty, u, t.time, s ?? n.prevComposition);
  } else return (a = t.getMeta("rebased")) ? new Jl(n.done.rebased(t, a), n.undone.rebased(t, a), wS(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) : new Jl(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), wS(n.prevRanges, t.mapping), n.prevTime, n.prevComposition);
}
function mme(n, e) {
  if (!e)
    return !1;
  if (!n.docChanged)
    return !0;
  let t = !1;
  return n.mapping.maps[0].forEach((r, i) => {
    for (let a = 0; a < e.length; a += 2)
      r <= e[a + 1] && i >= e[a] && (t = !0);
  }), t;
}
function mR(n) {
  let e = [];
  for (let t = n.length - 1; t >= 0 && e.length == 0; t--)
    n[t].forEach((r, i, a, o) => e.push(a, o));
  return e;
}
function wS(n, e) {
  if (!n)
    return null;
  let t = [];
  for (let r = 0; r < n.length; r += 2) {
    let i = e.map(n[r], 1), a = e.map(n[r + 1], -1);
    i <= a && t.push(i, a);
  }
  return t;
}
function gme(n, e, t) {
  let r = l1(e), i = ad.get(e).spec.config, a = (t ? n.undone : n.done).popEvent(e, r);
  if (!a)
    return null;
  let o = a.selection.resolve(a.transform.doc), s = (t ? n.done : n.undone).addTransform(a.transform, e.selection.getBookmark(), i, r), l = new Jl(t ? s : a.remaining, t ? a.remaining : s, null, 0, -1);
  return a.transform.setSelection(o).setMeta(ad, { redo: t, historyState: l });
}
let SS = !1, gR = null;
function l1(n) {
  let e = n.plugins;
  if (gR != e) {
    SS = !1, gR = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].spec.historyPreserveItems) {
        SS = !0;
        break;
      }
  }
  return SS;
}
const ad = new jn("history"), yme = new jn("closeHistory");
function bme(n = {}) {
  return n = {
    depth: n.depth || 100,
    newGroupDelay: n.newGroupDelay || 500
  }, new Pn({
    key: ad,
    state: {
      init() {
        return new Jl(go.empty, go.empty, null, 0, -1);
      },
      apply(e, t, r) {
        return vme(t, r, e, n);
      }
    },
    config: n,
    props: {
      handleDOMEvents: {
        beforeinput(e, t) {
          let r = t.inputType, i = r == "historyUndo" ? OH : r == "historyRedo" ? IH : null;
          return i ? (t.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function DH(n, e) {
  return (t, r) => {
    let i = ad.getState(t);
    if (!i || (n ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let a = gme(i, t, n);
      a && r(e ? a.scrollIntoView() : a);
    }
    return !0;
  };
}
const OH = DH(!1, !0), IH = DH(!0, !0), _me = Qn.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: n, dispatch: e }) => OH(n, e),
      redo: () => ({ state: n, dispatch: e }) => IH(n, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      bme(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
}), xme = pr.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["hr", Mn(this.options.HTMLAttributes, n)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: n, state: e }) => {
        if (!Xpe(e, e.schema.nodes[this.name]))
          return !1;
        const { selection: t } = e, { $from: r, $to: i } = t, a = n();
        return r.parentOffset === 0 ? a.insertContentAt({
          from: Math.max(r.pos - 1, 0),
          to: i.pos
        }, {
          type: this.name
        }) : J8(t) ? a.insertContentAt(i.pos, {
          type: this.name
        }) : a.insertContent({ type: this.name }), a.command(({ tr: o, dispatch: s }) => {
          var l;
          if (s) {
            const { $to: u } = o.selection, c = u.end();
            if (u.nodeAfter)
              u.nodeAfter.isTextblock ? o.setSelection(Dt.create(o.doc, u.pos + 1)) : u.nodeAfter.isBlock ? o.setSelection(Ct.create(o.doc, u.pos)) : o.setSelection(Dt.create(o.doc, u.pos));
            else {
              const d = (l = u.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
              d && (o.insert(c, d), o.setSelection(Dt.create(o.doc, c + 1)));
            }
            o.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      eH({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), wme = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, Sme = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, Eme = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, Tme = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, Cme = Ao.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (n) => n.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (n) => n.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["em", Mn(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: n }) => n.setMark(this.name),
      toggleItalic: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetItalic: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Dp({
        find: wme,
        type: this.type
      }),
      Dp({
        find: Eme,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Td({
        find: Sme,
        type: this.type
      }),
      Td({
        find: Tme,
        type: this.type
      })
    ];
  }
}), kme = pr.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["li", Mn(this.options.HTMLAttributes, n), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), Ame = "listItem", yR = "textStyle", bR = /^(\d+)\.\s$/, Mme = pr.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (n) => n.hasAttribute("start") ? parseInt(n.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: null,
        parseHTML: (n) => n.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    const { start: e, ...t } = n;
    return e === 1 ? ["ol", Mn(this.options.HTMLAttributes, t), 0] : ["ol", Mn(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: n, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Ame, this.editor.getAttributes(yR)).run() : n.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let n = Op({
      find: bR,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (n = Op({
      find: bR,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(yR) }),
      joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1],
      editor: this.editor
    })), [
      n
    ];
  }
}), Dme = pr.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["p", Mn(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: n }) => n.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), Ome = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, Ime = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, Lme = Ao.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (n) => n.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["s", Mn(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: n }) => n.setMark(this.name),
      toggleStrike: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetStrike: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Dp({
        find: Ome,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Td({
        find: Ime,
        type: this.type
      })
    ];
  }
}), Nme = pr.create({
  name: "text",
  group: "inline"
}), Rme = Qn.create({
  name: "starterKit",
  addExtensions() {
    const n = [];
    return this.options.bold !== !1 && n.push(Gve.configure(this.options.bold)), this.options.blockquote !== !1 && n.push($ve.configure(this.options.blockquote)), this.options.bulletList !== !1 && n.push(Wve.configure(this.options.bulletList)), this.options.code !== !1 && n.push(Kve.configure(this.options.code)), this.options.codeBlock !== !1 && n.push(kH.configure(this.options.codeBlock)), this.options.document !== !1 && n.push(Jve.configure(this.options.document)), this.options.dropcursor !== !1 && n.push(tme.configure(this.options.dropcursor)), this.options.gapcursor !== !1 && n.push(ume.configure(this.options.gapcursor)), this.options.hardBreak !== !1 && n.push(cme.configure(this.options.hardBreak)), this.options.heading !== !1 && n.push(AH.configure(this.options.heading)), this.options.history !== !1 && n.push(_me.configure(this.options.history)), this.options.horizontalRule !== !1 && n.push(xme.configure(this.options.horizontalRule)), this.options.italic !== !1 && n.push(Cme.configure(this.options.italic)), this.options.listItem !== !1 && n.push(kme.configure(this.options.listItem)), this.options.orderedList !== !1 && n.push(Mme.configure(this.options.orderedList)), this.options.paragraph !== !1 && n.push(Dme.configure(this.options.paragraph)), this.options.strike !== !1 && n.push(Lme.configure(this.options.strike)), this.options.text !== !1 && n.push(Nme.configure(this.options.text)), n;
  }
}), Pme = Qn.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something …",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new Pn({
        key: new jn("placeholder"),
        props: {
          decorations: ({ doc: n, selection: e }) => {
            const t = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: r } = e, i = [];
            if (!t)
              return null;
            const a = this.editor.isEmpty;
            return n.descendants((o, s) => {
              const l = r >= s && r <= s + o.nodeSize, u = !o.isLeaf && Dx(o);
              if ((l || !this.options.showOnlyCurrent) && u) {
                const c = [this.options.emptyNodeClass];
                a && c.push(this.options.emptyEditorClass);
                const d = zr.node(s, s + o.nodeSize, {
                  class: c.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: o,
                    pos: s,
                    hasAnchor: l
                  }) : this.options.placeholder
                });
                i.push(d);
              }
              return this.options.includeChildren;
            }), Zn.create(n, i);
          }
        }
      })
    ];
  }
}), jme = Qn.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (n) => {
              const e = n.style.textAlign;
              return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
            },
            renderHTML: (n) => n.textAlign ? { style: `text-align: ${n.textAlign}` } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (n) => ({ commands: e }) => this.options.alignments.includes(n) ? this.options.types.map((t) => e.updateAttributes(t, { textAlign: n })).every((t) => t) : !1,
      unsetTextAlign: () => ({ commands: n }) => this.options.types.map((e) => n.resetAttributes(e, "textAlign")).every((e) => e),
      toggleTextAlign: (n) => ({ editor: e, commands: t }) => this.options.alignments.includes(n) ? e.isActive({ textAlign: n }) ? t.unsetTextAlign() : t.setTextAlign(n) : !1
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
var cC, dC;
if (typeof WeakMap < "u") {
  let n = /* @__PURE__ */ new WeakMap();
  cC = (e) => n.get(e), dC = (e, t) => (n.set(e, t), t);
} else {
  const n = [];
  let t = 0;
  cC = (r) => {
    for (let i = 0; i < n.length; i += 2)
      if (n[i] == r) return n[i + 1];
  }, dC = (r, i) => (t == 10 && (t = 0), n[t++] = r, n[t++] = i);
}
var cr = class {
  constructor(n, e, t, r) {
    this.width = n, this.height = e, this.map = t, this.problems = r;
  }
  // Find the dimensions of the cell at the given position.
  findCell(n) {
    for (let e = 0; e < this.map.length; e++) {
      const t = this.map[e];
      if (t != n) continue;
      const r = e % this.width, i = e / this.width | 0;
      let a = r + 1, o = i + 1;
      for (let s = 1; a < this.width && this.map[e + s] == t; s++)
        a++;
      for (let s = 1; o < this.height && this.map[e + this.width * s] == t; s++)
        o++;
      return { left: r, top: i, right: a, bottom: o };
    }
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(n) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == n)
        return e % this.width;
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(n, e, t) {
    const { left: r, right: i, top: a, bottom: o } = this.findCell(n);
    return e == "horiz" ? (t < 0 ? r == 0 : i == this.width) ? null : this.map[a * this.width + (t < 0 ? r - 1 : i)] : (t < 0 ? a == 0 : o == this.height) ? null : this.map[r + this.width * (t < 0 ? a - 1 : o)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(n, e) {
    const {
      left: t,
      right: r,
      top: i,
      bottom: a
    } = this.findCell(n), {
      left: o,
      right: s,
      top: l,
      bottom: u
    } = this.findCell(e);
    return {
      left: Math.min(t, o),
      top: Math.min(i, l),
      right: Math.max(r, s),
      bottom: Math.max(a, u)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(n) {
    const e = [], t = {};
    for (let r = n.top; r < n.bottom; r++)
      for (let i = n.left; i < n.right; i++) {
        const a = r * this.width + i, o = this.map[a];
        t[o] || (t[o] = !0, !(i == n.left && i && this.map[a - 1] == o || r == n.top && r && this.map[a - this.width] == o) && e.push(o));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(n, e, t) {
    for (let r = 0, i = 0; ; r++) {
      const a = i + t.child(r).nodeSize;
      if (r == n) {
        let o = e + n * this.width;
        const s = (n + 1) * this.width;
        for (; o < s && this.map[o] < i; ) o++;
        return o == s ? a - 1 : this.map[o];
      }
      i = a;
    }
  }
  // Find the table map for the given table node.
  static get(n) {
    return cC(n) || dC(n, Bme(n));
  }
};
function Bme(n) {
  if (n.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + n.type.name);
  const e = $me(n), t = n.childCount, r = [];
  let i = 0, a = null;
  const o = [];
  for (let u = 0, c = e * t; u < c; u++) r[u] = 0;
  for (let u = 0, c = 0; u < t; u++) {
    const d = n.child(u);
    c++;
    for (let h = 0; ; h++) {
      for (; i < r.length && r[i] != 0; ) i++;
      if (h == d.childCount) break;
      const v = d.child(h), { colspan: m, rowspan: g, colwidth: y } = v.attrs;
      for (let b = 0; b < g; b++) {
        if (b + u >= t) {
          (a || (a = [])).push({
            type: "overlong_rowspan",
            pos: c,
            n: g - b
          });
          break;
        }
        const _ = i + b * e;
        for (let x = 0; x < m; x++) {
          r[_ + x] == 0 ? r[_ + x] = c : (a || (a = [])).push({
            type: "collision",
            row: u,
            pos: c,
            n: m - x
          });
          const w = y && y[x];
          if (w) {
            const S = (_ + x) % e * 2, C = o[S];
            C == null || C != w && o[S + 1] == 1 ? (o[S] = w, o[S + 1] = 1) : C == w && o[S + 1]++;
          }
        }
      }
      i += m, c += v.nodeSize;
    }
    const f = (u + 1) * e;
    let p = 0;
    for (; i < f; ) r[i++] == 0 && p++;
    p && (a || (a = [])).push({ type: "missing", row: u, n: p }), c++;
  }
  (e === 0 || t === 0) && (a || (a = [])).push({ type: "zero_sized" });
  const s = new cr(e, t, r, a);
  let l = !1;
  for (let u = 0; !l && u < o.length; u += 2)
    o[u] != null && o[u + 1] < t && (l = !0);
  return l && zme(s, o, n), s;
}
function $me(n) {
  let e = -1, t = !1;
  for (let r = 0; r < n.childCount; r++) {
    const i = n.child(r);
    let a = 0;
    if (t)
      for (let o = 0; o < r; o++) {
        const s = n.child(o);
        for (let l = 0; l < s.childCount; l++) {
          const u = s.child(l);
          o + u.attrs.rowspan > r && (a += u.attrs.colspan);
        }
      }
    for (let o = 0; o < i.childCount; o++) {
      const s = i.child(o);
      a += s.attrs.colspan, s.attrs.rowspan > 1 && (t = !0);
    }
    e == -1 ? e = a : e != a && (e = Math.max(e, a));
  }
  return e;
}
function zme(n, e, t) {
  n.problems || (n.problems = []);
  const r = {};
  for (let i = 0; i < n.map.length; i++) {
    const a = n.map[i];
    if (r[a]) continue;
    r[a] = !0;
    const o = t.nodeAt(a);
    if (!o)
      throw new RangeError(`No cell with offset ${a} found`);
    let s = null;
    const l = o.attrs;
    for (let u = 0; u < l.colspan; u++) {
      const c = (i + u) % n.width, d = e[c * 2];
      d != null && (!l.colwidth || l.colwidth[u] != d) && ((s || (s = Fme(l)))[u] = d);
    }
    s && n.problems.unshift({
      type: "colwidth mismatch",
      pos: a,
      colwidth: s
    });
  }
}
function Fme(n) {
  if (n.colwidth) return n.colwidth.slice();
  const e = [];
  for (let t = 0; t < n.colspan; t++) e.push(0);
  return e;
}
function pi(n) {
  let e = n.cached.tableNodeTypes;
  if (!e) {
    e = n.cached.tableNodeTypes = {};
    for (const t in n.nodes) {
      const r = n.nodes[t], i = r.spec.tableRole;
      i && (e[i] = r);
    }
  }
  return e;
}
var iu = new jn("selectingCells");
function ah(n) {
  for (let e = n.depth - 1; e > 0; e--)
    if (n.node(e).type.spec.tableRole == "row")
      return n.node(0).resolve(n.before(e + 1));
  return null;
}
function Vme(n) {
  for (let e = n.depth; e > 0; e--) {
    const t = n.node(e).type.spec.tableRole;
    if (t === "cell" || t === "header_cell") return n.node(e);
  }
  return null;
}
function No(n) {
  const e = n.selection.$head;
  for (let t = e.depth; t > 0; t--)
    if (e.node(t).type.spec.tableRole == "row") return !0;
  return !1;
}
function Lx(n) {
  const e = n.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const t = ah(e.$head) || Hme(e.$head);
  if (t)
    return t;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function Hme(n) {
  for (let e = n.nodeAfter, t = n.pos; e; e = e.firstChild, t++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return n.doc.resolve(t);
  }
  for (let e = n.nodeBefore, t = n.pos; e; e = e.lastChild, t--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return n.doc.resolve(t - e.nodeSize);
  }
}
function fC(n) {
  return n.parent.type.spec.tableRole == "row" && !!n.nodeAfter;
}
function Gme(n) {
  return n.node(0).resolve(n.pos + n.nodeAfter.nodeSize);
}
function HM(n, e) {
  return n.depth == e.depth && n.pos >= e.start(-1) && n.pos <= e.end(-1);
}
function LH(n, e, t) {
  const r = n.node(-1), i = cr.get(r), a = n.start(-1), o = i.nextCell(n.pos - a, e, t);
  return o == null ? null : n.node(0).resolve(a + o);
}
function kd(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan - t };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, t), r.colwidth.some((i) => i > 0) || (r.colwidth = null)), r;
}
function NH(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan + t };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let i = 0; i < t; i++) r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function Ume(n, e, t) {
  const r = pi(e.type.schema).header_cell;
  for (let i = 0; i < n.height; i++)
    if (e.nodeAt(n.map[t + i * n.width]).type != r)
      return !1;
  return !0;
}
var qn = class Vs extends It {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, t = e) {
    const r = e.node(-1), i = cr.get(r), a = e.start(-1), o = i.rectBetween(
      e.pos - a,
      t.pos - a
    ), s = e.node(0), l = i.cellsInRect(o).filter((c) => c != t.pos - a);
    l.unshift(t.pos - a);
    const u = l.map((c) => {
      const d = r.nodeAt(c);
      if (!d)
        throw RangeError(`No cell with offset ${c} found`);
      const f = a + c + 1;
      return new U6(
        s.resolve(f),
        s.resolve(f + d.content.size)
      );
    });
    super(u[0].$from, u[0].$to, u), this.$anchorCell = e, this.$headCell = t;
  }
  map(e, t) {
    const r = e.resolve(t.map(this.$anchorCell.pos)), i = e.resolve(t.map(this.$headCell.pos));
    if (fC(r) && fC(i) && HM(r, i)) {
      const a = this.$anchorCell.node(-1) != r.node(-1);
      return a && this.isRowSelection() ? Vs.rowSelection(r, i) : a && this.isColSelection() ? Vs.colSelection(r, i) : new Vs(r, i);
    }
    return Dt.between(r, i);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), t = cr.get(e), r = this.$anchorCell.start(-1), i = t.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    ), a = {}, o = [];
    for (let l = i.top; l < i.bottom; l++) {
      const u = [];
      for (let c = l * t.width + i.left, d = i.left; d < i.right; d++, c++) {
        const f = t.map[c];
        if (a[f]) continue;
        a[f] = !0;
        const p = t.findCell(f);
        let h = e.nodeAt(f);
        if (!h)
          throw RangeError(`No cell with offset ${f} found`);
        const v = i.left - p.left, m = p.right - i.right;
        if (v > 0 || m > 0) {
          let g = h.attrs;
          if (v > 0 && (g = kd(g, 0, v)), m > 0 && (g = kd(
            g,
            g.colspan - m,
            m
          )), p.left < i.left) {
            if (h = h.type.createAndFill(g), !h)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(g)}`
              );
          } else
            h = h.type.create(g, h.content);
        }
        if (p.top < i.top || p.bottom > i.bottom) {
          const g = {
            ...h.attrs,
            rowspan: Math.min(p.bottom, i.bottom) - Math.max(p.top, i.top)
          };
          p.top < i.top ? h = h.type.createAndFill(g) : h = h.type.create(g, h.content);
        }
        u.push(h);
      }
      o.push(e.child(l).copy($e.from(u)));
    }
    const s = this.isColSelection() && this.isRowSelection() ? e : o;
    return new nt($e.from(s), 1, 1);
  }
  replace(e, t = nt.empty) {
    const r = e.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      const { $from: s, $to: l } = i[o], u = e.mapping.slice(r);
      e.replace(
        u.map(s.pos),
        u.map(l.pos),
        o ? nt.empty : t
      );
    }
    const a = It.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    );
    a && e.setSelection(a);
  }
  replaceWith(e, t) {
    this.replace(e, new nt($e.from(t), 0, 0));
  }
  forEachCell(e) {
    const t = this.$anchorCell.node(-1), r = cr.get(t), i = this.$anchorCell.start(-1), a = r.cellsInRect(
      r.rectBetween(
        this.$anchorCell.pos - i,
        this.$headCell.pos - i
      )
    );
    for (let o = 0; o < a.length; o++)
      e(t.nodeAt(a[o]), i + a[o]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), t = this.$headCell.index(-1);
    if (Math.min(e, t) > 0) return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = t + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, i) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, t = e) {
    const r = e.node(-1), i = cr.get(r), a = e.start(-1), o = i.findCell(e.pos - a), s = i.findCell(t.pos - a), l = e.node(0);
    return o.top <= s.top ? (o.top > 0 && (e = l.resolve(a + i.map[o.left])), s.bottom < i.height && (t = l.resolve(
      a + i.map[i.width * (i.height - 1) + s.right - 1]
    ))) : (s.top > 0 && (t = l.resolve(a + i.map[s.left])), o.bottom < i.height && (e = l.resolve(
      a + i.map[i.width * (i.height - 1) + o.right - 1]
    ))), new Vs(e, t);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), t = cr.get(e), r = this.$anchorCell.start(-1), i = t.colCount(this.$anchorCell.pos - r), a = t.colCount(this.$headCell.pos - r);
    if (Math.min(i, a) > 0) return !1;
    const o = i + this.$anchorCell.nodeAfter.attrs.colspan, s = a + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(o, s) == t.width;
  }
  eq(e) {
    return e instanceof Vs && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, t = e) {
    const r = e.node(-1), i = cr.get(r), a = e.start(-1), o = i.findCell(e.pos - a), s = i.findCell(t.pos - a), l = e.node(0);
    return o.left <= s.left ? (o.left > 0 && (e = l.resolve(
      a + i.map[o.top * i.width]
    )), s.right < i.width && (t = l.resolve(
      a + i.map[i.width * (s.top + 1) - 1]
    ))) : (s.left > 0 && (t = l.resolve(a + i.map[s.top * i.width])), o.right < i.width && (e = l.resolve(
      a + i.map[i.width * (o.top + 1) - 1]
    ))), new Vs(e, t);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, t) {
    return new Vs(e.resolve(t.anchor), e.resolve(t.head));
  }
  static create(e, t, r = t) {
    return new Vs(e.resolve(t), e.resolve(r));
  }
  getBookmark() {
    return new Wme(this.$anchorCell.pos, this.$headCell.pos);
  }
};
qn.prototype.visible = !1;
It.jsonID("cell", qn);
var Wme = class RH {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new RH(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const t = e.resolve(this.anchor), r = e.resolve(this.head);
    return t.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && t.index() < t.parent.childCount && r.index() < r.parent.childCount && HM(t, r) ? new qn(t, r) : It.near(r, 1);
  }
};
function qme(n) {
  if (!(n.selection instanceof qn)) return null;
  const e = [];
  return n.selection.forEachCell((t, r) => {
    e.push(
      zr.node(r, r + t.nodeSize, { class: "selectedCell" })
    );
  }), Zn.create(n.doc, e);
}
function Yme({ $from: n, $to: e }) {
  if (n.pos == e.pos || n.pos < e.pos - 6) return !1;
  let t = n.pos, r = e.pos, i = n.depth;
  for (; i >= 0 && !(n.after(i + 1) < n.end(i)); i--, t++)
    ;
  for (let a = e.depth; a >= 0 && !(e.before(a + 1) > e.start(a)); a--, r--)
    ;
  return t == r && /row|table/.test(n.node(i).type.spec.tableRole);
}
function Kme({ $from: n, $to: e }) {
  let t, r;
  for (let i = n.depth; i > 0; i--) {
    const a = n.node(i);
    if (a.type.spec.tableRole === "cell" || a.type.spec.tableRole === "header_cell") {
      t = a;
      break;
    }
  }
  for (let i = e.depth; i > 0; i--) {
    const a = e.node(i);
    if (a.type.spec.tableRole === "cell" || a.type.spec.tableRole === "header_cell") {
      r = a;
      break;
    }
  }
  return t !== r && e.parentOffset === 0;
}
function Xme(n, e, t) {
  const r = (e || n).selection, i = (e || n).doc;
  let a, o;
  if (r instanceof Ct && (o = r.node.type.spec.tableRole)) {
    if (o == "cell" || o == "header_cell")
      a = qn.create(i, r.from);
    else if (o == "row") {
      const s = i.resolve(r.from + 1);
      a = qn.rowSelection(s, s);
    } else if (!t) {
      const s = cr.get(r.node), l = r.from + 1, u = l + s.map[s.width * s.height - 1];
      a = qn.create(i, l + 1, u);
    }
  } else r instanceof Dt && Yme(r) ? a = Dt.create(i, r.from) : r instanceof Dt && Kme(r) && (a = Dt.create(i, r.$from.start(), r.$from.end()));
  return a && (e || (e = n.tr)).setSelection(a), e;
}
var Zme = new jn("fix-tables");
function PH(n, e, t, r) {
  const i = n.childCount, a = e.childCount;
  e: for (let o = 0, s = 0; o < a; o++) {
    const l = e.child(o);
    for (let u = s, c = Math.min(i, o + 3); u < c; u++)
      if (n.child(u) == l) {
        s = u + 1, t += l.nodeSize;
        continue e;
      }
    r(l, t), s < i && n.child(s).sameMarkup(l) ? PH(n.child(s), l, t + 1, r) : l.nodesBetween(0, l.content.size, r, t + 1), t += l.nodeSize;
  }
}
function jH(n, e) {
  let t;
  const r = (i, a) => {
    i.type.spec.tableRole == "table" && (t = Jme(n, i, a, t));
  };
  return e ? e.doc != n.doc && PH(e.doc, n.doc, 0, r) : n.doc.descendants(r), t;
}
function Jme(n, e, t, r) {
  const i = cr.get(e);
  if (!i.problems) return r;
  r || (r = n.tr);
  const a = [];
  for (let l = 0; l < i.height; l++) a.push(0);
  for (let l = 0; l < i.problems.length; l++) {
    const u = i.problems[l];
    if (u.type == "collision") {
      const c = e.nodeAt(u.pos);
      if (!c) continue;
      const d = c.attrs;
      for (let f = 0; f < d.rowspan; f++) a[u.row + f] += u.n;
      r.setNodeMarkup(
        r.mapping.map(t + 1 + u.pos),
        null,
        kd(d, d.colspan - u.n, u.n)
      );
    } else if (u.type == "missing")
      a[u.row] += u.n;
    else if (u.type == "overlong_rowspan") {
      const c = e.nodeAt(u.pos);
      if (!c) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + u.pos), null, {
        ...c.attrs,
        rowspan: c.attrs.rowspan - u.n
      });
    } else if (u.type == "colwidth mismatch") {
      const c = e.nodeAt(u.pos);
      if (!c) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + u.pos), null, {
        ...c.attrs,
        colwidth: u.colwidth
      });
    } else if (u.type == "zero_sized") {
      const c = r.mapping.map(t);
      r.delete(c, c + e.nodeSize);
    }
  }
  let o, s;
  for (let l = 0; l < a.length; l++)
    a[l] && (o == null && (o = l), s = l);
  for (let l = 0, u = t + 1; l < i.height; l++) {
    const c = e.child(l), d = u + c.nodeSize, f = a[l];
    if (f > 0) {
      let p = "cell";
      c.firstChild && (p = c.firstChild.type.spec.tableRole);
      const h = [];
      for (let m = 0; m < f; m++) {
        const g = pi(n.schema)[p].createAndFill();
        g && h.push(g);
      }
      const v = (l == 0 || o == l - 1) && s == l ? u + 1 : d - 1;
      r.insert(r.mapping.map(v), h);
    }
    u = d;
  }
  return r.setMeta(Zme, { fixTables: !0 });
}
function As(n) {
  const e = n.selection, t = Lx(n), r = t.node(-1), i = t.start(-1), a = cr.get(r);
  return { ...e instanceof qn ? a.rectBetween(
    e.$anchorCell.pos - i,
    e.$headCell.pos - i
  ) : a.findCell(t.pos - i), tableStart: i, map: a, table: r };
}
function BH(n, { map: e, tableStart: t, table: r }, i) {
  let a = i > 0 ? -1 : 0;
  Ume(e, r, i + a) && (a = i == 0 || i == e.width ? null : 0);
  for (let o = 0; o < e.height; o++) {
    const s = o * e.width + i;
    if (i > 0 && i < e.width && e.map[s - 1] == e.map[s]) {
      const l = e.map[s], u = r.nodeAt(l);
      n.setNodeMarkup(
        n.mapping.map(t + l),
        null,
        NH(u.attrs, i - e.colCount(l))
      ), o += u.attrs.rowspan - 1;
    } else {
      const l = a == null ? pi(r.type.schema).cell : r.nodeAt(e.map[s + a]).type, u = e.positionAt(o, i, r);
      n.insert(n.mapping.map(t + u), l.createAndFill());
    }
  }
  return n;
}
function Qme(n, e) {
  if (!No(n)) return !1;
  if (e) {
    const t = As(n);
    e(BH(n.tr, t, t.left));
  }
  return !0;
}
function ege(n, e) {
  if (!No(n)) return !1;
  if (e) {
    const t = As(n);
    e(BH(n.tr, t, t.right));
  }
  return !0;
}
function tge(n, { map: e, table: t, tableStart: r }, i) {
  const a = n.mapping.maps.length;
  for (let o = 0; o < e.height; ) {
    const s = o * e.width + i, l = e.map[s], u = t.nodeAt(l), c = u.attrs;
    if (i > 0 && e.map[s - 1] == l || i < e.width - 1 && e.map[s + 1] == l)
      n.setNodeMarkup(
        n.mapping.slice(a).map(r + l),
        null,
        kd(c, i - e.colCount(l))
      );
    else {
      const d = n.mapping.slice(a).map(r + l);
      n.delete(d, d + u.nodeSize);
    }
    o += c.rowspan;
  }
}
function nge(n, e) {
  if (!No(n)) return !1;
  if (e) {
    const t = As(n), r = n.tr;
    if (t.left == 0 && t.right == t.map.width) return !1;
    for (let i = t.right - 1; tge(r, t, i), i != t.left; i--) {
      const a = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!a)
        throw RangeError("No table found");
      t.table = a, t.map = cr.get(a);
    }
    e(r);
  }
  return !0;
}
function rge(n, e, t) {
  var r;
  const i = pi(e.type.schema).header_cell;
  for (let a = 0; a < n.width; a++)
    if (((r = e.nodeAt(n.map[a + t * n.width])) == null ? void 0 : r.type) != i)
      return !1;
  return !0;
}
function $H(n, { map: e, tableStart: t, table: r }, i) {
  var a;
  let o = t;
  for (let u = 0; u < i; u++) o += r.child(u).nodeSize;
  const s = [];
  let l = i > 0 ? -1 : 0;
  rge(e, r, i + l) && (l = i == 0 || i == e.height ? null : 0);
  for (let u = 0, c = e.width * i; u < e.width; u++, c++)
    if (i > 0 && i < e.height && e.map[c] == e.map[c - e.width]) {
      const d = e.map[c], f = r.nodeAt(d).attrs;
      n.setNodeMarkup(t + d, null, {
        ...f,
        rowspan: f.rowspan + 1
      }), u += f.colspan - 1;
    } else {
      const d = l == null ? pi(r.type.schema).cell : (a = r.nodeAt(e.map[c + l * e.width])) == null ? void 0 : a.type, f = d == null ? void 0 : d.createAndFill();
      f && s.push(f);
    }
  return n.insert(o, pi(r.type.schema).row.create(null, s)), n;
}
function ige(n, e) {
  if (!No(n)) return !1;
  if (e) {
    const t = As(n);
    e($H(n.tr, t, t.top));
  }
  return !0;
}
function age(n, e) {
  if (!No(n)) return !1;
  if (e) {
    const t = As(n);
    e($H(n.tr, t, t.bottom));
  }
  return !0;
}
function oge(n, { map: e, table: t, tableStart: r }, i) {
  let a = 0;
  for (let u = 0; u < i; u++) a += t.child(u).nodeSize;
  const o = a + t.child(i).nodeSize, s = n.mapping.maps.length;
  n.delete(a + r, o + r);
  const l = /* @__PURE__ */ new Set();
  for (let u = 0, c = i * e.width; u < e.width; u++, c++) {
    const d = e.map[c];
    if (!l.has(d)) {
      if (l.add(d), i > 0 && d == e.map[c - e.width]) {
        const f = t.nodeAt(d).attrs;
        n.setNodeMarkup(n.mapping.slice(s).map(d + r), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), u += f.colspan - 1;
      } else if (i < e.height && d == e.map[c + e.width]) {
        const f = t.nodeAt(d), p = f.attrs, h = f.type.create(
          { ...p, rowspan: f.attrs.rowspan - 1 },
          f.content
        ), v = e.positionAt(i + 1, u, t);
        n.insert(n.mapping.slice(s).map(r + v), h), u += p.colspan - 1;
      }
    }
  }
}
function sge(n, e) {
  if (!No(n)) return !1;
  if (e) {
    const t = As(n), r = n.tr;
    if (t.top == 0 && t.bottom == t.map.height) return !1;
    for (let i = t.bottom - 1; oge(r, t, i), i != t.top; i--) {
      const a = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!a)
        throw RangeError("No table found");
      t.table = a, t.map = cr.get(t.table);
    }
    e(r);
  }
  return !0;
}
function _R(n) {
  const e = n.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function lge({ width: n, height: e, map: t }, r) {
  let i = r.top * n + r.left, a = i, o = (r.bottom - 1) * n + r.left, s = i + (r.right - r.left - 1);
  for (let l = r.top; l < r.bottom; l++) {
    if (r.left > 0 && t[a] == t[a - 1] || r.right < n && t[s] == t[s + 1])
      return !0;
    a += n, s += n;
  }
  for (let l = r.left; l < r.right; l++) {
    if (r.top > 0 && t[i] == t[i - n] || r.bottom < e && t[o] == t[o + n])
      return !0;
    i++, o++;
  }
  return !1;
}
function xR(n, e) {
  const t = n.selection;
  if (!(t instanceof qn) || t.$anchorCell.pos == t.$headCell.pos)
    return !1;
  const r = As(n), { map: i } = r;
  if (lge(i, r)) return !1;
  if (e) {
    const a = n.tr, o = {};
    let s = $e.empty, l, u;
    for (let c = r.top; c < r.bottom; c++)
      for (let d = r.left; d < r.right; d++) {
        const f = i.map[c * i.width + d], p = r.table.nodeAt(f);
        if (!(o[f] || !p))
          if (o[f] = !0, l == null)
            l = f, u = p;
          else {
            _R(p) || (s = s.append(p.content));
            const h = a.mapping.map(f + r.tableStart);
            a.delete(h, h + p.nodeSize);
          }
      }
    if (l == null || u == null)
      return !0;
    if (a.setNodeMarkup(l + r.tableStart, null, {
      ...NH(
        u.attrs,
        u.attrs.colspan,
        r.right - r.left - u.attrs.colspan
      ),
      rowspan: r.bottom - r.top
    }), s.size) {
      const c = l + 1 + u.content.size, d = _R(u) ? l + 1 : c;
      a.replaceWith(d + r.tableStart, c + r.tableStart, s);
    }
    a.setSelection(
      new qn(a.doc.resolve(l + r.tableStart))
    ), e(a);
  }
  return !0;
}
function wR(n, e) {
  const t = pi(n.schema);
  return uge(({ node: r }) => t[r.type.spec.tableRole])(n, e);
}
function uge(n) {
  return (e, t) => {
    var r;
    const i = e.selection;
    let a, o;
    if (i instanceof qn) {
      if (i.$anchorCell.pos != i.$headCell.pos) return !1;
      a = i.$anchorCell.nodeAfter, o = i.$anchorCell.pos;
    } else {
      if (a = Vme(i.$from), !a) return !1;
      o = (r = ah(i.$from)) == null ? void 0 : r.pos;
    }
    if (a == null || o == null || a.attrs.colspan == 1 && a.attrs.rowspan == 1)
      return !1;
    if (t) {
      let s = a.attrs;
      const l = [], u = s.colwidth;
      s.rowspan > 1 && (s = { ...s, rowspan: 1 }), s.colspan > 1 && (s = { ...s, colspan: 1 });
      const c = As(e), d = e.tr;
      for (let p = 0; p < c.right - c.left; p++)
        l.push(
          u ? {
            ...s,
            colwidth: u && u[p] ? [u[p]] : null
          } : s
        );
      let f;
      for (let p = c.top; p < c.bottom; p++) {
        let h = c.map.positionAt(p, c.left, c.table);
        p == c.top && (h += a.nodeSize);
        for (let v = c.left, m = 0; v < c.right; v++, m++)
          v == c.left && p == c.top || d.insert(
            f = d.mapping.map(h + c.tableStart, 1),
            n({ node: a, row: p, col: v }).createAndFill(l[m])
          );
      }
      d.setNodeMarkup(
        o,
        n({ node: a, row: c.top, col: c.left }),
        l[0]
      ), i instanceof qn && d.setSelection(
        new qn(
          d.doc.resolve(i.$anchorCell.pos),
          f ? d.doc.resolve(f) : void 0
        )
      ), t(d);
    }
    return !0;
  };
}
function cge(n, e) {
  return function(t, r) {
    if (!No(t)) return !1;
    const i = Lx(t);
    if (i.nodeAfter.attrs[n] === e) return !1;
    if (r) {
      const a = t.tr;
      t.selection instanceof qn ? t.selection.forEachCell((o, s) => {
        o.attrs[n] !== e && a.setNodeMarkup(s, null, {
          ...o.attrs,
          [n]: e
        });
      }) : a.setNodeMarkup(i.pos, null, {
        ...i.nodeAfter.attrs,
        [n]: e
      }), r(a);
    }
    return !0;
  };
}
function dge(n) {
  return function(e, t) {
    if (!No(e)) return !1;
    if (t) {
      const r = pi(e.schema), i = As(e), a = e.tr, o = i.map.cellsInRect(
        n == "column" ? {
          left: i.left,
          top: 0,
          right: i.right,
          bottom: i.map.height
        } : n == "row" ? {
          left: 0,
          top: i.top,
          right: i.map.width,
          bottom: i.bottom
        } : i
      ), s = o.map((l) => i.table.nodeAt(l));
      for (let l = 0; l < o.length; l++)
        s[l].type == r.header_cell && a.setNodeMarkup(
          i.tableStart + o[l],
          r.cell,
          s[l].attrs
        );
      if (a.steps.length == 0)
        for (let l = 0; l < o.length; l++)
          a.setNodeMarkup(
            i.tableStart + o[l],
            r.header_cell,
            s[l].attrs
          );
      t(a);
    }
    return !0;
  };
}
function SR(n, e, t) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: n == "row" ? e.map.width : 1,
    bottom: n == "column" ? e.map.height : 1
  });
  for (let i = 0; i < r.length; i++) {
    const a = e.table.nodeAt(r[i]);
    if (a && a.type !== t.header_cell)
      return !1;
  }
  return !0;
}
function zm(n, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? dge(n) : function(t, r) {
    if (!No(t)) return !1;
    if (r) {
      const i = pi(t.schema), a = As(t), o = t.tr, s = SR("row", a, i), l = SR(
        "column",
        a,
        i
      ), c = (n === "column" ? s : n === "row" ? l : !1) ? 1 : 0, d = n == "column" ? {
        left: 0,
        top: c,
        right: 1,
        bottom: a.map.height
      } : n == "row" ? {
        left: c,
        top: 0,
        right: a.map.width,
        bottom: 1
      } : a, f = n == "column" ? l ? i.cell : i.header_cell : n == "row" ? s ? i.cell : i.header_cell : i.cell;
      a.map.cellsInRect(d).forEach((p) => {
        const h = p + a.tableStart, v = o.doc.nodeAt(h);
        v && o.setNodeMarkup(h, f, v.attrs);
      }), r(o);
    }
    return !0;
  };
}
zm("row", {
  useDeprecatedLogic: !0
});
zm("column", {
  useDeprecatedLogic: !0
});
var fge = zm("cell", {
  useDeprecatedLogic: !0
});
function pge(n, e) {
  if (e < 0) {
    const t = n.nodeBefore;
    if (t) return n.pos - t.nodeSize;
    for (let r = n.index(-1) - 1, i = n.before(); r >= 0; r--) {
      const a = n.node(-1).child(r), o = a.lastChild;
      if (o)
        return i - 1 - o.nodeSize;
      i -= a.nodeSize;
    }
  } else {
    if (n.index() < n.parent.childCount - 1)
      return n.pos + n.nodeAfter.nodeSize;
    const t = n.node(-1);
    for (let r = n.indexAfter(-1), i = n.after(); r < t.childCount; r++) {
      const a = t.child(r);
      if (a.childCount) return i + 1;
      i += a.nodeSize;
    }
  }
  return null;
}
function ER(n) {
  return function(e, t) {
    if (!No(e)) return !1;
    const r = pge(Lx(e), n);
    if (r == null) return !1;
    if (t) {
      const i = e.doc.resolve(r);
      t(
        e.tr.setSelection(Dt.between(i, Gme(i))).scrollIntoView()
      );
    }
    return !0;
  };
}
function hge(n, e) {
  const t = n.selection.$anchor;
  for (let r = t.depth; r > 0; r--)
    if (t.node(r).type.spec.tableRole == "table")
      return e && e(
        n.tr.delete(t.before(r), t.after(r)).scrollIntoView()
      ), !0;
  return !1;
}
function Ny(n, e) {
  const t = n.selection;
  if (!(t instanceof qn)) return !1;
  if (e) {
    const r = n.tr, i = pi(n.schema).cell.createAndFill().content;
    t.forEachCell((a, o) => {
      a.content.eq(i) || r.replace(
        r.mapping.map(o + 1),
        r.mapping.map(o + a.nodeSize - 1),
        new nt(i, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function vge(n) {
  if (!n.size) return null;
  let { content: e, openStart: t, openEnd: r } = n;
  for (; e.childCount == 1 && (t > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    t--, r--, e = e.child(0).content;
  const i = e.child(0), a = i.type.spec.tableRole, o = i.type.schema, s = [];
  if (a == "row")
    for (let l = 0; l < e.childCount; l++) {
      let u = e.child(l).content;
      const c = l ? 0 : Math.max(0, t - 1), d = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (c || d) && (u = pC(
        pi(o).row,
        new nt(u, c, d)
      ).content), s.push(u);
    }
  else if (a == "cell" || a == "header_cell")
    s.push(
      t || r ? pC(
        pi(o).row,
        new nt(e, t, r)
      ).content : e
    );
  else
    return null;
  return mge(o, s);
}
function mge(n, e) {
  const t = [];
  for (let i = 0; i < e.length; i++) {
    const a = e[i];
    for (let o = a.childCount - 1; o >= 0; o--) {
      const { rowspan: s, colspan: l } = a.child(o).attrs;
      for (let u = i; u < i + s; u++)
        t[u] = (t[u] || 0) + l;
    }
  }
  let r = 0;
  for (let i = 0; i < t.length; i++) r = Math.max(r, t[i]);
  for (let i = 0; i < t.length; i++)
    if (i >= e.length && e.push($e.empty), t[i] < r) {
      const a = pi(n).cell.createAndFill(), o = [];
      for (let s = t[i]; s < r; s++)
        o.push(a);
      e[i] = e[i].append($e.from(o));
    }
  return { height: e.length, width: r, rows: e };
}
function pC(n, e) {
  const t = n.createAndFill();
  return new cM(t).replace(0, t.content.size, e).doc;
}
function gge({ width: n, height: e, rows: t }, r, i) {
  if (n != r) {
    const a = [], o = [];
    for (let s = 0; s < t.length; s++) {
      const l = t[s], u = [];
      for (let c = a[s] || 0, d = 0; c < r; d++) {
        let f = l.child(d % l.childCount);
        c + f.attrs.colspan > r && (f = f.type.createChecked(
          kd(
            f.attrs,
            f.attrs.colspan,
            c + f.attrs.colspan - r
          ),
          f.content
        )), u.push(f), c += f.attrs.colspan;
        for (let p = 1; p < f.attrs.rowspan; p++)
          a[s + p] = (a[s + p] || 0) + f.attrs.colspan;
      }
      o.push($e.from(u));
    }
    t = o, n = r;
  }
  if (e != i) {
    const a = [];
    for (let o = 0, s = 0; o < i; o++, s++) {
      const l = [], u = t[s % e];
      for (let c = 0; c < u.childCount; c++) {
        let d = u.child(c);
        o + d.attrs.rowspan > i && (d = d.type.create(
          {
            ...d.attrs,
            rowspan: Math.max(1, i - d.attrs.rowspan)
          },
          d.content
        )), l.push(d);
      }
      a.push($e.from(l));
    }
    t = a, e = i;
  }
  return { width: n, height: e, rows: t };
}
function yge(n, e, t, r, i, a, o) {
  const s = n.doc.type.schema, l = pi(s);
  let u, c;
  if (i > e.width)
    for (let d = 0, f = 0; d < e.height; d++) {
      const p = t.child(d);
      f += p.nodeSize;
      const h = [];
      let v;
      p.lastChild == null || p.lastChild.type == l.cell ? v = u || (u = l.cell.createAndFill()) : v = c || (c = l.header_cell.createAndFill());
      for (let m = e.width; m < i; m++) h.push(v);
      n.insert(n.mapping.slice(o).map(f - 1 + r), h);
    }
  if (a > e.height) {
    const d = [];
    for (let h = 0, v = (e.height - 1) * e.width; h < Math.max(e.width, i); h++) {
      const m = h >= e.width ? !1 : t.nodeAt(e.map[v + h]).type == l.header_cell;
      d.push(
        m ? c || (c = l.header_cell.createAndFill()) : u || (u = l.cell.createAndFill())
      );
    }
    const f = l.row.create(null, $e.from(d)), p = [];
    for (let h = e.height; h < a; h++) p.push(f);
    n.insert(n.mapping.slice(o).map(r + t.nodeSize - 2), p);
  }
  return !!(u || c);
}
function TR(n, e, t, r, i, a, o, s) {
  if (o == 0 || o == e.height) return !1;
  let l = !1;
  for (let u = i; u < a; u++) {
    const c = o * e.width + u, d = e.map[c];
    if (e.map[c - e.width] == d) {
      l = !0;
      const f = t.nodeAt(d), { top: p, left: h } = e.findCell(d);
      n.setNodeMarkup(n.mapping.slice(s).map(d + r), null, {
        ...f.attrs,
        rowspan: o - p
      }), n.insert(
        n.mapping.slice(s).map(e.positionAt(o, h, t)),
        f.type.createAndFill({
          ...f.attrs,
          rowspan: p + f.attrs.rowspan - o
        })
      ), u += f.attrs.colspan - 1;
    }
  }
  return l;
}
function CR(n, e, t, r, i, a, o, s) {
  if (o == 0 || o == e.width) return !1;
  let l = !1;
  for (let u = i; u < a; u++) {
    const c = u * e.width + o, d = e.map[c];
    if (e.map[c - 1] == d) {
      l = !0;
      const f = t.nodeAt(d), p = e.colCount(d), h = n.mapping.slice(s).map(d + r);
      n.setNodeMarkup(
        h,
        null,
        kd(
          f.attrs,
          o - p,
          f.attrs.colspan - (o - p)
        )
      ), n.insert(
        h + f.nodeSize,
        f.type.createAndFill(
          kd(f.attrs, 0, o - p)
        )
      ), u += f.attrs.rowspan - 1;
    }
  }
  return l;
}
function kR(n, e, t, r, i) {
  let a = t ? n.doc.nodeAt(t - 1) : n.doc;
  if (!a)
    throw new Error("No table found");
  let o = cr.get(a);
  const { top: s, left: l } = r, u = l + i.width, c = s + i.height, d = n.tr;
  let f = 0;
  function p() {
    if (a = t ? d.doc.nodeAt(t - 1) : d.doc, !a)
      throw new Error("No table found");
    o = cr.get(a), f = d.mapping.maps.length;
  }
  yge(d, o, a, t, u, c, f) && p(), TR(d, o, a, t, l, u, s, f) && p(), TR(d, o, a, t, l, u, c, f) && p(), CR(d, o, a, t, s, c, l, f) && p(), CR(d, o, a, t, s, c, u, f) && p();
  for (let h = s; h < c; h++) {
    const v = o.positionAt(h, l, a), m = o.positionAt(h, u, a);
    d.replace(
      d.mapping.slice(f).map(v + t),
      d.mapping.slice(f).map(m + t),
      new nt(i.rows[h - s], 0, 0)
    );
  }
  p(), d.setSelection(
    new qn(
      d.doc.resolve(t + o.positionAt(s, l, a)),
      d.doc.resolve(t + o.positionAt(c - 1, u - 1, a))
    )
  ), e(d);
}
var bge = xM({
  ArrowLeft: Ry("horiz", -1),
  ArrowRight: Ry("horiz", 1),
  ArrowUp: Ry("vert", -1),
  ArrowDown: Ry("vert", 1),
  "Shift-ArrowLeft": Py("horiz", -1),
  "Shift-ArrowRight": Py("horiz", 1),
  "Shift-ArrowUp": Py("vert", -1),
  "Shift-ArrowDown": Py("vert", 1),
  Backspace: Ny,
  "Mod-Backspace": Ny,
  Delete: Ny,
  "Mod-Delete": Ny
});
function u1(n, e, t) {
  return t.eq(n.selection) ? !1 : (e && e(n.tr.setSelection(t).scrollIntoView()), !0);
}
function Ry(n, e) {
  return (t, r, i) => {
    if (!i) return !1;
    const a = t.selection;
    if (a instanceof qn)
      return u1(
        t,
        r,
        It.near(a.$headCell, e)
      );
    if (n != "horiz" && !a.empty) return !1;
    const o = zH(i, n, e);
    if (o == null) return !1;
    if (n == "horiz")
      return u1(
        t,
        r,
        It.near(t.doc.resolve(a.head + e), e)
      );
    {
      const s = t.doc.resolve(o), l = LH(s, n, e);
      let u;
      return l ? u = It.near(l, 1) : e < 0 ? u = It.near(t.doc.resolve(s.before(-1)), -1) : u = It.near(t.doc.resolve(s.after(-1)), 1), u1(t, r, u);
    }
  };
}
function Py(n, e) {
  return (t, r, i) => {
    if (!i) return !1;
    const a = t.selection;
    let o;
    if (a instanceof qn)
      o = a;
    else {
      const l = zH(i, n, e);
      if (l == null) return !1;
      o = new qn(t.doc.resolve(l));
    }
    const s = LH(o.$headCell, n, e);
    return s ? u1(
      t,
      r,
      new qn(o.$anchorCell, s)
    ) : !1;
  };
}
function _ge(n, e) {
  const t = n.state.doc, r = ah(t.resolve(e));
  return r ? (n.dispatch(n.state.tr.setSelection(new qn(r))), !0) : !1;
}
function xge(n, e, t) {
  if (!No(n.state)) return !1;
  let r = vge(t);
  const i = n.state.selection;
  if (i instanceof qn) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [
        $e.from(
          pC(pi(n.state.schema).cell, t)
        )
      ]
    });
    const a = i.$anchorCell.node(-1), o = i.$anchorCell.start(-1), s = cr.get(a).rectBetween(
      i.$anchorCell.pos - o,
      i.$headCell.pos - o
    );
    return r = gge(r, s.right - s.left, s.bottom - s.top), kR(n.state, n.dispatch, o, s, r), !0;
  } else if (r) {
    const a = Lx(n.state), o = a.start(-1);
    return kR(
      n.state,
      n.dispatch,
      o,
      cr.get(a.node(-1)).findCell(a.pos - o),
      r
    ), !0;
  } else
    return !1;
}
function wge(n, e) {
  var t;
  if (e.ctrlKey || e.metaKey) return;
  const r = AR(n, e.target);
  let i;
  if (e.shiftKey && n.state.selection instanceof qn)
    a(n.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (i = ah(n.state.selection.$anchor)) != null && ((t = ES(n, e)) == null ? void 0 : t.pos) != i.pos)
    a(i, e), e.preventDefault();
  else if (!r)
    return;
  function a(l, u) {
    let c = ES(n, u);
    const d = iu.getState(n.state) == null;
    if (!c || !HM(l, c))
      if (d) c = l;
      else return;
    const f = new qn(l, c);
    if (d || !n.state.selection.eq(f)) {
      const p = n.state.tr.setSelection(f);
      d && p.setMeta(iu, l.pos), n.dispatch(p);
    }
  }
  function o() {
    n.root.removeEventListener("mouseup", o), n.root.removeEventListener("dragstart", o), n.root.removeEventListener("mousemove", s), iu.getState(n.state) != null && n.dispatch(n.state.tr.setMeta(iu, -1));
  }
  function s(l) {
    const u = l, c = iu.getState(n.state);
    let d;
    if (c != null)
      d = n.state.doc.resolve(c);
    else if (AR(n, u.target) != r && (d = ES(n, e), !d))
      return o();
    d && a(d, u);
  }
  n.root.addEventListener("mouseup", o), n.root.addEventListener("dragstart", o), n.root.addEventListener("mousemove", s);
}
function zH(n, e, t) {
  if (!(n.state.selection instanceof Dt)) return null;
  const { $head: r } = n.state.selection;
  for (let i = r.depth - 1; i >= 0; i--) {
    const a = r.node(i);
    if ((t < 0 ? r.index(i) : r.indexAfter(i)) != (t < 0 ? 0 : a.childCount)) return null;
    if (a.type.spec.tableRole == "cell" || a.type.spec.tableRole == "header_cell") {
      const s = r.before(i), l = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
      return n.endOfTextblock(l) ? s : null;
    }
  }
  return null;
}
function AR(n, e) {
  for (; e && e != n.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function ES(n, e) {
  const t = n.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return t && t ? ah(n.state.doc.resolve(t.pos)) : null;
}
var Sge = class {
  constructor(e, t) {
    this.node = e, this.defaultCellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${t}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), hC(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, hC(
      e,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function hC(n, e, t, r, i, a) {
  var o;
  let s = 0, l = !0, u = e.firstChild;
  const c = n.firstChild;
  if (c) {
    for (let d = 0, f = 0; d < c.childCount; d++) {
      const { colspan: p, colwidth: h } = c.child(d).attrs;
      for (let v = 0; v < p; v++, f++) {
        const m = i == f ? a : h && h[v], g = m ? m + "px" : "";
        if (s += m || r, m || (l = !1), u)
          u.style.width != g && (u.style.width = g), u = u.nextSibling;
        else {
          const y = document.createElement("col");
          y.style.width = g, e.appendChild(y);
        }
      }
    }
    for (; u; ) {
      const d = u.nextSibling;
      (o = u.parentNode) == null || o.removeChild(u), u = d;
    }
    l ? (t.style.width = s + "px", t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = s + "px");
  }
}
var fa = new jn(
  "tableColumnResizing"
);
function Ege({
  handleWidth: n = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: t = 100,
  View: r = Sge,
  lastColumnResizable: i = !0
} = {}) {
  const a = new Pn({
    key: fa,
    state: {
      init(o, s) {
        var l, u;
        const c = (u = (l = a.spec) == null ? void 0 : l.props) == null ? void 0 : u.nodeViews, d = pi(s.schema).table.name;
        return r && c && (c[d] = (f, p) => new r(f, t, p)), new Tge(-1, !1);
      },
      apply(o, s) {
        return s.apply(o);
      }
    },
    props: {
      attributes: (o) => {
        const s = fa.getState(o);
        return s && s.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (o, s) => {
          Cge(o, s, n, i);
        },
        mouseleave: (o) => {
          kge(o);
        },
        mousedown: (o, s) => {
          Age(o, s, e, t);
        }
      },
      decorations: (o) => {
        const s = fa.getState(o);
        if (s && s.activeHandle > -1)
          return Lge(o, s.activeHandle);
      },
      nodeViews: {}
    }
  });
  return a;
}
var Tge = class c1 {
  constructor(e, t) {
    this.activeHandle = e, this.dragging = t;
  }
  apply(e) {
    const t = this, r = e.getMeta(fa);
    if (r && r.setHandle != null)
      return new c1(r.setHandle, !1);
    if (r && r.setDragging !== void 0)
      return new c1(t.activeHandle, r.setDragging);
    if (t.activeHandle > -1 && e.docChanged) {
      let i = e.mapping.map(t.activeHandle, -1);
      return fC(e.doc.resolve(i)) || (i = -1), new c1(i, t.dragging);
    }
    return t;
  }
};
function Cge(n, e, t, r) {
  if (!n.editable) return;
  const i = fa.getState(n.state);
  if (i && !i.dragging) {
    const a = Dge(e.target);
    let o = -1;
    if (a) {
      const { left: s, right: l } = a.getBoundingClientRect();
      e.clientX - s <= t ? o = MR(n, e, "left", t) : l - e.clientX <= t && (o = MR(n, e, "right", t));
    }
    if (o != i.activeHandle) {
      if (!r && o !== -1) {
        const s = n.state.doc.resolve(o), l = s.node(-1), u = cr.get(l), c = s.start(-1);
        if (u.colCount(s.pos - c) + s.nodeAfter.attrs.colspan - 1 == u.width - 1)
          return;
      }
      FH(n, o);
    }
  }
}
function kge(n) {
  if (!n.editable) return;
  const e = fa.getState(n.state);
  e && e.activeHandle > -1 && !e.dragging && FH(n, -1);
}
function Age(n, e, t, r) {
  var i;
  if (!n.editable) return !1;
  const a = (i = n.dom.ownerDocument.defaultView) != null ? i : window, o = fa.getState(n.state);
  if (!o || o.activeHandle == -1 || o.dragging)
    return !1;
  const s = n.state.doc.nodeAt(o.activeHandle), l = Mge(n, o.activeHandle, s.attrs);
  n.dispatch(
    n.state.tr.setMeta(fa, {
      setDragging: { startX: e.clientX, startWidth: l }
    })
  );
  function u(d) {
    a.removeEventListener("mouseup", u), a.removeEventListener("mousemove", c);
    const f = fa.getState(n.state);
    f != null && f.dragging && (Oge(
      n,
      f.activeHandle,
      DR(f.dragging, d, t)
    ), n.dispatch(
      n.state.tr.setMeta(fa, { setDragging: null })
    ));
  }
  function c(d) {
    if (!d.which) return u(d);
    const f = fa.getState(n.state);
    if (f && f.dragging) {
      const p = DR(f.dragging, d, t);
      OR(
        n,
        f.activeHandle,
        p,
        r
      );
    }
  }
  return OR(
    n,
    o.activeHandle,
    l,
    r
  ), a.addEventListener("mouseup", u), a.addEventListener("mousemove", c), e.preventDefault(), !0;
}
function Mge(n, e, { colspan: t, colwidth: r }) {
  const i = r && r[r.length - 1];
  if (i) return i;
  const a = n.domAtPos(e);
  let s = a.node.childNodes[a.offset].offsetWidth, l = t;
  if (r)
    for (let u = 0; u < t; u++)
      r[u] && (s -= r[u], l--);
  return s / l;
}
function Dge(n) {
  for (; n && n.nodeName != "TD" && n.nodeName != "TH"; )
    n = n.classList && n.classList.contains("ProseMirror") ? null : n.parentNode;
  return n;
}
function MR(n, e, t, r) {
  const i = t == "right" ? -r : r, a = n.posAtCoords({
    left: e.clientX + i,
    top: e.clientY
  });
  if (!a) return -1;
  const { pos: o } = a, s = ah(n.state.doc.resolve(o));
  if (!s) return -1;
  if (t == "right") return s.pos;
  const l = cr.get(s.node(-1)), u = s.start(-1), c = l.map.indexOf(s.pos - u);
  return c % l.width == 0 ? -1 : u + l.map[c - 1];
}
function DR(n, e, t) {
  const r = e.clientX - n.startX;
  return Math.max(t, n.startWidth + r);
}
function FH(n, e) {
  n.dispatch(
    n.state.tr.setMeta(fa, { setHandle: e })
  );
}
function Oge(n, e, t) {
  const r = n.state.doc.resolve(e), i = r.node(-1), a = cr.get(i), o = r.start(-1), s = a.colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1, l = n.state.tr;
  for (let u = 0; u < a.height; u++) {
    const c = u * a.width + s;
    if (u && a.map[c] == a.map[c - a.width]) continue;
    const d = a.map[c], f = i.nodeAt(d).attrs, p = f.colspan == 1 ? 0 : s - a.colCount(d);
    if (f.colwidth && f.colwidth[p] == t) continue;
    const h = f.colwidth ? f.colwidth.slice() : Ige(f.colspan);
    h[p] = t, l.setNodeMarkup(o + d, null, { ...f, colwidth: h });
  }
  l.docChanged && n.dispatch(l);
}
function OR(n, e, t, r) {
  const i = n.state.doc.resolve(e), a = i.node(-1), o = i.start(-1), s = cr.get(a).colCount(i.pos - o) + i.nodeAfter.attrs.colspan - 1;
  let l = n.domAtPos(i.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; )
    l = l.parentNode;
  l && hC(
    a,
    l.firstChild,
    l,
    r,
    s,
    t
  );
}
function Ige(n) {
  return Array(n).fill(0);
}
function Lge(n, e) {
  var t;
  const r = [], i = n.doc.resolve(e), a = i.node(-1);
  if (!a)
    return Zn.empty;
  const o = cr.get(a), s = i.start(-1), l = o.colCount(i.pos - s) + i.nodeAfter.attrs.colspan - 1;
  for (let u = 0; u < o.height; u++) {
    const c = l + u * o.width;
    if ((l == o.width - 1 || o.map[c] != o.map[c + 1]) && (u == 0 || o.map[c] != o.map[c - o.width])) {
      const d = o.map[c], f = s + d + a.nodeAt(d).nodeSize - 1, p = document.createElement("div");
      p.className = "column-resize-handle", (t = fa.getState(n)) != null && t.dragging && r.push(
        zr.node(
          s + d,
          s + d + a.nodeAt(d).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), r.push(zr.widget(f, p));
    }
  }
  return Zn.create(n.doc, r);
}
function Nge({
  allowTableNodeSelection: n = !1
} = {}) {
  return new Pn({
    key: iu,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, t) {
        const r = e.getMeta(iu);
        if (r != null) return r == -1 ? null : r;
        if (t == null || !e.docChanged) return t;
        const { deleted: i, pos: a } = e.mapping.mapResult(t);
        return i ? null : a;
      }
    },
    props: {
      decorations: qme,
      handleDOMEvents: {
        mousedown: wge
      },
      createSelectionBetween(e) {
        return iu.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: _ge,
      handleKeyDown: bge,
      handlePaste: xge
    },
    appendTransaction(e, t, r) {
      return Xme(
        r,
        jH(r, t),
        n
      );
    }
  });
}
function vC(n, e) {
  return e ? ["width", `${Math.max(e, n)}px`] : ["min-width", `${n}px`];
}
function IR(n, e, t, r, i, a) {
  var o;
  let s = 0, l = !0, u = e.firstChild;
  const c = n.firstChild;
  if (c !== null)
    for (let d = 0, f = 0; d < c.childCount; d += 1) {
      const { colspan: p, colwidth: h } = c.child(d).attrs;
      for (let v = 0; v < p; v += 1, f += 1) {
        const m = i === f ? a : h && h[v], g = m ? `${m}px` : "";
        if (s += m || r, m || (l = !1), u) {
          if (u.style.width !== g) {
            const [y, b] = vC(r, m);
            u.style.setProperty(y, b);
          }
          u = u.nextSibling;
        } else {
          const y = document.createElement("col"), [b, _] = vC(r, m);
          y.style.setProperty(b, _), e.appendChild(y);
        }
      }
    }
  for (; u; ) {
    const d = u.nextSibling;
    (o = u.parentNode) === null || o === void 0 || o.removeChild(u), u = d;
  }
  l ? (t.style.width = `${s}px`, t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = `${s}px`);
}
class Rge {
  constructor(e, t) {
    this.node = e, this.cellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), IR(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type !== this.node.type ? !1 : (this.node = e, IR(e, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(e) {
    return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
  }
}
function Pge(n, e, t, r) {
  let i = 0, a = !0;
  const o = [], s = n.firstChild;
  if (!s)
    return {};
  for (let d = 0, f = 0; d < s.childCount; d += 1) {
    const { colspan: p, colwidth: h } = s.child(d).attrs;
    for (let v = 0; v < p; v += 1, f += 1) {
      const m = t === f ? r : h && h[v];
      i += m || e, m || (a = !1);
      const [g, y] = vC(e, m);
      o.push([
        "col",
        { style: `${g}: ${y}` }
      ]);
    }
  }
  const l = a ? `${i}px` : "", u = a ? "" : `${i}px`;
  return { colgroup: ["colgroup", {}, ...o], tableWidth: l, tableMinWidth: u };
}
function LR(n, e) {
  return n.createAndFill();
}
function jge(n) {
  if (n.cached.tableNodeTypes)
    return n.cached.tableNodeTypes;
  const e = {};
  return Object.keys(n.nodes).forEach((t) => {
    const r = n.nodes[t];
    r.spec.tableRole && (e[r.spec.tableRole] = r);
  }), n.cached.tableNodeTypes = e, e;
}
function Bge(n, e, t, r, i) {
  const a = jge(n), o = [], s = [];
  for (let u = 0; u < t; u += 1) {
    const c = LR(a.cell);
    if (c && s.push(c), r) {
      const d = LR(a.header_cell);
      d && o.push(d);
    }
  }
  const l = [];
  for (let u = 0; u < e; u += 1)
    l.push(a.row.createChecked(null, r && u === 0 ? o : s));
  return a.table.createChecked(null, l);
}
function $ge(n) {
  return n instanceof qn;
}
const jy = ({ editor: n }) => {
  const { selection: e } = n.state;
  if (!$ge(e))
    return !1;
  let t = 0;
  const r = K8(e.ranges[0].$from, (a) => a.type.name === "table");
  return r == null || r.node.descendants((a) => {
    if (a.type.name === "table")
      return !1;
    ["tableCell", "tableHeader"].includes(a.type.name) && (t += 1);
  }), t === e.ranges.length ? (n.commands.deleteTable(), !0) : !1;
}, zge = pr.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: Rge,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: !0,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node: n, HTMLAttributes: e }) {
    const { colgroup: t, tableWidth: r, tableMinWidth: i } = Pge(n, this.options.cellMinWidth);
    return [
      "table",
      Mn(this.options.HTMLAttributes, e, {
        style: r ? `width: ${r}` : `min-width: ${i}`
      }),
      t,
      ["tbody", 0]
    ];
  },
  addCommands() {
    return {
      insertTable: ({ rows: n = 3, cols: e = 3, withHeaderRow: t = !0 } = {}) => ({ tr: r, dispatch: i, editor: a }) => {
        const o = Bge(a.schema, n, e, t);
        if (i) {
          const s = r.selection.from + 1;
          r.replaceSelectionWith(o).scrollIntoView().setSelection(Dt.near(r.doc.resolve(s)));
        }
        return !0;
      },
      addColumnBefore: () => ({ state: n, dispatch: e }) => Qme(n, e),
      addColumnAfter: () => ({ state: n, dispatch: e }) => ege(n, e),
      deleteColumn: () => ({ state: n, dispatch: e }) => nge(n, e),
      addRowBefore: () => ({ state: n, dispatch: e }) => ige(n, e),
      addRowAfter: () => ({ state: n, dispatch: e }) => age(n, e),
      deleteRow: () => ({ state: n, dispatch: e }) => sge(n, e),
      deleteTable: () => ({ state: n, dispatch: e }) => hge(n, e),
      mergeCells: () => ({ state: n, dispatch: e }) => xR(n, e),
      splitCell: () => ({ state: n, dispatch: e }) => wR(n, e),
      toggleHeaderColumn: () => ({ state: n, dispatch: e }) => zm("column")(n, e),
      toggleHeaderRow: () => ({ state: n, dispatch: e }) => zm("row")(n, e),
      toggleHeaderCell: () => ({ state: n, dispatch: e }) => fge(n, e),
      mergeOrSplit: () => ({ state: n, dispatch: e }) => xR(n, e) ? !0 : wR(n, e),
      setCellAttribute: (n, e) => ({ state: t, dispatch: r }) => cge(n, e)(t, r),
      goToNextCell: () => ({ state: n, dispatch: e }) => ER(1)(n, e),
      goToPreviousCell: () => ({ state: n, dispatch: e }) => ER(-1)(n, e),
      fixTables: () => ({ state: n, dispatch: e }) => (e && jH(n), !0),
      setCellSelection: (n) => ({ tr: e, dispatch: t }) => {
        if (t) {
          const r = qn.create(e.doc, n.anchorCell, n.headCell);
          e.setSelection(r);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: jy,
      "Mod-Backspace": jy,
      Delete: jy,
      "Mod-Delete": jy
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.options.resizable && this.editor.isEditable ? [
        Ege({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      Nge({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(n) {
    const e = {
      name: n.name,
      options: n.options,
      storage: n.storage
    };
    return {
      tableRole: on(vt(n, "tableRole", e))
    };
  }
}), Fge = pr.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (n) => {
          const e = n.getAttribute("colwidth");
          return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "td" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["td", Mn(this.options.HTMLAttributes, n), 0];
  }
}), Vge = pr.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (n) => {
          const e = n.getAttribute("colwidth");
          return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "th" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["th", Mn(this.options.HTMLAttributes, n), 0];
  }
}), Hge = pr.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [
      { tag: "tr" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["tr", Mn(this.options.HTMLAttributes, n), 0];
  }
}), Gge = {
  class: "lucide lucide-move-diagonal-2",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Uge(n, e) {
  return L(), W("svg", Gge, [...e[0] || (e[0] = [
    G("path", { d: "M19 13v6h-6" }, null, -1),
    G("path", { d: "M5 11V5h6" }, null, -1),
    G("path", { d: "m5 5 14 14" }, null, -1)
  ])]);
}
const Wge = cn({ name: "lucide-move-diagonal-2", render: Uge }), qge = {
  class: "lucide lucide-align-left",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Yge(n, e) {
  return L(), W("svg", qge, [...e[0] || (e[0] = [
    G("path", { d: "M15 12H3" }, null, -1),
    G("path", { d: "M17 18H3" }, null, -1),
    G("path", { d: "M21 6H3" }, null, -1)
  ])]);
}
const Kge = cn({ name: "lucide-align-left", render: Yge }), Xge = {
  class: "lucide lucide-align-center",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Zge(n, e) {
  return L(), W("svg", Xge, [...e[0] || (e[0] = [
    G("path", { d: "M17 12H7" }, null, -1),
    G("path", { d: "M19 18H5" }, null, -1),
    G("path", { d: "M21 6H3" }, null, -1)
  ])]);
}
const Jge = cn({ name: "lucide-align-center", render: Zge }), Qge = {
  class: "lucide lucide-align-right",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function eye(n, e) {
  return L(), W("svg", Qge, [...e[0] || (e[0] = [
    G("path", { d: "M21 12H9" }, null, -1),
    G("path", { d: "M21 18H7" }, null, -1),
    G("path", { d: "M21 6H3" }, null, -1)
  ])]);
}
const tye = cn({ name: "lucide-align-right", render: eye }), nye = { class: "relative" }, rye = ["src", "alt", "width", "height"], iye = { class: "absolute bottom-2 right-2 flex items-center gap-2" }, aye = {
  key: 0,
  class: "flex divide-x divide-outline-gray-5 rounded bg-black/65"
}, oye = {
  key: 1,
  class: "inset-0 absolute flex items-center justify-center z-10"
}, sye = { class: "bg-gray-900/80 p-2 inset-0 leading-none rounded-sm flex flex-col items-center justify-center gap-2" }, lye = { class: "flex items-center gap-2" }, uye = ["disabled"], cye = {
  key: 1,
  class: "w-full py-1.5"
}, dye = /* @__PURE__ */ ve({
  __name: "ImageNodeView",
  props: CH,
  setup(n) {
    const e = n, t = Z(null), r = Z(null), i = Z(!1), a = Z(0), o = Z(0), s = Z(1);
    function l() {
      e.editor.commands.setNodeSelection(e.getPos());
    }
    const u = Z(e.node.attrs.alt || ""), c = Z(!1);
    kt(() => {
      if (c.value = e.editor.isEditable, t.value) {
        const x = e.node.attrs.width || t.value.naturalWidth, w = e.node.attrs.height || t.value.naturalHeight;
        x && w && (s.value = w / x);
      }
    }), e.editor.on("update", () => {
      c.value = e.editor.isEditable;
    });
    function d(x) {
      const w = x.target.value;
      u.value = w, e.updateAttributes({ alt: w });
    }
    function f(x) {
      x.key === "Enter" ? (x.preventDefault(), h()) : (x.key === "Escape" || x.key === "ArrowDown") && (x.preventDefault(), v()), x.key === "ArrowUp" && (x.preventDefault(), m());
    }
    function p(x) {
      e.editor.commands.focus(), e.editor.chain().setTextSelection(x).scrollIntoView().run();
    }
    function h() {
      const x = e.getPos();
      e.editor.commands.focus(), e.editor.chain().setTextSelection(x + 1).createParagraphNear().scrollIntoView().run();
    }
    function v() {
      const x = e.getPos();
      p(x + 1);
    }
    function m() {
      const x = e.getPos();
      p(x - 1);
    }
    function g(x) {
      var C, k, M;
      if (!c.value) return;
      l(), i.value = !0, a.value = x.clientX, o.value = ((C = t.value) == null ? void 0 : C.offsetWidth) || e.node.attrs.width || 0;
      const w = e.node.attrs.width || ((k = t.value) == null ? void 0 : k.naturalWidth), S = e.node.attrs.height || ((M = t.value) == null ? void 0 : M.naturalHeight);
      w && S ? s.value = S / w : s.value = 1, window.addEventListener("mousemove", y), window.addEventListener("mouseup", b), document.body.style.cursor = "ew-resize";
    }
    function y(x) {
      if (!i.value || !t.value || !r.value) return;
      const S = e.editor.view.dom.clientWidth, C = x.clientX - a.value;
      let k = o.value + C;
      k = Math.max(50, Math.min(k, S));
      const M = k * s.value;
      t.value.style.width = `${k}px`, t.value.style.height = `${M}px`, r.value.style.width = `${k}px`;
    }
    function b() {
      if (i.value && (i.value = !1, window.removeEventListener("mousemove", y), window.removeEventListener("mouseup", b), document.body.style.cursor = "", t.value && r.value)) {
        const x = t.value.offsetWidth, w = t.value.offsetHeight;
        e.updateAttributes({ width: x, height: w }), t.value.style.width = "", t.value.style.height = "", r.value.style.width = "";
      }
    }
    function _(x) {
      e.editor.commands.setImageAlign(x);
    }
    return (x, w) => (L(), re(O(FM), null, {
      default: ee(() => [
        G("div", {
          ref_key: "containerRef",
          ref: r,
          class: _e(["relative overflow-hidden not-prose my-6 rounded-[2px] block max-w-full", [
            { "ring-2 ring-outline-gray-3 ring-offset-2": x.selected },
            x.node.attrs.align === "center" ? "mx-auto" : "",
            x.node.attrs.align === "right" ? "ml-auto mr-0" : "",
            x.node.attrs.align === "left" ? "mr-auto ml-0" : ""
          ]]),
          style: An({ width: x.node.attrs.width ? `${x.node.attrs.width}px` : "auto" })
        }, [
          G("div", nye, [
            x.node.attrs.src ? (L(), W("img", {
              key: 0,
              ref_key: "imageRef",
              ref: t,
              class: "rounded-[2px]",
              src: x.node.attrs.src,
              alt: x.node.attrs.alt || "",
              width: x.node.attrs.width,
              height: x.node.attrs.height,
              onClick: xt(l, ["stop"])
            }, null, 8, rye)) : ge("", !0),
            G("div", iye, [
              x.selected && c.value ? (L(), W("div", aye, [
                G("button", {
                  onClick: w[0] || (w[0] = xt((S) => _("left"), ["stop"])),
                  class: _e([
                    "px-1.5 py-1 hover:text-ink-white",
                    x.node.attrs.align === "left" ? "text-ink-white" : "text-ink-gray-4"
                  ])
                }, [
                  se(O(Kge), { class: "size-4" })
                ], 2),
                G("button", {
                  onClick: w[1] || (w[1] = xt((S) => _("center"), ["stop"])),
                  class: _e([
                    "px-1.5 py-1 hover:text-ink-white",
                    x.node.attrs.align === "center" ? "text-ink-white" : "text-ink-gray-4"
                  ])
                }, [
                  se(O(Jge), { class: "size-4" })
                ], 2),
                G("button", {
                  onClick: w[2] || (w[2] = xt((S) => _("right"), ["stop"])),
                  class: _e([
                    "px-1.5 py-1 hover:text-ink-white",
                    x.node.attrs.align === "right" ? "text-ink-white" : "text-ink-gray-4"
                  ])
                }, [
                  se(O(tye), { class: "size-4" })
                ], 2)
              ])) : ge("", !0),
              x.selected && c.value ? (L(), W("button", {
                key: 1,
                class: "cursor-nw-resize bg-black/65 rounded p-1",
                onMousedown: xt(g, ["prevent"])
              }, [
                se(O(Wge), { class: "text-white size-4" })
              ], 32)) : ge("", !0)
            ]),
            x.node.attrs.loading ? (L(), W("div", oye, [
              G("div", sye, [
                G("div", lye, [
                  se(nh, { class: "text-gray-100 size-4" }),
                  w[4] || (w[4] = G("span", { class: "text-gray-100" }, "Uploading...", -1))
                ])
              ])
            ])) : ge("", !0)
          ]),
          (c.value || x.node.attrs.alt) && !x.node.attrs.error ? ta((L(), W("input", {
            key: 0,
            "onUpdate:modelValue": w[3] || (w[3] = (S) => u.value = S),
            class: "w-full text-center bg-transparent text-sm text-ink-gray-6 h-7 border-none focus:ring-0 placeholder-ink-gray-4",
            placeholder: "Add caption",
            disabled: !c.value,
            onChange: d,
            onKeydown: f
          }, null, 40, uye)), [
            [mT, u.value]
          ]) : ge("", !0),
          x.node.attrs.error ? (L(), W("div", cye, [
            se(O(f6), {
              message: `Upload Failed: ${x.node.attrs.error}`
            }, null, 8, ["message"])
          ])) : ge("", !0)
        ], 6)
      ]),
      _: 1
    }));
  }
}), fye = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, pye = pr.create({
  name: "image",
  group: "block",
  draggable: !0,
  selectable: !0,
  addAttributes() {
    return {
      src: { default: null },
      alt: { default: null },
      title: { default: null },
      width: { default: null },
      height: { default: null },
      loading: {
        default: !1,
        parseHTML: () => !1
      },
      align: {
        default: "left",
        parseHTML: (n) => {
          const e = (n.getAttribute("data-align") || n.getAttribute("align") || "left").toLowerCase();
          return ["left", "center", "right"].includes(e) ? e : "left";
        },
        renderHTML: (n) => ({
          "data-align": n.align || "left"
        })
      },
      uploadId: {
        default: null,
        parseHTML: () => null
      },
      error: {
        default: null,
        parseHTML: () => null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "img[src]",
        getAttrs: (n) => {
          if (typeof n == "string") return {};
          const e = n;
          return {
            src: e.getAttribute("src"),
            alt: e.getAttribute("alt"),
            title: e.getAttribute("title"),
            width: e.getAttribute("width"),
            height: e.getAttribute("height")
          };
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return [
      "img",
      Mn(this.options.HTMLAttributes || {}, n)
    ];
  },
  addNodeView() {
    return Ix(dye);
  },
  addOptions() {
    return {
      uploadFunction: null,
      HTMLAttributes: {}
    };
  },
  addCommands() {
    return {
      setImageAlign: (n) => ({ commands: e }) => e.updateAttributes(this.name, { align: n }),
      setImage: (n) => ({ commands: e, editor: t }) => {
        const r = e.insertContent({
          type: this.name,
          attrs: n
        });
        return r && n.src && mye(t.view, n.src, (i, a) => {
          NR(n.src, t.view, a);
        }), r;
      },
      uploadImage: (n) => ({ editor: e }) => HH(n, e.view, null, this.options),
      selectAndUploadImage: () => ({ editor: n }) => {
        const e = document.createElement("input");
        return e.type = "file", e.accept = "image/*", e.onchange = (t) => {
          const r = t.target;
          if (r.files && r.files.length) {
            const i = r.files[0];
            n.commands.uploadImage(i);
          }
        }, e.click(), !0;
      }
    };
  },
  addInputRules() {
    return [
      eH({
        find: fye,
        type: this.type,
        getAttributes: (n) => {
          const [, , e, t, r] = n;
          return { src: t, alt: e, title: r };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const n = this;
    return [
      new Pn({
        props: {
          handleDOMEvents: {
            drop: (e, t) => {
              var s, l;
              if (!((l = (s = t.dataTransfer) == null ? void 0 : s.files) == null ? void 0 : l.length) || !n.options.uploadFunction)
                return !1;
              const i = Array.from(t.dataTransfer.files).filter(
                (u) => /image/i.test(u.type)
              );
              if (i.length === 0)
                return !1;
              t.preventDefault();
              const a = e.posAtCoords({
                left: t.clientX,
                top: t.clientY
              });
              let o = null;
              if (a) {
                o = a.pos;
                const u = e.state.tr.setSelection(
                  It.near(e.state.doc.resolve(o))
                );
                e.dispatch(u);
              }
              return mC(i, e, o, n.options), !0;
            },
            handlePaste: (e, t) => {
              var a;
              if (!n.options.uploadFunction)
                return !1;
              const r = (a = t.clipboardData) == null ? void 0 : a.items;
              if (!r || r.length === 0)
                return !1;
              const i = [];
              for (let o = 0; o < r.length; o++) {
                const s = r[o];
                if (s.kind === "file" && s.type.indexOf("image/") !== -1) {
                  const l = s.getAsFile();
                  l && i.push(l);
                }
              }
              return i.length === 0 ? !1 : (t.preventDefault(), mC(i, e, null, n.options), !0);
            }
          }
        },
        appendTransaction(e, t, r) {
          const i = [];
          return e.some((a) => a.docChanged) && r.doc.descendants((a, o) => {
            a.type.name === "image" && a.attrs.src && (!a.attrs.width || !a.attrs.height) && !a.attrs.loading && i.push({ node: a, pos: o });
          }), i.length === 0 || i.forEach(({ node: a, pos: o }) => {
            const s = n.editor;
            s && NR(a.attrs.src, s.view, o);
          }), null;
        }
      })
    ];
  }
});
function hye(n, e) {
  if (!e)
    return null;
  let t = null;
  return n.state.doc.descendants((r, i) => {
    if (r.type.name === "image" && r.attrs.uploadId === e)
      return t = i + r.nodeSize, !1;
  }), t;
}
function VH(n, e, t, r, i, a, o = !1) {
  if (!r.uploadFunction)
    return console.error("uploadFunction option is not provided"), !1;
  const s = `upload-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  return eUe(n).then((l) => {
    const u = e.state.schema.nodes.image.create({
      loading: !0,
      uploadId: s,
      src: l
    }), c = e.state.tr;
    if (t != null)
      c.insert(t, u);
    else if (i === "replace")
      c.replaceSelectionWith(u);
    else {
      const d = e.state.selection.from;
      c.insert(d, u);
    }
    if (e.dispatch(c), o) {
      const d = u.nodeSize || 1;
      setTimeout(() => {
        try {
          let f = null;
          if (e.state.doc.descendants((p, h) => {
            if (p.type.name === "image" && p.attrs.uploadId === s)
              return f = h, !1;
          }), f !== null) {
            const p = f + d, h = e.state.tr.setSelection(
              It.near(e.state.doc.resolve(p))
            );
            e.dispatch(h);
          }
        } catch (f) {
          console.error("Error moving cursor:", f);
        }
      }, 10);
    }
    return r.uploadFunction(n);
  }).then((l) => GH(l.file_url).then((u) => ({
    ...l,
    width: u.width,
    height: u.height
  })).catch(() => l)).then((l) => {
    const u = e.state.tr;
    e.state.doc.descendants((c, d) => {
      if (c.type.name === "image" && c.attrs.uploadId === s)
        return u.setNodeMarkup(d, void 0, {
          ...c.attrs,
          src: l.file_url,
          width: l.width || c.attrs.width,
          height: l.height || c.attrs.height,
          loading: !1
        }), !1;
    }), e.dispatch(u), a && a(s);
  }).catch((l) => {
    console.error("Image upload failed:", l);
    try {
      const u = e.state.tr;
      e.state.doc.descendants((c, d) => {
        if (c.type.name === "image" && c.attrs.uploadId === s)
          return u.setNodeMarkup(d, void 0, {
            ...c.attrs,
            loading: !1,
            error: l.message || "Failed to upload image"
          }), !1;
      }), e.dispatch(u);
    } catch (u) {
      console.error("Error updating failed node:", u);
    }
    a && a(s);
  }), !0;
}
function vye(n, e, t, r, i) {
  return VH(n, e, t, r, "insert", i, !0);
}
function HH(n, e, t, r) {
  return VH(n, e, t, r, "replace");
}
function mye(n, e, t) {
  n.state.doc.descendants((r, i) => {
    if (r.type.name === "image" && r.attrs.src === e)
      return t(r, i), !1;
  });
}
function NR(n, e, t) {
  GH(n).then((r) => {
    const i = e.state.doc.nodeAt(t);
    if (!i || i.type.name !== "image")
      return;
    const a = i.attrs;
    if (a.width == null || a.height == null) {
      const o = e.state.tr.setNodeMarkup(t, void 0, {
        ...a,
        width: a.width ?? r.width,
        height: a.height ?? r.height
      });
      e.dispatch(o);
    }
  }).catch((r) => {
  });
}
function GH(n) {
  return new Promise((e, t) => {
    const r = new Image();
    r.onload = () => e({
      width: r.naturalWidth,
      height: r.naturalHeight
    }), r.onerror = t, r.src = n;
  });
}
function mC(n, e, t, r) {
  if (n.length === 1) {
    HH(n[0], e, t, r);
    return;
  }
  let i = [...n], a = null;
  const o = () => {
    if (i.length === 0) return;
    const s = i.shift();
    if (!s) return;
    const l = a ? hye(e, a) : t;
    vye(s, e, l, r, (u) => {
      a = u, setTimeout(o, 100);
    });
  };
  o();
}
function gye(n) {
  const {
    targetRef: e,
    zoomLevel: t = Z(100),
    onSwipeLeft: r,
    onSwipeRight: i,
    onDoubleTap: a,
    onTap: o,
    onPanStart: s,
    onPanMove: l,
    onPanAnimate: u,
    onPanEnd: c,
    onPinchStart: d,
    onPinchMove: f,
    onPinchEnd: p,
    doubleTapDelay: h = 300,
    minSwipeDistance: v = 50,
    maxVerticalSwipeDistance: m = 75,
    maxTapDuration: g = 200,
    maxTapMovement: y = 10,
    panThreshold: b = 5,
    // Pixels moved before pan starts
    inertiaDamping: _ = 0.94,
    // Damping for inertia slowdown (higher = slower stop)
    inertiaVelocityThreshold: x = 0.5
    // Pixels per ms
  } = n, w = Z(!1), S = Z(!1), C = Z(!1), k = Z({ x: 0, y: 0 }), M = Z(0), D = Z(0), N = Z(0), R = Z(null), j = Z(0), z = Z({ x: 0, y: 0 }), F = Z({ x: 0, y: 0 }), B = Z(null), H = () => {
    B.value !== null && (cancelAnimationFrame(B.value), B.value = null), C.value = !1, F.value = { x: 0, y: 0 };
  }, Y = (X) => {
    H(), X.preventDefault(), w.value = !1, S.value = !1, R.value = X.touches;
    const ie = performance.now(), ye = ie - M.value;
    if (ye < h && ye > 0 && X.touches.length === 1 && a) {
      a(X), M.value = 0, D.value = 0;
      return;
    }
    if (D.value = ie, X.touches.length === 1) {
      M.value = ie;
      const pe = X.touches[0];
      k.value = { x: pe.clientX, y: pe.clientY }, j.value = ie, z.value = { ...k.value }, F.value = { x: 0, y: 0 }, s && s(X);
    } else if (X.touches.length === 2) {
      M.value = 0;
      const pe = X.touches[0], Be = X.touches[1];
      N.value = Math.hypot(
        Be.clientX - pe.clientX,
        Be.clientY - pe.clientY
      ), S.value = !0, d && d(X);
    } else
      M.value = 0, D.value = 0;
  }, ne = (X) => {
    if (!R.value) return;
    X.preventDefault();
    const ie = performance.now(), ye = ie - j.value;
    if (X.touches.length === 2 && R.value.length === 2) {
      w.value = !1, S.value = !0;
      const pe = X.touches[0], Be = X.touches[1], Ce = Math.hypot(
        Be.clientX - pe.clientX,
        Be.clientY - pe.clientY
      );
      if (N.value > 0 && f) {
        const Ee = Ce / N.value;
        f(Ee, X);
      }
      F.value = { x: 0, y: 0 };
    } else if (X.touches.length === 1 && R.value.length === 1 && !S.value) {
      const pe = X.touches[0].clientX, Be = X.touches[0].clientY, Ce = pe - z.value.x, Ee = Be - z.value.y;
      ye > 1 ? F.value = {
        x: Ce / ye,
        y: Ee / ye
      } : F.value = { x: 0, y: 0 }, j.value = ie, z.value = { x: pe, y: Be };
      const ce = pe - k.value.x, Pe = Be - k.value.y;
      if (!w.value && t.value > 100 && (Math.abs(ce) > b || Math.abs(Pe) > b) && (w.value = !0, k.value = {
        x: pe,
        y: Be
      }), w.value && l) {
        const Ae = t.value / 100, fe = ce / Ae, oe = Pe / Ae;
        l(fe, oe, X);
      }
    }
  }, J = (X) => {
    var Ee;
    const ie = X.touches.length, ye = performance.now(), pe = w.value, Be = S.value, Ce = { ...F.value };
    if (pe && R.value && ie < R.value.length)
      if (w.value = !1, c && c(X), Math.hypot(Ce.x, Ce.y) > x && u && t.value > 100) {
        C.value = !0;
        let Pe = performance.now(), Ae = { ...Ce };
        const fe = (oe) => {
          if (!C.value) return;
          const he = Math.max(1, oe - Pe);
          Pe = oe;
          const Oe = t.value / 100, Te = Ae.x * he / Oe, Ge = Ae.y * he / Oe;
          u(Te, Ge);
          const je = Math.pow(
            Math.min(0.999, _),
            // Ensure base is < 1
            he / 16.67
            // Normalize damping based on ~60fps
          );
          Ae.x *= je, Ae.y *= je, Math.hypot(Ae.x, Ae.y) < 0.01 || t.value <= 100 ? H() : B.value = requestAnimationFrame(fe);
        };
        B.value = requestAnimationFrame(fe);
      } else
        F.value = { x: 0, y: 0 };
    else pe || (F.value = { x: 0, y: 0 });
    if (Be && ie < 2 && (S.value = !1, N.value = 0, p && p(X)), ie === 0 && X.changedTouches.length === 1 && // Ensure it's the end of a single touch sequence
    D.value > 0 && // Ensure there was a valid start time recorded
    ((Ee = R.value) == null ? void 0 : Ee.length) === 1) {
      const ce = X.changedTouches[0], Pe = ce.clientX - k.value.x, Ae = ce.clientY - k.value.y, fe = ye - D.value;
      !pe && // Only detect swipe if not panning
      t.value <= 100 && // Swipes only make sense at base zoom
      Math.abs(Pe) > v && Math.abs(Ae) < m ? Pe < 0 && r ? r() : Pe > 0 && i && i() : !pe && fe < g && Math.abs(Pe) < y && Math.abs(Ae) < y && o && o(X);
    }
    ie === 0 ? (D.value = 0, k.value = { x: 0, y: 0 }, R.value = null, S.value = !1, C.value || (F.value = { x: 0, y: 0 })) : ie === 1 && !w.value && !S.value && (k.value = {
      x: X.touches[0].clientX,
      y: X.touches[0].clientY
    }, D.value = performance.now(), R.value = X.touches);
  };
  return et(
    e,
    (X, ie) => {
      ie && (ie.removeEventListener("touchstart", Y), ie.removeEventListener("touchmove", ne), ie.removeEventListener("touchend", J), ie.removeEventListener("touchcancel", J), H()), X && (X.addEventListener("touchstart", Y, {
        passive: !1
      }), X.addEventListener("touchmove", ne, {
        passive: !1
      }), X.addEventListener("touchend", J, {
        passive: !0
      }), X.addEventListener("touchcancel", J, {
        passive: !0
      }));
    },
    { immediate: !0 }
  ), {
    isPanning: fp(w),
    isPinching: fp(S),
    isAnimatingPan: fp(C)
    // Expose inertia animation status
  };
}
function yye({
  initialIndex: n,
  imageCount: e,
  onNavigate: t
}) {
  const r = Z(n.value);
  et(n, (o) => {
    r.value = o, t == null || t();
  });
  function i() {
    e.value > 0 && (r.value = (r.value + 1) % e.value, t == null || t());
  }
  function a() {
    e.value > 0 && (r.value = (r.value - 1 + e.value) % e.value, t == null || t());
  }
  return {
    currentIndex: r,
    nextImage: i,
    previousImage: a
  };
}
function bye({ containerRef: n, isEnabled: e }) {
  const t = Z(100), r = Z({ x: 0, y: 0 }), i = Z(!1), a = Z({ x: 0, y: 0 }), o = Z({ x: 0, y: 0 }), s = 90, l = 110;
  et(t, (h, v) => {
    h <= 100 && v > 100 && (r.value = { x: 0, y: 0 });
  });
  function u() {
    t.value = Math.min(t.value + 25, 300);
  }
  function c() {
    const h = Math.max(t.value - 25, 25);
    t.value > 100 && h < 100 ? t.value = 100 : t.value = h;
  }
  function d() {
    t.value = 100, r.value = { x: 0, y: 0 }, i.value = !1, o.value = { x: 0, y: 0 };
  }
  function f(h) {
    if (t.value <= 100) return;
    h.preventDefault(), i.value = !0, a.value = { x: h.clientX, y: h.clientY }, o.value = { ...r.value };
    const v = (g) => {
      if (!i.value) return;
      const y = g.clientX - a.value.x, b = g.clientY - a.value.y, _ = t.value / 100;
      r.value = {
        x: o.value.x + y / _,
        y: o.value.y + b / _
      };
    }, m = () => {
      i.value && (i.value = !1, document.removeEventListener("mousemove", v), document.removeEventListener("mouseup", m));
    };
    document.addEventListener("mousemove", v), document.addEventListener("mouseup", m);
  }
  function p(h) {
    var v;
    if (e.value && (v = n.value) != null && v.contains(h.target)) {
      h.preventDefault();
      let m = h.ctrlKey ? 0.5 : 0.2;
      const g = -h.deltaY * m, y = t.value, b = Math.round(y + g);
      let _ = Math.max(25, Math.min(300, b));
      (y > 100 && _ < 100 || y < 100 && _ > 100) && Math.abs(100 - _) < Math.abs(g) * 1.5 && (_ = 100), t.value = _;
    }
  }
  return kt(() => {
    const h = n.value;
    h && h.addEventListener("wheel", p, {
      passive: !1,
      capture: !0
    });
  }), Nn(() => {
    const h = n.value;
    h && h.removeEventListener("wheel", p, { capture: !0 }), i.value && (i.value = !1);
  }), {
    zoomLevel: t,
    panPosition: r,
    isMousePanning: i,
    initialPanPositionOnGestureStart: o,
    zoomIn: u,
    zoomOut: c,
    resetZoom: d,
    handlePanStart: f,
    snapThresholdLower: s,
    snapThresholdUpper: l
  };
}
const _ye = {
  class: "lucide lucide-download",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function xye(n, e) {
  return L(), W("svg", _ye, [...e[0] || (e[0] = [
    G("path", { d: "M12 15V3" }, null, -1),
    G("path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }, null, -1),
    G("path", { d: "m7 10 5 5 5-5" }, null, -1)
  ])]);
}
const wye = cn({ name: "lucide-download", render: xye }), Sye = {
  class: "lucide lucide-maximize",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Eye(n, e) {
  return L(), W("svg", Sye, [...e[0] || (e[0] = [
    G("path", { d: "M8 3H5a2 2 0 0 0-2 2v3" }, null, -1),
    G("path", { d: "M21 8V5a2 2 0 0 0-2-2h-3" }, null, -1),
    G("path", { d: "M3 16v3a2 2 0 0 0 2 2h3" }, null, -1),
    G("path", { d: "M16 21h3a2 2 0 0 0 2-2v-3" }, null, -1)
  ])]);
}
const Tye = cn({ name: "lucide-maximize", render: Eye }), Cye = {
  class: "lucide lucide-minimize",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function kye(n, e) {
  return L(), W("svg", Cye, [...e[0] || (e[0] = [
    G("path", { d: "M8 3v3a2 2 0 0 1-2 2H3" }, null, -1),
    G("path", { d: "M21 8h-3a2 2 0 0 1-2-2V3" }, null, -1),
    G("path", { d: "M3 16h3a2 2 0 0 1 2 2v3" }, null, -1),
    G("path", { d: "M16 21v-3a2 2 0 0 1 2-2h3" }, null, -1)
  ])]);
}
const Aye = cn({ name: "lucide-minimize", render: kye }), Mye = {
  class: "lucide lucide-chevron-left",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Dye(n, e) {
  return L(), W("svg", Mye, [...e[0] || (e[0] = [
    G("path", { d: "m15 18-6-6 6-6" }, null, -1)
  ])]);
}
const Oye = cn({ name: "lucide-chevron-left", render: Dye }), Iye = {
  class: "lucide lucide-chevron-right",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Lye(n, e) {
  return L(), W("svg", Iye, [...e[0] || (e[0] = [
    G("path", { d: "m9 18 6-6-6-6" }, null, -1)
  ])]);
}
const UH = cn({ name: "lucide-chevron-right", render: Lye }), Nye = {
  class: "lucide lucide-plus",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Rye(n, e) {
  return L(), W("svg", Nye, [...e[0] || (e[0] = [
    G("path", { d: "M5 12h14" }, null, -1),
    G("path", { d: "M12 5v14" }, null, -1)
  ])]);
}
const Pye = cn({ name: "lucide-plus", render: Rye }), jye = {
  class: "lucide lucide-minus",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function Bye(n, e) {
  return L(), W("svg", jye, [...e[0] || (e[0] = [
    G("path", { d: "M5 12h14" }, null, -1)
  ])]);
}
const WH = cn({ name: "lucide-minus", render: Bye }), $ye = { class: "relative z-10 flex flex-col items-center" }, zye = ["src", "alt"], Fye = { class: "bg-black/65 rounded flex items-center" }, Vye = { class: "px-2 text-sm tabular-nums text-gray-400 select-none" }, Hye = { class: "bg-black/65 rounded flex items-center" }, Gye = { class: "bg-black/65 rounded flex items-center" }, Uye = { class: "bg-black/65 rounded flex items-center" }, Wye = 3e3, qH = /* @__PURE__ */ ve({
  __name: "ImageViewerModal",
  props: {
    show: { type: Boolean },
    images: {},
    initialIndex: {}
  },
  emits: ["update:show"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = t1("imageContainer"), a = t1("backdropElement"), o = t1("controlsBar"), s = Z(0), l = Z(!1), u = Z(100), c = Z(!0), d = Z(null), {
      zoomLevel: f,
      panPosition: p,
      isMousePanning: h,
      initialPanPositionOnGestureStart: v,
      zoomIn: m,
      zoomOut: g,
      resetZoom: y,
      handlePanStart: b,
      snapThresholdLower: _,
      snapThresholdUpper: x
    } = bye({
      containerRef: i,
      isEnabled: j1(t, "show")
    }), { currentIndex: w, nextImage: S, previousImage: C } = yye({
      initialIndex: j1(t, "initialIndex"),
      imageCount: K(() => t.images.length),
      onNavigate: y
    }), k = K(() => t.images[w.value]), {
      isPanning: M,
      isPinching: D,
      isAnimatingPan: N
    } = gye({
      targetRef: i,
      zoomLevel: f,
      panThreshold: 10,
      onSwipeLeft: () => {
        f.value <= 100 && S();
      },
      onSwipeRight: () => {
        f.value <= 100 && C();
      },
      onDoubleTap: (J) => {
        var X;
        (X = o.value) != null && X.contains(J.target) || (f.value > 100 ? y() : (f.value = 200, p.value = { x: 0, y: 0 }));
      },
      onTap: (J) => {
        J.target === a.value && F();
      },
      onPanStart: () => {
        f.value <= 100 || (v.value = { ...p.value });
      },
      onPanMove: (J, X) => {
        f.value <= 100 || (p.value = {
          x: v.value.x + J,
          y: v.value.y + X
        });
      },
      onPanAnimate: (J, X) => {
        p.value = {
          x: p.value.x + J,
          y: p.value.y + X
        };
      },
      onPinchStart: () => {
        u.value = f.value, v.value = { ...p.value };
      },
      onPinchMove: (J) => {
        const X = u.value * J;
        let ie = Math.max(25, Math.min(300, Math.round(X)));
        ie > _ && ie < x && (ie = 100), f.value = ie;
      },
      onPinchEnd: () => {
        f.value < 100 && y(), v.value = { x: 0, y: 0 };
      }
    }), R = K(() => h.value || M.value);
    function j() {
      c.value = !0, d.value && clearTimeout(d.value), d.value = setTimeout(() => {
        !R.value && !D.value ? c.value = !1 : j();
      }, Wye);
    }
    function z() {
      (!D.value || !c.value) && j();
    }
    function F() {
      r("update:show", !1), y(), d.value && (clearTimeout(d.value), d.value = null);
    }
    function B() {
      var ye;
      const J = k.value, X = document.createElement("a");
      X.href = J.src;
      const ie = ((ye = J.alt) == null ? void 0 : ye.replace(/[^a-z0-9]/gi, "_").toLowerCase()) || J.src.split("/").pop() || "download";
      X.download = ie.includes(".") ? ie : `${ie}.jpg`, document.body.appendChild(X), X.click(), document.body.removeChild(X);
    }
    function H() {
      const J = i.value;
      l.value ? document.exitFullscreen && (document.exitFullscreen(), l.value = !1) : J != null && J.requestFullscreen && (J.requestFullscreen(), l.value = !0);
    }
    function Y() {
      l.value = !!document.fullscreenElement;
    }
    function ne(J) {
      if (t.show)
        switch (z(), J.key) {
          case "ArrowLeft":
            R.value || C(), J.preventDefault();
            break;
          case "ArrowRight":
            R.value || S(), J.preventDefault();
            break;
          case "+":
          case "=":
            m(), J.preventDefault();
            break;
          case "-":
            g(), J.preventDefault();
            break;
          case "Escape":
            F(), J.preventDefault();
            break;
          case "f":
          case "F":
            H(), J.preventDefault();
            break;
        }
    }
    return et(
      () => t.show,
      (J) => {
        J ? (c.value = !0, y(), j()) : (d.value && (clearTimeout(d.value), d.value = null), l.value && document.exitFullscreen && document.exitFullscreen());
      }
    ), et(o, (J) => {
      if (J) {
        const X = () => {
          s.value = J.offsetHeight;
        }, ie = new ResizeObserver(X);
        ie.observe(J), X(), Nn(() => ie.disconnect());
      } else
        s.value = 0;
    }), kt(() => {
      document.addEventListener("fullscreenchange", Y), document.addEventListener("keydown", ne);
    }), Nn(() => {
      document.removeEventListener("fullscreenchange", Y), document.removeEventListener("keydown", ne), d.value && clearTimeout(d.value), l.value && document.exitFullscreen && document.exitFullscreen();
    }), (J, X) => (L(), re(wg, { to: "body" }, [
      se(H_, {
        "enter-active-class": "transition-opacity duration-150 ease-in-out",
        "leave-active-class": "transition-opacity duration-150 ease-in-out",
        "enter-from-class": "opacity-0",
        "leave-to-class": "opacity-0",
        appear: ""
      }, {
        default: ee(() => [
          t.show ? (L(), W("div", {
            key: 0,
            class: "fixed top-0 left-0 w-full h-full bg-black sm:bg-black/90 z-[50] flex flex-col justify-center items-center overflow-hidden touch-none",
            ref_key: "imageContainer",
            ref: i,
            onMousemove: z,
            onTouchstart: z,
            onTouchmove: z
          }, [
            G("div", {
              class: "absolute inset-0 z-0",
              ref_key: "backdropElement",
              ref: a,
              onClick: F
            }, null, 512),
            G("div", $ye, [
              G("img", {
                src: k.value.src,
                alt: k.value.alt || "Image preview",
                class: "max-w-screen max-h-screen object-contain block",
                style: An({
                  transform: `scale(${O(f) / 100}) translate(${O(p).x}px, ${O(p).y}px)`,
                  cursor: O(f) > 100 ? O(h) ? "grabbing" : "grab" : "default",
                  transition: R.value || O(D) || O(N) ? "none" : "transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)"
                }),
                onMousedown: X[0] || (X[0] = //@ts-ignore
                (...ie) => O(b) && O(b)(...ie)),
                draggable: "false"
              }, null, 44, zye)
            ]),
            k.value.alt ? (L(), W("div", {
              key: 0,
              class: _e(["absolute bottom-4 p-2 text-center rounded-sm text-white text-sm bg-black/65 z-10 transition-opacity duration-300 ease-in-out", { "opacity-0 pointer-events-none": !c.value }])
            }, ke(k.value.alt), 3)) : ge("", !0),
            G("div", {
              ref_key: "controlsBar",
              ref: o,
              class: _e(["absolute top-4 flex items-center space-x-3 p-2 text-white z-20 transition-opacity duration-300 ease-in-out", { "opacity-0 pointer-events-none": !c.value }]),
              onTouchstart: X[6] || (X[6] = xt(() => {
              }, ["stop"])),
              onTouchmove: X[7] || (X[7] = xt(() => {
              }, ["stop"])),
              onTouchend: X[8] || (X[8] = xt(() => {
              }, ["stop"])),
              onMousedown: X[9] || (X[9] = xt(() => {
              }, ["stop"])),
              onWheel: X[10] || (X[10] = xt(() => {
              }, ["stop"]))
            }, [
              G("div", Fye, [
                se(Ei, { text: "Previous image" }, {
                  default: ee(() => [
                    G("button", {
                      class: "p-2 hover:bg-gray-900 rounded-l focus:outline-none",
                      onClick: X[1] || (X[1] = xt(
                        //@ts-ignore
                        (...ie) => O(C) && O(C)(...ie),
                        ["stop"]
                      ))
                    }, [
                      se(O(Oye), { class: "size-4" })
                    ])
                  ]),
                  _: 1
                }),
                G("span", Vye, ke(O(w) + 1) + "/" + ke(t.images.length), 1),
                se(Ei, { text: "Next image" }, {
                  default: ee(() => [
                    G("button", {
                      class: "p-2 hover:bg-gray-900 rounded-r focus:outline-none",
                      onClick: X[2] || (X[2] = xt(
                        //@ts-ignore
                        (...ie) => O(S) && O(S)(...ie),
                        ["stop"]
                      ))
                    }, [
                      se(O(UH), { class: "size-4" })
                    ])
                  ]),
                  _: 1
                })
              ]),
              G("div", Hye, [
                se(Ei, { text: "Zoom out" }, {
                  default: ee(() => [
                    G("button", {
                      class: "p-2 hover:bg-gray-900 rounded-l focus:outline-none",
                      onClick: X[3] || (X[3] = xt(
                        //@ts-ignore
                        (...ie) => O(g) && O(g)(...ie),
                        ["stop"]
                      ))
                    }, [
                      se(O(WH), { class: "size-4" })
                    ])
                  ]),
                  _: 1
                }),
                se(Ei, { text: "Reset zoom" }, {
                  default: ee(() => [
                    G("button", {
                      class: "p-2 hover:bg-gray-900 text-sm text-gray-400 focus:outline-none",
                      onClick: X[4] || (X[4] = xt(
                        //@ts-ignore
                        (...ie) => O(y) && O(y)(...ie),
                        ["stop"]
                      ))
                    }, ke(O(f)) + "% ", 1)
                  ]),
                  _: 1
                }),
                se(Ei, { text: "Zoom in" }, {
                  default: ee(() => [
                    G("button", {
                      class: "p-2 hover:bg-gray-900 rounded-r focus:outline-none",
                      onClick: X[5] || (X[5] = xt(
                        //@ts-ignore
                        (...ie) => O(m) && O(m)(...ie),
                        ["stop"]
                      ))
                    }, [
                      se(O(Pye), { class: "size-4" })
                    ])
                  ]),
                  _: 1
                })
              ]),
              G("div", Gye, [
                se(Ei, { text: "Download image" }, {
                  default: ee(() => [
                    G("button", {
                      class: "p-2 hover:bg-gray-900 rounded-l focus:outline-none",
                      onClick: xt(B, ["stop"])
                    }, [
                      se(O(wye), { class: "size-4" })
                    ])
                  ]),
                  _: 1
                }),
                se(Ei, {
                  text: l.value ? "Exit fullscreen" : "Enter fullscreen"
                }, {
                  default: ee(() => [
                    G("button", {
                      class: "p-2 hover:bg-gray-900 rounded-r focus:outline-none hidden sm:block",
                      onClick: xt(H, ["stop"])
                    }, [
                      l.value ? (L(), re(O(Aye), {
                        key: 1,
                        class: "size-4"
                      })) : (L(), re(O(Tye), {
                        key: 0,
                        class: "size-4"
                      }))
                    ])
                  ]),
                  _: 1
                }, 8, ["text"])
              ]),
              G("div", Uye, [
                se(Ei, { text: "Close" }, {
                  default: ee(() => [
                    G("button", {
                      class: "p-2 hover:bg-gray-900 rounded focus:outline-none",
                      onClick: xt(F, ["stop"])
                    }, [
                      se(O(rh), { class: "size-4" })
                    ])
                  ]),
                  _: 1
                })
              ])
            ], 34)
          ], 544)) : ge("", !0)
        ]),
        _: 1
      })
    ]));
  }
}), qye = Qn.create({
  name: "imageViewer",
  onBeforeCreate() {
    if (!document.querySelector("style[data-image-viewer-style]")) {
      const n = document.createElement("style");
      n.textContent = `
          .ProseMirror:not(.ProseMirror-focused) img {
            cursor: pointer;
          }
        `, n.setAttribute("data-image-viewer-style", "true"), document.head.appendChild(n);
    }
  },
  onDestroy() {
    const n = document.querySelector("style[data-image-viewer-style]");
    n && document.head.removeChild(n);
  },
  addCommands() {
    return {
      openImageViewer: (n) => ({ editor: e }) => {
        const t = [];
        e.state.doc.descendants((i) => (i.type.name === "image" && t.push({
          src: i.attrs.src,
          alt: i.attrs.alt || null
        }), !0));
        const r = t.findIndex((i) => i.src === n);
        return Yye(t, r), !0;
      }
    };
  },
  addProseMirrorPlugins() {
    const n = this;
    return [
      new Pn({
        key: new jn("imageViewer"),
        props: {
          handleClick(e, t, r) {
            if (n.editor.isEditable)
              return !1;
            const { state: i } = e, a = i.doc.nodeAt(t);
            if ((a == null ? void 0 : a.type.name) === "image") {
              r.preventDefault();
              const o = a.attrs.src;
              return n.editor.commands.openImageViewer(o), !0;
            }
            if (r.target instanceof HTMLImageElement) {
              let o = !1;
              if (i.doc.descendants((s, l) => {
                if (s.type.name === "image" && !o) {
                  const u = e.nodeDOM(l);
                  if (u && (u === r.target || u.contains(r.target)))
                    return r.preventDefault(), n.editor.commands.openImageViewer(s.attrs.src), o = !0, !1;
                }
                return !0;
              }), o) return !0;
            }
            return !1;
          }
        }
      })
    ];
  }
});
function Yye(n, e) {
  const t = document.createElement("div");
  document.body.appendChild(t);
  const r = bF({
    render() {
      return qt(qH, {
        show: !0,
        images: n,
        // Pass the collected image data
        initialIndex: e,
        // Pass the starting index
        "onUpdate:show": (i) => {
          i || setTimeout(() => {
            r.unmount(), t.remove();
          }, 0);
        }
      });
    }
  });
  r.mount(t);
}
const Kye = pr.create({
  name: "video",
  group: "block",
  selectable: !0,
  draggable: !0,
  atom: !0,
  addOptions() {
    return {
      uploadFunction: null,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return {
      src: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "video"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return [
      "video",
      Mn(this.options.HTMLAttributes, n, {
        controls: ""
      })
    ];
  },
  addCommands() {
    return {
      setVideo: (n) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: n
      }),
      uploadVideo: (n) => ({ editor: e }) => {
        const t = e.state.selection.from;
        return Xye(n, e.view, t, this.options);
      },
      selectAndUploadVideo: () => ({ editor: n }) => {
        if (!this.options.uploadFunction)
          return console.error("uploadFunction option is not provided for videos."), !1;
        const e = document.createElement("input");
        return e.type = "file", e.accept = "video/*", e.onchange = (t) => {
          const r = t.target;
          if (r.files && r.files.length) {
            const i = r.files[0];
            n.commands.uploadVideo(i);
          }
        }, e.click(), !0;
      }
    };
  },
  addNodeView() {
    return ({ editor: n, node: e }) => {
      const t = document.createElement("div");
      t.className = "relative aspect-w-16 aspect-h-9" + (n.isEditable ? " cursor-pointer" : "");
      const r = document.createElement("video");
      if (r.src = e.attrs.src, r.setAttribute("controls", ""), n.isEditable) {
        let i = document.createElement("div");
        i.className = "absolute top-0 right-0 text-xs m-2 bg-surface-gray-6 text-ink-white px-2 py-1 rounded-md", i.innerHTML = "Video", t.append(i);
      }
      return t.append(r), {
        dom: t
      };
    };
  }
});
function Xye(n, e, t, r) {
  return r.uploadFunction ? (r.uploadFunction(n).then((i) => {
    const { schema: a } = e.state, o = a.nodes.video.create({ src: i.file_url }), s = e.state.tr;
    t != null ? s.insert(t, o) : s.replaceSelectionWith(o), e.dispatch(s);
  }).catch((i) => {
    console.error("Video upload failed:", i);
  }), !0) : (console.error("uploadFunction option is not provided for videos."), !1);
}
const Zye = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", Jye = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", gC = "numeric", yC = "ascii", bC = "alpha", Kv = "asciinumeric", Tv = "alphanumeric", _C = "domain", YH = "emoji", Qye = "scheme", e0e = "slashscheme", TS = "whitespace";
function t0e(n, e) {
  return n in e || (e[n] = []), e[n];
}
function Vc(n, e, t) {
  e[gC] && (e[Kv] = !0, e[Tv] = !0), e[yC] && (e[Kv] = !0, e[bC] = !0), e[Kv] && (e[Tv] = !0), e[bC] && (e[Tv] = !0), e[Tv] && (e[_C] = !0), e[YH] && (e[_C] = !0);
  for (const r in e) {
    const i = t0e(r, t);
    i.indexOf(n) < 0 && i.push(n);
  }
}
function n0e(n, e) {
  const t = {};
  for (const r in e)
    e[r].indexOf(n) >= 0 && (t[r] = !0);
  return t;
}
function Wi(n = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = n;
}
Wi.groups = {};
Wi.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(n) {
    const e = this, t = e.j[n];
    if (t)
      return t;
    for (let r = 0; r < e.jr.length; r++) {
      const i = e.jr[r][0], a = e.jr[r][1];
      if (a && i.test(n))
        return a;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(n, e = !1) {
    return e ? n in this.j : !!this.go(n);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(n, e, t, r) {
    for (let i = 0; i < n.length; i++)
      this.tt(n[i], e, t, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(n, e, t, r) {
    r = r || Wi.groups;
    let i;
    return e && e.j ? i = e : (i = new Wi(e), t && r && Vc(e, t, r)), this.jr.push([n, i]), i;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(n, e, t, r) {
    let i = this;
    const a = n.length;
    if (!a)
      return i;
    for (let o = 0; o < a - 1; o++)
      i = i.tt(n[o]);
    return i.tt(n[a - 1], e, t, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(n, e, t, r) {
    r = r || Wi.groups;
    const i = this;
    if (e && e.j)
      return i.j[n] = e, e;
    const a = e;
    let o, s = i.go(n);
    if (s ? (o = new Wi(), Object.assign(o.j, s.j), o.jr.push.apply(o.jr, s.jr), o.jd = s.jd, o.t = s.t) : o = new Wi(), a) {
      if (r)
        if (o.t && typeof o.t == "string") {
          const l = Object.assign(n0e(o.t, r), t);
          Vc(a, l, r);
        } else t && Vc(a, t, r);
      o.t = a;
    }
    return i.j[n] = o, o;
  }
};
const an = (n, e, t, r, i) => n.ta(e, t, r, i), or = (n, e, t, r, i) => n.tr(e, t, r, i), RR = (n, e, t, r, i) => n.ts(e, t, r, i), Ye = (n, e, t, r, i) => n.tt(e, t, r, i), Hs = "WORD", xC = "UWORD", KH = "ASCIINUMERICAL", XH = "ALPHANUMERICAL", Fm = "LOCALHOST", wC = "TLD", SC = "UTLD", d1 = "SCHEME", Yf = "SLASH_SCHEME", GM = "NUM", EC = "WS", UM = "NL", Xv = "OPENBRACE", Zv = "CLOSEBRACE", sb = "OPENBRACKET", lb = "CLOSEBRACKET", ub = "OPENPAREN", cb = "CLOSEPAREN", db = "OPENANGLEBRACKET", fb = "CLOSEANGLEBRACKET", pb = "FULLWIDTHLEFTPAREN", hb = "FULLWIDTHRIGHTPAREN", vb = "LEFTCORNERBRACKET", mb = "RIGHTCORNERBRACKET", gb = "LEFTWHITECORNERBRACKET", yb = "RIGHTWHITECORNERBRACKET", bb = "FULLWIDTHLESSTHAN", _b = "FULLWIDTHGREATERTHAN", xb = "AMPERSAND", wb = "APOSTROPHE", Sb = "ASTERISK", Ql = "AT", Eb = "BACKSLASH", Tb = "BACKTICK", Cb = "CARET", au = "COLON", WM = "COMMA", kb = "DOLLAR", Xo = "DOT", Ab = "EQUALS", qM = "EXCLAMATION", Ra = "HYPHEN", Jv = "PERCENT", Mb = "PIPE", Db = "PLUS", Ob = "POUND", Qv = "QUERY", YM = "QUOTE", ZH = "FULLWIDTHMIDDLEDOT", KM = "SEMI", Zo = "SLASH", em = "TILDE", Ib = "UNDERSCORE", JH = "EMOJI", Lb = "SYM";
var QH = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: XH,
  AMPERSAND: xb,
  APOSTROPHE: wb,
  ASCIINUMERICAL: KH,
  ASTERISK: Sb,
  AT: Ql,
  BACKSLASH: Eb,
  BACKTICK: Tb,
  CARET: Cb,
  CLOSEANGLEBRACKET: fb,
  CLOSEBRACE: Zv,
  CLOSEBRACKET: lb,
  CLOSEPAREN: cb,
  COLON: au,
  COMMA: WM,
  DOLLAR: kb,
  DOT: Xo,
  EMOJI: JH,
  EQUALS: Ab,
  EXCLAMATION: qM,
  FULLWIDTHGREATERTHAN: _b,
  FULLWIDTHLEFTPAREN: pb,
  FULLWIDTHLESSTHAN: bb,
  FULLWIDTHMIDDLEDOT: ZH,
  FULLWIDTHRIGHTPAREN: hb,
  HYPHEN: Ra,
  LEFTCORNERBRACKET: vb,
  LEFTWHITECORNERBRACKET: gb,
  LOCALHOST: Fm,
  NL: UM,
  NUM: GM,
  OPENANGLEBRACKET: db,
  OPENBRACE: Xv,
  OPENBRACKET: sb,
  OPENPAREN: ub,
  PERCENT: Jv,
  PIPE: Mb,
  PLUS: Db,
  POUND: Ob,
  QUERY: Qv,
  QUOTE: YM,
  RIGHTCORNERBRACKET: mb,
  RIGHTWHITECORNERBRACKET: yb,
  SCHEME: d1,
  SEMI: KM,
  SLASH: Zo,
  SLASH_SCHEME: Yf,
  SYM: Lb,
  TILDE: em,
  TLD: wC,
  UNDERSCORE: Ib,
  UTLD: SC,
  UWORD: xC,
  WORD: Hs,
  WS: EC
});
const Ps = /[a-z]/, jh = new RegExp("\\p{L}", "u"), CS = new RegExp("\\p{Emoji}", "u"), js = /\d/, kS = /\s/, PR = "\r", AS = `
`, r0e = "️", i0e = "‍", MS = "￼";
let By = null, $y = null;
function a0e(n = []) {
  const e = {};
  Wi.groups = e;
  const t = new Wi();
  By == null && (By = jR(Zye)), $y == null && ($y = jR(Jye)), Ye(t, "'", wb), Ye(t, "{", Xv), Ye(t, "}", Zv), Ye(t, "[", sb), Ye(t, "]", lb), Ye(t, "(", ub), Ye(t, ")", cb), Ye(t, "<", db), Ye(t, ">", fb), Ye(t, "（", pb), Ye(t, "）", hb), Ye(t, "「", vb), Ye(t, "」", mb), Ye(t, "『", gb), Ye(t, "』", yb), Ye(t, "＜", bb), Ye(t, "＞", _b), Ye(t, "&", xb), Ye(t, "*", Sb), Ye(t, "@", Ql), Ye(t, "`", Tb), Ye(t, "^", Cb), Ye(t, ":", au), Ye(t, ",", WM), Ye(t, "$", kb), Ye(t, ".", Xo), Ye(t, "=", Ab), Ye(t, "!", qM), Ye(t, "-", Ra), Ye(t, "%", Jv), Ye(t, "|", Mb), Ye(t, "+", Db), Ye(t, "#", Ob), Ye(t, "?", Qv), Ye(t, '"', YM), Ye(t, "/", Zo), Ye(t, ";", KM), Ye(t, "~", em), Ye(t, "_", Ib), Ye(t, "\\", Eb), Ye(t, "・", ZH);
  const r = or(t, js, GM, {
    [gC]: !0
  });
  or(r, js, r);
  const i = or(r, Ps, KH, {
    [Kv]: !0
  }), a = or(r, jh, XH, {
    [Tv]: !0
  }), o = or(t, Ps, Hs, {
    [yC]: !0
  });
  or(o, js, i), or(o, Ps, o), or(i, js, i), or(i, Ps, i);
  const s = or(t, jh, xC, {
    [bC]: !0
  });
  or(s, Ps), or(s, js, a), or(s, jh, s), or(a, js, a), or(a, Ps), or(a, jh, a);
  const l = Ye(t, AS, UM, {
    [TS]: !0
  }), u = Ye(t, PR, EC, {
    [TS]: !0
  }), c = or(t, kS, EC, {
    [TS]: !0
  });
  Ye(t, MS, c), Ye(u, AS, l), Ye(u, MS, c), or(u, kS, c), Ye(c, PR), Ye(c, AS), or(c, kS, c), Ye(c, MS, c);
  const d = or(t, CS, JH, {
    [YH]: !0
  });
  Ye(d, "#"), or(d, CS, d), Ye(d, r0e, d);
  const f = Ye(d, i0e);
  Ye(f, "#"), or(f, CS, d);
  const p = [[Ps, o], [js, i]], h = [[Ps, null], [jh, s], [js, a]];
  for (let v = 0; v < By.length; v++)
    jl(t, By[v], wC, Hs, p);
  for (let v = 0; v < $y.length; v++)
    jl(t, $y[v], SC, xC, h);
  Vc(wC, {
    tld: !0,
    ascii: !0
  }, e), Vc(SC, {
    utld: !0,
    alpha: !0
  }, e), jl(t, "file", d1, Hs, p), jl(t, "mailto", d1, Hs, p), jl(t, "http", Yf, Hs, p), jl(t, "https", Yf, Hs, p), jl(t, "ftp", Yf, Hs, p), jl(t, "ftps", Yf, Hs, p), Vc(d1, {
    scheme: !0,
    ascii: !0
  }, e), Vc(Yf, {
    slashscheme: !0,
    ascii: !0
  }, e), n = n.sort((v, m) => v[0] > m[0] ? 1 : -1);
  for (let v = 0; v < n.length; v++) {
    const m = n[v][0], y = n[v][1] ? {
      [Qye]: !0
    } : {
      [e0e]: !0
    };
    m.indexOf("-") >= 0 ? y[_C] = !0 : Ps.test(m) ? js.test(m) ? y[Kv] = !0 : y[yC] = !0 : y[gC] = !0, RR(t, m, m, y);
  }
  return RR(t, "localhost", Fm, {
    ascii: !0
  }), t.jd = new Wi(Lb), {
    start: t,
    tokens: Object.assign({
      groups: e
    }, QH)
  };
}
function e7(n, e) {
  const t = o0e(e.replace(/[A-Z]/g, (s) => s.toLowerCase())), r = t.length, i = [];
  let a = 0, o = 0;
  for (; o < r; ) {
    let s = n, l = null, u = 0, c = null, d = -1, f = -1;
    for (; o < r && (l = s.go(t[o])); )
      s = l, s.accepts() ? (d = 0, f = 0, c = s) : d >= 0 && (d += t[o].length, f++), u += t[o].length, a += t[o].length, o++;
    a -= d, o -= f, u -= d, i.push({
      t: c.t,
      // token type/name
      v: e.slice(a - u, a),
      // string value
      s: a - u,
      // start index
      e: a
      // end index (excluding)
    });
  }
  return i;
}
function o0e(n) {
  const e = [], t = n.length;
  let r = 0;
  for (; r < t; ) {
    let i = n.charCodeAt(r), a, o = i < 55296 || i > 56319 || r + 1 === t || (a = n.charCodeAt(r + 1)) < 56320 || a > 57343 ? n[r] : n.slice(r, r + 2);
    e.push(o), r += o.length;
  }
  return e;
}
function jl(n, e, t, r, i) {
  let a;
  const o = e.length;
  for (let s = 0; s < o - 1; s++) {
    const l = e[s];
    n.j[l] ? a = n.j[l] : (a = new Wi(r), a.jr = i.slice(), n.j[l] = a), n = a;
  }
  return a = new Wi(t), a.jr = i.slice(), n.j[e[o - 1]] = a, a;
}
function jR(n) {
  const e = [], t = [];
  let r = 0, i = "0123456789";
  for (; r < n.length; ) {
    let a = 0;
    for (; i.indexOf(n[r + a]) >= 0; )
      a++;
    if (a > 0) {
      e.push(t.join(""));
      for (let o = parseInt(n.substring(r, r + a), 10); o > 0; o--)
        t.pop();
      r += a;
    } else
      t.push(n[r]), r++;
  }
  return e;
}
const Vm = {
  defaultProtocol: "http",
  events: null,
  format: BR,
  formatHref: BR,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function XM(n, e = null) {
  let t = Object.assign({}, Vm);
  n && (t = Object.assign(t, n instanceof XM ? n.o : n));
  const r = t.ignoreTags, i = [];
  for (let a = 0; a < r.length; a++)
    i.push(r[a].toUpperCase());
  this.o = t, e && (this.defaultRender = e), this.ignoreTags = i;
}
XM.prototype = {
  o: Vm,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(n) {
    return n;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(n) {
    return this.get("validate", n.toString(), n);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(n, e, t) {
    const r = e != null;
    let i = this.o[n];
    return i && (typeof i == "object" ? (i = t.t in i ? i[t.t] : Vm[n], typeof i == "function" && r && (i = i(e, t))) : typeof i == "function" && r && (i = i(e, t.t, t)), i);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(n, e, t) {
    let r = this.o[n];
    return typeof r == "function" && e != null && (r = r(e, t.t, t)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(n) {
    const e = n.render(this);
    return (this.get("render", null, n) || this.defaultRender)(e, n.t, n);
  }
};
function BR(n) {
  return n;
}
function t7(n, e) {
  this.t = "token", this.v = n, this.tk = e;
}
t7.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(n) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(n) {
    const e = this.toString(), t = n.get("truncate", e, this), r = n.get("format", e, this);
    return t && r.length > t ? r.substring(0, t) + "…" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(n) {
    return n.get("formatHref", this.toHref(n.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(n = Vm.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(n),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(n) {
    return {
      type: this.t,
      value: this.toFormattedString(n),
      isLink: this.isLink,
      href: this.toFormattedHref(n),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(n) {
    return n.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(n) {
    const e = this, t = this.toHref(n.get("defaultProtocol")), r = n.get("formatHref", t, this), i = n.get("tagName", t, e), a = this.toFormattedString(n), o = {}, s = n.get("className", t, e), l = n.get("target", t, e), u = n.get("rel", t, e), c = n.getObj("attributes", t, e), d = n.getObj("events", t, e);
    return o.href = r, s && (o.class = s), l && (o.target = l), u && (o.rel = u), c && Object.assign(o, c), {
      tagName: i,
      attributes: o,
      content: a,
      eventListeners: d
    };
  }
};
function Nx(n, e) {
  class t extends t7 {
    constructor(i, a) {
      super(i, a), this.t = n;
    }
  }
  for (const r in e)
    t.prototype[r] = e[r];
  return t.t = n, t;
}
const $R = Nx("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), zR = Nx("text"), s0e = Nx("nl"), zy = Nx("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(n = Vm.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${n}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const n = this.tk;
    return n.length >= 2 && n[0].t !== Fm && n[1].t === au;
  }
}), Aa = (n) => new Wi(n);
function l0e({
  groups: n
}) {
  const e = n.domain.concat([xb, Sb, Ql, Eb, Tb, Cb, kb, Ab, Ra, GM, Jv, Mb, Db, Ob, Zo, Lb, em, Ib]), t = [wb, au, WM, Xo, qM, Jv, Qv, YM, KM, db, fb, Xv, Zv, lb, sb, ub, cb, pb, hb, vb, mb, gb, yb, bb, _b], r = [xb, wb, Sb, Eb, Tb, Cb, kb, Ab, Ra, Xv, Zv, Jv, Mb, Db, Ob, Qv, Zo, Lb, em, Ib], i = Aa(), a = Ye(i, em);
  an(a, r, a), an(a, n.domain, a);
  const o = Aa(), s = Aa(), l = Aa();
  an(i, n.domain, o), an(i, n.scheme, s), an(i, n.slashscheme, l), an(o, r, a), an(o, n.domain, o);
  const u = Ye(o, Ql);
  Ye(a, Ql, u), Ye(s, Ql, u), Ye(l, Ql, u);
  const c = Ye(a, Xo);
  an(c, r, a), an(c, n.domain, a);
  const d = Aa();
  an(u, n.domain, d), an(d, n.domain, d);
  const f = Ye(d, Xo);
  an(f, n.domain, d);
  const p = Aa($R);
  an(f, n.tld, p), an(f, n.utld, p), Ye(u, Fm, p);
  const h = Ye(d, Ra);
  Ye(h, Ra, h), an(h, n.domain, d), an(p, n.domain, d), Ye(p, Xo, f), Ye(p, Ra, h);
  const v = Ye(p, au);
  an(v, n.numeric, $R);
  const m = Ye(o, Ra), g = Ye(o, Xo);
  Ye(m, Ra, m), an(m, n.domain, o), an(g, r, a), an(g, n.domain, o);
  const y = Aa(zy);
  an(g, n.tld, y), an(g, n.utld, y), an(y, n.domain, o), an(y, r, a), Ye(y, Xo, g), Ye(y, Ra, m), Ye(y, Ql, u);
  const b = Ye(y, au), _ = Aa(zy);
  an(b, n.numeric, _);
  const x = Aa(zy), w = Aa();
  an(x, e, x), an(x, t, w), an(w, e, x), an(w, t, w), Ye(y, Zo, x), Ye(_, Zo, x);
  const S = Ye(s, au), C = Ye(l, au), k = Ye(C, Zo), M = Ye(k, Zo);
  an(s, n.domain, o), Ye(s, Xo, g), Ye(s, Ra, m), an(l, n.domain, o), Ye(l, Xo, g), Ye(l, Ra, m), an(S, n.domain, x), Ye(S, Zo, x), Ye(S, Qv, x), an(M, n.domain, x), an(M, e, x), Ye(M, Zo, x);
  const D = [
    [Xv, Zv],
    // {}
    [sb, lb],
    // []
    [ub, cb],
    // ()
    [db, fb],
    // <>
    [pb, hb],
    // （）
    [vb, mb],
    // 「」
    [gb, yb],
    // 『』
    [bb, _b]
    // ＜＞
  ];
  for (let N = 0; N < D.length; N++) {
    const [R, j] = D[N], z = Ye(x, R);
    Ye(w, R, z), Ye(z, j, x);
    const F = Aa(zy);
    an(z, e, F);
    const B = Aa();
    an(z, t), an(F, e, F), an(F, t, B), an(B, e, F), an(B, t, B), Ye(F, j, x), Ye(B, j, x);
  }
  return Ye(i, Fm, y), Ye(i, UM, s0e), {
    start: i,
    tokens: QH
  };
}
function u0e(n, e, t) {
  let r = t.length, i = 0, a = [], o = [];
  for (; i < r; ) {
    let s = n, l = null, u = null, c = 0, d = null, f = -1;
    for (; i < r && !(l = s.go(t[i].t)); )
      o.push(t[i++]);
    for (; i < r && (u = l || s.go(t[i].t)); )
      l = null, s = u, s.accepts() ? (f = 0, d = s) : f >= 0 && f++, i++, c++;
    if (f < 0)
      i -= c, i < r && (o.push(t[i]), i++);
    else {
      o.length > 0 && (a.push(DS(zR, e, o)), o = []), i -= f, c -= f;
      const p = d.t, h = t.slice(i - c, i);
      a.push(DS(p, e, h));
    }
  }
  return o.length > 0 && a.push(DS(zR, e, o)), a;
}
function DS(n, e, t) {
  const r = t[0].s, i = t[t.length - 1].e, a = e.slice(r, i);
  return new n(a, t);
}
const c0e = typeof console < "u" && console && console.warn || (() => {
}), d0e = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", Xn = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function f0e() {
  return Wi.groups = {}, Xn.scanner = null, Xn.parser = null, Xn.tokenQueue = [], Xn.pluginQueue = [], Xn.customSchemes = [], Xn.initialized = !1, Xn;
}
function FR(n, e = !1) {
  if (Xn.initialized && c0e(`linkifyjs: already initialized - will not register custom scheme "${n}" ${d0e}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(n))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  Xn.customSchemes.push([n, e]);
}
function p0e() {
  Xn.scanner = a0e(Xn.customSchemes);
  for (let n = 0; n < Xn.tokenQueue.length; n++)
    Xn.tokenQueue[n][1]({
      scanner: Xn.scanner
    });
  Xn.parser = l0e(Xn.scanner.tokens);
  for (let n = 0; n < Xn.pluginQueue.length; n++)
    Xn.pluginQueue[n][1]({
      scanner: Xn.scanner,
      parser: Xn.parser
    });
  return Xn.initialized = !0, Xn;
}
function ZM(n) {
  return Xn.initialized || p0e(), u0e(Xn.parser.start, n, e7(Xn.scanner.start, n));
}
ZM.scan = e7;
function n7(n, e = null, t = null) {
  if (e && typeof e == "object") {
    if (t)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    t = e, e = null;
  }
  const r = new XM(t), i = ZM(n), a = [];
  for (let o = 0; o < i.length; o++) {
    const s = i[o];
    s.isLink && (!e || s.t === e) && r.check(s) && a.push(s.toFormattedObject(r));
  }
  return a;
}
const JM = "[\0-   ᠎ -\u2029 　]", h0e = new RegExp(JM), v0e = new RegExp(`${JM}$`), m0e = new RegExp(JM, "g");
function g0e(n) {
  return n.length === 1 ? n[0].isLink : n.length === 3 && n[1].isLink ? ["()", "[]"].includes(n[0].value + n[2].value) : !1;
}
function y0e(n) {
  return new Pn({
    key: new jn("autolink"),
    appendTransaction: (e, t, r) => {
      const i = e.some((u) => u.docChanged) && !t.doc.eq(r.doc), a = e.some((u) => u.getMeta("preventAutolink"));
      if (!i || a)
        return;
      const { tr: o } = r, s = cpe(t.doc, [...e]);
      if (mpe(s).forEach(({ newRange: u }) => {
        const c = fpe(r.doc, u, (p) => p.isTextblock);
        let d, f;
        if (c.length > 1)
          d = c[0], f = r.doc.textBetween(d.pos, d.pos + d.node.nodeSize, void 0, " ");
        else if (c.length) {
          const p = r.doc.textBetween(u.from, u.to, " ", " ");
          if (!v0e.test(p))
            return;
          d = c[0], f = r.doc.textBetween(d.pos, u.to, void 0, " ");
        }
        if (d && f) {
          const p = f.split(h0e).filter(Boolean);
          if (p.length <= 0)
            return !1;
          const h = p[p.length - 1], v = d.pos + f.lastIndexOf(h);
          if (!h)
            return !1;
          const m = ZM(h).map((g) => g.toObject(n.defaultProtocol));
          if (!g0e(m))
            return !1;
          m.filter((g) => g.isLink).map((g) => ({
            ...g,
            from: v + g.start + 1,
            to: v + g.end + 1
          })).filter((g) => r.schema.marks.code ? !r.doc.rangeHasMark(g.from, g.to, r.schema.marks.code) : !0).filter((g) => n.validate(g.value)).filter((g) => n.shouldAutoLink(g.value)).forEach((g) => {
            IM(g.from, g.to, r.doc).some((y) => y.mark.type === n.type) || o.addMark(g.from, g.to, n.type.create({
              href: g.href
            }));
          });
        }
      }), !!o.steps.length)
        return o;
    }
  });
}
function b0e(n) {
  return new Pn({
    key: new jn("handleClickLink"),
    props: {
      handleClick: (e, t, r) => {
        var i, a;
        if (r.button !== 0 || !e.editable)
          return !1;
        let o = r.target;
        const s = [];
        for (; o.nodeName !== "DIV"; )
          s.push(o), o = o.parentNode;
        if (!s.find((f) => f.nodeName === "A"))
          return !1;
        const l = Z8(e.state, n.type.name), u = r.target, c = (i = u == null ? void 0 : u.href) !== null && i !== void 0 ? i : l.href, d = (a = u == null ? void 0 : u.target) !== null && a !== void 0 ? a : l.target;
        return u && c ? (window.open(c, d), !0) : !1;
      }
    }
  });
}
function _0e(n) {
  return new Pn({
    key: new jn("handlePasteLink"),
    props: {
      handlePaste: (e, t, r) => {
        const { state: i } = e, { selection: a } = i, { empty: o } = a;
        if (o)
          return !1;
        let s = "";
        r.content.forEach((u) => {
          s += u.textContent;
        });
        const l = n7(s, { defaultProtocol: n.defaultProtocol }).find((u) => u.isLink && u.value === s);
        return !s || !l ? !1 : n.editor.commands.setMark(n.type, {
          href: l.href
        });
      }
    }
  });
}
function Ju(n, e) {
  const t = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  return e && e.forEach((r) => {
    const i = typeof r == "string" ? r : r.scheme;
    i && t.push(i);
  }), !n || n.replace(m0e, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${t.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
const x0e = Ao.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((n) => {
      if (typeof n == "string") {
        FR(n);
        return;
      }
      FR(n.scheme, n.optionalSlashes);
    });
  },
  onDestroy() {
    f0e();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (n, e) => !!Ju(n, e.protocols),
      validate: (n) => !!n,
      shouldAutoLink: (n) => !!n
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(n) {
          return n.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (n) => {
          const e = n.getAttribute("href");
          return !e || !this.options.isAllowedUri(e, {
            defaultValidate: (t) => !!Ju(t, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return this.options.isAllowedUri(n.href, {
      defaultValidate: (e) => !!Ju(e, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", Mn(this.options.HTMLAttributes, n), 0] : [
      "a",
      Mn(this.options.HTMLAttributes, { ...n, href: "" }),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (n) => ({ chain: e }) => {
        const { href: t } = n;
        return this.options.isAllowedUri(t, {
          defaultValidate: (r) => !!Ju(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().setMark(this.name, n).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (n) => ({ chain: e }) => {
        const { href: t } = n;
        return this.options.isAllowedUri(t, {
          defaultValidate: (r) => !!Ju(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().toggleMark(this.name, n, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run() : !1;
      },
      unsetLink: () => ({ chain: n }) => n().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Td({
        find: (n) => {
          const e = [];
          if (n) {
            const { protocols: t, defaultProtocol: r } = this.options, i = n7(n).filter((a) => a.isLink && this.options.isAllowedUri(a.value, {
              defaultValidate: (o) => !!Ju(o, t),
              protocols: t,
              defaultProtocol: r
            }));
            i.length && i.forEach((a) => e.push({
              text: a.value,
              data: {
                href: a.href
              },
              index: a.start
            }));
          }
          return e;
        },
        type: this.type,
        getAttributes: (n) => {
          var e;
          return {
            href: (e = n.data) === null || e === void 0 ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const n = [], { protocols: e, defaultProtocol: t } = this.options;
    return this.options.autolink && n.push(y0e({
      type: this.type,
      defaultProtocol: this.options.defaultProtocol,
      validate: (r) => this.options.isAllowedUri(r, {
        defaultValidate: (i) => !!Ju(i, e),
        protocols: e,
        defaultProtocol: t
      }),
      shouldAutoLink: this.options.shouldAutoLink
    })), this.options.openOnClick === !0 && n.push(b0e({
      type: this.type
    })), this.options.linkOnPaste && n.push(_0e({
      editor: this.editor,
      defaultProtocol: this.options.defaultProtocol,
      type: this.type
    })), n;
  }
});
function r7(n) {
  return !!(n === "" || /^(https?:\/\/|mailto:|tel:|\/\/)[^\s]+$/i.test(n) || /^([./#][^\s]*)$/i.test(n) || /^[\w\-]([\w\-./#?=&%]*)$/i.test(n));
}
const w0e = { class: "p-2 flex min-w-72 items-center gap-2 bg-surface-white shadow-xl rounded-lg" }, S0e = { class: "shrink-0 flex items-center gap-2" }, E0e = /* @__PURE__ */ ve({
  __name: "EditLink",
  props: {
    href: {}
  },
  emits: ["updateHref", "close"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Z(t.href), a = t1("input"), o = () => {
      (i.value === "" || r7(i.value)) && r("updateHref", i.value);
    };
    return kt(async () => {
      var s;
      await Wt(), (s = a.value) != null && s.el && (a.value.el.focus(), a.value.el.select());
    }), (s, l) => (L(), W("div", w0e, [
      se(Ga, {
        ref_key: "input",
        ref: a,
        type: "text",
        class: "w-full",
        placeholder: "https://example.com",
        modelValue: i.value,
        "onUpdate:modelValue": l[0] || (l[0] = (u) => i.value = u),
        onKeydown: [
          ci(o, ["enter"]),
          l[1] || (l[1] = ci((u) => s.$emit("close"), ["esc"]))
        ]
      }, null, 8, ["modelValue"]),
      G("div", S0e, [
        se(Ei, {
          text: "Submit",
          placement: "top"
        }, {
          default: ee(() => [
            se(fn, {
              label: "Submit",
              onClick: o
            }, {
              icon: ee(() => [
                se(O(IT), { class: "size-4" })
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        se(Ei, {
          text: "Remove link",
          placement: "top"
        }, {
          default: ee(() => [
            se(fn, {
              label: "Remove link",
              onClick: l[2] || (l[2] = (u) => s.$emit("updateHref", ""))
            }, {
              icon: ee(() => [
                se(O(rh), { class: "size-4" })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ])
    ]));
  }
});
function T0e(n) {
  return new Pn({
    key: new jn("handlePasteLink"),
    props: {
      handlePaste: (e, t, r) => {
        const { state: i } = e, { selection: a } = i, { empty: o } = a;
        if (o)
          return !1;
        let s = "";
        if (r.content.forEach((u) => {
          s += u.textContent;
        }), !s)
          return !1;
        let l = r7(s) ? s : null;
        return l ? n.editor.chain().setTextSelection({ from: a.from, to: a.to }).setLink({ href: l }).setTextSelection(a.to).command(({ tr: u }) => (u.setStoredMarks([]), !0)).run() : !1;
      }
    }
  });
}
const C0e = x0e.extend({
  addOptions() {
    var n;
    return {
      ...(n = this.parent) == null ? void 0 : n.call(this),
      openOnClick: !1,
      autolink: !0,
      defaultProtocol: "https",
      linkOnPaste: !1
    };
  },
  addCommands() {
    var n;
    return {
      ...(n = this.parent) == null ? void 0 : n.call(this),
      openLinkEditor: () => ({ editor: e }) => {
        const { state: t } = e, { from: r, to: i } = t.selection, { doc: a } = t;
        let o, s, l = !1;
        if (r === i) {
          const p = t.selection.$from, h = kx(p, this.type);
          if (h)
            o = h, s = a.resolve(h.from).marks().find((v) => v.type === this.type), e.chain().setTextSelection({ from: h.from, to: h.to }).run(), l = !0;
          else
            return !1;
        } else
          o = { from: r, to: i }, s = a.resolve(r).marks().find((p) => p.type === this.type);
        if (!o) return !1;
        const u = (s == null ? void 0 : s.attrs.href) || "", c = o.from, d = o.to, f = () => {
          k0e(u, e.view.dom).then((p) => {
            if (p === null)
              return;
            let h = e.chain().focus(null, { scrollIntoView: !1 });
            if (p === "") {
              h.setTextSelection({ from: c, to: d }).unsetLink().command(({ tr: g }) => (g.setStoredMarks([]), !0)).run();
              return;
            }
            h = h.setTextSelection({ from: c, to: d }).setLink({ href: p }).setTextSelection(d).command(({ tr: g }) => (g.setStoredMarks([]), !0));
            const v = d, m = v < a.content.size ? a.textBetween(v, v + 1) : null;
            (m === null || m !== " ") && (h = h.insertContent(" ")), h.run();
          }).catch(() => {
          });
        };
        return l ? requestAnimationFrame(f) : f(), !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-k": () => this.editor.commands.openLinkEditor()
    };
  },
  addProseMirrorPlugins() {
    var e;
    let n = ((e = this.parent) == null ? void 0 : e.call(this)) || [];
    return n.push(
      T0e({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type
      })
    ), n.push(
      A0e({
        editor: this.editor,
        type: this.type
      })
    ), n;
  }
});
function k0e(n, e) {
  return new Promise((t, r) => {
    const i = document.createElement("div");
    document.body.appendChild(i);
    let a;
    const o = window.getSelection();
    if (o && o.rangeCount > 0) {
      const p = o.getRangeAt(0), h = p.getBoundingClientRect(), v = p.collapsed;
      a = {
        getBoundingClientRect: () => ({
          width: 0,
          height: h.height,
          top: h.top,
          right: v ? h.left : h.right,
          bottom: h.bottom,
          left: h.left,
          x: h.left,
          y: h.top,
          toJSON: () => {
          }
        })
      };
    } else
      a = {
        getBoundingClientRect: () => e.getBoundingClientRect()
      };
    let s = null, l = null, u = !1, c = !1;
    const d = (p, h) => {
      c || (c = !0, p === "resolve" ? t(h) : r(h));
    }, f = () => {
      u || (u = !0, d("reject", "Link editing cancelled or destroyed"), requestAnimationFrame(() => {
        l == null || l.destroy(), s == null || s.unmount(), i == null || i.remove(), s = null, l = null;
      }));
    };
    if (s = bF({
      render() {
        return qt(E0e, {
          href: n,
          onClose: () => {
            d("reject", "Link editing cancelled"), f();
          },
          onUpdateHref: (p) => {
            d("resolve", p), f();
          }
        });
      }
    }), s.mount(i), l = qu(e, {
      getReferenceClientRect: () => a.getBoundingClientRect(),
      content: i,
      trigger: "manual",
      interactive: !0,
      appendTo: document.body,
      placement: "top",
      arrow: !1,
      theme: "link-editor",
      maxWidth: "none",
      onHidden() {
        f();
      },
      hideOnClick: !0,
      interactiveDebounce: 75
    }), !l) {
      i.remove(), d("reject", "Failed to initialize link editor tooltip");
      return;
    }
    l.show();
  });
}
function A0e(n) {
  return new Pn({
    key: new jn("clearLinkMarkOnBoundary"),
    appendTransaction: (e, t, r) => {
      if (!n.editor.isEditable)
        return null;
      const { tr: i, doc: a, selection: o, storedMarks: s } = r, { $from: l, empty: u } = o;
      if (!u || !s || s.length === 0)
        return null;
      const c = n.type;
      return !s.some(
        (h) => h.type === c
      ) || l.marks().some(
        (h) => h.type === c
      ) ? null : i.setStoredMarks([]);
    }
  });
}
const M0e = (n) => fr({
  find: /--$/,
  replace: n ?? "—"
}), D0e = (n) => fr({
  find: /\.\.\.$/,
  replace: n ?? "…"
}), O0e = (n) => fr({
  find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/,
  replace: n ?? "“"
}), I0e = (n) => fr({
  find: /"$/,
  replace: n ?? "”"
}), L0e = (n) => fr({
  find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/,
  replace: n ?? "‘"
}), N0e = (n) => fr({
  find: /'$/,
  replace: n ?? "’"
}), R0e = (n) => fr({
  find: /<-$/,
  replace: n ?? "←"
}), P0e = (n) => fr({
  find: /->$/,
  replace: n ?? "→"
}), j0e = (n) => fr({
  find: /\(c\)$/,
  replace: n ?? "©"
}), B0e = (n) => fr({
  find: /\(tm\)$/,
  replace: n ?? "™"
}), $0e = (n) => fr({
  find: /\(sm\)$/,
  replace: n ?? "℠"
}), z0e = (n) => fr({
  find: /\(r\)$/,
  replace: n ?? "®"
}), F0e = (n) => fr({
  find: /(?:^|\s)(1\/2)\s$/,
  replace: n ?? "½"
}), V0e = (n) => fr({
  find: /\+\/-$/,
  replace: n ?? "±"
}), H0e = (n) => fr({
  find: /!=$/,
  replace: n ?? "≠"
}), G0e = (n) => fr({
  find: /<<$/,
  replace: n ?? "«"
}), U0e = (n) => fr({
  find: />>$/,
  replace: n ?? "»"
}), W0e = (n) => fr({
  find: /\d+\s?([*x])\s?\d+$/,
  replace: n ?? "×"
}), q0e = (n) => fr({
  find: /\^2$/,
  replace: n ?? "²"
}), Y0e = (n) => fr({
  find: /\^3$/,
  replace: n ?? "³"
}), K0e = (n) => fr({
  find: /(?:^|\s)(1\/4)\s$/,
  replace: n ?? "¼"
}), X0e = (n) => fr({
  find: /(?:^|\s)(3\/4)\s$/,
  replace: n ?? "¾"
}), Z0e = Qn.create({
  name: "typography",
  addOptions() {
    return {
      closeDoubleQuote: "”",
      closeSingleQuote: "’",
      copyright: "©",
      ellipsis: "…",
      emDash: "—",
      laquo: "«",
      leftArrow: "←",
      multiplication: "×",
      notEqual: "≠",
      oneHalf: "½",
      oneQuarter: "¼",
      openDoubleQuote: "“",
      openSingleQuote: "‘",
      plusMinus: "±",
      raquo: "»",
      registeredTrademark: "®",
      rightArrow: "→",
      servicemark: "℠",
      superscriptThree: "³",
      superscriptTwo: "²",
      threeQuarters: "¾",
      trademark: "™"
    };
  },
  addInputRules() {
    const n = [];
    return this.options.emDash !== !1 && n.push(M0e(this.options.emDash)), this.options.ellipsis !== !1 && n.push(D0e(this.options.ellipsis)), this.options.openDoubleQuote !== !1 && n.push(O0e(this.options.openDoubleQuote)), this.options.closeDoubleQuote !== !1 && n.push(I0e(this.options.closeDoubleQuote)), this.options.openSingleQuote !== !1 && n.push(L0e(this.options.openSingleQuote)), this.options.closeSingleQuote !== !1 && n.push(N0e(this.options.closeSingleQuote)), this.options.leftArrow !== !1 && n.push(R0e(this.options.leftArrow)), this.options.rightArrow !== !1 && n.push(P0e(this.options.rightArrow)), this.options.copyright !== !1 && n.push(j0e(this.options.copyright)), this.options.trademark !== !1 && n.push(B0e(this.options.trademark)), this.options.servicemark !== !1 && n.push($0e(this.options.servicemark)), this.options.registeredTrademark !== !1 && n.push(z0e(this.options.registeredTrademark)), this.options.oneHalf !== !1 && n.push(F0e(this.options.oneHalf)), this.options.plusMinus !== !1 && n.push(V0e(this.options.plusMinus)), this.options.notEqual !== !1 && n.push(H0e(this.options.notEqual)), this.options.laquo !== !1 && n.push(G0e(this.options.laquo)), this.options.raquo !== !1 && n.push(U0e(this.options.raquo)), this.options.multiplication !== !1 && n.push(W0e(this.options.multiplication)), this.options.superscriptTwo !== !1 && n.push(q0e(this.options.superscriptTwo)), this.options.superscriptThree !== !1 && n.push(Y0e(this.options.superscriptThree)), this.options.oneQuarter !== !1 && n.push(K0e(this.options.oneQuarter)), this.options.threeQuarters !== !1 && n.push(X0e(this.options.threeQuarters)), n;
  }
}), J0e = (n) => {
  if (!n.children.length)
    return;
  const e = n.querySelectorAll("span");
  e && e.forEach((t) => {
    var r, i;
    const a = t.getAttribute("style"), o = (i = (r = t.parentElement) === null || r === void 0 ? void 0 : r.closest("span")) === null || i === void 0 ? void 0 : i.getAttribute("style");
    t.setAttribute("style", `${o};${a}`);
  });
}, Q0e = Ao.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      mergeNestedSpanStyles: !1
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (n) => n.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && J0e(n), {}) : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["span", Mn(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ tr: n }) => {
        const { selection: e } = n;
        return n.doc.nodesBetween(e.from, e.to, (t, r) => {
          if (t.isTextblock)
            return !0;
          t.marks.filter((i) => i.type === this.type).some((i) => Object.values(i.attrs).some((a) => !!a)) || n.removeMark(r, r + t.nodeSize, this.type);
        }), !0;
      }
    };
  }
}), e1e = /^\s*(\[([( |x])?\])\s$/, t1e = pr.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList",
      a11y: void 0
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (n) => {
          const e = n.getAttribute("data-checked");
          return e === "" || e === "true";
        },
        renderHTML: (n) => ({
          "data-checked": n.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: n, HTMLAttributes: e }) {
    return [
      "li",
      Mn(this.options.HTMLAttributes, e, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: n.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  addKeyboardShortcuts() {
    const n = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...n,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : n;
  },
  addNodeView() {
    return ({ node: n, HTMLAttributes: e, getPos: t, editor: r }) => {
      const i = document.createElement("li"), a = document.createElement("label"), o = document.createElement("span"), s = document.createElement("input"), l = document.createElement("div"), u = () => {
        var c, d;
        s.ariaLabel = ((d = (c = this.options.a11y) === null || c === void 0 ? void 0 : c.checkboxLabel) === null || d === void 0 ? void 0 : d.call(c, n, s.checked)) || `Task item checkbox for ${n.textContent || "empty task item"}`;
      };
      return u(), a.contentEditable = "false", s.type = "checkbox", s.addEventListener("mousedown", (c) => c.preventDefault()), s.addEventListener("change", (c) => {
        if (!r.isEditable && !this.options.onReadOnlyChecked) {
          s.checked = !s.checked;
          return;
        }
        const { checked: d } = c.target;
        r.isEditable && typeof t == "function" && r.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: f }) => {
          const p = t();
          if (typeof p != "number")
            return !1;
          const h = f.doc.nodeAt(p);
          return f.setNodeMarkup(p, void 0, {
            ...h == null ? void 0 : h.attrs,
            checked: d
          }), !0;
        }).run(), !r.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(n, d) || (s.checked = !s.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([c, d]) => {
        i.setAttribute(c, d);
      }), i.dataset.checked = n.attrs.checked, s.checked = n.attrs.checked, a.append(s, o), i.append(a, l), Object.entries(e).forEach(([c, d]) => {
        i.setAttribute(c, d);
      }), {
        dom: i,
        contentDOM: l,
        update: (c) => c.type !== this.type ? !1 : (i.dataset.checked = c.attrs.checked, s.checked = c.attrs.checked, u(), !0)
      };
    };
  },
  addInputRules() {
    return [
      Op({
        find: e1e,
        type: this.type,
        getAttributes: (n) => ({
          checked: n[n.length - 1] === "x"
        })
      })
    ];
  }
}), n1e = pr.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["ul", Mn(this.options.HTMLAttributes, n, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: n }) => n.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
}), i7 = {
  black: "#000000",
  red: "#dc2626",
  blue: "#1579D0",
  green: "#16a34a",
  yellow: "#ca8a04",
  orange: "#ea580c",
  purple: "#9333ea",
  pink: "#db2777",
  gray: "#6b7280",
  indigo: "#4f46e5",
  teal: "#0d9488",
  cyan: "#06b6d4"
}, a7 = {
  red: "#fecaca",
  blue: "#bfdbfe",
  green: "#bbf7d0",
  yellow: "#fef08a",
  orange: "#fed7aa",
  purple: "#e9d5ff",
  pink: "#fbcfe8",
  gray: "#e5e7eb",
  indigo: "#c7d2fe",
  teal: "#99f6e4",
  cyan: "#a5f3fc"
}, o7 = {
  "#1F272E": "gray",
  "#ca8a04": "yellow",
  "#ea580c": "orange",
  "#dc2626": "red",
  "#16a34a": "green",
  "#1579D0": "blue",
  "#9333ea": "purple",
  "#db2777": "pink"
}, s7 = {
  "#fef9c3": "yellow",
  "#ffedd5": "orange",
  "#fee2e2": "red",
  "#dcfce7": "green",
  "#D3E9FC": "blue",
  "#f3e8ff": "purple",
  "#fce7f3": "pink"
};
function TC(n, e, t, r) {
  if (r && n.startsWith("#") && r[n])
    return r[n];
  let i = 0, a = 0, o = 0;
  if (n.startsWith("#")) {
    const u = n.substring(1);
    u.length === 6 && (i = parseInt(u.substring(0, 2), 16), a = parseInt(u.substring(2, 4), 16), o = parseInt(u.substring(4, 6), 16));
  } else if (n.startsWith("rgb")) {
    const u = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.exec(n);
    u && (i = parseInt(u[1], 10), a = parseInt(u[2], 10), o = parseInt(u[3], 10));
  }
  if (isNaN(i) || isNaN(a) || isNaN(o))
    return null;
  let s = null, l = 1 / 0;
  for (const u of e) {
    const c = t[u];
    if (!c) continue;
    const d = c.startsWith("#") ? c.substring(1) : c;
    if (d.length !== 6) continue;
    const f = parseInt(d.substring(0, 2), 16), p = parseInt(d.substring(2, 4), 16), h = parseInt(d.substring(4, 6), 16), v = Math.sqrt(
      Math.pow(i - f, 2) + Math.pow(a - p, 2) + Math.pow(o - h, 2)
    );
    v < l && (l = v, s = u);
  }
  return s;
}
function l7(n, e, t = i7, r = o7, i = "color") {
  const a = Object.keys(t), o = new RegExp(`${i}:\\s*(#[0-9a-f]{6})`, "i").exec(
    n
  );
  if (o && o[1]) {
    const l = TC(
      o[1],
      a,
      // Search in all colors from the map
      t,
      r
    );
    if (l && e.includes(l))
      return l === "gray" ? null : l;
  }
  const s = new RegExp(
    `${i}:\\s*(rgb\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+\\s*\\))`,
    "i"
  ).exec(n);
  if (s && s[1]) {
    const l = TC(
      s[1],
      a,
      // Search in all colors from the map
      t,
      r
    );
    if (l && e.includes(l))
      return l === "gray" ? null : l;
  }
  return null;
}
function r1e(n, e) {
  return l7(
    n,
    e,
    i7,
    o7,
    "color"
  );
}
function i1e(n, e) {
  return l7(
    n,
    e,
    a7,
    s7,
    "background-color"
  );
}
const a1e = Qn.create({
  name: "namedColor",
  addOptions() {
    return {
      types: ["textStyle"],
      colors: [
        "red",
        "blue",
        "green",
        "yellow",
        "orange",
        "purple",
        "pink",
        "gray",
        "teal",
        "cyan"
      ]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (n) => {
              const e = n.getAttribute("style");
              if (e) {
                const t = e.match(
                  /color:\s*var\(--prose-color-(\w+)\)/
                );
                if (t && this.options.colors.includes(t[1]))
                  return t[1];
                const r = r1e(
                  e,
                  this.options.colors
                );
                if (r)
                  return r;
              }
              return null;
            },
            renderHTML: (n) => !n.color || !this.options.colors.includes(n.color) ? {} : {
              style: `color: var(--prose-color-${n.color})`
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColorByName: (n) => ({ chain: e, state: t, editor: r }) => {
        if (!this.options.colors.includes(n))
          return console.warn(
            `Color "${n}" is not in the allowed colors list`
          ), !1;
        const { to: i, empty: a } = t.selection;
        let o = e().setMark("textStyle", { color: n });
        return a || (o = o.setTextSelection(i).command(({ tr: s }) => (s.setStoredMarks([]), !0))), o.focus().run();
      },
      unsetColor: () => ({ chain: n }) => n().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
    };
  }
}), o1e = Ao.create({
  name: "namedHighlight",
  addOptions() {
    return {
      HTMLAttributes: {},
      multicolor: !0,
      colors: [
        "yellow",
        "blue",
        "green",
        "red",
        "orange",
        "purple",
        "pink",
        "gray",
        "teal",
        "cyan"
      ]
    };
  },
  addAttributes() {
    return this.options.multicolor ? {
      color: {
        default: null,
        parseHTML: (n) => {
          const e = n.getAttribute("style");
          if (e) {
            const r = e.match(
              /background-color:\s*var\(--prose-highlight-(\w+)\)/
            );
            if (r && this.options.colors.includes(r[1]))
              return r[1];
          }
          const t = n.getAttribute("data-color");
          if (t) {
            const r = TC(
              t,
              this.options.colors,
              a7,
              s7
            );
            if (r)
              return r;
          }
          if (e) {
            const r = i1e(
              e,
              this.options.colors
            );
            if (r)
              return r;
          }
          return null;
        },
        renderHTML: (n) => !n.color || !this.options.colors.includes(n.color) ? {} : {
          style: `background-color: var(--prose-highlight-${n.color})`
        }
      }
    } : {};
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return [
      "mark",
      Mn(this.options.HTMLAttributes, n),
      0
    ];
  },
  addCommands() {
    return {
      setHighlightByName: (n) => ({ chain: e, commands: t, editor: r, state: i }) => {
        if (!this.options.colors.includes(n))
          return console.warn(
            `Highlight color "${n}" is not in the allowed colors list`
          ), !1;
        const { from: a, to: o, empty: s } = i.selection;
        let l = e();
        return this.options.multicolor ? l = l.setMark(this.name, { color: n }) : l = l.setMark(this.name), s || (l = l.setTextSelection(o).command(({ tr: u }) => (u.setStoredMarks([]), !0))), l.focus().run();
      },
      toggleHighlightByName: (n) => ({ chain: e, commands: t, editor: r, state: i }) => {
        if (!this.options.colors.includes(n))
          return console.warn(
            `Highlight color "${n}" is not in the allowed colors list`
          ), !1;
        const { to: a, empty: o } = i.selection, s = this.options.multicolor ? { color: n } : void 0, l = r.isActive(
          this.name,
          s
        );
        let u = e().toggleMark(this.name, s);
        return !o && !l && (u = u.setTextSelection(a).command(({ tr: c }) => (c.setStoredMarks([]), !0))), u.focus().run();
      },
      unsetHighlight: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  }
});
function s1e(n) {
  const e = n.regex, t = n.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", o = "(?!struct)(" + r + "|" + e.optional(i) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", s = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, u = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [n.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      n.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, c = {
    className: "number",
    variants: [
      // Floating-point literal.
      {
        begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
      },
      // Integer literal.
      {
        begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
        // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
        // literal highlight actually makes it stand out more.
      }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      n.inherit(u, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      t,
      n.C_BLOCK_COMMENT_MODE
    ]
  }, f = {
    className: "title",
    begin: e.optional(i) + n.IDENT_RE,
    relevance: 0
  }, p = e.optional(i) + n.IDENT_RE + "\\s*\\(", h = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], v = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], m = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "flat_map",
    "flat_set",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], g = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], _ = {
    type: v,
    keyword: h,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: m
  }, x = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: g
    },
    begin: e.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      n.IDENT_RE,
      e.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, w = [
    x,
    d,
    s,
    t,
    n.C_BLOCK_COMMENT_MODE,
    c,
    u
  ], S = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: _,
    contains: w.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: _,
        contains: w.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, C = {
    className: "function",
    begin: "(" + o + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: _,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: _,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [f],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          u,
          c
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: _,
        relevance: 0,
        contains: [
          t,
          n.C_BLOCK_COMMENT_MODE,
          u,
          c,
          s,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: _,
            relevance: 0,
            contains: [
              "self",
              t,
              n.C_BLOCK_COMMENT_MODE,
              u,
              c,
              s
            ]
          }
        ]
      },
      s,
      t,
      n.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: _,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      S,
      C,
      x,
      w,
      [
        d,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
          end: ">",
          keywords: _,
          contains: [
            "self",
            s
          ]
        },
        {
          begin: n.IDENT_RE + "::",
          keywords: _
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function l1e(n) {
  const e = {
    type: [
      "boolean",
      "byte",
      "word",
      "String"
    ],
    built_in: [
      "KeyboardController",
      "MouseController",
      "SoftwareSerial",
      "EthernetServer",
      "EthernetClient",
      "LiquidCrystal",
      "RobotControl",
      "GSMVoiceCall",
      "EthernetUDP",
      "EsploraTFT",
      "HttpClient",
      "RobotMotor",
      "WiFiClient",
      "GSMScanner",
      "FileSystem",
      "Scheduler",
      "GSMServer",
      "YunClient",
      "YunServer",
      "IPAddress",
      "GSMClient",
      "GSMModem",
      "Keyboard",
      "Ethernet",
      "Console",
      "GSMBand",
      "Esplora",
      "Stepper",
      "Process",
      "WiFiUDP",
      "GSM_SMS",
      "Mailbox",
      "USBHost",
      "Firmata",
      "PImage",
      "Client",
      "Server",
      "GSMPIN",
      "FileIO",
      "Bridge",
      "Serial",
      "EEPROM",
      "Stream",
      "Mouse",
      "Audio",
      "Servo",
      "File",
      "Task",
      "GPRS",
      "WiFi",
      "Wire",
      "TFT",
      "GSM",
      "SPI",
      "SD"
    ],
    _hints: [
      "setup",
      "loop",
      "runShellCommandAsynchronously",
      "analogWriteResolution",
      "retrieveCallingNumber",
      "printFirmwareVersion",
      "analogReadResolution",
      "sendDigitalPortPair",
      "noListenOnLocalhost",
      "readJoystickButton",
      "setFirmwareVersion",
      "readJoystickSwitch",
      "scrollDisplayRight",
      "getVoiceCallStatus",
      "scrollDisplayLeft",
      "writeMicroseconds",
      "delayMicroseconds",
      "beginTransmission",
      "getSignalStrength",
      "runAsynchronously",
      "getAsynchronously",
      "listenOnLocalhost",
      "getCurrentCarrier",
      "readAccelerometer",
      "messageAvailable",
      "sendDigitalPorts",
      "lineFollowConfig",
      "countryNameWrite",
      "runShellCommand",
      "readStringUntil",
      "rewindDirectory",
      "readTemperature",
      "setClockDivider",
      "readLightSensor",
      "endTransmission",
      "analogReference",
      "detachInterrupt",
      "countryNameRead",
      "attachInterrupt",
      "encryptionType",
      "readBytesUntil",
      "robotNameWrite",
      "readMicrophone",
      "robotNameRead",
      "cityNameWrite",
      "userNameWrite",
      "readJoystickY",
      "readJoystickX",
      "mouseReleased",
      "openNextFile",
      "scanNetworks",
      "noInterrupts",
      "digitalWrite",
      "beginSpeaker",
      "mousePressed",
      "isActionDone",
      "mouseDragged",
      "displayLogos",
      "noAutoscroll",
      "addParameter",
      "remoteNumber",
      "getModifiers",
      "keyboardRead",
      "userNameRead",
      "waitContinue",
      "processInput",
      "parseCommand",
      "printVersion",
      "readNetworks",
      "writeMessage",
      "blinkVersion",
      "cityNameRead",
      "readMessage",
      "setDataMode",
      "parsePacket",
      "isListening",
      "setBitOrder",
      "beginPacket",
      "isDirectory",
      "motorsWrite",
      "drawCompass",
      "digitalRead",
      "clearScreen",
      "serialEvent",
      "rightToLeft",
      "setTextSize",
      "leftToRight",
      "requestFrom",
      "keyReleased",
      "compassRead",
      "analogWrite",
      "interrupts",
      "WiFiServer",
      "disconnect",
      "playMelody",
      "parseFloat",
      "autoscroll",
      "getPINUsed",
      "setPINUsed",
      "setTimeout",
      "sendAnalog",
      "readSlider",
      "analogRead",
      "beginWrite",
      "createChar",
      "motorsStop",
      "keyPressed",
      "tempoWrite",
      "readButton",
      "subnetMask",
      "debugPrint",
      "macAddress",
      "writeGreen",
      "randomSeed",
      "attachGPRS",
      "readString",
      "sendString",
      "remotePort",
      "releaseAll",
      "mouseMoved",
      "background",
      "getXChange",
      "getYChange",
      "answerCall",
      "getResult",
      "voiceCall",
      "endPacket",
      "constrain",
      "getSocket",
      "writeJSON",
      "getButton",
      "available",
      "connected",
      "findUntil",
      "readBytes",
      "exitValue",
      "readGreen",
      "writeBlue",
      "startLoop",
      "IPAddress",
      "isPressed",
      "sendSysex",
      "pauseMode",
      "gatewayIP",
      "setCursor",
      "getOemKey",
      "tuneWrite",
      "noDisplay",
      "loadImage",
      "switchPIN",
      "onRequest",
      "onReceive",
      "changePIN",
      "playFile",
      "noBuffer",
      "parseInt",
      "overflow",
      "checkPIN",
      "knobRead",
      "beginTFT",
      "bitClear",
      "updateIR",
      "bitWrite",
      "position",
      "writeRGB",
      "highByte",
      "writeRed",
      "setSpeed",
      "readBlue",
      "noStroke",
      "remoteIP",
      "transfer",
      "shutdown",
      "hangCall",
      "beginSMS",
      "endWrite",
      "attached",
      "maintain",
      "noCursor",
      "checkReg",
      "checkPUK",
      "shiftOut",
      "isValid",
      "shiftIn",
      "pulseIn",
      "connect",
      "println",
      "localIP",
      "pinMode",
      "getIMEI",
      "display",
      "noBlink",
      "process",
      "getBand",
      "running",
      "beginSD",
      "drawBMP",
      "lowByte",
      "setBand",
      "release",
      "bitRead",
      "prepare",
      "pointTo",
      "readRed",
      "setMode",
      "noFill",
      "remove",
      "listen",
      "stroke",
      "detach",
      "attach",
      "noTone",
      "exists",
      "buffer",
      "height",
      "bitSet",
      "circle",
      "config",
      "cursor",
      "random",
      "IRread",
      "setDNS",
      "endSMS",
      "getKey",
      "micros",
      "millis",
      "begin",
      "print",
      "write",
      "ready",
      "flush",
      "width",
      "isPIN",
      "blink",
      "clear",
      "press",
      "mkdir",
      "rmdir",
      "close",
      "point",
      "yield",
      "image",
      "BSSID",
      "click",
      "delay",
      "read",
      "text",
      "move",
      "peek",
      "beep",
      "rect",
      "line",
      "open",
      "seek",
      "fill",
      "size",
      "turn",
      "stop",
      "home",
      "find",
      "step",
      "tone",
      "sqrt",
      "RSSI",
      "SSID",
      "end",
      "bit",
      "tan",
      "cos",
      "sin",
      "pow",
      "map",
      "abs",
      "max",
      "min",
      "get",
      "run",
      "put"
    ],
    literal: [
      "DIGITAL_MESSAGE",
      "FIRMATA_STRING",
      "ANALOG_MESSAGE",
      "REPORT_DIGITAL",
      "REPORT_ANALOG",
      "INPUT_PULLUP",
      "SET_PIN_MODE",
      "INTERNAL2V56",
      "SYSTEM_RESET",
      "LED_BUILTIN",
      "INTERNAL1V1",
      "SYSEX_START",
      "INTERNAL",
      "EXTERNAL",
      "DEFAULT",
      "OUTPUT",
      "INPUT",
      "HIGH",
      "LOW"
    ]
  }, t = s1e(n), r = (
    /** @type {Record<string,any>} */
    t.keywords
  );
  return r.type = [
    ...r.type,
    ...e.type
  ], r.literal = [
    ...r.literal,
    ...e.literal
  ], r.built_in = [
    ...r.built_in,
    ...e.built_in
  ], r._hints = e._hints, t.name = "Arduino", t.aliases = ["ino"], t.supersetOf = "cpp", t;
}
function u1e(n) {
  const e = n.regex, t = {}, r = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [t]
      }
      // default values
    ]
  };
  Object.assign(t, {
    className: "variable",
    variants: [
      { begin: e.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      r
    ]
  });
  const i = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [n.BACKSLASH_ESCAPE]
  }, a = n.inherit(
    n.COMMENT(),
    {
      match: [
        /(^|\s)/,
        /#.*$/
      ],
      scope: {
        2: "comment"
      }
    }
  ), o = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      n.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, s = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      n.BACKSLASH_ESCAPE,
      t,
      i
    ]
  };
  i.contains.push(s);
  const l = {
    match: /\\"/
  }, u = {
    className: "string",
    begin: /'/,
    end: /'/
  }, c = {
    match: /\\'/
  }, d = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      n.NUMBER_MODE,
      t
    ]
  }, f = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], p = n.SHEBANG({
    binary: `(${f.join("|")})`,
    relevance: 10
  }), h = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: !0,
    contains: [n.inherit(n.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, v = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "time",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "coproc",
    "function",
    "select"
  ], m = [
    "true",
    "false"
  ], g = { match: /(\/[a-z._-]+)+/ }, y = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], b = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "sudo",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], _ = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], x = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: [
      "sh",
      "zsh"
    ],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: v,
      literal: m,
      built_in: [
        ...y,
        ...b,
        // Shell modifiers
        "set",
        "shopt",
        ..._,
        ...x
      ]
    },
    contains: [
      p,
      // to catch known shells and boost relevancy
      n.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      h,
      d,
      a,
      o,
      g,
      s,
      l,
      u,
      c,
      t
    ]
  };
}
function c1e(n) {
  const e = n.regex, t = n.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", o = "(" + r + "|" + e.optional(i) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", s = {
    className: "type",
    variants: [
      { begin: "\\b[a-z\\d_]*_t\\b" },
      { match: /\batomic_[a-z]{3,6}\b/ }
    ]
  }, u = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [n.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      n.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, c = {
    className: "number",
    variants: [
      { match: /\b(0b[01']+)/ },
      { match: /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/ },
      { match: /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/ },
      { match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      n.inherit(u, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      t,
      n.C_BLOCK_COMMENT_MODE
    ]
  }, f = {
    className: "title",
    begin: e.optional(i) + n.IDENT_RE,
    relevance: 0
  }, p = e.optional(i) + n.IDENT_RE + "\\s*\\(", m = {
    keyword: [
      "asm",
      "auto",
      "break",
      "case",
      "continue",
      "default",
      "do",
      "else",
      "enum",
      "extern",
      "for",
      "fortran",
      "goto",
      "if",
      "inline",
      "register",
      "restrict",
      "return",
      "sizeof",
      "typeof",
      "typeof_unqual",
      "struct",
      "switch",
      "typedef",
      "union",
      "volatile",
      "while",
      "_Alignas",
      "_Alignof",
      "_Atomic",
      "_Generic",
      "_Noreturn",
      "_Static_assert",
      "_Thread_local",
      // aliases
      "alignas",
      "alignof",
      "noreturn",
      "static_assert",
      "thread_local",
      // not a C keyword but is, for all intents and purposes, treated exactly like one.
      "_Pragma"
    ],
    type: [
      "float",
      "double",
      "signed",
      "unsigned",
      "int",
      "short",
      "long",
      "char",
      "void",
      "_Bool",
      "_BitInt",
      "_Complex",
      "_Imaginary",
      "_Decimal32",
      "_Decimal64",
      "_Decimal96",
      "_Decimal128",
      "_Decimal64x",
      "_Decimal128x",
      "_Float16",
      "_Float32",
      "_Float64",
      "_Float128",
      "_Float32x",
      "_Float64x",
      "_Float128x",
      // modifiers
      "const",
      "static",
      "constexpr",
      // aliases
      "complex",
      "bool",
      "imaginary"
    ],
    literal: "true false NULL",
    // TODO: apply hinting work similar to what was done in cpp.js
    built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
  }, g = [
    d,
    s,
    t,
    n.C_BLOCK_COMMENT_MODE,
    c,
    u
  ], y = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: m,
    contains: g.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: m,
        contains: g.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, b = {
    begin: "(" + o + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: m,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: m,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [n.inherit(f, { className: "title.function" })],
        relevance: 0
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: m,
        relevance: 0,
        contains: [
          t,
          n.C_BLOCK_COMMENT_MODE,
          u,
          c,
          s,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: m,
            relevance: 0,
            contains: [
              "self",
              t,
              n.C_BLOCK_COMMENT_MODE,
              u,
              c,
              s
            ]
          }
        ]
      },
      s,
      t,
      n.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C",
    aliases: ["h"],
    keywords: m,
    // Until differentiations are added between `c` and `cpp`, `c` will
    // not be auto-detected to avoid auto-detect conflicts between C and C++
    disableAutodetect: !0,
    illegal: "</",
    contains: [].concat(
      y,
      b,
      g,
      [
        d,
        {
          begin: n.IDENT_RE + "::",
          keywords: m
        },
        {
          className: "class",
          beginKeywords: "enum class struct union",
          end: /[{;:<>=]/,
          contains: [
            { beginKeywords: "final class struct" },
            n.TITLE_MODE
          ]
        }
      ]
    ),
    exports: {
      preprocessor: d,
      strings: u,
      keywords: m
    }
  };
}
function d1e(n) {
  const e = n.regex, t = n.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", o = "(?!struct)(" + r + "|" + e.optional(i) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", s = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, u = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [n.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      n.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, c = {
    className: "number",
    variants: [
      // Floating-point literal.
      {
        begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
      },
      // Integer literal.
      {
        begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
        // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
        // literal highlight actually makes it stand out more.
      }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      n.inherit(u, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      t,
      n.C_BLOCK_COMMENT_MODE
    ]
  }, f = {
    className: "title",
    begin: e.optional(i) + n.IDENT_RE,
    relevance: 0
  }, p = e.optional(i) + n.IDENT_RE + "\\s*\\(", h = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], v = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], m = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "flat_map",
    "flat_set",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], g = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], _ = {
    type: v,
    keyword: h,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: m
  }, x = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: g
    },
    begin: e.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      n.IDENT_RE,
      e.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, w = [
    x,
    d,
    s,
    t,
    n.C_BLOCK_COMMENT_MODE,
    c,
    u
  ], S = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: _,
    contains: w.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: _,
        contains: w.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, C = {
    className: "function",
    begin: "(" + o + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: _,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: _,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [f],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          u,
          c
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: _,
        relevance: 0,
        contains: [
          t,
          n.C_BLOCK_COMMENT_MODE,
          u,
          c,
          s,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: _,
            relevance: 0,
            contains: [
              "self",
              t,
              n.C_BLOCK_COMMENT_MODE,
              u,
              c,
              s
            ]
          }
        ]
      },
      s,
      t,
      n.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: _,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      S,
      C,
      x,
      w,
      [
        d,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
          end: ">",
          keywords: _,
          contains: [
            "self",
            s
          ]
        },
        {
          begin: n.IDENT_RE + "::",
          keywords: _
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function f1e(n) {
  const e = [
    "bool",
    "byte",
    "char",
    "decimal",
    "delegate",
    "double",
    "dynamic",
    "enum",
    "float",
    "int",
    "long",
    "nint",
    "nuint",
    "object",
    "sbyte",
    "short",
    "string",
    "ulong",
    "uint",
    "ushort"
  ], t = [
    "public",
    "private",
    "protected",
    "static",
    "internal",
    "protected",
    "abstract",
    "async",
    "extern",
    "override",
    "unsafe",
    "virtual",
    "new",
    "sealed",
    "partial"
  ], r = [
    "default",
    "false",
    "null",
    "true"
  ], i = [
    "abstract",
    "as",
    "base",
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "do",
    "else",
    "event",
    "explicit",
    "extern",
    "finally",
    "fixed",
    "for",
    "foreach",
    "goto",
    "if",
    "implicit",
    "in",
    "interface",
    "internal",
    "is",
    "lock",
    "namespace",
    "new",
    "operator",
    "out",
    "override",
    "params",
    "private",
    "protected",
    "public",
    "readonly",
    "record",
    "ref",
    "return",
    "scoped",
    "sealed",
    "sizeof",
    "stackalloc",
    "static",
    "struct",
    "switch",
    "this",
    "throw",
    "try",
    "typeof",
    "unchecked",
    "unsafe",
    "using",
    "virtual",
    "void",
    "volatile",
    "while"
  ], a = [
    "add",
    "alias",
    "and",
    "ascending",
    "args",
    "async",
    "await",
    "by",
    "descending",
    "dynamic",
    "equals",
    "file",
    "from",
    "get",
    "global",
    "group",
    "init",
    "into",
    "join",
    "let",
    "nameof",
    "not",
    "notnull",
    "on",
    "or",
    "orderby",
    "partial",
    "record",
    "remove",
    "required",
    "scoped",
    "select",
    "set",
    "unmanaged",
    "value|0",
    "var",
    "when",
    "where",
    "with",
    "yield"
  ], o = {
    keyword: i.concat(a),
    built_in: e,
    literal: r
  }, s = n.inherit(n.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), l = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, u = {
    className: "string",
    begin: /"""("*)(?!")(.|\n)*?"""\1/,
    relevance: 1
  }, c = {
    className: "string",
    begin: '@"',
    end: '"',
    contains: [{ begin: '""' }]
  }, d = n.inherit(c, { illegal: /\n/ }), f = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: o
  }, p = n.inherit(f, { illegal: /\n/ }), h = {
    className: "string",
    begin: /\$"/,
    end: '"',
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      n.BACKSLASH_ESCAPE,
      p
    ]
  }, v = {
    className: "string",
    begin: /\$@"/,
    end: '"',
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      f
    ]
  }, m = n.inherit(v, {
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      p
    ]
  });
  f.contains = [
    v,
    h,
    c,
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE,
    l,
    n.C_BLOCK_COMMENT_MODE
  ], p.contains = [
    m,
    h,
    d,
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE,
    l,
    n.inherit(n.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
  ];
  const g = { variants: [
    u,
    v,
    h,
    c,
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE
  ] }, y = {
    begin: "<",
    end: ">",
    contains: [
      { beginKeywords: "in out" },
      s
    ]
  }, b = n.IDENT_RE + "(<" + n.IDENT_RE + "(\\s*,\\s*" + n.IDENT_RE + ")*>)?(\\[\\])?", _ = {
    // prevents expressions like `@class` from incorrect flagging
    // `class` as a keyword
    begin: "@" + n.IDENT_RE,
    relevance: 0
  };
  return {
    name: "C#",
    aliases: [
      "cs",
      "c#"
    ],
    keywords: o,
    illegal: /::/,
    contains: [
      n.COMMENT(
        "///",
        "$",
        {
          returnBegin: !0,
          contains: [
            {
              className: "doctag",
              variants: [
                {
                  begin: "///",
                  relevance: 0
                },
                { begin: "<!--|-->" },
                {
                  begin: "</?",
                  end: ">"
                }
              ]
            }
          ]
        }
      ),
      n.C_LINE_COMMENT_MODE,
      n.C_BLOCK_COMMENT_MODE,
      {
        className: "meta",
        begin: "#",
        end: "$",
        keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
      },
      g,
      l,
      {
        beginKeywords: "class interface",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:,]/,
        contains: [
          { beginKeywords: "where class" },
          s,
          y,
          n.C_LINE_COMMENT_MODE,
          n.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          s,
          n.C_LINE_COMMENT_MODE,
          n.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "record",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          s,
          y,
          n.C_LINE_COMMENT_MODE,
          n.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // [Attributes("")]
        className: "meta",
        begin: "^\\s*\\[(?=[\\w])",
        excludeBegin: !0,
        end: "\\]",
        excludeEnd: !0,
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new return throw await else",
        relevance: 0
      },
      {
        className: "function",
        begin: "(" + b + "\\s+)+" + n.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
        returnBegin: !0,
        end: /\s*[{;=]/,
        excludeEnd: !0,
        keywords: o,
        contains: [
          // prevents these from being highlighted `title`
          {
            beginKeywords: t.join(" "),
            relevance: 0
          },
          {
            begin: n.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: !0,
            contains: [
              n.TITLE_MODE,
              y
            ],
            relevance: 0
          },
          { match: /\(\)/ },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: o,
            relevance: 0,
            contains: [
              g,
              l,
              n.C_BLOCK_COMMENT_MODE
            ]
          },
          n.C_LINE_COMMENT_MODE,
          n.C_BLOCK_COMMENT_MODE
        ]
      },
      _
    ]
  };
}
const p1e = (n) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: n.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: n.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), h1e = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], v1e = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], m1e = [
  ...h1e,
  ...v1e
], g1e = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), y1e = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), b1e = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), _1e = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "anchor-name",
  "animation",
  "animation-composition",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-range",
  "animation-range-end",
  "animation-range-start",
  "animation-timeline",
  "animation-timing-function",
  "appearance",
  "aspect-ratio",
  "backdrop-filter",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-position-x",
  "background-position-y",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-align",
  "box-decoration-break",
  "box-direction",
  "box-flex",
  "box-flex-group",
  "box-lines",
  "box-ordinal-group",
  "box-orient",
  "box-pack",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "cx",
  "cy",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "field-sizing",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flood-color",
  "flood-opacity",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "font-smooth",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-position",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphenate-character",
  "hyphenate-limit-chars",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "initial-letter",
  "initial-letter-align",
  "inline-size",
  "inset",
  "inset-area",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "justify-content",
  "justify-items",
  "justify-self",
  "kerning",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "line-height-step",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "masonry-auto-flow",
  "math-depth",
  "math-shift",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "overlay",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "place-content",
  "place-items",
  "place-self",
  "pointer-events",
  "position",
  "position-anchor",
  "position-visibility",
  "print-color-adjust",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "ruby-align",
  "ruby-position",
  "scale",
  "scroll-behavior",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scroll-timeline",
  "scroll-timeline-axis",
  "scroll-timeline-name",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-anchor",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-size-adjust",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "text-wrap",
  "text-wrap-mode",
  "text-wrap-style",
  "timeline-scope",
  "top",
  "touch-action",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-behavior",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "user-modify",
  "user-select",
  "vector-effect",
  "vertical-align",
  "view-timeline",
  "view-timeline-axis",
  "view-timeline-inset",
  "view-timeline-name",
  "view-transition-name",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "white-space-collapse",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
].sort().reverse();
function x1e(n) {
  const e = n.regex, t = p1e(n), r = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, i = "and or not only", a = /@-?\w[\w]*(-\w+)*/, o = "[a-zA-Z-][a-zA-Z0-9_-]*", s = [
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE
  ];
  return {
    name: "CSS",
    case_insensitive: !0,
    illegal: /[=|'\$]/,
    keywords: { keyframePosition: "from to" },
    classNameAliases: {
      // for visual continuity with `tag {}` and because we
      // don't have a great class for this?
      keyframePosition: "selector-tag"
    },
    contains: [
      t.BLOCK_COMMENT,
      r,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      t.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\." + o,
        relevance: 0
      },
      t.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          { begin: ":(" + y1e.join("|") + ")" },
          { begin: ":(:)?(" + b1e.join("|") + ")" }
        ]
      },
      // we may actually need this (12/2020)
      // { // pseudo-selector params
      //   begin: /\(/,
      //   end: /\)/,
      //   contains: [ hljs.CSS_NUMBER_MODE ]
      // },
      t.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + _1e.join("|") + ")\\b"
      },
      // attribute values
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          t.BLOCK_COMMENT,
          t.HEXCOLOR,
          t.IMPORTANT,
          t.CSS_NUMBER_MODE,
          ...s,
          // needed to highlight these as strings and to avoid issues with
          // illegal characters that might be inside urls that would tigger the
          // languages illegal stack
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            // from keywords
            keywords: { built_in: "url data-uri" },
            contains: [
              ...s,
              {
                className: "string",
                // any character other than `)` as in `url()` will be the start
                // of a string, which ends with `)` (from the parent mode)
                begin: /[^)]/,
                endsWithParent: !0,
                excludeEnd: !0
              }
            ]
          },
          t.FUNCTION_DISPATCH
        ]
      },
      {
        begin: e.lookahead(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        // break on Less variables @var: ...
        contains: [
          {
            className: "keyword",
            begin: a
          },
          {
            begin: /\s/,
            endsWithParent: !0,
            excludeEnd: !0,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: i,
              attribute: g1e.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...s,
              t.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: "selector-tag",
        begin: "\\b(" + m1e.join("|") + ")\\b"
      }
    ]
  };
}
function w1e(n) {
  const e = n.regex;
  return {
    name: "Diff",
    aliases: ["patch"],
    contains: [
      {
        className: "meta",
        relevance: 10,
        match: e.either(
          /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
          /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
          /^--- +\d+,\d+ +----$/
        )
      },
      {
        className: "comment",
        variants: [
          {
            begin: e.either(
              /Index: /,
              /^index/,
              /={3,}/,
              /^-{3}/,
              /^\*{3} /,
              /^\+{3}/,
              /^diff --git/
            ),
            end: /$/
          },
          { match: /^\*{15}$/ }
        ]
      },
      {
        className: "addition",
        begin: /^\+/,
        end: /$/
      },
      {
        className: "deletion",
        begin: /^-/,
        end: /$/
      },
      {
        className: "addition",
        begin: /^!/,
        end: /$/
      }
    ]
  };
}
function S1e(n) {
  const a = {
    keyword: [
      "break",
      "case",
      "chan",
      "const",
      "continue",
      "default",
      "defer",
      "else",
      "fallthrough",
      "for",
      "func",
      "go",
      "goto",
      "if",
      "import",
      "interface",
      "map",
      "package",
      "range",
      "return",
      "select",
      "struct",
      "switch",
      "type",
      "var"
    ],
    type: [
      "bool",
      "byte",
      "complex64",
      "complex128",
      "error",
      "float32",
      "float64",
      "int8",
      "int16",
      "int32",
      "int64",
      "string",
      "uint8",
      "uint16",
      "uint32",
      "uint64",
      "int",
      "uint",
      "uintptr",
      "rune"
    ],
    literal: [
      "true",
      "false",
      "iota",
      "nil"
    ],
    built_in: [
      "append",
      "cap",
      "close",
      "complex",
      "copy",
      "imag",
      "len",
      "make",
      "new",
      "panic",
      "print",
      "println",
      "real",
      "recover",
      "delete"
    ]
  };
  return {
    name: "Go",
    aliases: ["golang"],
    keywords: a,
    illegal: "</",
    contains: [
      n.C_LINE_COMMENT_MODE,
      n.C_BLOCK_COMMENT_MODE,
      {
        className: "string",
        variants: [
          n.QUOTE_STRING_MODE,
          n.APOS_STRING_MODE,
          {
            begin: "`",
            end: "`"
          }
        ]
      },
      {
        className: "number",
        variants: [
          {
            match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
            // hex without a present digit before . (making a digit afterwards required)
            relevance: 0
          },
          {
            match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
            // hex with a present digit before . (making a digit afterwards optional)
            relevance: 0
          },
          {
            match: /-?\b0[oO](_?[0-7])*i?/,
            // leading 0o octal
            relevance: 0
          },
          {
            match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
            // decimal without a present digit before . (making a digit afterwards required)
            relevance: 0
          },
          {
            match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
            // decimal with a present digit before . (making a digit afterwards optional)
            relevance: 0
          }
        ]
      },
      {
        begin: /:=/
        // relevance booster
      },
      {
        className: "function",
        beginKeywords: "func",
        end: "\\s*(\\{|$)",
        excludeEnd: !0,
        contains: [
          n.TITLE_MODE,
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: a,
            illegal: /["']/
          }
        ]
      }
    ]
  };
}
function E1e(n) {
  const e = n.regex, t = /[_A-Za-z][_0-9A-Za-z]*/;
  return {
    name: "GraphQL",
    aliases: ["gql"],
    case_insensitive: !0,
    disableAutodetect: !1,
    keywords: {
      keyword: [
        "query",
        "mutation",
        "subscription",
        "type",
        "input",
        "schema",
        "directive",
        "interface",
        "union",
        "scalar",
        "fragment",
        "enum",
        "on"
      ],
      literal: [
        "true",
        "false",
        "null"
      ]
    },
    contains: [
      n.HASH_COMMENT_MODE,
      n.QUOTE_STRING_MODE,
      n.NUMBER_MODE,
      {
        scope: "punctuation",
        match: /[.]{3}/,
        relevance: 0
      },
      {
        scope: "punctuation",
        begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
        relevance: 0
      },
      {
        scope: "variable",
        begin: /\$/,
        end: /\W/,
        excludeEnd: !0,
        relevance: 0
      },
      {
        scope: "meta",
        match: /@\w+/,
        excludeEnd: !0
      },
      {
        scope: "symbol",
        begin: e.concat(t, e.lookahead(/\s*:/)),
        relevance: 0
      }
    ],
    illegal: [
      /[;<']/,
      /BEGIN/
    ]
  };
}
function T1e(n) {
  const e = n.regex, t = {
    className: "number",
    relevance: 0,
    variants: [
      { begin: /([+-]+)?[\d]+_[\d_]+/ },
      { begin: n.NUMBER_RE }
    ]
  }, r = n.COMMENT();
  r.variants = [
    {
      begin: /;/,
      end: /$/
    },
    {
      begin: /#/,
      end: /$/
    }
  ];
  const i = {
    className: "variable",
    variants: [
      { begin: /\$[\w\d"][\w\d_]*/ },
      { begin: /\$\{(.*?)\}/ }
    ]
  }, a = {
    className: "literal",
    begin: /\bon|off|true|false|yes|no\b/
  }, o = {
    className: "string",
    contains: [n.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: "'''",
        end: "'''",
        relevance: 10
      },
      {
        begin: '"""',
        end: '"""',
        relevance: 10
      },
      {
        begin: '"',
        end: '"'
      },
      {
        begin: "'",
        end: "'"
      }
    ]
  }, s = {
    begin: /\[/,
    end: /\]/,
    contains: [
      r,
      a,
      i,
      o,
      t,
      "self"
    ],
    relevance: 0
  }, l = /[A-Za-z0-9_-]+/, u = /"(\\"|[^"])*"/, c = /'[^']*'/, d = e.either(
    l,
    u,
    c
  ), f = e.concat(
    d,
    "(\\s*\\.\\s*",
    d,
    ")*",
    e.lookahead(/\s*=\s*[^#\s]/)
  );
  return {
    name: "TOML, also INI",
    aliases: ["toml"],
    case_insensitive: !0,
    illegal: /\S/,
    contains: [
      r,
      {
        className: "section",
        begin: /\[+/,
        end: /\]+/
      },
      {
        begin: f,
        className: "attr",
        starts: {
          end: /$/,
          contains: [
            r,
            s,
            a,
            i,
            o,
            t
          ]
        }
      }
    ]
  };
}
var Kf = "[0-9](_*[0-9])*", Fy = `\\.(${Kf})`, Vy = "[0-9a-fA-F](_*[0-9a-fA-F])*", VR = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${Kf})((${Fy})|\\.)?|(${Fy}))[eE][+-]?(${Kf})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${Kf})((${Fy})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${Fy})[fFdD]?\\b` },
    { begin: `\\b(${Kf})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Vy})\\.?|(${Vy})?\\.(${Vy}))[pP][+-]?(${Kf})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Vy})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function u7(n, e, t) {
  return t === -1 ? "" : n.replace(e, (r) => u7(n, e, t - 1));
}
function C1e(n) {
  const e = n.regex, t = "[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*", r = t + u7("(?:<" + t + "~~~(?:\\s*,\\s*" + t + "~~~)*>)?", /~~~/g, 2), l = {
    keyword: [
      "synchronized",
      "abstract",
      "private",
      "var",
      "static",
      "if",
      "const ",
      "for",
      "while",
      "strictfp",
      "finally",
      "protected",
      "import",
      "native",
      "final",
      "void",
      "enum",
      "else",
      "break",
      "transient",
      "catch",
      "instanceof",
      "volatile",
      "case",
      "assert",
      "package",
      "default",
      "public",
      "try",
      "switch",
      "continue",
      "throws",
      "protected",
      "public",
      "private",
      "module",
      "requires",
      "exports",
      "do",
      "sealed",
      "yield",
      "permits",
      "goto",
      "when"
    ],
    literal: [
      "false",
      "true",
      "null"
    ],
    type: [
      "char",
      "boolean",
      "long",
      "float",
      "int",
      "byte",
      "short",
      "double"
    ],
    built_in: [
      "super",
      "this"
    ]
  }, u = {
    className: "meta",
    begin: "@" + t,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: ["self"]
        // allow nested () inside our annotation
      }
    ]
  }, c = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    keywords: l,
    relevance: 0,
    contains: [n.C_BLOCK_COMMENT_MODE],
    endsParent: !0
  };
  return {
    name: "Java",
    aliases: ["jsp"],
    keywords: l,
    illegal: /<\/|#/,
    contains: [
      n.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              // eat up @'s in emails to prevent them to be recognized as doctags
              begin: /\w+@/,
              relevance: 0
            },
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      // relevance boost
      {
        begin: /import java\.[a-z]+\./,
        keywords: "import",
        relevance: 2
      },
      n.C_LINE_COMMENT_MODE,
      n.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: "string",
        contains: [n.BACKSLASH_ESCAPE]
      },
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      {
        match: [
          /\b(?:class|interface|enum|extends|implements|new)/,
          /\s+/,
          t
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        // Exceptions for hyphenated keywords
        match: /non-sealed/,
        scope: "keyword"
      },
      {
        begin: [
          e.concat(/(?!else)/, t),
          /\s+/,
          t,
          /\s+/,
          /=(?!=)/
        ],
        className: {
          1: "type",
          3: "variable",
          5: "operator"
        }
      },
      {
        begin: [
          /record/,
          /\s+/,
          t
        ],
        className: {
          1: "keyword",
          3: "title.class"
        },
        contains: [
          c,
          n.C_LINE_COMMENT_MODE,
          n.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new throw return else",
        relevance: 0
      },
      {
        begin: [
          "(?:" + r + "\\s+)",
          n.UNDERSCORE_IDENT_RE,
          /\s*(?=\()/
        ],
        className: { 2: "title.function" },
        keywords: l,
        contains: [
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: l,
            relevance: 0,
            contains: [
              u,
              n.APOS_STRING_MODE,
              n.QUOTE_STRING_MODE,
              VR,
              n.C_BLOCK_COMMENT_MODE
            ]
          },
          n.C_LINE_COMMENT_MODE,
          n.C_BLOCK_COMMENT_MODE
        ]
      },
      VR,
      u
    ]
  };
}
const HR = "[A-Za-z$_][0-9A-Za-z$_]*", k1e = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends",
  // It's reached stage 3, which is "recommended for implementation":
  "using"
], A1e = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], c7 = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], d7 = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], f7 = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], M1e = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], D1e = [].concat(
  f7,
  c7,
  d7
);
function O1e(n) {
  const e = n.regex, t = (H, { after: Y }) => {
    const ne = "</" + H[0].slice(1);
    return H.input.indexOf(ne, Y) !== -1;
  }, r = HR, i = {
    begin: "<>",
    end: "</>"
  }, a = /<[A-Za-z0-9\\._:-]+\s*\/>/, o = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (H, Y) => {
      const ne = H[0].length + H.index, J = H.input[ne];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        J === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        J === ","
      ) {
        Y.ignoreMatch();
        return;
      }
      J === ">" && (t(H, { after: ne }) || Y.ignoreMatch());
      let X;
      const ie = H.input.substring(ne);
      if (X = ie.match(/^\s*=/)) {
        Y.ignoreMatch();
        return;
      }
      if ((X = ie.match(/^\s+extends\s+/)) && X.index === 0) {
        Y.ignoreMatch();
        return;
      }
    }
  }, s = {
    $pattern: HR,
    keyword: k1e,
    literal: A1e,
    built_in: D1e,
    "variable.language": M1e
  }, l = "[0-9](_?[0-9])*", u = `\\.(${l})`, c = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${c})((${u})|\\.)?|(${u}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${c})\\b((${u})\\b|\\.)?|(${u})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: s,
    contains: []
    // defined later
  }, p = {
    begin: ".?html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, h = {
    begin: ".?css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, v = {
    begin: ".?gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, m = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      n.BACKSLASH_ESCAPE,
      f
    ]
  }, y = {
    className: "comment",
    variants: [
      n.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      n.C_BLOCK_COMMENT_MODE,
      n.C_LINE_COMMENT_MODE
    ]
  }, b = [
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE,
    p,
    h,
    v,
    m,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    d
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = b.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: s,
    contains: [
      "self"
    ].concat(b)
  });
  const _ = [].concat(y, f.contains), x = _.concat([
    // eat recursive parens in sub expressions
    {
      begin: /(\s*)\(/,
      end: /\)/,
      keywords: s,
      contains: ["self"].concat(_)
    }
  ]), w = {
    className: "params",
    // convert this to negative lookbehind in v12
    begin: /(\s*)\(/,
    // to match the parms with
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: s,
    contains: x
  }, S = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, C = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...c7,
        ...d7
      ]
    }
  }, k = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, M = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [w],
    illegal: /%/
  }, D = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function N(H) {
    return e.concat("(?!", H.join("|"), ")");
  }
  const R = {
    match: e.concat(
      /\b/,
      N([
        ...f7,
        "super",
        "import"
      ].map((H) => `${H}\\s*\\(`)),
      r,
      e.lookahead(/\s*\(/)
    ),
    className: "title.function",
    relevance: 0
  }, j = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, z = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      w
    ]
  }, F = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", B = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(F)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      w
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: s,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: x, CLASS_REFERENCE: C },
    illegal: /#(?![$_A-z])/,
    contains: [
      n.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      k,
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      p,
      h,
      v,
      m,
      y,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      d,
      C,
      {
        scope: "attr",
        match: r + e.lookahead(":"),
        relevance: 0
      },
      B,
      {
        // "value" container
        begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          y,
          n.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: F,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: n.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /(\s*)\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: s,
                    contains: x
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: i.begin, end: i.end },
              { match: a },
              {
                begin: o.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": o.isTrulyOpeningTag,
                end: o.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: o.begin,
                end: o.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      M,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          w,
          n.inherit(n.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      j,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [w]
      },
      R,
      D,
      S,
      z,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function I1e(n) {
  const e = {
    className: "attr",
    begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
    relevance: 1.01
  }, t = {
    match: /[{}[\],:]/,
    className: "punctuation",
    relevance: 0
  }, r = [
    "true",
    "false",
    "null"
  ], i = {
    scope: "literal",
    beginKeywords: r.join(" ")
  };
  return {
    name: "JSON",
    aliases: ["jsonc"],
    keywords: {
      literal: r
    },
    contains: [
      e,
      t,
      n.QUOTE_STRING_MODE,
      i,
      n.C_NUMBER_MODE,
      n.C_LINE_COMMENT_MODE,
      n.C_BLOCK_COMMENT_MODE
    ],
    illegal: "\\S"
  };
}
var Xf = "[0-9](_*[0-9])*", Hy = `\\.(${Xf})`, Gy = "[0-9a-fA-F](_*[0-9a-fA-F])*", L1e = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${Xf})((${Hy})|\\.)?|(${Hy}))[eE][+-]?(${Xf})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${Xf})((${Hy})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${Hy})[fFdD]?\\b` },
    { begin: `\\b(${Xf})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Gy})\\.?|(${Gy})?\\.(${Gy}))[pP][+-]?(${Xf})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Gy})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function N1e(n) {
  const e = {
    keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
    built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
    literal: "true false null"
  }, t = {
    className: "keyword",
    begin: /\b(break|continue|return|this)\b/,
    starts: { contains: [
      {
        className: "symbol",
        begin: /@\w+/
      }
    ] }
  }, r = {
    className: "symbol",
    begin: n.UNDERSCORE_IDENT_RE + "@"
  }, i = {
    className: "subst",
    begin: /\$\{/,
    end: /\}/,
    contains: [n.C_NUMBER_MODE]
  }, a = {
    className: "variable",
    begin: "\\$" + n.UNDERSCORE_IDENT_RE
  }, o = {
    className: "string",
    variants: [
      {
        begin: '"""',
        end: '"""(?=[^"])',
        contains: [
          a,
          i
        ]
      },
      // Can't use built-in modes easily, as we want to use STRING in the meta
      // context as 'meta-string' and there's no syntax to remove explicitly set
      // classNames in built-in modes.
      {
        begin: "'",
        end: "'",
        illegal: /\n/,
        contains: [n.BACKSLASH_ESCAPE]
      },
      {
        begin: '"',
        end: '"',
        illegal: /\n/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a,
          i
        ]
      }
    ]
  };
  i.contains.push(o);
  const s = {
    className: "meta",
    begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + n.UNDERSCORE_IDENT_RE + ")?"
  }, l = {
    className: "meta",
    begin: "@" + n.UNDERSCORE_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          n.inherit(o, { className: "string" }),
          "self"
        ]
      }
    ]
  }, u = L1e, c = n.COMMENT(
    "/\\*",
    "\\*/",
    { contains: [n.C_BLOCK_COMMENT_MODE] }
  ), d = { variants: [
    {
      className: "type",
      begin: n.UNDERSCORE_IDENT_RE
    },
    {
      begin: /\(/,
      end: /\)/,
      contains: []
      // defined later
    }
  ] }, f = d;
  return f.variants[1].contains = [d], d.variants[1].contains = [f], {
    name: "Kotlin",
    aliases: [
      "kt",
      "kts"
    ],
    keywords: e,
    contains: [
      n.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      n.C_LINE_COMMENT_MODE,
      c,
      t,
      r,
      s,
      l,
      {
        className: "function",
        beginKeywords: "fun",
        end: "[(]|$",
        returnBegin: !0,
        excludeEnd: !0,
        keywords: e,
        relevance: 5,
        contains: [
          {
            begin: n.UNDERSCORE_IDENT_RE + "\\s*\\(",
            returnBegin: !0,
            relevance: 0,
            contains: [n.UNDERSCORE_TITLE_MODE]
          },
          {
            className: "type",
            begin: /</,
            end: />/,
            keywords: "reified",
            relevance: 0
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: e,
            relevance: 0,
            contains: [
              {
                begin: /:/,
                end: /[=,\/]/,
                endsWithParent: !0,
                contains: [
                  d,
                  n.C_LINE_COMMENT_MODE,
                  c
                ],
                relevance: 0
              },
              n.C_LINE_COMMENT_MODE,
              c,
              s,
              l,
              o,
              n.C_NUMBER_MODE
            ]
          },
          c
        ]
      },
      {
        begin: [
          /class|interface|trait/,
          /\s+/,
          n.UNDERSCORE_IDENT_RE
        ],
        beginScope: {
          3: "title.class"
        },
        keywords: "class interface trait",
        end: /[:\{(]|$/,
        excludeEnd: !0,
        illegal: "extends implements",
        contains: [
          { beginKeywords: "public protected internal private constructor" },
          n.UNDERSCORE_TITLE_MODE,
          {
            className: "type",
            begin: /</,
            end: />/,
            excludeBegin: !0,
            excludeEnd: !0,
            relevance: 0
          },
          {
            className: "type",
            begin: /[,:]\s*/,
            end: /[<\(,){\s]|$/,
            excludeBegin: !0,
            returnEnd: !0
          },
          s,
          l
        ]
      },
      o,
      {
        className: "meta",
        begin: "^#!/usr/bin/env",
        end: "$",
        illegal: `
`
      },
      u
    ]
  };
}
const R1e = (n) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: n.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: n.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), P1e = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], j1e = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], B1e = [
  ...P1e,
  ...j1e
], $1e = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), p7 = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), h7 = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), z1e = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "anchor-name",
  "animation",
  "animation-composition",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-range",
  "animation-range-end",
  "animation-range-start",
  "animation-timeline",
  "animation-timing-function",
  "appearance",
  "aspect-ratio",
  "backdrop-filter",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-position-x",
  "background-position-y",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-align",
  "box-decoration-break",
  "box-direction",
  "box-flex",
  "box-flex-group",
  "box-lines",
  "box-ordinal-group",
  "box-orient",
  "box-pack",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "cx",
  "cy",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "field-sizing",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flood-color",
  "flood-opacity",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "font-smooth",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-position",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphenate-character",
  "hyphenate-limit-chars",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "initial-letter",
  "initial-letter-align",
  "inline-size",
  "inset",
  "inset-area",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "justify-content",
  "justify-items",
  "justify-self",
  "kerning",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "line-height-step",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "masonry-auto-flow",
  "math-depth",
  "math-shift",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "overlay",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "place-content",
  "place-items",
  "place-self",
  "pointer-events",
  "position",
  "position-anchor",
  "position-visibility",
  "print-color-adjust",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "ruby-align",
  "ruby-position",
  "scale",
  "scroll-behavior",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scroll-timeline",
  "scroll-timeline-axis",
  "scroll-timeline-name",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-anchor",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-size-adjust",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "text-wrap",
  "text-wrap-mode",
  "text-wrap-style",
  "timeline-scope",
  "top",
  "touch-action",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-behavior",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "user-modify",
  "user-select",
  "vector-effect",
  "vertical-align",
  "view-timeline",
  "view-timeline-axis",
  "view-timeline-inset",
  "view-timeline-name",
  "view-transition-name",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "white-space-collapse",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
].sort().reverse(), F1e = p7.concat(h7).sort().reverse();
function V1e(n) {
  const e = R1e(n), t = F1e, r = "and or not only", i = "[\\w-]+", a = "(" + i + "|@\\{" + i + "\\})", o = [], s = [], l = function(b) {
    return {
      // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
      className: "string",
      begin: "~?" + b + ".*?" + b
    };
  }, u = function(b, _, x) {
    return {
      className: b,
      begin: _,
      relevance: x
    };
  }, c = {
    $pattern: /[a-z-]+/,
    keyword: r,
    attribute: $1e.join(" ")
  }, d = {
    // used only to properly balance nested parens inside mixin call, def. arg list
    begin: "\\(",
    end: "\\)",
    contains: s,
    keywords: c,
    relevance: 0
  };
  s.push(
    n.C_LINE_COMMENT_MODE,
    n.C_BLOCK_COMMENT_MODE,
    l("'"),
    l('"'),
    e.CSS_NUMBER_MODE,
    // fixme: it does not include dot for numbers like .5em :(
    {
      begin: "(url|data-uri)\\(",
      starts: {
        className: "string",
        end: "[\\)\\n]",
        excludeEnd: !0
      }
    },
    e.HEXCOLOR,
    d,
    u("variable", "@@?" + i, 10),
    u("variable", "@\\{" + i + "\\}"),
    u("built_in", "~?`[^`]*?`"),
    // inline javascript (or whatever host language) *multiline* string
    {
      // @media features (it’s here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
      className: "attribute",
      begin: i + "\\s*:",
      end: ":",
      returnBegin: !0,
      excludeEnd: !0
    },
    e.IMPORTANT,
    { beginKeywords: "and not" },
    e.FUNCTION_DISPATCH
  );
  const f = s.concat({
    begin: /\{/,
    end: /\}/,
    contains: o
  }), p = {
    beginKeywords: "when",
    endsWithParent: !0,
    contains: [{ beginKeywords: "and not" }].concat(s)
    // using this form to override VALUE’s 'function' match
  }, h = {
    begin: a + "\\s*:",
    returnBegin: !0,
    end: /[;}]/,
    relevance: 0,
    contains: [
      { begin: /-(webkit|moz|ms|o)-/ },
      e.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + z1e.join("|") + ")\\b",
        end: /(?=:)/,
        starts: {
          endsWithParent: !0,
          illegal: "[<=$]",
          relevance: 0,
          contains: s
        }
      }
    ]
  }, v = {
    className: "keyword",
    begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
    starts: {
      end: "[;{}]",
      keywords: c,
      returnEnd: !0,
      contains: s,
      relevance: 0
    }
  }, m = {
    className: "variable",
    variants: [
      // using more strict pattern for higher relevance to increase chances of Less detection.
      // this is *the only* Less specific statement used in most of the sources, so...
      // (we’ll still often loose to the css-parser unless there's '//' comment,
      // simply because 1 variable just can't beat 99 properties :)
      {
        begin: "@" + i + "\\s*:",
        relevance: 15
      },
      { begin: "@" + i }
    ],
    starts: {
      end: "[;}]",
      returnEnd: !0,
      contains: f
    }
  }, g = {
    // first parse unambiguous selectors (i.e. those not starting with tag)
    // then fall into the scary lookahead-discriminator variant.
    // this mode also handles mixin definitions and calls
    variants: [
      {
        begin: "[\\.#:&\\[>]",
        end: "[;{}]"
        // mixin calls end with ';'
      },
      {
        begin: a,
        end: /\{/
      }
    ],
    returnBegin: !0,
    returnEnd: !0,
    illegal: `[<='$"]`,
    relevance: 0,
    contains: [
      n.C_LINE_COMMENT_MODE,
      n.C_BLOCK_COMMENT_MODE,
      p,
      u("keyword", "all\\b"),
      u("variable", "@\\{" + i + "\\}"),
      // otherwise it’s identified as tag
      {
        begin: "\\b(" + B1e.join("|") + ")\\b",
        className: "selector-tag"
      },
      e.CSS_NUMBER_MODE,
      u("selector-tag", a, 0),
      u("selector-id", "#" + a),
      u("selector-class", "\\." + a, 0),
      u("selector-tag", "&", 0),
      e.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        begin: ":(" + p7.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + h7.join("|") + ")"
      },
      {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        contains: f
      },
      // argument list of parametric mixins
      { begin: "!important" },
      // eat !important after mixin call or it will be colored as tag
      e.FUNCTION_DISPATCH
    ]
  }, y = {
    begin: i + `:(:)?(${t.join("|")})`,
    returnBegin: !0,
    contains: [g]
  };
  return o.push(
    n.C_LINE_COMMENT_MODE,
    n.C_BLOCK_COMMENT_MODE,
    v,
    m,
    y,
    h,
    g,
    p,
    e.FUNCTION_DISPATCH
  ), {
    name: "Less",
    case_insensitive: !0,
    illegal: `[=>'/<($"]`,
    contains: o
  };
}
function H1e(n) {
  const e = "\\[=*\\[", t = "\\]=*\\]", r = {
    begin: e,
    end: t,
    contains: ["self"]
  }, i = [
    n.COMMENT("--(?!" + e + ")", "$"),
    n.COMMENT(
      "--" + e,
      t,
      {
        contains: [r],
        relevance: 10
      }
    )
  ];
  return {
    name: "Lua",
    aliases: ["pluto"],
    keywords: {
      $pattern: n.UNDERSCORE_IDENT_RE,
      literal: "true false nil",
      keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
      built_in: (
        // Metatags and globals:
        "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
      )
    },
    contains: i.concat([
      {
        className: "function",
        beginKeywords: "function",
        end: "\\)",
        contains: [
          n.inherit(n.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
          {
            className: "params",
            begin: "\\(",
            endsWithParent: !0,
            contains: i
          }
        ].concat(i)
      },
      n.C_NUMBER_MODE,
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      {
        className: "string",
        begin: e,
        end: t,
        contains: [r],
        relevance: 5
      }
    ])
  };
}
function G1e(n) {
  const e = {
    className: "variable",
    variants: [
      {
        begin: "\\$\\(" + n.UNDERSCORE_IDENT_RE + "\\)",
        contains: [n.BACKSLASH_ESCAPE]
      },
      { begin: /\$[@%<?\^\+\*]/ }
    ]
  }, t = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      n.BACKSLASH_ESCAPE,
      e
    ]
  }, r = {
    className: "variable",
    begin: /\$\([\w-]+\s/,
    end: /\)/,
    keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
    contains: [
      e,
      t
      // Added QUOTE_STRING as they can be a part of functions
    ]
  }, i = { begin: "^" + n.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, a = {
    className: "meta",
    begin: /^\.PHONY:/,
    end: /$/,
    keywords: {
      $pattern: /[\.\w]+/,
      keyword: ".PHONY"
    }
  }, o = {
    className: "section",
    begin: /^[^\s]+:/,
    end: /$/,
    contains: [e]
  };
  return {
    name: "Makefile",
    aliases: [
      "mk",
      "mak",
      "make"
    ],
    keywords: {
      $pattern: /[\w-]+/,
      keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
    },
    contains: [
      n.HASH_COMMENT_MODE,
      e,
      t,
      r,
      i,
      a,
      o
    ]
  };
}
function U1e(n) {
  const e = n.regex, t = {
    begin: /<\/?[A-Za-z_]/,
    end: ">",
    subLanguage: "xml",
    relevance: 0
  }, r = {
    begin: "^[-\\*]{3,}",
    end: "$"
  }, i = {
    className: "code",
    variants: [
      // TODO: fix to allow these to work with sublanguage also
      { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
      { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
      // needed to allow markdown as a sublanguage to work
      {
        begin: "```",
        end: "```+[ ]*$"
      },
      {
        begin: "~~~",
        end: "~~~+[ ]*$"
      },
      { begin: "`.+?`" },
      {
        begin: "(?=^( {4}|\\t))",
        // use contains to gobble up multiple lines to allow the block to be whatever size
        // but only have a single open/close tag vs one per line
        contains: [
          {
            begin: "^( {4}|\\t)",
            end: "(\\n)$"
          }
        ],
        relevance: 0
      }
    ]
  }, a = {
    className: "bullet",
    begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
    end: "\\s+",
    excludeEnd: !0
  }, o = {
    begin: /^\[[^\n]+\]:/,
    returnBegin: !0,
    contains: [
      {
        className: "symbol",
        begin: /\[/,
        end: /\]/,
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "link",
        begin: /:\s*/,
        end: /$/,
        excludeBegin: !0
      }
    ]
  }, s = /[A-Za-z][A-Za-z0-9+.-]*/, l = {
    variants: [
      // too much like nested array access in so many languages
      // to have any real relevance
      {
        begin: /\[.+?\]\[.*?\]/,
        relevance: 0
      },
      // popular internet URLs
      {
        begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
        relevance: 2
      },
      {
        begin: e.concat(/\[.+?\]\(/, s, /:\/\/.*?\)/),
        relevance: 2
      },
      // relative urls
      {
        begin: /\[.+?\]\([./?&#].*?\)/,
        relevance: 1
      },
      // whatever else, lower relevance (might not be a link at all)
      {
        begin: /\[.*?\]\(.*?\)/,
        relevance: 0
      }
    ],
    returnBegin: !0,
    contains: [
      {
        // empty strings for alt or link text
        match: /\[(?=\])/
      },
      {
        className: "string",
        relevance: 0,
        begin: "\\[",
        end: "\\]",
        excludeBegin: !0,
        returnEnd: !0
      },
      {
        className: "link",
        relevance: 0,
        begin: "\\]\\(",
        end: "\\)",
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "symbol",
        relevance: 0,
        begin: "\\]\\[",
        end: "\\]",
        excludeBegin: !0,
        excludeEnd: !0
      }
    ]
  }, u = {
    className: "strong",
    contains: [],
    // defined later
    variants: [
      {
        begin: /_{2}(?!\s)/,
        end: /_{2}/
      },
      {
        begin: /\*{2}(?!\s)/,
        end: /\*{2}/
      }
    ]
  }, c = {
    className: "emphasis",
    contains: [],
    // defined later
    variants: [
      {
        begin: /\*(?![*\s])/,
        end: /\*/
      },
      {
        begin: /_(?![_\s])/,
        end: /_/,
        relevance: 0
      }
    ]
  }, d = n.inherit(u, { contains: [] }), f = n.inherit(c, { contains: [] });
  u.contains.push(f), c.contains.push(d);
  let p = [
    t,
    l
  ];
  return [
    u,
    c,
    d,
    f
  ].forEach((g) => {
    g.contains = g.contains.concat(p);
  }), p = p.concat(u, c), {
    name: "Markdown",
    aliases: [
      "md",
      "mkdown",
      "mkd"
    ],
    contains: [
      {
        className: "section",
        variants: [
          {
            begin: "^#{1,6}",
            end: "$",
            contains: p
          },
          {
            begin: "(?=^.+?\\n[=-]{2,}$)",
            contains: [
              { begin: "^[=-]*$" },
              {
                begin: "^",
                end: "\\n",
                contains: p
              }
            ]
          }
        ]
      },
      t,
      a,
      u,
      c,
      {
        className: "quote",
        begin: "^>\\s+",
        contains: p,
        end: "$"
      },
      i,
      r,
      l,
      o,
      {
        //https://spec.commonmark.org/0.31.2/#entity-references
        scope: "literal",
        match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/
      }
    ]
  };
}
function W1e(n) {
  const e = {
    className: "built_in",
    begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
  }, t = /[a-zA-Z@][a-zA-Z0-9_]*/, s = {
    "variable.language": [
      "this",
      "super"
    ],
    $pattern: t,
    keyword: [
      "while",
      "export",
      "sizeof",
      "typedef",
      "const",
      "struct",
      "for",
      "union",
      "volatile",
      "static",
      "mutable",
      "if",
      "do",
      "return",
      "goto",
      "enum",
      "else",
      "break",
      "extern",
      "asm",
      "case",
      "default",
      "register",
      "explicit",
      "typename",
      "switch",
      "continue",
      "inline",
      "readonly",
      "assign",
      "readwrite",
      "self",
      "@synchronized",
      "id",
      "typeof",
      "nonatomic",
      "IBOutlet",
      "IBAction",
      "strong",
      "weak",
      "copy",
      "in",
      "out",
      "inout",
      "bycopy",
      "byref",
      "oneway",
      "__strong",
      "__weak",
      "__block",
      "__autoreleasing",
      "@private",
      "@protected",
      "@public",
      "@try",
      "@property",
      "@end",
      "@throw",
      "@catch",
      "@finally",
      "@autoreleasepool",
      "@synthesize",
      "@dynamic",
      "@selector",
      "@optional",
      "@required",
      "@encode",
      "@package",
      "@import",
      "@defs",
      "@compatibility_alias",
      "__bridge",
      "__bridge_transfer",
      "__bridge_retained",
      "__bridge_retain",
      "__covariant",
      "__contravariant",
      "__kindof",
      "_Nonnull",
      "_Nullable",
      "_Null_unspecified",
      "__FUNCTION__",
      "__PRETTY_FUNCTION__",
      "__attribute__",
      "getter",
      "setter",
      "retain",
      "unsafe_unretained",
      "nonnull",
      "nullable",
      "null_unspecified",
      "null_resettable",
      "class",
      "instancetype",
      "NS_DESIGNATED_INITIALIZER",
      "NS_UNAVAILABLE",
      "NS_REQUIRES_SUPER",
      "NS_RETURNS_INNER_POINTER",
      "NS_INLINE",
      "NS_AVAILABLE",
      "NS_DEPRECATED",
      "NS_ENUM",
      "NS_OPTIONS",
      "NS_SWIFT_UNAVAILABLE",
      "NS_ASSUME_NONNULL_BEGIN",
      "NS_ASSUME_NONNULL_END",
      "NS_REFINED_FOR_SWIFT",
      "NS_SWIFT_NAME",
      "NS_SWIFT_NOTHROW",
      "NS_DURING",
      "NS_HANDLER",
      "NS_ENDHANDLER",
      "NS_VALUERETURN",
      "NS_VOIDRETURN"
    ],
    literal: [
      "false",
      "true",
      "FALSE",
      "TRUE",
      "nil",
      "YES",
      "NO",
      "NULL"
    ],
    built_in: [
      "dispatch_once_t",
      "dispatch_queue_t",
      "dispatch_sync",
      "dispatch_async",
      "dispatch_once"
    ],
    type: [
      "int",
      "float",
      "char",
      "unsigned",
      "signed",
      "short",
      "long",
      "double",
      "wchar_t",
      "unichar",
      "void",
      "bool",
      "BOOL",
      "id|0",
      "_Bool"
    ]
  }, l = {
    $pattern: t,
    keyword: [
      "@interface",
      "@class",
      "@protocol",
      "@implementation"
    ]
  };
  return {
    name: "Objective-C",
    aliases: [
      "mm",
      "objc",
      "obj-c",
      "obj-c++",
      "objective-c++"
    ],
    keywords: s,
    illegal: "</",
    contains: [
      e,
      n.C_LINE_COMMENT_MODE,
      n.C_BLOCK_COMMENT_MODE,
      n.C_NUMBER_MODE,
      n.QUOTE_STRING_MODE,
      n.APOS_STRING_MODE,
      {
        className: "string",
        variants: [
          {
            begin: '@"',
            end: '"',
            illegal: "\\n",
            contains: [n.BACKSLASH_ESCAPE]
          }
        ]
      },
      {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          n.inherit(n.QUOTE_STRING_MODE, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/,
            end: /$/,
            illegal: "\\n"
          },
          n.C_LINE_COMMENT_MODE,
          n.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        className: "class",
        begin: "(" + l.keyword.join("|") + ")\\b",
        end: /(\{|$)/,
        excludeEnd: !0,
        keywords: l,
        contains: [n.UNDERSCORE_TITLE_MODE]
      },
      {
        begin: "\\." + n.UNDERSCORE_IDENT_RE,
        relevance: 0
      }
    ]
  };
}
function q1e(n) {
  const e = n.regex, t = [
    "abs",
    "accept",
    "alarm",
    "and",
    "atan2",
    "bind",
    "binmode",
    "bless",
    "break",
    "caller",
    "chdir",
    "chmod",
    "chomp",
    "chop",
    "chown",
    "chr",
    "chroot",
    "class",
    "close",
    "closedir",
    "connect",
    "continue",
    "cos",
    "crypt",
    "dbmclose",
    "dbmopen",
    "defined",
    "delete",
    "die",
    "do",
    "dump",
    "each",
    "else",
    "elsif",
    "endgrent",
    "endhostent",
    "endnetent",
    "endprotoent",
    "endpwent",
    "endservent",
    "eof",
    "eval",
    "exec",
    "exists",
    "exit",
    "exp",
    "fcntl",
    "field",
    "fileno",
    "flock",
    "for",
    "foreach",
    "fork",
    "format",
    "formline",
    "getc",
    "getgrent",
    "getgrgid",
    "getgrnam",
    "gethostbyaddr",
    "gethostbyname",
    "gethostent",
    "getlogin",
    "getnetbyaddr",
    "getnetbyname",
    "getnetent",
    "getpeername",
    "getpgrp",
    "getpriority",
    "getprotobyname",
    "getprotobynumber",
    "getprotoent",
    "getpwent",
    "getpwnam",
    "getpwuid",
    "getservbyname",
    "getservbyport",
    "getservent",
    "getsockname",
    "getsockopt",
    "given",
    "glob",
    "gmtime",
    "goto",
    "grep",
    "gt",
    "hex",
    "if",
    "index",
    "int",
    "ioctl",
    "join",
    "keys",
    "kill",
    "last",
    "lc",
    "lcfirst",
    "length",
    "link",
    "listen",
    "local",
    "localtime",
    "log",
    "lstat",
    "lt",
    "ma",
    "map",
    "method",
    "mkdir",
    "msgctl",
    "msgget",
    "msgrcv",
    "msgsnd",
    "my",
    "ne",
    "next",
    "no",
    "not",
    "oct",
    "open",
    "opendir",
    "or",
    "ord",
    "our",
    "pack",
    "package",
    "pipe",
    "pop",
    "pos",
    "print",
    "printf",
    "prototype",
    "push",
    "q|0",
    "qq",
    "quotemeta",
    "qw",
    "qx",
    "rand",
    "read",
    "readdir",
    "readline",
    "readlink",
    "readpipe",
    "recv",
    "redo",
    "ref",
    "rename",
    "require",
    "reset",
    "return",
    "reverse",
    "rewinddir",
    "rindex",
    "rmdir",
    "say",
    "scalar",
    "seek",
    "seekdir",
    "select",
    "semctl",
    "semget",
    "semop",
    "send",
    "setgrent",
    "sethostent",
    "setnetent",
    "setpgrp",
    "setpriority",
    "setprotoent",
    "setpwent",
    "setservent",
    "setsockopt",
    "shift",
    "shmctl",
    "shmget",
    "shmread",
    "shmwrite",
    "shutdown",
    "sin",
    "sleep",
    "socket",
    "socketpair",
    "sort",
    "splice",
    "split",
    "sprintf",
    "sqrt",
    "srand",
    "stat",
    "state",
    "study",
    "sub",
    "substr",
    "symlink",
    "syscall",
    "sysopen",
    "sysread",
    "sysseek",
    "system",
    "syswrite",
    "tell",
    "telldir",
    "tie",
    "tied",
    "time",
    "times",
    "tr",
    "truncate",
    "uc",
    "ucfirst",
    "umask",
    "undef",
    "unless",
    "unlink",
    "unpack",
    "unshift",
    "untie",
    "until",
    "use",
    "utime",
    "values",
    "vec",
    "wait",
    "waitpid",
    "wantarray",
    "warn",
    "when",
    "while",
    "write",
    "x|0",
    "xor",
    "y|0"
  ], r = /[dualxmsipngr]{0,12}/, i = {
    $pattern: /[\w.]+/,
    keyword: t.join(" ")
  }, a = {
    className: "subst",
    begin: "[$@]\\{",
    end: "\\}",
    keywords: i
  }, o = {
    begin: /->\{/,
    end: /\}/
    // contains defined later
  }, s = {
    scope: "attr",
    match: /\s+:\s*\w+(\s*\(.*?\))?/
  }, l = {
    scope: "variable",
    variants: [
      { begin: /\$\d/ },
      {
        begin: e.concat(
          /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
          // negative look-ahead tries to avoid matching patterns that are not
          // Perl at all like $ident$, @ident@, etc.
          "(?![A-Za-z])(?![@$%])"
        )
      },
      {
        // Only $= is a special Perl variable and one can't declare @= or %=.
        begin: /[$%@](?!")[^\s\w{=]|\$=/,
        relevance: 0
      }
    ],
    contains: [s]
  }, u = {
    className: "number",
    variants: [
      // decimal numbers:
      // include the case where a number starts with a dot (eg. .9), and
      // the leading 0? avoids mixing the first and second match on 0.x cases
      { match: /0?\.[0-9][0-9_]+\b/ },
      // include the special versioned number (eg. v5.38)
      { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
      // non-decimal numbers:
      { match: /\b0[0-7][0-7_]*\b/ },
      { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
      { match: /\b0b[0-1][0-1_]*\b/ }
    ],
    relevance: 0
  }, c = [
    n.BACKSLASH_ESCAPE,
    a,
    l
  ], d = [
    /!/,
    /\//,
    /\|/,
    /\?/,
    /'/,
    /"/,
    // valid but infrequent and weird
    /#/
    // valid but infrequent and weird
  ], f = (v, m, g = "\\1") => {
    const y = g === "\\1" ? g : e.concat(g, m);
    return e.concat(
      e.concat("(?:", v, ")"),
      m,
      /(?:\\.|[^\\\/])*?/,
      y,
      /(?:\\.|[^\\\/])*?/,
      g,
      r
    );
  }, p = (v, m, g) => e.concat(
    e.concat("(?:", v, ")"),
    m,
    /(?:\\.|[^\\\/])*?/,
    g,
    r
  ), h = [
    l,
    n.HASH_COMMENT_MODE,
    n.COMMENT(
      /^=\w/,
      /=cut/,
      { endsWithParent: !0 }
    ),
    o,
    {
      className: "string",
      contains: c,
      variants: [
        {
          begin: "q[qwxr]?\\s*\\(",
          end: "\\)",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\[",
          end: "\\]",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\{",
          end: "\\}",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\|",
          end: "\\|",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*<",
          end: ">",
          relevance: 5
        },
        {
          begin: "qw\\s+q",
          end: "q",
          relevance: 5
        },
        {
          begin: "'",
          end: "'",
          contains: [n.BACKSLASH_ESCAPE]
        },
        {
          begin: '"',
          end: '"'
        },
        {
          begin: "`",
          end: "`",
          contains: [n.BACKSLASH_ESCAPE]
        },
        {
          begin: /\{\w+\}/,
          relevance: 0
        },
        {
          begin: "-?\\w+\\s*=>",
          relevance: 0
        }
      ]
    },
    u,
    {
      // regexp container
      begin: "(\\/\\/|" + n.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
      keywords: "split return print reverse grep",
      relevance: 0,
      contains: [
        n.HASH_COMMENT_MODE,
        {
          className: "regexp",
          variants: [
            // allow matching common delimiters
            { begin: f("s|tr|y", e.either(...d, { capture: !0 })) },
            // and then paired delmis
            { begin: f("s|tr|y", "\\(", "\\)") },
            { begin: f("s|tr|y", "\\[", "\\]") },
            { begin: f("s|tr|y", "\\{", "\\}") }
          ],
          relevance: 2
        },
        {
          className: "regexp",
          variants: [
            {
              // could be a comment in many languages so do not count
              // as relevant
              begin: /(m|qr)\/\//,
              relevance: 0
            },
            // prefix is optional with /regex/
            { begin: p("(?:m|qr)?", /\//, /\//) },
            // allow matching common delimiters
            { begin: p("m|qr", e.either(...d, { capture: !0 }), /\1/) },
            // allow common paired delmins
            { begin: p("m|qr", /\(/, /\)/) },
            { begin: p("m|qr", /\[/, /\]/) },
            { begin: p("m|qr", /\{/, /\}/) }
          ]
        }
      ]
    },
    {
      className: "function",
      beginKeywords: "sub method",
      end: "(\\s*\\(.*?\\))?[;{]",
      excludeEnd: !0,
      relevance: 5,
      contains: [n.TITLE_MODE, s]
    },
    {
      className: "class",
      beginKeywords: "class",
      end: "[;{]",
      excludeEnd: !0,
      relevance: 5,
      contains: [n.TITLE_MODE, s, u]
    },
    {
      begin: "-\\w\\b",
      relevance: 0
    },
    {
      begin: "^__DATA__$",
      end: "^__END__$",
      subLanguage: "mojolicious",
      contains: [
        {
          begin: "^@@.*",
          end: "$",
          className: "comment"
        }
      ]
    }
  ];
  return a.contains = h, o.contains = h, {
    name: "Perl",
    aliases: [
      "pl",
      "pm"
    ],
    keywords: i,
    contains: h
  };
}
function Y1e(n) {
  const e = n.regex, t = /(?![A-Za-z0-9])(?![$])/, r = e.concat(
    /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
    t
  ), i = e.concat(
    /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
    t
  ), a = e.concat(
    /[A-Z]+/,
    t
  ), o = {
    scope: "variable",
    match: "\\$+" + r
  }, s = {
    scope: "meta",
    variants: [
      { begin: /<\?php/, relevance: 10 },
      // boost for obvious PHP
      { begin: /<\?=/ },
      // less relevant per PSR-1 which says not to use short-tags
      { begin: /<\?/, relevance: 0.1 },
      { begin: /\?>/ }
      // end php tag
    ]
  }, l = {
    scope: "subst",
    variants: [
      { begin: /\$\w+/ },
      {
        begin: /\{\$/,
        end: /\}/
      }
    ]
  }, u = n.inherit(n.APOS_STRING_MODE, { illegal: null }), c = n.inherit(n.QUOTE_STRING_MODE, {
    illegal: null,
    contains: n.QUOTE_STRING_MODE.contains.concat(l)
  }), d = {
    begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
    end: /[ \t]*(\w+)\b/,
    contains: n.QUOTE_STRING_MODE.contains.concat(l),
    "on:begin": (j, z) => {
      z.data._beginMatch = j[1] || j[2];
    },
    "on:end": (j, z) => {
      z.data._beginMatch !== j[1] && z.ignoreMatch();
    }
  }, f = n.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*'(\w+)'\n/,
    end: /[ \t]*(\w+)\b/
  }), p = `[ 	
]`, h = {
    scope: "string",
    variants: [
      c,
      u,
      d,
      f
    ]
  }, v = {
    scope: "number",
    variants: [
      { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
      // Binary w/ underscore support
      { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
      // Octals w/ underscore support
      { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
      // Hex w/ underscore support
      // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
      { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
    ],
    relevance: 0
  }, m = [
    "false",
    "null",
    "true"
  ], g = [
    // Magic constants:
    // <https://www.php.net/manual/en/language.constants.predefined.php>
    "__CLASS__",
    "__DIR__",
    "__FILE__",
    "__FUNCTION__",
    "__COMPILER_HALT_OFFSET__",
    "__LINE__",
    "__METHOD__",
    "__NAMESPACE__",
    "__TRAIT__",
    // Function that look like language construct or language construct that look like function:
    // List of keywords that may not require parenthesis
    "die",
    "echo",
    "exit",
    "include",
    "include_once",
    "print",
    "require",
    "require_once",
    // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
    // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
    // Other keywords:
    // <https://www.php.net/manual/en/reserved.php>
    // <https://www.php.net/manual/en/language.types.type-juggling.php>
    "array",
    "abstract",
    "and",
    "as",
    "binary",
    "bool",
    "boolean",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "double",
    "else",
    "elseif",
    "empty",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "eval",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "foreach",
    "from",
    "global",
    "goto",
    "if",
    "implements",
    "instanceof",
    "insteadof",
    "int",
    "integer",
    "interface",
    "isset",
    "iterable",
    "list",
    "match|0",
    "mixed",
    "new",
    "never",
    "object",
    "or",
    "private",
    "protected",
    "public",
    "readonly",
    "real",
    "return",
    "string",
    "switch",
    "throw",
    "trait",
    "try",
    "unset",
    "use",
    "var",
    "void",
    "while",
    "xor",
    "yield"
  ], y = [
    // Standard PHP library:
    // <https://www.php.net/manual/en/book.spl.php>
    "Error|0",
    "AppendIterator",
    "ArgumentCountError",
    "ArithmeticError",
    "ArrayIterator",
    "ArrayObject",
    "AssertionError",
    "BadFunctionCallException",
    "BadMethodCallException",
    "CachingIterator",
    "CallbackFilterIterator",
    "CompileError",
    "Countable",
    "DirectoryIterator",
    "DivisionByZeroError",
    "DomainException",
    "EmptyIterator",
    "ErrorException",
    "Exception",
    "FilesystemIterator",
    "FilterIterator",
    "GlobIterator",
    "InfiniteIterator",
    "InvalidArgumentException",
    "IteratorIterator",
    "LengthException",
    "LimitIterator",
    "LogicException",
    "MultipleIterator",
    "NoRewindIterator",
    "OutOfBoundsException",
    "OutOfRangeException",
    "OuterIterator",
    "OverflowException",
    "ParentIterator",
    "ParseError",
    "RangeException",
    "RecursiveArrayIterator",
    "RecursiveCachingIterator",
    "RecursiveCallbackFilterIterator",
    "RecursiveDirectoryIterator",
    "RecursiveFilterIterator",
    "RecursiveIterator",
    "RecursiveIteratorIterator",
    "RecursiveRegexIterator",
    "RecursiveTreeIterator",
    "RegexIterator",
    "RuntimeException",
    "SeekableIterator",
    "SplDoublyLinkedList",
    "SplFileInfo",
    "SplFileObject",
    "SplFixedArray",
    "SplHeap",
    "SplMaxHeap",
    "SplMinHeap",
    "SplObjectStorage",
    "SplObserver",
    "SplPriorityQueue",
    "SplQueue",
    "SplStack",
    "SplSubject",
    "SplTempFileObject",
    "TypeError",
    "UnderflowException",
    "UnexpectedValueException",
    "UnhandledMatchError",
    // Reserved interfaces:
    // <https://www.php.net/manual/en/reserved.interfaces.php>
    "ArrayAccess",
    "BackedEnum",
    "Closure",
    "Fiber",
    "Generator",
    "Iterator",
    "IteratorAggregate",
    "Serializable",
    "Stringable",
    "Throwable",
    "Traversable",
    "UnitEnum",
    "WeakReference",
    "WeakMap",
    // Reserved classes:
    // <https://www.php.net/manual/en/reserved.classes.php>
    "Directory",
    "__PHP_Incomplete_Class",
    "parent",
    "php_user_filter",
    "self",
    "static",
    "stdClass"
  ], _ = {
    keyword: g,
    literal: ((j) => {
      const z = [];
      return j.forEach((F) => {
        z.push(F), F.toLowerCase() === F ? z.push(F.toUpperCase()) : z.push(F.toLowerCase());
      }), z;
    })(m),
    built_in: y
  }, x = (j) => j.map((z) => z.replace(/\|\d+$/, "")), w = { variants: [
    {
      match: [
        /new/,
        e.concat(p, "+"),
        // to prevent built ins from being confused as the class constructor call
        e.concat("(?!", x(y).join("\\b|"), "\\b)"),
        i
      ],
      scope: {
        1: "keyword",
        4: "title.class"
      }
    }
  ] }, S = e.concat(r, "\\b(?!\\()"), C = { variants: [
    {
      match: [
        e.concat(
          /::/,
          e.lookahead(/(?!class\b)/)
        ),
        S
      ],
      scope: { 2: "variable.constant" }
    },
    {
      match: [
        /::/,
        /class/
      ],
      scope: { 2: "variable.language" }
    },
    {
      match: [
        i,
        e.concat(
          /::/,
          e.lookahead(/(?!class\b)/)
        ),
        S
      ],
      scope: {
        1: "title.class",
        3: "variable.constant"
      }
    },
    {
      match: [
        i,
        e.concat(
          "::",
          e.lookahead(/(?!class\b)/)
        )
      ],
      scope: { 1: "title.class" }
    },
    {
      match: [
        i,
        /::/,
        /class/
      ],
      scope: {
        1: "title.class",
        3: "variable.language"
      }
    }
  ] }, k = {
    scope: "attr",
    match: e.concat(r, e.lookahead(":"), e.lookahead(/(?!::)/))
  }, M = {
    relevance: 0,
    begin: /\(/,
    end: /\)/,
    keywords: _,
    contains: [
      k,
      o,
      C,
      n.C_BLOCK_COMMENT_MODE,
      h,
      v,
      w
    ]
  }, D = {
    relevance: 0,
    match: [
      /\b/,
      // to prevent keywords from being confused as the function title
      e.concat("(?!fn\\b|function\\b|", x(g).join("\\b|"), "|", x(y).join("\\b|"), "\\b)"),
      r,
      e.concat(p, "*"),
      e.lookahead(/(?=\()/)
    ],
    scope: { 3: "title.function.invoke" },
    contains: [M]
  };
  M.contains.push(D);
  const N = [
    k,
    C,
    n.C_BLOCK_COMMENT_MODE,
    h,
    v,
    w
  ], R = {
    begin: e.concat(
      /#\[\s*\\?/,
      e.either(
        i,
        a
      )
    ),
    beginScope: "meta",
    end: /]/,
    endScope: "meta",
    keywords: {
      literal: m,
      keyword: [
        "new",
        "array"
      ]
    },
    contains: [
      {
        begin: /\[/,
        end: /]/,
        keywords: {
          literal: m,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          "self",
          ...N
        ]
      },
      ...N,
      {
        scope: "meta",
        variants: [
          { match: i },
          { match: a }
        ]
      }
    ]
  };
  return {
    case_insensitive: !1,
    keywords: _,
    contains: [
      R,
      n.HASH_COMMENT_MODE,
      n.COMMENT("//", "$"),
      n.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [
          {
            scope: "doctag",
            match: "@[A-Za-z]+"
          }
        ] }
      ),
      {
        match: /__halt_compiler\(\);/,
        keywords: "__halt_compiler",
        starts: {
          scope: "comment",
          end: n.MATCH_NOTHING_RE,
          contains: [
            {
              match: /\?>/,
              scope: "meta",
              endsParent: !0
            }
          ]
        }
      },
      s,
      {
        scope: "variable.language",
        match: /\$this\b/
      },
      o,
      D,
      C,
      {
        match: [
          /const/,
          /\s/,
          r
        ],
        scope: {
          1: "keyword",
          3: "variable.constant"
        }
      },
      w,
      {
        scope: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: !0,
        illegal: "[$%\\[]",
        contains: [
          { beginKeywords: "use" },
          n.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            // No markup, just a relevance booster
            endsParent: !0
          },
          {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: _,
            contains: [
              "self",
              R,
              o,
              C,
              n.C_BLOCK_COMMENT_MODE,
              h,
              v
            ]
          }
        ]
      },
      {
        scope: "class",
        variants: [
          {
            beginKeywords: "enum",
            illegal: /[($"]/
          },
          {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: !0,
        contains: [
          { beginKeywords: "extends implements" },
          n.UNDERSCORE_TITLE_MODE
        ]
      },
      // both use and namespace still use "old style" rules (vs multi-match)
      // because the namespace name can include `\` and we still want each
      // element to be treated as its own *individual* title
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [n.inherit(n.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [
          // TODO: title.function vs title.class
          {
            match: /\b(as|const|function)\b/,
            scope: "keyword"
          },
          // TODO: could be title.class or title.function
          n.UNDERSCORE_TITLE_MODE
        ]
      },
      h,
      v
    ]
  };
}
function K1e(n) {
  return {
    name: "PHP template",
    subLanguage: "xml",
    contains: [
      {
        begin: /<\?(php|=)?/,
        end: /\?>/,
        subLanguage: "php",
        contains: [
          // We don't want the php closing tag ?> to close the PHP block when
          // inside any of the following blocks:
          {
            begin: "/\\*",
            end: "\\*/",
            skip: !0
          },
          {
            begin: 'b"',
            end: '"',
            skip: !0
          },
          {
            begin: "b'",
            end: "'",
            skip: !0
          },
          n.inherit(n.APOS_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          }),
          n.inherit(n.QUOTE_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          })
        ]
      }
    ]
  };
}
function X1e(n) {
  return {
    name: "Plain text",
    aliases: [
      "text",
      "txt"
    ],
    disableAutodetect: !0
  };
}
function Z1e(n) {
  const e = n.regex, t = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), r = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], s = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: r,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, l = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, u = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: s,
    illegal: /#/
  }, c = {
    begin: /\{\{/,
    relevance: 0
  }, d = {
    className: "string",
    contains: [n.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          l,
          c,
          u
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          l,
          c,
          u
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          n.BACKSLASH_ESCAPE,
          c,
          u
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          n.BACKSLASH_ESCAPE,
          c,
          u
        ]
      },
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE
    ]
  }, f = "[0-9](_?[0-9])*", p = `(\\b(${f}))?\\.(${f})|\\b(${f})\\.`, h = `\\b|${r.join("|")}`, v = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${f})|(${p}))[eE][+-]?(${f})[jJ]?(?=${h})`
      },
      {
        begin: `(${p})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${h})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${h})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${h})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${h})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${f})[jJ](?=${h})`
      }
    ]
  }, m = {
    className: "comment",
    begin: e.lookahead(/# type:/),
    end: /$/,
    keywords: s,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: !0
      }
    ]
  }, g = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: !0
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: s,
        contains: [
          "self",
          l,
          v,
          d,
          n.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return u.contains = [
    d,
    v,
    l
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: !0,
    keywords: s,
    illegal: /(<\/|\?)|=>/,
    contains: [
      l,
      v,
      {
        // very common convention
        scope: "variable.language",
        match: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      { match: /\bor\b/, scope: "keyword" },
      d,
      m,
      n.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          t
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [g]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              t,
              /\s*/,
              /\(\s*/,
              t,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              t
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          v,
          g,
          d
        ]
      }
    ]
  };
}
function J1e(n) {
  return {
    aliases: ["pycon"],
    contains: [
      {
        className: "meta.prompt",
        starts: {
          // a space separates the REPL prefix from the actual code
          // this is purely for cleaner HTML output
          end: / |$/,
          starts: {
            end: "$",
            subLanguage: "python"
          }
        },
        variants: [
          { begin: /^>>>(?=[ ]|$)/ },
          { begin: /^\.\.\.(?=[ ]|$)/ }
        ]
      }
    ]
  };
}
function Q1e(n) {
  const e = n.regex, t = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, r = e.either(
    // Special case: only hexadecimal binary powers can contain fractions
    /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
    // Hexadecimal numbers without fraction and optional binary power
    /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
    // Decimal numbers
    /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
  ), i = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, a = e.either(
    /[()]/,
    /[{}]/,
    /\[\[/,
    /[[\]]/,
    /\\/,
    /,/
  );
  return {
    name: "R",
    keywords: {
      $pattern: t,
      keyword: "function if in break next repeat else for while",
      literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
      built_in: (
        // Builtin constants
        "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
      )
    },
    contains: [
      // Roxygen comments
      n.COMMENT(
        /#'/,
        /$/,
        { contains: [
          {
            // Handle `@examples` separately to cause all subsequent code
            // until the next `@`-tag on its own line to be kept as-is,
            // preventing highlighting. This code is example R code, so nested
            // doctags shouldn’t be treated as such. See
            // `test/markup/r/roxygen.txt` for an example.
            scope: "doctag",
            match: /@examples/,
            starts: {
              end: e.lookahead(e.either(
                // end if another doc comment
                /\n^#'\s*(?=@[a-zA-Z]+)/,
                // or a line with no comment
                /\n^(?!#')/
              )),
              endsParent: !0
            }
          },
          {
            // Handle `@param` to highlight the parameter name following
            // after.
            scope: "doctag",
            begin: "@param",
            end: /$/,
            contains: [
              {
                scope: "variable",
                variants: [
                  { match: t },
                  { match: /`(?:\\.|[^`\\])+`/ }
                ],
                endsParent: !0
              }
            ]
          },
          {
            scope: "doctag",
            match: /@[a-zA-Z]+/
          },
          {
            scope: "keyword",
            match: /\\[a-zA-Z]+/
          }
        ] }
      ),
      n.HASH_COMMENT_MODE,
      {
        scope: "string",
        contains: [n.BACKSLASH_ESCAPE],
        variants: [
          n.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\(/,
            end: /\)(-*)"/
          }),
          n.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\{/,
            end: /\}(-*)"/
          }),
          n.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\[/,
            end: /\](-*)"/
          }),
          n.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\(/,
            end: /\)(-*)'/
          }),
          n.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\{/,
            end: /\}(-*)'/
          }),
          n.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\[/,
            end: /\](-*)'/
          }),
          {
            begin: '"',
            end: '"',
            relevance: 0
          },
          {
            begin: "'",
            end: "'",
            relevance: 0
          }
        ]
      },
      // Matching numbers immediately following punctuation and operators is
      // tricky since we need to look at the character ahead of a number to
      // ensure the number is not part of an identifier, and we cannot use
      // negative look-behind assertions. So instead we explicitly handle all
      // possible combinations of (operator|punctuation), number.
      // TODO: replace with negative look-behind when available
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
      // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
      {
        relevance: 0,
        variants: [
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              i,
              r
            ]
          },
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              /%[^%]*%/,
              r
            ]
          },
          {
            scope: {
              1: "punctuation",
              2: "number"
            },
            match: [
              a,
              r
            ]
          },
          {
            scope: { 2: "number" },
            match: [
              /[^a-zA-Z0-9._]|^/,
              // not part of an identifier, or start of document
              r
            ]
          }
        ]
      },
      // Operators/punctuation when they're not directly followed by numbers
      {
        // Relevance boost for the most common assignment form.
        scope: { 3: "operator" },
        match: [
          t,
          /\s+/,
          /<-/,
          /\s+/
        ]
      },
      {
        scope: "operator",
        relevance: 0,
        variants: [
          { match: i },
          { match: /%[^%]*%/ }
        ]
      },
      {
        scope: "punctuation",
        relevance: 0,
        match: a
      },
      {
        // Escaped identifier
        begin: "`",
        end: "`",
        contains: [{ begin: /\\./ }]
      }
    ]
  };
}
function ebe(n) {
  const e = n.regex, t = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", r = e.either(
    /\b([A-Z]+[a-z0-9]+)+/,
    // ends in caps
    /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
  ), i = e.concat(r, /(::\w+)*/), o = {
    "variable.constant": [
      "__FILE__",
      "__LINE__",
      "__ENCODING__"
    ],
    "variable.language": [
      "self",
      "super"
    ],
    keyword: [
      "alias",
      "and",
      "begin",
      "BEGIN",
      "break",
      "case",
      "class",
      "defined",
      "do",
      "else",
      "elsif",
      "end",
      "END",
      "ensure",
      "for",
      "if",
      "in",
      "module",
      "next",
      "not",
      "or",
      "redo",
      "require",
      "rescue",
      "retry",
      "return",
      "then",
      "undef",
      "unless",
      "until",
      "when",
      "while",
      "yield",
      ...[
        "include",
        "extend",
        "prepend",
        "public",
        "private",
        "protected",
        "raise",
        "throw"
      ]
    ],
    built_in: [
      "proc",
      "lambda",
      "attr_accessor",
      "attr_reader",
      "attr_writer",
      "define_method",
      "private_constant",
      "module_function"
    ],
    literal: [
      "true",
      "false",
      "nil"
    ]
  }, s = {
    className: "doctag",
    begin: "@[A-Za-z]+"
  }, l = {
    begin: "#<",
    end: ">"
  }, u = [
    n.COMMENT(
      "#",
      "$",
      { contains: [s] }
    ),
    n.COMMENT(
      "^=begin",
      "^=end",
      {
        contains: [s],
        relevance: 10
      }
    ),
    n.COMMENT("^__END__", n.MATCH_NOTHING_RE)
  ], c = {
    className: "subst",
    begin: /#\{/,
    end: /\}/,
    keywords: o
  }, d = {
    className: "string",
    contains: [
      n.BACKSLASH_ESCAPE,
      c
    ],
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      {
        begin: /`/,
        end: /`/
      },
      {
        begin: /%[qQwWx]?\(/,
        end: /\)/
      },
      {
        begin: /%[qQwWx]?\[/,
        end: /\]/
      },
      {
        begin: /%[qQwWx]?\{/,
        end: /\}/
      },
      {
        begin: /%[qQwWx]?</,
        end: />/
      },
      {
        begin: /%[qQwWx]?\//,
        end: /\//
      },
      {
        begin: /%[qQwWx]?%/,
        end: /%/
      },
      {
        begin: /%[qQwWx]?-/,
        end: /-/
      },
      {
        begin: /%[qQwWx]?\|/,
        end: /\|/
      },
      // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
      // where ? is the last character of a preceding identifier, as in: `func?4`
      { begin: /\B\?(\\\d{1,3})/ },
      { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
      { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
      { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
      { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
      { begin: /\B\?\\?\S/ },
      // heredocs
      {
        // this guard makes sure that we have an entire heredoc and not a false
        // positive (auto-detect, etc.)
        begin: e.concat(
          /<<[-~]?'?/,
          e.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
        ),
        contains: [
          n.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            contains: [
              n.BACKSLASH_ESCAPE,
              c
            ]
          })
        ]
      }
    ]
  }, f = "[1-9](_?[0-9])*|0", p = "[0-9](_?[0-9])*", h = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal integer/float, optionally exponential or rational, optionally imaginary
      { begin: `\\b(${f})(\\.(${p}))?([eE][+-]?(${p})|r)?i?\\b` },
      // explicit decimal/binary/octal/hexadecimal integer,
      // optionally rational and/or imaginary
      { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
      // 0-prefixed implicit octal integer, optionally rational and/or imaginary
      { begin: "\\b0(_?[0-7])+r?i?\\b" }
    ]
  }, v = {
    variants: [
      {
        match: /\(\)/
      },
      {
        className: "params",
        begin: /\(/,
        end: /(?=\))/,
        excludeBegin: !0,
        endsParent: !0,
        keywords: o
      }
    ]
  }, w = [
    d,
    {
      variants: [
        {
          match: [
            /class\s+/,
            i,
            /\s+<\s+/,
            i
          ]
        },
        {
          match: [
            /\b(class|module)\s+/,
            i
          ]
        }
      ],
      scope: {
        2: "title.class",
        4: "title.class.inherited"
      },
      keywords: o
    },
    {
      match: [
        /(include|extend)\s+/,
        i
      ],
      scope: {
        2: "title.class"
      },
      keywords: o
    },
    {
      relevance: 0,
      match: [
        i,
        /\.new[. (]/
      ],
      scope: {
        1: "title.class"
      }
    },
    {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    },
    {
      relevance: 0,
      match: r,
      scope: "title.class"
    },
    {
      match: [
        /def/,
        /\s+/,
        t
      ],
      scope: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        v
      ]
    },
    {
      // swallow namespace qualifiers before symbols
      begin: n.IDENT_RE + "::"
    },
    {
      className: "symbol",
      begin: n.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
      relevance: 0
    },
    {
      className: "symbol",
      begin: ":(?!\\s)",
      contains: [
        d,
        { begin: t }
      ],
      relevance: 0
    },
    h,
    {
      // negative-look forward attempts to prevent false matches like:
      // @ident@ or $ident$ that might indicate this is not ruby at all
      className: "variable",
      begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
    },
    {
      className: "params",
      begin: /\|(?!=)/,
      end: /\|/,
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0,
      // this could be a lot of things (in other languages) other than params
      keywords: o
    },
    {
      // regexp container
      begin: "(" + n.RE_STARTERS_RE + "|unless)\\s*",
      keywords: "unless",
      contains: [
        {
          className: "regexp",
          contains: [
            n.BACKSLASH_ESCAPE,
            c
          ],
          illegal: /\n/,
          variants: [
            {
              begin: "/",
              end: "/[a-z]*"
            },
            {
              begin: /%r\{/,
              end: /\}[a-z]*/
            },
            {
              begin: "%r\\(",
              end: "\\)[a-z]*"
            },
            {
              begin: "%r!",
              end: "![a-z]*"
            },
            {
              begin: "%r\\[",
              end: "\\][a-z]*"
            }
          ]
        }
      ].concat(l, u),
      relevance: 0
    }
  ].concat(l, u);
  c.contains = w, v.contains = w;
  const M = [
    {
      begin: /^\s*=>/,
      starts: {
        end: "$",
        contains: w
      }
    },
    {
      className: "meta.prompt",
      begin: "^(" + "[>?]>" + "|" + "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]" + "|" + "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>" + ")(?=[ ])",
      starts: {
        end: "$",
        keywords: o,
        contains: w
      }
    }
  ];
  return u.unshift(l), {
    name: "Ruby",
    aliases: [
      "rb",
      "gemspec",
      "podspec",
      "thor",
      "irb"
    ],
    keywords: o,
    illegal: /\/\*/,
    contains: [n.SHEBANG({ binary: "ruby" })].concat(M).concat(u).concat(w)
  };
}
function tbe(n) {
  const e = n.regex, t = /(r#)?/, r = e.concat(t, n.UNDERSCORE_IDENT_RE), i = e.concat(t, n.IDENT_RE), a = {
    className: "title.function.invoke",
    relevance: 0,
    begin: e.concat(
      /\b/,
      /(?!let|for|while|if|else|match\b)/,
      i,
      e.lookahead(/\s*\(/)
    )
  }, o = "([ui](8|16|32|64|128|size)|f(32|64))?", s = [
    "abstract",
    "as",
    "async",
    "await",
    "become",
    "box",
    "break",
    "const",
    "continue",
    "crate",
    "do",
    "dyn",
    "else",
    "enum",
    "extern",
    "false",
    "final",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "macro",
    "match",
    "mod",
    "move",
    "mut",
    "override",
    "priv",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "try",
    "type",
    "typeof",
    "union",
    "unsafe",
    "unsized",
    "use",
    "virtual",
    "where",
    "while",
    "yield"
  ], l = [
    "true",
    "false",
    "Some",
    "None",
    "Ok",
    "Err"
  ], u = [
    // functions
    "drop ",
    // traits
    "Copy",
    "Send",
    "Sized",
    "Sync",
    "Drop",
    "Fn",
    "FnMut",
    "FnOnce",
    "ToOwned",
    "Clone",
    "Debug",
    "PartialEq",
    "PartialOrd",
    "Eq",
    "Ord",
    "AsRef",
    "AsMut",
    "Into",
    "From",
    "Default",
    "Iterator",
    "Extend",
    "IntoIterator",
    "DoubleEndedIterator",
    "ExactSizeIterator",
    "SliceConcatExt",
    "ToString",
    // macros
    "assert!",
    "assert_eq!",
    "bitflags!",
    "bytes!",
    "cfg!",
    "col!",
    "concat!",
    "concat_idents!",
    "debug_assert!",
    "debug_assert_eq!",
    "env!",
    "eprintln!",
    "panic!",
    "file!",
    "format!",
    "format_args!",
    "include_bytes!",
    "include_str!",
    "line!",
    "local_data_key!",
    "module_path!",
    "option_env!",
    "print!",
    "println!",
    "select!",
    "stringify!",
    "try!",
    "unimplemented!",
    "unreachable!",
    "vec!",
    "write!",
    "writeln!",
    "macro_rules!",
    "assert_ne!",
    "debug_assert_ne!"
  ], c = [
    "i8",
    "i16",
    "i32",
    "i64",
    "i128",
    "isize",
    "u8",
    "u16",
    "u32",
    "u64",
    "u128",
    "usize",
    "f32",
    "f64",
    "str",
    "char",
    "bool",
    "Box",
    "Option",
    "Result",
    "String",
    "Vec"
  ];
  return {
    name: "Rust",
    aliases: ["rs"],
    keywords: {
      $pattern: n.IDENT_RE + "!?",
      type: c,
      keyword: s,
      literal: l,
      built_in: u
    },
    illegal: "</",
    contains: [
      n.C_LINE_COMMENT_MODE,
      n.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
      n.inherit(n.QUOTE_STRING_MODE, {
        begin: /b?"/,
        illegal: null
      }),
      {
        className: "symbol",
        // negative lookahead to avoid matching `'`
        begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/
      },
      {
        scope: "string",
        variants: [
          { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
          {
            begin: /b?'/,
            end: /'/,
            contains: [
              {
                scope: "char.escape",
                match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/
              }
            ]
          }
        ]
      },
      {
        className: "number",
        variants: [
          { begin: "\\b0b([01_]+)" + o },
          { begin: "\\b0o([0-7_]+)" + o },
          { begin: "\\b0x([A-Fa-f0-9_]+)" + o },
          { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + o }
        ],
        relevance: 0
      },
      {
        begin: [
          /fn/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      },
      {
        className: "meta",
        begin: "#!?\\[",
        end: "\\]",
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/,
            contains: [
              n.BACKSLASH_ESCAPE
            ]
          }
        ]
      },
      {
        begin: [
          /let/,
          /\s+/,
          /(?:mut\s+)?/,
          r
        ],
        className: {
          1: "keyword",
          3: "keyword",
          4: "variable"
        }
      },
      // must come before impl/for rule later
      {
        begin: [
          /for/,
          /\s+/,
          r,
          /\s+/,
          /in/
        ],
        className: {
          1: "keyword",
          3: "variable",
          5: "keyword"
        }
      },
      {
        begin: [
          /type/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: [
          /(?:trait|enum|struct|union|impl|for)/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: n.IDENT_RE + "::",
        keywords: {
          keyword: "Self",
          built_in: u,
          type: c
        }
      },
      {
        className: "punctuation",
        begin: "->"
      },
      a
    ]
  };
}
const nbe = (n) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: n.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: n.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), rbe = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], ibe = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], abe = [
  ...rbe,
  ...ibe
], obe = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), sbe = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), lbe = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), ube = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "anchor-name",
  "animation",
  "animation-composition",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-range",
  "animation-range-end",
  "animation-range-start",
  "animation-timeline",
  "animation-timing-function",
  "appearance",
  "aspect-ratio",
  "backdrop-filter",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-position-x",
  "background-position-y",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-align",
  "box-decoration-break",
  "box-direction",
  "box-flex",
  "box-flex-group",
  "box-lines",
  "box-ordinal-group",
  "box-orient",
  "box-pack",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "cx",
  "cy",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "field-sizing",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flood-color",
  "flood-opacity",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "font-smooth",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-position",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphenate-character",
  "hyphenate-limit-chars",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "initial-letter",
  "initial-letter-align",
  "inline-size",
  "inset",
  "inset-area",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "justify-content",
  "justify-items",
  "justify-self",
  "kerning",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "line-height-step",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "masonry-auto-flow",
  "math-depth",
  "math-shift",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "overlay",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "place-content",
  "place-items",
  "place-self",
  "pointer-events",
  "position",
  "position-anchor",
  "position-visibility",
  "print-color-adjust",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "ruby-align",
  "ruby-position",
  "scale",
  "scroll-behavior",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scroll-timeline",
  "scroll-timeline-axis",
  "scroll-timeline-name",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-anchor",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-size-adjust",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "text-wrap",
  "text-wrap-mode",
  "text-wrap-style",
  "timeline-scope",
  "top",
  "touch-action",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-behavior",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "user-modify",
  "user-select",
  "vector-effect",
  "vertical-align",
  "view-timeline",
  "view-timeline-axis",
  "view-timeline-inset",
  "view-timeline-name",
  "view-transition-name",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "white-space-collapse",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
].sort().reverse();
function cbe(n) {
  const e = nbe(n), t = lbe, r = sbe, i = "@[a-z-]+", a = "and or not only", s = {
    className: "variable",
    begin: "(\\$" + "[a-zA-Z-][a-zA-Z0-9_-]*" + ")\\b",
    relevance: 0
  };
  return {
    name: "SCSS",
    case_insensitive: !0,
    illegal: "[=/|']",
    contains: [
      n.C_LINE_COMMENT_MODE,
      n.C_BLOCK_COMMENT_MODE,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      e.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: "#[A-Za-z0-9_-]+",
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\.[A-Za-z0-9_-]+",
        relevance: 0
      },
      e.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-tag",
        begin: "\\b(" + abe.join("|") + ")\\b",
        // was there, before, but why?
        relevance: 0
      },
      {
        className: "selector-pseudo",
        begin: ":(" + r.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + t.join("|") + ")"
      },
      s,
      {
        // pseudo-selector params
        begin: /\(/,
        end: /\)/,
        contains: [e.CSS_NUMBER_MODE]
      },
      e.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + ube.join("|") + ")\\b"
      },
      { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
      {
        begin: /:/,
        end: /[;}{]/,
        relevance: 0,
        contains: [
          e.BLOCK_COMMENT,
          s,
          e.HEXCOLOR,
          e.CSS_NUMBER_MODE,
          n.QUOTE_STRING_MODE,
          n.APOS_STRING_MODE,
          e.IMPORTANT,
          e.FUNCTION_DISPATCH
        ]
      },
      // matching these here allows us to treat them more like regular CSS
      // rules so everything between the {} gets regular rule highlighting,
      // which is what we want for page and font-face
      {
        begin: "@(page|font-face)",
        keywords: {
          $pattern: i,
          keyword: "@page @font-face"
        }
      },
      {
        begin: "@",
        end: "[{;]",
        returnBegin: !0,
        keywords: {
          $pattern: /[a-z-]+/,
          keyword: a,
          attribute: obe.join(" ")
        },
        contains: [
          {
            begin: i,
            className: "keyword"
          },
          {
            begin: /[a-z-]+(?=:)/,
            className: "attribute"
          },
          s,
          n.QUOTE_STRING_MODE,
          n.APOS_STRING_MODE,
          e.HEXCOLOR,
          e.CSS_NUMBER_MODE
        ]
      },
      e.FUNCTION_DISPATCH
    ]
  };
}
function dbe(n) {
  return {
    name: "Shell Session",
    aliases: [
      "console",
      "shellsession"
    ],
    contains: [
      {
        className: "meta.prompt",
        // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
        // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
        // echo /path/to/home > t.exe
        begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
        starts: {
          end: /[^\\](?=\s*$)/,
          subLanguage: "bash"
        }
      }
    ]
  };
}
function fbe(n) {
  const e = n.regex, t = n.COMMENT("--", "$"), r = {
    scope: "string",
    variants: [
      {
        begin: /'/,
        end: /'/,
        contains: [{ match: /''/ }]
      }
    ]
  }, i = {
    begin: /"/,
    end: /"/,
    contains: [{ match: /""/ }]
  }, a = [
    "true",
    "false",
    // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
    // "null",
    "unknown"
  ], o = [
    "double precision",
    "large object",
    "with timezone",
    "without timezone"
  ], s = [
    "bigint",
    "binary",
    "blob",
    "boolean",
    "char",
    "character",
    "clob",
    "date",
    "dec",
    "decfloat",
    "decimal",
    "float",
    "int",
    "integer",
    "interval",
    "nchar",
    "nclob",
    "national",
    "numeric",
    "real",
    "row",
    "smallint",
    "time",
    "timestamp",
    "varchar",
    "varying",
    // modifier (character varying)
    "varbinary"
  ], l = [
    "add",
    "asc",
    "collation",
    "desc",
    "final",
    "first",
    "last",
    "view"
  ], u = [
    "abs",
    "acos",
    "all",
    "allocate",
    "alter",
    "and",
    "any",
    "are",
    "array",
    "array_agg",
    "array_max_cardinality",
    "as",
    "asensitive",
    "asin",
    "asymmetric",
    "at",
    "atan",
    "atomic",
    "authorization",
    "avg",
    "begin",
    "begin_frame",
    "begin_partition",
    "between",
    "bigint",
    "binary",
    "blob",
    "boolean",
    "both",
    "by",
    "call",
    "called",
    "cardinality",
    "cascaded",
    "case",
    "cast",
    "ceil",
    "ceiling",
    "char",
    "char_length",
    "character",
    "character_length",
    "check",
    "classifier",
    "clob",
    "close",
    "coalesce",
    "collate",
    "collect",
    "column",
    "commit",
    "condition",
    "connect",
    "constraint",
    "contains",
    "convert",
    "copy",
    "corr",
    "corresponding",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "create",
    "cross",
    "cube",
    "cume_dist",
    "current",
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_row",
    "current_schema",
    "current_time",
    "current_timestamp",
    "current_path",
    "current_role",
    "current_transform_group_for_type",
    "current_user",
    "cursor",
    "cycle",
    "date",
    "day",
    "deallocate",
    "dec",
    "decimal",
    "decfloat",
    "declare",
    "default",
    "define",
    "delete",
    "dense_rank",
    "deref",
    "describe",
    "deterministic",
    "disconnect",
    "distinct",
    "double",
    "drop",
    "dynamic",
    "each",
    "element",
    "else",
    "empty",
    "end",
    "end_frame",
    "end_partition",
    "end-exec",
    "equals",
    "escape",
    "every",
    "except",
    "exec",
    "execute",
    "exists",
    "exp",
    "external",
    "extract",
    "false",
    "fetch",
    "filter",
    "first_value",
    "float",
    "floor",
    "for",
    "foreign",
    "frame_row",
    "free",
    "from",
    "full",
    "function",
    "fusion",
    "get",
    "global",
    "grant",
    "group",
    "grouping",
    "groups",
    "having",
    "hold",
    "hour",
    "identity",
    "in",
    "indicator",
    "initial",
    "inner",
    "inout",
    "insensitive",
    "insert",
    "int",
    "integer",
    "intersect",
    "intersection",
    "interval",
    "into",
    "is",
    "join",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "language",
    "large",
    "last_value",
    "lateral",
    "lead",
    "leading",
    "left",
    "like",
    "like_regex",
    "listagg",
    "ln",
    "local",
    "localtime",
    "localtimestamp",
    "log",
    "log10",
    "lower",
    "match",
    "match_number",
    "match_recognize",
    "matches",
    "max",
    "member",
    "merge",
    "method",
    "min",
    "minute",
    "mod",
    "modifies",
    "module",
    "month",
    "multiset",
    "national",
    "natural",
    "nchar",
    "nclob",
    "new",
    "no",
    "none",
    "normalize",
    "not",
    "nth_value",
    "ntile",
    "null",
    "nullif",
    "numeric",
    "octet_length",
    "occurrences_regex",
    "of",
    "offset",
    "old",
    "omit",
    "on",
    "one",
    "only",
    "open",
    "or",
    "order",
    "out",
    "outer",
    "over",
    "overlaps",
    "overlay",
    "parameter",
    "partition",
    "pattern",
    "per",
    "percent",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "period",
    "portion",
    "position",
    "position_regex",
    "power",
    "precedes",
    "precision",
    "prepare",
    "primary",
    "procedure",
    "ptf",
    "range",
    "rank",
    "reads",
    "real",
    "recursive",
    "ref",
    "references",
    "referencing",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "release",
    "result",
    "return",
    "returns",
    "revoke",
    "right",
    "rollback",
    "rollup",
    "row",
    "row_number",
    "rows",
    "running",
    "savepoint",
    "scope",
    "scroll",
    "search",
    "second",
    "seek",
    "select",
    "sensitive",
    "session_user",
    "set",
    "show",
    "similar",
    "sin",
    "sinh",
    "skip",
    "smallint",
    "some",
    "specific",
    "specifictype",
    "sql",
    "sqlexception",
    "sqlstate",
    "sqlwarning",
    "sqrt",
    "start",
    "static",
    "stddev_pop",
    "stddev_samp",
    "submultiset",
    "subset",
    "substring",
    "substring_regex",
    "succeeds",
    "sum",
    "symmetric",
    "system",
    "system_time",
    "system_user",
    "table",
    "tablesample",
    "tan",
    "tanh",
    "then",
    "time",
    "timestamp",
    "timezone_hour",
    "timezone_minute",
    "to",
    "trailing",
    "translate",
    "translate_regex",
    "translation",
    "treat",
    "trigger",
    "trim",
    "trim_array",
    "true",
    "truncate",
    "uescape",
    "union",
    "unique",
    "unknown",
    "unnest",
    "update",
    "upper",
    "user",
    "using",
    "value",
    "values",
    "value_of",
    "var_pop",
    "var_samp",
    "varbinary",
    "varchar",
    "varying",
    "versioning",
    "when",
    "whenever",
    "where",
    "width_bucket",
    "window",
    "with",
    "within",
    "without",
    "year"
  ], c = [
    "abs",
    "acos",
    "array_agg",
    "asin",
    "atan",
    "avg",
    "cast",
    "ceil",
    "ceiling",
    "coalesce",
    "corr",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "cume_dist",
    "dense_rank",
    "deref",
    "element",
    "exp",
    "extract",
    "first_value",
    "floor",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "last_value",
    "lead",
    "listagg",
    "ln",
    "log",
    "log10",
    "lower",
    "max",
    "min",
    "mod",
    "nth_value",
    "ntile",
    "nullif",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "position",
    "position_regex",
    "power",
    "rank",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "row_number",
    "sin",
    "sinh",
    "sqrt",
    "stddev_pop",
    "stddev_samp",
    "substring",
    "substring_regex",
    "sum",
    "tan",
    "tanh",
    "translate",
    "translate_regex",
    "treat",
    "trim",
    "trim_array",
    "unnest",
    "upper",
    "value_of",
    "var_pop",
    "var_samp",
    "width_bucket"
  ], d = [
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_schema",
    "current_transform_group_for_type",
    "current_user",
    "session_user",
    "system_time",
    "system_user",
    "current_time",
    "localtime",
    "current_timestamp",
    "localtimestamp"
  ], f = [
    "create table",
    "insert into",
    "primary key",
    "foreign key",
    "not null",
    "alter table",
    "add constraint",
    "grouping sets",
    "on overflow",
    "character set",
    "respect nulls",
    "ignore nulls",
    "nulls first",
    "nulls last",
    "depth first",
    "breadth first"
  ], p = c, h = [
    ...u,
    ...l
  ].filter((x) => !c.includes(x)), v = {
    scope: "variable",
    match: /@[a-z0-9][a-z0-9_]*/
  }, m = {
    scope: "operator",
    match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
    relevance: 0
  }, g = {
    match: e.concat(/\b/, e.either(...p), /\s*\(/),
    relevance: 0,
    keywords: { built_in: p }
  };
  function y(x) {
    return e.concat(
      /\b/,
      e.either(...x.map((w) => w.replace(/\s+/, "\\s+"))),
      /\b/
    );
  }
  const b = {
    scope: "keyword",
    match: y(f),
    relevance: 0
  };
  function _(x, {
    exceptions: w,
    when: S
  } = {}) {
    const C = S;
    return w = w || [], x.map((k) => k.match(/\|\d+$/) || w.includes(k) ? k : C(k) ? `${k}|0` : k);
  }
  return {
    name: "SQL",
    case_insensitive: !0,
    // does not include {} or HTML tags `</`
    illegal: /[{}]|<\//,
    keywords: {
      $pattern: /\b[\w\.]+/,
      keyword: _(h, { when: (x) => x.length < 3 }),
      literal: a,
      type: s,
      built_in: d
    },
    contains: [
      {
        scope: "type",
        match: y(o)
      },
      b,
      g,
      v,
      r,
      i,
      n.C_NUMBER_MODE,
      n.C_BLOCK_COMMENT_MODE,
      t,
      m
    ]
  };
}
function v7(n) {
  return n ? typeof n == "string" ? n : n.source : null;
}
function Bh(n) {
  return $n("(?=", n, ")");
}
function $n(...n) {
  return n.map((t) => v7(t)).join("");
}
function pbe(n) {
  const e = n[n.length - 1];
  return typeof e == "object" && e.constructor === Object ? (n.splice(n.length - 1, 1), e) : {};
}
function wi(...n) {
  return "(" + (pbe(n).capture ? "" : "?:") + n.map((r) => v7(r)).join("|") + ")";
}
const QM = (n) => $n(
  /\b/,
  n,
  /\w$/.test(n) ? /\b/ : /\B/
), hbe = [
  "Protocol",
  // contextual
  "Type"
  // contextual
].map(QM), GR = [
  "init",
  "self"
].map(QM), vbe = [
  "Any",
  "Self"
], OS = [
  // strings below will be fed into the regular `keywords` engine while regex
  // will result in additional modes being created to scan for those keywords to
  // avoid conflicts with other rules
  "actor",
  "any",
  // contextual
  "associatedtype",
  "async",
  "await",
  /as\?/,
  // operator
  /as!/,
  // operator
  "as",
  // operator
  "borrowing",
  // contextual
  "break",
  "case",
  "catch",
  "class",
  "consume",
  // contextual
  "consuming",
  // contextual
  "continue",
  "convenience",
  // contextual
  "copy",
  // contextual
  "default",
  "defer",
  "deinit",
  "didSet",
  // contextual
  "distributed",
  "do",
  "dynamic",
  // contextual
  "each",
  "else",
  "enum",
  "extension",
  "fallthrough",
  /fileprivate\(set\)/,
  "fileprivate",
  "final",
  // contextual
  "for",
  "func",
  "get",
  // contextual
  "guard",
  "if",
  "import",
  "indirect",
  // contextual
  "infix",
  // contextual
  /init\?/,
  /init!/,
  "inout",
  /internal\(set\)/,
  "internal",
  "in",
  "is",
  // operator
  "isolated",
  // contextual
  "nonisolated",
  // contextual
  "lazy",
  // contextual
  "let",
  "macro",
  "mutating",
  // contextual
  "nonmutating",
  // contextual
  /open\(set\)/,
  // contextual
  "open",
  // contextual
  "operator",
  "optional",
  // contextual
  "override",
  // contextual
  "package",
  "postfix",
  // contextual
  "precedencegroup",
  "prefix",
  // contextual
  /private\(set\)/,
  "private",
  "protocol",
  /public\(set\)/,
  "public",
  "repeat",
  "required",
  // contextual
  "rethrows",
  "return",
  "set",
  // contextual
  "some",
  // contextual
  "static",
  "struct",
  "subscript",
  "super",
  "switch",
  "throws",
  "throw",
  /try\?/,
  // operator
  /try!/,
  // operator
  "try",
  // operator
  "typealias",
  /unowned\(safe\)/,
  // contextual
  /unowned\(unsafe\)/,
  // contextual
  "unowned",
  // contextual
  "var",
  "weak",
  // contextual
  "where",
  "while",
  "willSet"
  // contextual
], UR = [
  "false",
  "nil",
  "true"
], mbe = [
  "assignment",
  "associativity",
  "higherThan",
  "left",
  "lowerThan",
  "none",
  "right"
], gbe = [
  "#colorLiteral",
  "#column",
  "#dsohandle",
  "#else",
  "#elseif",
  "#endif",
  "#error",
  "#file",
  "#fileID",
  "#fileLiteral",
  "#filePath",
  "#function",
  "#if",
  "#imageLiteral",
  "#keyPath",
  "#line",
  "#selector",
  "#sourceLocation",
  "#warning"
], WR = [
  "abs",
  "all",
  "any",
  "assert",
  "assertionFailure",
  "debugPrint",
  "dump",
  "fatalError",
  "getVaList",
  "isKnownUniquelyReferenced",
  "max",
  "min",
  "numericCast",
  "pointwiseMax",
  "pointwiseMin",
  "precondition",
  "preconditionFailure",
  "print",
  "readLine",
  "repeatElement",
  "sequence",
  "stride",
  "swap",
  "swift_unboxFromSwiftValueWithType",
  "transcode",
  "type",
  "unsafeBitCast",
  "unsafeDowncast",
  "withExtendedLifetime",
  "withUnsafeMutablePointer",
  "withUnsafePointer",
  "withVaList",
  "withoutActuallyEscaping",
  "zip"
], m7 = wi(
  /[/=\-+!*%<>&|^~?]/,
  /[\u00A1-\u00A7]/,
  /[\u00A9\u00AB]/,
  /[\u00AC\u00AE]/,
  /[\u00B0\u00B1]/,
  /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
  /[\u2016-\u2017]/,
  /[\u2020-\u2027]/,
  /[\u2030-\u203E]/,
  /[\u2041-\u2053]/,
  /[\u2055-\u205E]/,
  /[\u2190-\u23FF]/,
  /[\u2500-\u2775]/,
  /[\u2794-\u2BFF]/,
  /[\u2E00-\u2E7F]/,
  /[\u3001-\u3003]/,
  /[\u3008-\u3020]/,
  /[\u3030]/
), g7 = wi(
  m7,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
  // TODO: The following characters are also allowed, but the regex isn't supported yet.
  // /[\u{E0100}-\u{E01EF}]/u
), IS = $n(m7, g7, "*"), y7 = wi(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
  // The following characters are also allowed, but the regexes aren't supported yet.
  // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
  // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
  // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
  // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
), Nb = wi(
  y7,
  /\d/,
  /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
), Go = $n(y7, Nb, "*"), Uy = $n(/[A-Z]/, Nb, "*"), ybe = [
  "attached",
  "autoclosure",
  $n(/convention\(/, wi("swift", "block", "c"), /\)/),
  "discardableResult",
  "dynamicCallable",
  "dynamicMemberLookup",
  "escaping",
  "freestanding",
  "frozen",
  "GKInspectable",
  "IBAction",
  "IBDesignable",
  "IBInspectable",
  "IBOutlet",
  "IBSegueAction",
  "inlinable",
  "main",
  "nonobjc",
  "NSApplicationMain",
  "NSCopying",
  "NSManaged",
  $n(/objc\(/, Go, /\)/),
  "objc",
  "objcMembers",
  "propertyWrapper",
  "requires_stored_property_inits",
  "resultBuilder",
  "Sendable",
  "testable",
  "UIApplicationMain",
  "unchecked",
  "unknown",
  "usableFromInline",
  "warn_unqualified_access"
], bbe = [
  "iOS",
  "iOSApplicationExtension",
  "macOS",
  "macOSApplicationExtension",
  "macCatalyst",
  "macCatalystApplicationExtension",
  "watchOS",
  "watchOSApplicationExtension",
  "tvOS",
  "tvOSApplicationExtension",
  "swift"
];
function _be(n) {
  const e = {
    match: /\s+/,
    relevance: 0
  }, t = n.COMMENT(
    "/\\*",
    "\\*/",
    { contains: ["self"] }
  ), r = [
    n.C_LINE_COMMENT_MODE,
    t
  ], i = {
    match: [
      /\./,
      wi(...hbe, ...GR)
    ],
    className: { 2: "keyword" }
  }, a = {
    // Consume .keyword to prevent highlighting properties and methods as keywords.
    match: $n(/\./, wi(...OS)),
    relevance: 0
  }, o = OS.filter((Te) => typeof Te == "string").concat(["_|0"]), s = OS.filter((Te) => typeof Te != "string").concat(vbe).map(QM), l = { variants: [
    {
      className: "keyword",
      match: wi(...s, ...GR)
    }
  ] }, u = {
    $pattern: wi(
      /\b\w+/,
      // regular keywords
      /#\w+/
      // number keywords
    ),
    keyword: o.concat(gbe),
    literal: UR
  }, c = [
    i,
    a,
    l
  ], d = {
    // Consume .built_in to prevent highlighting properties and methods.
    match: $n(/\./, wi(...WR)),
    relevance: 0
  }, f = {
    className: "built_in",
    match: $n(/\b/, wi(...WR), /(?=\()/)
  }, p = [
    d,
    f
  ], h = {
    // Prevent -> from being highlighting as an operator.
    match: /->/,
    relevance: 0
  }, v = {
    className: "operator",
    relevance: 0,
    variants: [
      { match: IS },
      {
        // dot-operator: only operators that start with a dot are allowed to use dots as
        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
        // characters that may also include dots.
        match: `\\.(\\.|${g7})+`
      }
    ]
  }, m = [
    h,
    v
  ], g = "([0-9]_*)+", y = "([0-9a-fA-F]_*)+", b = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal floating-point-literal (subsumes decimal-literal)
      { match: `\\b(${g})(\\.(${g}))?([eE][+-]?(${g}))?\\b` },
      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
      { match: `\\b0x(${y})(\\.(${y}))?([pP][+-]?(${g}))?\\b` },
      // octal-literal
      { match: /\b0o([0-7]_*)+\b/ },
      // binary-literal
      { match: /\b0b([01]_*)+\b/ }
    ]
  }, _ = (Te = "") => ({
    className: "subst",
    variants: [
      { match: $n(/\\/, Te, /[0\\tnr"']/) },
      { match: $n(/\\/, Te, /u\{[0-9a-fA-F]{1,8}\}/) }
    ]
  }), x = (Te = "") => ({
    className: "subst",
    match: $n(/\\/, Te, /[\t ]*(?:[\r\n]|\r\n)/)
  }), w = (Te = "") => ({
    className: "subst",
    label: "interpol",
    begin: $n(/\\/, Te, /\(/),
    end: /\)/
  }), S = (Te = "") => ({
    begin: $n(Te, /"""/),
    end: $n(/"""/, Te),
    contains: [
      _(Te),
      x(Te),
      w(Te)
    ]
  }), C = (Te = "") => ({
    begin: $n(Te, /"/),
    end: $n(/"/, Te),
    contains: [
      _(Te),
      w(Te)
    ]
  }), k = {
    className: "string",
    variants: [
      S(),
      S("#"),
      S("##"),
      S("###"),
      C(),
      C("#"),
      C("##"),
      C("###")
    ]
  }, M = [
    n.BACKSLASH_ESCAPE,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [n.BACKSLASH_ESCAPE]
    }
  ], D = {
    begin: /\/[^\s](?=[^/\n]*\/)/,
    end: /\//,
    contains: M
  }, N = (Te) => {
    const Ge = $n(Te, /\//), je = $n(/\//, Te);
    return {
      begin: Ge,
      end: je,
      contains: [
        ...M,
        {
          scope: "comment",
          begin: `#(?!.*${je})`,
          end: /$/
        }
      ]
    };
  }, R = {
    scope: "regexp",
    variants: [
      N("###"),
      N("##"),
      N("#"),
      D
    ]
  }, j = { match: $n(/`/, Go, /`/) }, z = {
    className: "variable",
    match: /\$\d+/
  }, F = {
    className: "variable",
    match: `\\$${Nb}+`
  }, B = [
    j,
    z,
    F
  ], H = {
    match: /(@|#(un)?)available/,
    scope: "keyword",
    starts: { contains: [
      {
        begin: /\(/,
        end: /\)/,
        keywords: bbe,
        contains: [
          ...m,
          b,
          k
        ]
      }
    ] }
  }, Y = {
    scope: "keyword",
    match: $n(/@/, wi(...ybe), Bh(wi(/\(/, /\s+/)))
  }, ne = {
    scope: "meta",
    match: $n(/@/, Go)
  }, J = [
    H,
    Y,
    ne
  ], X = {
    match: Bh(/\b[A-Z]/),
    relevance: 0,
    contains: [
      {
        // Common Apple frameworks, for relevance boost
        className: "type",
        match: $n(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, Nb, "+")
      },
      {
        // Type identifier
        className: "type",
        match: Uy,
        relevance: 0
      },
      {
        // Optional type
        match: /[?!]+/,
        relevance: 0
      },
      {
        // Variadic parameter
        match: /\.\.\./,
        relevance: 0
      },
      {
        // Protocol composition
        match: $n(/\s+&\s+/, Bh(Uy)),
        relevance: 0
      }
    ]
  }, ie = {
    begin: /</,
    end: />/,
    keywords: u,
    contains: [
      ...r,
      ...c,
      ...J,
      h,
      X
    ]
  };
  X.contains.push(ie);
  const ye = {
    match: $n(Go, /\s*:/),
    keywords: "_|0",
    relevance: 0
  }, pe = {
    begin: /\(/,
    end: /\)/,
    relevance: 0,
    keywords: u,
    contains: [
      "self",
      ye,
      ...r,
      R,
      ...c,
      ...p,
      ...m,
      b,
      k,
      ...B,
      ...J,
      X
    ]
  }, Be = {
    begin: /</,
    end: />/,
    keywords: "repeat each",
    contains: [
      ...r,
      X
    ]
  }, Ce = {
    begin: wi(
      Bh($n(Go, /\s*:/)),
      Bh($n(Go, /\s+/, Go, /\s*:/))
    ),
    end: /:/,
    relevance: 0,
    contains: [
      {
        className: "keyword",
        match: /\b_\b/
      },
      {
        className: "params",
        match: Go
      }
    ]
  }, Ee = {
    begin: /\(/,
    end: /\)/,
    keywords: u,
    contains: [
      Ce,
      ...r,
      ...c,
      ...m,
      b,
      k,
      ...J,
      X,
      pe
    ],
    endsParent: !0,
    illegal: /["']/
  }, ce = {
    match: [
      /(func|macro)/,
      /\s+/,
      wi(j.match, Go, IS)
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      Be,
      Ee,
      e
    ],
    illegal: [
      /\[/,
      /%/
    ]
  }, Pe = {
    match: [
      /\b(?:subscript|init[?!]?)/,
      /\s*(?=[<(])/
    ],
    className: { 1: "keyword" },
    contains: [
      Be,
      Ee,
      e
    ],
    illegal: /\[|%/
  }, Ae = {
    match: [
      /operator/,
      /\s+/,
      IS
    ],
    className: {
      1: "keyword",
      3: "title"
    }
  }, fe = {
    begin: [
      /precedencegroup/,
      /\s+/,
      Uy
    ],
    className: {
      1: "keyword",
      3: "title"
    },
    contains: [X],
    keywords: [
      ...mbe,
      ...UR
    ],
    end: /}/
  }, oe = {
    match: [
      /class\b/,
      /\s+/,
      /func\b/,
      /\s+/,
      /\b[A-Za-z_][A-Za-z0-9_]*\b/
    ],
    scope: {
      1: "keyword",
      3: "keyword",
      5: "title.function"
    }
  }, he = {
    match: [
      /class\b/,
      /\s+/,
      /var\b/
    ],
    scope: {
      1: "keyword",
      3: "keyword"
    }
  }, Oe = {
    begin: [
      /(struct|protocol|class|extension|enum|actor)/,
      /\s+/,
      Go,
      /\s*/
    ],
    beginScope: {
      1: "keyword",
      3: "title.class"
    },
    keywords: u,
    contains: [
      Be,
      ...c,
      {
        begin: /:/,
        end: /\{/,
        keywords: u,
        contains: [
          {
            scope: "title.class.inherited",
            match: Uy
          },
          ...c
        ],
        relevance: 0
      }
    ]
  };
  for (const Te of k.variants) {
    const Ge = Te.contains.find((Qe) => Qe.label === "interpol");
    Ge.keywords = u;
    const je = [
      ...c,
      ...p,
      ...m,
      b,
      k,
      ...B
    ];
    Ge.contains = [
      ...je,
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          "self",
          ...je
        ]
      }
    ];
  }
  return {
    name: "Swift",
    keywords: u,
    contains: [
      ...r,
      ce,
      Pe,
      oe,
      he,
      Oe,
      Ae,
      fe,
      {
        beginKeywords: "import",
        end: /$/,
        contains: [...r],
        relevance: 0
      },
      R,
      ...c,
      ...p,
      ...m,
      b,
      k,
      ...B,
      ...J,
      X,
      pe
    ]
  };
}
const Rb = "[A-Za-z$_][0-9A-Za-z$_]*", b7 = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends",
  // It's reached stage 3, which is "recommended for implementation":
  "using"
], _7 = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], x7 = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], w7 = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], S7 = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], E7 = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], T7 = [].concat(
  S7,
  x7,
  w7
);
function xbe(n) {
  const e = n.regex, t = (H, { after: Y }) => {
    const ne = "</" + H[0].slice(1);
    return H.input.indexOf(ne, Y) !== -1;
  }, r = Rb, i = {
    begin: "<>",
    end: "</>"
  }, a = /<[A-Za-z0-9\\._:-]+\s*\/>/, o = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (H, Y) => {
      const ne = H[0].length + H.index, J = H.input[ne];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        J === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        J === ","
      ) {
        Y.ignoreMatch();
        return;
      }
      J === ">" && (t(H, { after: ne }) || Y.ignoreMatch());
      let X;
      const ie = H.input.substring(ne);
      if (X = ie.match(/^\s*=/)) {
        Y.ignoreMatch();
        return;
      }
      if ((X = ie.match(/^\s+extends\s+/)) && X.index === 0) {
        Y.ignoreMatch();
        return;
      }
    }
  }, s = {
    $pattern: Rb,
    keyword: b7,
    literal: _7,
    built_in: T7,
    "variable.language": E7
  }, l = "[0-9](_?[0-9])*", u = `\\.(${l})`, c = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${c})((${u})|\\.)?|(${u}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${c})\\b((${u})\\b|\\.)?|(${u})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: s,
    contains: []
    // defined later
  }, p = {
    begin: ".?html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, h = {
    begin: ".?css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, v = {
    begin: ".?gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, m = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      n.BACKSLASH_ESCAPE,
      f
    ]
  }, y = {
    className: "comment",
    variants: [
      n.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      n.C_BLOCK_COMMENT_MODE,
      n.C_LINE_COMMENT_MODE
    ]
  }, b = [
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE,
    p,
    h,
    v,
    m,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    d
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = b.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: s,
    contains: [
      "self"
    ].concat(b)
  });
  const _ = [].concat(y, f.contains), x = _.concat([
    // eat recursive parens in sub expressions
    {
      begin: /(\s*)\(/,
      end: /\)/,
      keywords: s,
      contains: ["self"].concat(_)
    }
  ]), w = {
    className: "params",
    // convert this to negative lookbehind in v12
    begin: /(\s*)\(/,
    // to match the parms with
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: s,
    contains: x
  }, S = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, C = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...x7,
        ...w7
      ]
    }
  }, k = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, M = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [w],
    illegal: /%/
  }, D = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function N(H) {
    return e.concat("(?!", H.join("|"), ")");
  }
  const R = {
    match: e.concat(
      /\b/,
      N([
        ...S7,
        "super",
        "import"
      ].map((H) => `${H}\\s*\\(`)),
      r,
      e.lookahead(/\s*\(/)
    ),
    className: "title.function",
    relevance: 0
  }, j = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, z = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      w
    ]
  }, F = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", B = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(F)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      w
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: s,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: x, CLASS_REFERENCE: C },
    illegal: /#(?![$_A-z])/,
    contains: [
      n.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      k,
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      p,
      h,
      v,
      m,
      y,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      d,
      C,
      {
        scope: "attr",
        match: r + e.lookahead(":"),
        relevance: 0
      },
      B,
      {
        // "value" container
        begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          y,
          n.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: F,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: n.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /(\s*)\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: s,
                    contains: x
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: i.begin, end: i.end },
              { match: a },
              {
                begin: o.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": o.isTrulyOpeningTag,
                end: o.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: o.begin,
                end: o.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      M,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          w,
          n.inherit(n.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      j,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [w]
      },
      R,
      D,
      S,
      z,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function wbe(n) {
  const e = n.regex, t = xbe(n), r = Rb, i = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ], a = {
    begin: [
      /namespace/,
      /\s+/,
      n.IDENT_RE
    ],
    beginScope: {
      1: "keyword",
      3: "title.class"
    }
  }, o = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: !0,
    keywords: {
      keyword: "interface extends",
      built_in: i
    },
    contains: [t.exports.CLASS_REFERENCE]
  }, s = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }, l = [
    "type",
    // "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override",
    "satisfies"
  ], u = {
    $pattern: Rb,
    keyword: b7.concat(l),
    literal: _7,
    built_in: T7.concat(i),
    "variable.language": E7
  }, c = {
    className: "meta",
    begin: "@" + r
  }, d = (v, m, g) => {
    const y = v.contains.findIndex((b) => b.label === m);
    if (y === -1)
      throw new Error("can not find mode to replace");
    v.contains.splice(y, 1, g);
  };
  Object.assign(t.keywords, u), t.exports.PARAMS_CONTAINS.push(c);
  const f = t.contains.find((v) => v.scope === "attr"), p = Object.assign(
    {},
    f,
    { match: e.concat(r, e.lookahead(/\s*\?:/)) }
  );
  t.exports.PARAMS_CONTAINS.push([
    t.exports.CLASS_REFERENCE,
    // class reference for highlighting the params types
    f,
    // highlight the params key
    p
    // Added for optional property assignment highlighting
  ]), t.contains = t.contains.concat([
    c,
    a,
    o,
    p
    // Added for optional property assignment highlighting
  ]), d(t, "shebang", n.SHEBANG()), d(t, "use_strict", s);
  const h = t.contains.find((v) => v.label === "func.def");
  return h.relevance = 0, Object.assign(t, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  }), t;
}
function Sbe(n) {
  const e = n.regex, t = {
    className: "string",
    begin: /"(""|[^/n])"C\b/
  }, r = {
    className: "string",
    begin: /"/,
    end: /"/,
    illegal: /\n/,
    contains: [
      {
        // double quote escape
        begin: /""/
      }
    ]
  }, i = /\d{1,2}\/\d{1,2}\/\d{4}/, a = /\d{4}-\d{1,2}-\d{1,2}/, o = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, s = /\d{1,2}(:\d{1,2}){1,2}/, l = {
    className: "literal",
    variants: [
      {
        // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
        begin: e.concat(/# */, e.either(a, i), / *#/)
      },
      {
        // #H:mm[:ss]# (24h Time)
        begin: e.concat(/# */, s, / *#/)
      },
      {
        // #h[:mm[:ss]] A# (12h Time)
        begin: e.concat(/# */, o, / *#/)
      },
      {
        // date plus time
        begin: e.concat(
          /# */,
          e.either(a, i),
          / +/,
          e.either(o, s),
          / *#/
        )
      }
    ]
  }, u = {
    className: "number",
    relevance: 0,
    variants: [
      {
        // Float
        begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
      },
      {
        // Integer (base 10)
        begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 16)
        begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 8)
        begin: /&O[0-7_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 2)
        begin: /&B[01_]+((U?[SIL])|[%&])?/
      }
    ]
  }, c = {
    className: "label",
    begin: /^\w+:/
  }, d = n.COMMENT(/'''/, /$/, { contains: [
    {
      className: "doctag",
      begin: /<\/?/,
      end: />/
    }
  ] }), f = n.COMMENT(null, /$/, { variants: [
    { begin: /'/ },
    {
      // TODO: Use multi-class for leading spaces
      begin: /([\t ]|^)REM(?=\s)/
    }
  ] });
  return {
    name: "Visual Basic .NET",
    aliases: ["vb"],
    case_insensitive: !0,
    classNameAliases: { label: "symbol" },
    keywords: {
      keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
      built_in: (
        // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
        "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
      ),
      type: (
        // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
        "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
      ),
      literal: "true false nothing"
    },
    illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
    contains: [
      t,
      r,
      l,
      u,
      c,
      d,
      f,
      {
        className: "meta",
        // TODO: Use multi-class for indentation once available
        begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
        end: /$/,
        keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
        contains: [f]
      }
    ]
  };
}
function Ebe(n) {
  n.regex;
  const e = n.COMMENT(/\(;/, /;\)/);
  e.contains.push("self");
  const t = n.COMMENT(/;;/, /$/), r = [
    "anyfunc",
    "block",
    "br",
    "br_if",
    "br_table",
    "call",
    "call_indirect",
    "data",
    "drop",
    "elem",
    "else",
    "end",
    "export",
    "func",
    "global.get",
    "global.set",
    "local.get",
    "local.set",
    "local.tee",
    "get_global",
    "get_local",
    "global",
    "if",
    "import",
    "local",
    "loop",
    "memory",
    "memory.grow",
    "memory.size",
    "module",
    "mut",
    "nop",
    "offset",
    "param",
    "result",
    "return",
    "select",
    "set_global",
    "set_local",
    "start",
    "table",
    "tee_local",
    "then",
    "type",
    "unreachable"
  ], i = {
    begin: [
      /(?:func|call|call_indirect)/,
      /\s+/,
      /\$[^\s)]+/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    }
  }, a = {
    className: "variable",
    begin: /\$[\w_]+/
  }, o = {
    match: /(\((?!;)|\))+/,
    className: "punctuation",
    relevance: 0
  }, s = {
    className: "number",
    relevance: 0,
    // borrowed from Prism, TODO: split out into variants
    match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
  }, l = {
    // look-ahead prevents us from gobbling up opcodes
    match: /(i32|i64|f32|f64)(?!\.)/,
    className: "type"
  }, u = {
    className: "keyword",
    // borrowed from Prism, TODO: split out into variants
    match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
  };
  return {
    name: "WebAssembly",
    keywords: {
      $pattern: /[\w.]+/,
      keyword: r
    },
    contains: [
      t,
      e,
      {
        match: [
          /(?:offset|align)/,
          /\s*/,
          /=/
        ],
        className: {
          1: "keyword",
          3: "operator"
        }
      },
      a,
      o,
      i,
      n.QUOTE_STRING_MODE,
      l,
      u,
      s
    ]
  };
}
function Tbe(n) {
  const e = n.regex, t = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, i = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, a = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, o = n.inherit(a, {
    begin: /\(/,
    end: /\)/
  }), s = n.inherit(n.APOS_STRING_MODE, { className: "string" }), l = n.inherit(n.QUOTE_STRING_MODE, { className: "string" }), u = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: r,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [i]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [i]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          a,
          l,
          s,
          o,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  a,
                  o,
                  l,
                  s
                ]
              }
            ]
          }
        ]
      },
      n.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      i,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              l
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [u],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [u],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: e.concat(
          /</,
          e.lookahead(e.concat(
            t,
            // <tag/>
            // <tag>
            // <tag ...
            e.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: t,
            relevance: 0,
            starts: u
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: e.concat(
          /<\//,
          e.lookahead(e.concat(
            t,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: t,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
function Cbe(n) {
  const e = "true false yes no null", t = "[\\w#;/?:@&=+$,.~*'()[\\]]+", r = {
    className: "attr",
    variants: [
      // added brackets support and special char support
      { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
      {
        // double quoted keys - with brackets and special char support
        begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/
      },
      {
        // single quoted keys - with brackets and special char support
        begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/
      }
    ]
  }, i = {
    className: "template-variable",
    variants: [
      {
        // jinja templates Ansible
        begin: /\{\{/,
        end: /\}\}/
      },
      {
        // Ruby i18n
        begin: /%\{/,
        end: /\}/
      }
    ]
  }, a = {
    className: "string",
    relevance: 0,
    begin: /'/,
    end: /'/,
    contains: [
      {
        match: /''/,
        scope: "char.escape",
        relevance: 0
      }
    ]
  }, o = {
    className: "string",
    relevance: 0,
    variants: [
      {
        begin: /"/,
        end: /"/
      },
      { begin: /\S+/ }
    ],
    contains: [
      n.BACKSLASH_ESCAPE,
      i
    ]
  }, s = n.inherit(o, { variants: [
    {
      begin: /'/,
      end: /'/,
      contains: [
        {
          begin: /''/,
          relevance: 0
        }
      ]
    },
    {
      begin: /"/,
      end: /"/
    },
    { begin: /[^\s,{}[\]]+/ }
  ] }), f = {
    className: "number",
    begin: "\\b" + "[0-9]{4}(-[0-9][0-9]){0,2}" + "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?" + "(\\.[0-9]*)?" + "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?" + "\\b"
  }, p = {
    end: ",",
    endsWithParent: !0,
    excludeEnd: !0,
    keywords: e,
    relevance: 0
  }, h = {
    begin: /\{/,
    end: /\}/,
    contains: [p],
    illegal: "\\n",
    relevance: 0
  }, v = {
    begin: "\\[",
    end: "\\]",
    contains: [p],
    illegal: "\\n",
    relevance: 0
  }, m = [
    r,
    {
      className: "meta",
      begin: "^---\\s*$",
      relevance: 10
    },
    {
      // multi line string
      // Blocks start with a | or > followed by a newline
      //
      // Indentation of subsequent lines must be the same to
      // be considered part of the block
      className: "string",
      begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
    },
    {
      // Ruby/Rails erb
      begin: "<%[%=-]?",
      end: "[%-]?%>",
      subLanguage: "ruby",
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0
    },
    {
      // named tags
      className: "type",
      begin: "!\\w+!" + t
    },
    // https://yaml.org/spec/1.2/spec.html#id2784064
    {
      // verbatim tags
      className: "type",
      begin: "!<" + t + ">"
    },
    {
      // primary tags
      className: "type",
      begin: "!" + t
    },
    {
      // secondary tags
      className: "type",
      begin: "!!" + t
    },
    {
      // fragment id &ref
      className: "meta",
      begin: "&" + n.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // fragment reference *ref
      className: "meta",
      begin: "\\*" + n.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // array listing
      className: "bullet",
      // TODO: remove |$ hack when we have proper look-ahead support
      begin: "-(?=[ ]|$)",
      relevance: 0
    },
    n.HASH_COMMENT_MODE,
    {
      beginKeywords: e,
      keywords: { literal: e }
    },
    f,
    // numbers are any valid C-style number that
    // sit isolated from other words
    {
      className: "number",
      begin: n.C_NUMBER_RE + "\\b",
      relevance: 0
    },
    h,
    v,
    a,
    o
  ], g = [...m];
  return g.pop(), g.push(s), p.contains = g, {
    name: "YAML",
    case_insensitive: !0,
    aliases: ["yml"],
    contains: m
  };
}
const kbe = {
  arduino: l1e,
  bash: u1e,
  c: c1e,
  cpp: d1e,
  csharp: f1e,
  css: x1e,
  diff: w1e,
  go: S1e,
  graphql: E1e,
  ini: T1e,
  java: C1e,
  javascript: O1e,
  json: I1e,
  kotlin: N1e,
  less: V1e,
  lua: H1e,
  makefile: G1e,
  markdown: U1e,
  objectivec: W1e,
  perl: q1e,
  php: Y1e,
  "php-template": K1e,
  plaintext: X1e,
  python: Z1e,
  "python-repl": J1e,
  r: Q1e,
  ruby: ebe,
  rust: tbe,
  scss: cbe,
  shell: dbe,
  sql: fbe,
  swift: _be,
  typescript: wbe,
  vbnet: Sbe,
  wasm: Ebe,
  xml: Tbe,
  yaml: Cbe
};
function C7(n) {
  return n instanceof Map ? n.clear = n.delete = n.set = function() {
    throw new Error("map is read-only");
  } : n instanceof Set && (n.add = n.clear = n.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(n), Object.getOwnPropertyNames(n).forEach((e) => {
    const t = n[e], r = typeof t;
    (r === "object" || r === "function") && !Object.isFrozen(t) && C7(t);
  }), n;
}
let qR = class {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
};
function k7(n) {
  return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function uu(n, ...e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const r in n)
    t[r] = n[r];
  return e.forEach(function(r) {
    for (const i in r)
      t[i] = r[i];
  }), /** @type {T} */
  t;
}
const Abe = "</span>", YR = (n) => !!n.scope, Mbe = (n, { prefix: e }) => {
  if (n.startsWith("language:"))
    return n.replace("language:", "language-");
  if (n.includes(".")) {
    const t = n.split(".");
    return [
      `${e}${t.shift()}`,
      ...t.map((r, i) => `${r}${"_".repeat(i + 1)}`)
    ].join(" ");
  }
  return `${e}${n}`;
};
let Dbe = class {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, t) {
    this.buffer = "", this.classPrefix = t.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += k7(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!YR(e)) return;
    const t = Mbe(
      e.scope,
      { prefix: this.classPrefix }
    );
    this.span(t);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    YR(e) && (this.buffer += Abe);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
};
const KR = (n = {}) => {
  const e = { children: [] };
  return Object.assign(e, n), e;
};
let Obe = class A7 {
  constructor() {
    this.rootNode = KR(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const t = KR({ scope: e });
    this.add(t), this.stack.push(t);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); ) ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, t) {
    return typeof t == "string" ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach((r) => this._walk(e, r)), e.closeNode(t)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((t) => typeof t == "string") ? e.children = [e.children.join("")] : e.children.forEach((t) => {
      A7._collapse(t);
    }));
  }
}, Ibe = class extends Obe {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /** @param {string} scope */
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(e, t) {
    const r = e.root;
    t && (r.scope = `language:${t}`), this.add(r);
  }
  toHTML() {
    return new Dbe(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
};
function Hm(n) {
  return n ? typeof n == "string" ? n : n.source : null;
}
function M7(n) {
  return Wd("(?=", n, ")");
}
function Lbe(n) {
  return Wd("(?:", n, ")*");
}
function Nbe(n) {
  return Wd("(?:", n, ")?");
}
function Wd(...n) {
  return n.map((t) => Hm(t)).join("");
}
function Rbe(n) {
  const e = n[n.length - 1];
  return typeof e == "object" && e.constructor === Object ? (n.splice(n.length - 1, 1), e) : {};
}
function eD(...n) {
  return "(" + (Rbe(n).capture ? "" : "?:") + n.map((r) => Hm(r)).join("|") + ")";
}
function D7(n) {
  return new RegExp(n.toString() + "|").exec("").length - 1;
}
function Pbe(n, e) {
  const t = n && n.exec(e);
  return t && t.index === 0;
}
const jbe = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function tD(n, { joinWith: e }) {
  let t = 0;
  return n.map((r) => {
    t += 1;
    const i = t;
    let a = Hm(r), o = "";
    for (; a.length > 0; ) {
      const s = jbe.exec(a);
      if (!s) {
        o += a;
        break;
      }
      o += a.substring(0, s.index), a = a.substring(s.index + s[0].length), s[0][0] === "\\" && s[1] ? o += "\\" + String(Number(s[1]) + i) : (o += s[0], s[0] === "(" && t++);
    }
    return o;
  }).map((r) => `(${r})`).join(e);
}
const Bbe = /\b\B/, O7 = "[a-zA-Z]\\w*", nD = "[a-zA-Z_]\\w*", I7 = "\\b\\d+(\\.\\d+)?", L7 = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", N7 = "\\b(0b[01]+)", $be = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", zbe = (n = {}) => {
  const e = /^#![ ]*\//;
  return n.binary && (n.begin = Wd(
    e,
    /.*\b/,
    n.binary,
    /\b.*/
  )), uu({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (t, r) => {
      t.index !== 0 && r.ignoreMatch();
    }
  }, n);
}, Gm = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, Fbe = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [Gm]
}, Vbe = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [Gm]
}, Hbe = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, Rx = function(n, e, t = {}) {
  const r = uu(
    {
      scope: "comment",
      begin: n,
      end: e,
      contains: []
    },
    t
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const i = eD(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: Wd(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        i,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
}, Gbe = Rx("//", "$"), Ube = Rx("/\\*", "\\*/"), Wbe = Rx("#", "$"), qbe = {
  scope: "number",
  begin: I7,
  relevance: 0
}, Ybe = {
  scope: "number",
  begin: L7,
  relevance: 0
}, Kbe = {
  scope: "number",
  begin: N7,
  relevance: 0
}, Xbe = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    Gm,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [Gm]
    }
  ]
}, Zbe = {
  scope: "title",
  begin: O7,
  relevance: 0
}, Jbe = {
  scope: "title",
  begin: nD,
  relevance: 0
}, Qbe = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + nD,
  relevance: 0
}, e_e = function(n) {
  return Object.assign(
    n,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, t) => {
        t.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, t) => {
        t.data._beginMatch !== e[1] && t.ignoreMatch();
      }
    }
  );
};
var Wy = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: Fbe,
  BACKSLASH_ESCAPE: Gm,
  BINARY_NUMBER_MODE: Kbe,
  BINARY_NUMBER_RE: N7,
  COMMENT: Rx,
  C_BLOCK_COMMENT_MODE: Ube,
  C_LINE_COMMENT_MODE: Gbe,
  C_NUMBER_MODE: Ybe,
  C_NUMBER_RE: L7,
  END_SAME_AS_BEGIN: e_e,
  HASH_COMMENT_MODE: Wbe,
  IDENT_RE: O7,
  MATCH_NOTHING_RE: Bbe,
  METHOD_GUARD: Qbe,
  NUMBER_MODE: qbe,
  NUMBER_RE: I7,
  PHRASAL_WORDS_MODE: Hbe,
  QUOTE_STRING_MODE: Vbe,
  REGEXP_MODE: Xbe,
  RE_STARTERS_RE: $be,
  SHEBANG: zbe,
  TITLE_MODE: Zbe,
  UNDERSCORE_IDENT_RE: nD,
  UNDERSCORE_TITLE_MODE: Jbe
});
function t_e(n, e) {
  n.input[n.index - 1] === "." && e.ignoreMatch();
}
function n_e(n, e) {
  n.className !== void 0 && (n.scope = n.className, delete n.className);
}
function r_e(n, e) {
  e && n.beginKeywords && (n.begin = "\\b(" + n.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", n.__beforeBegin = t_e, n.keywords = n.keywords || n.beginKeywords, delete n.beginKeywords, n.relevance === void 0 && (n.relevance = 0));
}
function i_e(n, e) {
  Array.isArray(n.illegal) && (n.illegal = eD(...n.illegal));
}
function a_e(n, e) {
  if (n.match) {
    if (n.begin || n.end) throw new Error("begin & end are not supported with match");
    n.begin = n.match, delete n.match;
  }
}
function o_e(n, e) {
  n.relevance === void 0 && (n.relevance = 1);
}
const s_e = (n, e) => {
  if (!n.beforeMatch) return;
  if (n.starts) throw new Error("beforeMatch cannot be used with starts");
  const t = Object.assign({}, n);
  Object.keys(n).forEach((r) => {
    delete n[r];
  }), n.keywords = t.keywords, n.begin = Wd(t.beforeMatch, M7(t.begin)), n.starts = {
    relevance: 0,
    contains: [
      Object.assign(t, { endsParent: !0 })
    ]
  }, n.relevance = 0, delete t.beforeMatch;
}, l_e = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], u_e = "keyword";
function R7(n, e, t = u_e) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof n == "string" ? i(t, n.split(" ")) : Array.isArray(n) ? i(t, n) : Object.keys(n).forEach(function(a) {
    Object.assign(
      r,
      R7(n[a], e, a)
    );
  }), r;
  function i(a, o) {
    e && (o = o.map((s) => s.toLowerCase())), o.forEach(function(s) {
      const l = s.split("|");
      r[l[0]] = [a, c_e(l[0], l[1])];
    });
  }
}
function c_e(n, e) {
  return e ? Number(e) : d_e(n) ? 0 : 1;
}
function d_e(n) {
  return l_e.includes(n.toLowerCase());
}
const XR = {}, od = (n) => {
  console.error(n);
}, ZR = (n, ...e) => {
  console.log(`WARN: ${n}`, ...e);
}, gf = (n, e) => {
  XR[`${n}/${e}`] || (console.log(`Deprecated as of ${n}. ${e}`), XR[`${n}/${e}`] = !0);
}, Pb = new Error();
function P7(n, e, { key: t }) {
  let r = 0;
  const i = n[t], a = {}, o = {};
  for (let s = 1; s <= e.length; s++)
    o[s + r] = i[s], a[s + r] = !0, r += D7(e[s - 1]);
  n[t] = o, n[t]._emit = a, n[t]._multi = !0;
}
function f_e(n) {
  if (Array.isArray(n.begin)) {
    if (n.skip || n.excludeBegin || n.returnBegin)
      throw od("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Pb;
    if (typeof n.beginScope != "object" || n.beginScope === null)
      throw od("beginScope must be object"), Pb;
    P7(n, n.begin, { key: "beginScope" }), n.begin = tD(n.begin, { joinWith: "" });
  }
}
function p_e(n) {
  if (Array.isArray(n.end)) {
    if (n.skip || n.excludeEnd || n.returnEnd)
      throw od("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Pb;
    if (typeof n.endScope != "object" || n.endScope === null)
      throw od("endScope must be object"), Pb;
    P7(n, n.end, { key: "endScope" }), n.end = tD(n.end, { joinWith: "" });
  }
}
function h_e(n) {
  n.scope && typeof n.scope == "object" && n.scope !== null && (n.beginScope = n.scope, delete n.scope);
}
function v_e(n) {
  h_e(n), typeof n.beginScope == "string" && (n.beginScope = { _wrap: n.beginScope }), typeof n.endScope == "string" && (n.endScope = { _wrap: n.endScope }), f_e(n), p_e(n);
}
function m_e(n) {
  function e(o, s) {
    return new RegExp(
      Hm(o),
      "m" + (n.case_insensitive ? "i" : "") + (n.unicodeRegex ? "u" : "") + (s ? "g" : "")
    );
  }
  class t {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(s, l) {
      l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, s]), this.matchAt += D7(s) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const s = this.regexes.map((l) => l[1]);
      this.matcherRe = e(tD(s, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(s) {
      this.matcherRe.lastIndex = this.lastIndex;
      const l = this.matcherRe.exec(s);
      if (!l)
        return null;
      const u = l.findIndex((d, f) => f > 0 && d !== void 0), c = this.matchIndexes[u];
      return l.splice(0, u), Object.assign(l, c);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(s) {
      if (this.multiRegexes[s]) return this.multiRegexes[s];
      const l = new t();
      return this.rules.slice(s).forEach(([u, c]) => l.addRule(u, c)), l.compile(), this.multiRegexes[s] = l, l;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(s, l) {
      this.rules.push([s, l]), l.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(s) {
      const l = this.getMatcher(this.regexIndex);
      l.lastIndex = this.lastIndex;
      let u = l.exec(s);
      if (this.resumingScanAtSamePosition() && !(u && u.index === this.lastIndex)) {
        const c = this.getMatcher(0);
        c.lastIndex = this.lastIndex + 1, u = c.exec(s);
      }
      return u && (this.regexIndex += u.position + 1, this.regexIndex === this.count && this.considerAll()), u;
    }
  }
  function i(o) {
    const s = new r();
    return o.contains.forEach((l) => s.addRule(l.begin, { rule: l, type: "begin" })), o.terminatorEnd && s.addRule(o.terminatorEnd, { type: "end" }), o.illegal && s.addRule(o.illegal, { type: "illegal" }), s;
  }
  function a(o, s) {
    const l = (
      /** @type CompiledMode */
      o
    );
    if (o.isCompiled) return l;
    [
      n_e,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      a_e,
      v_e,
      s_e
    ].forEach((c) => c(o, s)), n.compilerExtensions.forEach((c) => c(o, s)), o.__beforeBegin = null, [
      r_e,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      i_e,
      // default to 1 relevance if not specified
      o_e
    ].forEach((c) => c(o, s)), o.isCompiled = !0;
    let u = null;
    return typeof o.keywords == "object" && o.keywords.$pattern && (o.keywords = Object.assign({}, o.keywords), u = o.keywords.$pattern, delete o.keywords.$pattern), u = u || /\w+/, o.keywords && (o.keywords = R7(o.keywords, n.case_insensitive)), l.keywordPatternRe = e(u, !0), s && (o.begin || (o.begin = /\B|\b/), l.beginRe = e(l.begin), !o.end && !o.endsWithParent && (o.end = /\B|\b/), o.end && (l.endRe = e(l.end)), l.terminatorEnd = Hm(l.end) || "", o.endsWithParent && s.terminatorEnd && (l.terminatorEnd += (o.end ? "|" : "") + s.terminatorEnd)), o.illegal && (l.illegalRe = e(
      /** @type {RegExp | string} */
      o.illegal
    )), o.contains || (o.contains = []), o.contains = [].concat(...o.contains.map(function(c) {
      return g_e(c === "self" ? o : c);
    })), o.contains.forEach(function(c) {
      a(
        /** @type Mode */
        c,
        l
      );
    }), o.starts && a(o.starts, s), l.matcher = i(l), l;
  }
  if (n.compilerExtensions || (n.compilerExtensions = []), n.contains && n.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return n.classNameAliases = uu(n.classNameAliases || {}), a(
    /** @type Mode */
    n
  );
}
function j7(n) {
  return n ? n.endsWithParent || j7(n.starts) : !1;
}
function g_e(n) {
  return n.variants && !n.cachedVariants && (n.cachedVariants = n.variants.map(function(e) {
    return uu(n, { variants: null }, e);
  })), n.cachedVariants ? n.cachedVariants : j7(n) ? uu(n, { starts: n.starts ? uu(n.starts) : null }) : Object.isFrozen(n) ? uu(n) : n;
}
var y_e = "11.11.1";
let b_e = class extends Error {
  constructor(e, t) {
    super(e), this.name = "HTMLInjectionError", this.html = t;
  }
};
const LS = k7, JR = uu, QR = Symbol("nomatch"), __e = 7, B7 = function(n) {
  const e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), r = [];
  let i = !0;
  const a = "Could not find the language '{}', did you forget to load/include a language module?", o = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let s = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: Ibe
  };
  function l(F) {
    return s.noHighlightRe.test(F);
  }
  function u(F) {
    let B = F.className + " ";
    B += F.parentNode ? F.parentNode.className : "";
    const H = s.languageDetectRe.exec(B);
    if (H) {
      const Y = C(H[1]);
      return Y || (ZR(a.replace("{}", H[1])), ZR("Falling back to no-highlight mode for this block.", F)), Y ? H[1] : "no-highlight";
    }
    return B.split(/\s+/).find((Y) => l(Y) || C(Y));
  }
  function c(F, B, H) {
    let Y = "", ne = "";
    typeof B == "object" ? (Y = F, H = B.ignoreIllegals, ne = B.language) : (gf("10.7.0", "highlight(lang, code, ...args) has been deprecated."), gf("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), ne = F, Y = B), H === void 0 && (H = !0);
    const J = {
      code: Y,
      language: ne
    };
    j("before:highlight", J);
    const X = J.result ? J.result : d(J.language, J.code, H);
    return X.code = J.code, j("after:highlight", X), X;
  }
  function d(F, B, H, Y) {
    const ne = /* @__PURE__ */ Object.create(null);
    function J(Re, be) {
      return Re.keywords[be];
    }
    function X() {
      if (!je.keywords) {
        ot.addText(it);
        return;
      }
      let Re = 0;
      je.keywordPatternRe.lastIndex = 0;
      let be = je.keywordPatternRe.exec(it), we = "";
      for (; be; ) {
        we += it.substring(Re, be.index);
        const Ne = Oe.case_insensitive ? be[0].toLowerCase() : be[0], lt = J(je, Ne);
        if (lt) {
          const [Gt, _n] = lt;
          if (ot.addText(we), we = "", ne[Ne] = (ne[Ne] || 0) + 1, ne[Ne] <= __e && (Nt += _n), Gt.startsWith("_"))
            we += be[0];
          else {
            const Tr = Oe.classNameAliases[Gt] || Gt;
            pe(be[0], Tr);
          }
        } else
          we += be[0];
        Re = je.keywordPatternRe.lastIndex, be = je.keywordPatternRe.exec(it);
      }
      we += it.substring(Re), ot.addText(we);
    }
    function ie() {
      if (it === "") return;
      let Re = null;
      if (typeof je.subLanguage == "string") {
        if (!e[je.subLanguage]) {
          ot.addText(it);
          return;
        }
        Re = d(je.subLanguage, it, !0, Qe[je.subLanguage]), Qe[je.subLanguage] = /** @type {CompiledMode} */
        Re._top;
      } else
        Re = p(it, je.subLanguage.length ? je.subLanguage : null);
      je.relevance > 0 && (Nt += Re.relevance), ot.__addSublanguage(Re._emitter, Re.language);
    }
    function ye() {
      je.subLanguage != null ? ie() : X(), it = "";
    }
    function pe(Re, be) {
      Re !== "" && (ot.startScope(be), ot.addText(Re), ot.endScope());
    }
    function Be(Re, be) {
      let we = 1;
      const Ne = be.length - 1;
      for (; we <= Ne; ) {
        if (!Re._emit[we]) {
          we++;
          continue;
        }
        const lt = Oe.classNameAliases[Re[we]] || Re[we], Gt = be[we];
        lt ? pe(Gt, lt) : (it = Gt, X(), it = ""), we++;
      }
    }
    function Ce(Re, be) {
      return Re.scope && typeof Re.scope == "string" && ot.openNode(Oe.classNameAliases[Re.scope] || Re.scope), Re.beginScope && (Re.beginScope._wrap ? (pe(it, Oe.classNameAliases[Re.beginScope._wrap] || Re.beginScope._wrap), it = "") : Re.beginScope._multi && (Be(Re.beginScope, be), it = "")), je = Object.create(Re, { parent: { value: je } }), je;
    }
    function Ee(Re, be, we) {
      let Ne = Pbe(Re.endRe, we);
      if (Ne) {
        if (Re["on:end"]) {
          const lt = new qR(Re);
          Re["on:end"](be, lt), lt.isMatchIgnored && (Ne = !1);
        }
        if (Ne) {
          for (; Re.endsParent && Re.parent; )
            Re = Re.parent;
          return Re;
        }
      }
      if (Re.endsWithParent)
        return Ee(Re.parent, be, we);
    }
    function ce(Re) {
      return je.matcher.regexIndex === 0 ? (it += Re[0], 1) : (Rt = !0, 0);
    }
    function Pe(Re) {
      const be = Re[0], we = Re.rule, Ne = new qR(we), lt = [we.__beforeBegin, we["on:begin"]];
      for (const Gt of lt)
        if (Gt && (Gt(Re, Ne), Ne.isMatchIgnored))
          return ce(be);
      return we.skip ? it += be : (we.excludeBegin && (it += be), ye(), !we.returnBegin && !we.excludeBegin && (it = be)), Ce(we, Re), we.returnBegin ? 0 : be.length;
    }
    function Ae(Re) {
      const be = Re[0], we = B.substring(Re.index), Ne = Ee(je, Re, we);
      if (!Ne)
        return QR;
      const lt = je;
      je.endScope && je.endScope._wrap ? (ye(), pe(be, je.endScope._wrap)) : je.endScope && je.endScope._multi ? (ye(), Be(je.endScope, Re)) : lt.skip ? it += be : (lt.returnEnd || lt.excludeEnd || (it += be), ye(), lt.excludeEnd && (it = be));
      do
        je.scope && ot.closeNode(), !je.skip && !je.subLanguage && (Nt += je.relevance), je = je.parent;
      while (je !== Ne.parent);
      return Ne.starts && Ce(Ne.starts, Re), lt.returnEnd ? 0 : be.length;
    }
    function fe() {
      const Re = [];
      for (let be = je; be !== Oe; be = be.parent)
        be.scope && Re.unshift(be.scope);
      Re.forEach((be) => ot.openNode(be));
    }
    let oe = {};
    function he(Re, be) {
      const we = be && be[0];
      if (it += Re, we == null)
        return ye(), 0;
      if (oe.type === "begin" && be.type === "end" && oe.index === be.index && we === "") {
        if (it += B.slice(be.index, be.index + 1), !i) {
          const Ne = new Error(`0 width match regex (${F})`);
          throw Ne.languageName = F, Ne.badRule = oe.rule, Ne;
        }
        return 1;
      }
      if (oe = be, be.type === "begin")
        return Pe(be);
      if (be.type === "illegal" && !H) {
        const Ne = new Error('Illegal lexeme "' + we + '" for mode "' + (je.scope || "<unnamed>") + '"');
        throw Ne.mode = je, Ne;
      } else if (be.type === "end") {
        const Ne = Ae(be);
        if (Ne !== QR)
          return Ne;
      }
      if (be.type === "illegal" && we === "")
        return it += `
`, 1;
      if (ft > 1e5 && ft > be.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return it += we, we.length;
    }
    const Oe = C(F);
    if (!Oe)
      throw od(a.replace("{}", F)), new Error('Unknown language: "' + F + '"');
    const Te = m_e(Oe);
    let Ge = "", je = Y || Te;
    const Qe = {}, ot = new s.__emitter(s);
    fe();
    let it = "", Nt = 0, Le = 0, ft = 0, Rt = !1;
    try {
      if (Oe.__emitTokens)
        Oe.__emitTokens(B, ot);
      else {
        for (je.matcher.considerAll(); ; ) {
          ft++, Rt ? Rt = !1 : je.matcher.considerAll(), je.matcher.lastIndex = Le;
          const Re = je.matcher.exec(B);
          if (!Re) break;
          const be = B.substring(Le, Re.index), we = he(be, Re);
          Le = Re.index + we;
        }
        he(B.substring(Le));
      }
      return ot.finalize(), Ge = ot.toHTML(), {
        language: F,
        value: Ge,
        relevance: Nt,
        illegal: !1,
        _emitter: ot,
        _top: je
      };
    } catch (Re) {
      if (Re.message && Re.message.includes("Illegal"))
        return {
          language: F,
          value: LS(B),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: Re.message,
            index: Le,
            context: B.slice(Le - 100, Le + 100),
            mode: Re.mode,
            resultSoFar: Ge
          },
          _emitter: ot
        };
      if (i)
        return {
          language: F,
          value: LS(B),
          illegal: !1,
          relevance: 0,
          errorRaised: Re,
          _emitter: ot,
          _top: je
        };
      throw Re;
    }
  }
  function f(F) {
    const B = {
      value: LS(F),
      illegal: !1,
      relevance: 0,
      _top: o,
      _emitter: new s.__emitter(s)
    };
    return B._emitter.addText(F), B;
  }
  function p(F, B) {
    B = B || s.languages || Object.keys(e);
    const H = f(F), Y = B.filter(C).filter(M).map(
      (ye) => d(ye, F, !1)
    );
    Y.unshift(H);
    const ne = Y.sort((ye, pe) => {
      if (ye.relevance !== pe.relevance) return pe.relevance - ye.relevance;
      if (ye.language && pe.language) {
        if (C(ye.language).supersetOf === pe.language)
          return 1;
        if (C(pe.language).supersetOf === ye.language)
          return -1;
      }
      return 0;
    }), [J, X] = ne, ie = J;
    return ie.secondBest = X, ie;
  }
  function h(F, B, H) {
    const Y = B && t[B] || H;
    F.classList.add("hljs"), F.classList.add(`language-${Y}`);
  }
  function v(F) {
    let B = null;
    const H = u(F);
    if (l(H)) return;
    if (j(
      "before:highlightElement",
      { el: F, language: H }
    ), F.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", F);
      return;
    }
    if (F.children.length > 0 && (s.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(F)), s.throwUnescapedHTML))
      throw new b_e(
        "One of your code blocks includes unescaped HTML.",
        F.innerHTML
      );
    B = F;
    const Y = B.textContent, ne = H ? c(Y, { language: H, ignoreIllegals: !0 }) : p(Y);
    F.innerHTML = ne.value, F.dataset.highlighted = "yes", h(F, H, ne.language), F.result = {
      language: ne.language,
      // TODO: remove with version 11.0
      re: ne.relevance,
      relevance: ne.relevance
    }, ne.secondBest && (F.secondBest = {
      language: ne.secondBest.language,
      relevance: ne.secondBest.relevance
    }), j("after:highlightElement", { el: F, result: ne, text: Y });
  }
  function m(F) {
    s = JR(s, F);
  }
  const g = () => {
    _(), gf("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function y() {
    _(), gf("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let b = !1;
  function _() {
    function F() {
      _();
    }
    if (document.readyState === "loading") {
      b || window.addEventListener("DOMContentLoaded", F, !1), b = !0;
      return;
    }
    document.querySelectorAll(s.cssSelector).forEach(v);
  }
  function x(F, B) {
    let H = null;
    try {
      H = B(n);
    } catch (Y) {
      if (od("Language definition for '{}' could not be registered.".replace("{}", F)), i)
        od(Y);
      else
        throw Y;
      H = o;
    }
    H.name || (H.name = F), e[F] = H, H.rawDefinition = B.bind(null, n), H.aliases && k(H.aliases, { languageName: F });
  }
  function w(F) {
    delete e[F];
    for (const B of Object.keys(t))
      t[B] === F && delete t[B];
  }
  function S() {
    return Object.keys(e);
  }
  function C(F) {
    return F = (F || "").toLowerCase(), e[F] || e[t[F]];
  }
  function k(F, { languageName: B }) {
    typeof F == "string" && (F = [F]), F.forEach((H) => {
      t[H.toLowerCase()] = B;
    });
  }
  function M(F) {
    const B = C(F);
    return B && !B.disableAutodetect;
  }
  function D(F) {
    F["before:highlightBlock"] && !F["before:highlightElement"] && (F["before:highlightElement"] = (B) => {
      F["before:highlightBlock"](
        Object.assign({ block: B.el }, B)
      );
    }), F["after:highlightBlock"] && !F["after:highlightElement"] && (F["after:highlightElement"] = (B) => {
      F["after:highlightBlock"](
        Object.assign({ block: B.el }, B)
      );
    });
  }
  function N(F) {
    D(F), r.push(F);
  }
  function R(F) {
    const B = r.indexOf(F);
    B !== -1 && r.splice(B, 1);
  }
  function j(F, B) {
    const H = F;
    r.forEach(function(Y) {
      Y[H] && Y[H](B);
    });
  }
  function z(F) {
    return gf("10.7.0", "highlightBlock will be removed entirely in v12.0"), gf("10.7.0", "Please use highlightElement now."), v(F);
  }
  Object.assign(n, {
    highlight: c,
    highlightAuto: p,
    highlightAll: _,
    highlightElement: v,
    // TODO: Remove with v12 API
    highlightBlock: z,
    configure: m,
    initHighlighting: g,
    initHighlightingOnLoad: y,
    registerLanguage: x,
    unregisterLanguage: w,
    listLanguages: S,
    getLanguage: C,
    registerAliases: k,
    autoDetection: M,
    inherit: JR,
    addPlugin: N,
    removePlugin: R
  }), n.debugMode = function() {
    i = !1;
  }, n.safeMode = function() {
    i = !0;
  }, n.versionString = y_e, n.regex = {
    concat: Wd,
    lookahead: M7,
    either: eD,
    optional: Nbe,
    anyNumberOfTimes: Lbe
  };
  for (const F in Wy)
    typeof Wy[F] == "object" && C7(Wy[F]);
  return Object.assign(n, Wy), n;
}, Pp = B7({});
Pp.newInstance = () => B7({});
var x_e = Pp;
Pp.HighlightJS = Pp;
Pp.default = Pp;
const w_e = /* @__PURE__ */ nM(x_e), eP = {}, S_e = "hljs-";
function E_e(n) {
  const e = w_e.newInstance();
  return n && a(n), {
    highlight: t,
    highlightAuto: r,
    listLanguages: i,
    register: a,
    registerAlias: o,
    registered: s
  };
  function t(l, u, c) {
    const d = c || eP, f = typeof d.prefix == "string" ? d.prefix : S_e;
    if (!e.getLanguage(l))
      throw new Error("Unknown language: `" + l + "` is not registered");
    e.configure({ __emitter: T_e, classPrefix: f });
    const p = (
      /** @type {HighlightResult & {_emitter: HastEmitter}} */
      e.highlight(u, { ignoreIllegals: !0, language: l })
    );
    if (p.errorRaised)
      throw new Error("Could not highlight with `Highlight.js`", {
        cause: p.errorRaised
      });
    const h = p._emitter.root, v = (
      /** @type {RootData} */
      h.data
    );
    return v.language = p.language, v.relevance = p.relevance, h;
  }
  function r(l, u) {
    const d = (u || eP).subset || i();
    let f = -1, p = 0, h;
    for (; ++f < d.length; ) {
      const v = d[f];
      if (!e.getLanguage(v)) continue;
      const m = t(v, l, u);
      m.data && m.data.relevance !== void 0 && m.data.relevance > p && (p = m.data.relevance, h = m);
    }
    return h || {
      type: "root",
      children: [],
      data: { language: void 0, relevance: p }
    };
  }
  function i() {
    return e.listLanguages();
  }
  function a(l, u) {
    if (typeof l == "string")
      e.registerLanguage(l, u);
    else {
      let c;
      for (c in l)
        Object.hasOwn(l, c) && e.registerLanguage(c, l[c]);
    }
  }
  function o(l, u) {
    if (typeof l == "string")
      e.registerAliases(
        // Note: copy needed because hljs doesn’t accept readonly arrays yet.
        typeof u == "string" ? u : [...u],
        { languageName: l }
      );
    else {
      let c;
      for (c in l)
        if (Object.hasOwn(l, c)) {
          const d = l[c];
          e.registerAliases(
            // Note: copy needed because hljs doesn’t accept readonly arrays yet.
            typeof d == "string" ? d : [...d],
            { languageName: c }
          );
        }
    }
  }
  function s(l) {
    return !!e.getLanguage(l);
  }
}
class T_e {
  /**
   * @param {Readonly<HljsOptions>} options
   *   Configuration.
   * @returns
   *   Instance.
   */
  constructor(e) {
    this.options = e, this.root = {
      type: "root",
      children: [],
      data: { language: void 0, relevance: 0 }
    }, this.stack = [this.root];
  }
  /**
   * @param {string} value
   *   Text to add.
   * @returns {undefined}
   *   Nothing.
   *
   */
  addText(e) {
    if (e === "") return;
    const t = this.stack[this.stack.length - 1], r = t.children[t.children.length - 1];
    r && r.type === "text" ? r.value += e : t.children.push({ type: "text", value: e });
  }
  /**
   *
   * @param {unknown} rawName
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  startScope(e) {
    this.openNode(String(e));
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  endScope() {
    this.closeNode();
  }
  /**
   * @param {HastEmitter} other
   *   Other emitter.
   * @param {string} name
   *   Name of the sublanguage.
   * @returns {undefined}
   *   Nothing.
   */
  __addSublanguage(e, t) {
    const r = this.stack[this.stack.length - 1], i = (
      /** @type {Array<ElementContent>} */
      e.root.children
    );
    t ? r.children.push({
      type: "element",
      tagName: "span",
      properties: { className: [t] },
      children: i
    }) : r.children.push(...i);
  }
  /**
   * @param {string} name
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  openNode(e) {
    const t = this, r = e.split(".").map(function(o, s) {
      return s ? o + "_".repeat(s) : t.options.classPrefix + o;
    }), i = this.stack[this.stack.length - 1], a = {
      type: "element",
      tagName: "span",
      properties: { className: r },
      children: []
    };
    i.children.push(a), this.stack.push(a);
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  closeNode() {
    this.stack.pop();
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  finalize() {
  }
  /**
   * @returns {string}
   *   Nothing.
   */
  toHTML() {
    return "";
  }
}
function C_e(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function $7(n) {
  return n instanceof Map ? n.clear = n.delete = n.set = function() {
    throw new Error("map is read-only");
  } : n instanceof Set && (n.add = n.clear = n.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(n), Object.getOwnPropertyNames(n).forEach((e) => {
    const t = n[e], r = typeof t;
    (r === "object" || r === "function") && !Object.isFrozen(t) && $7(t);
  }), n;
}
class tP {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function z7(n) {
  return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function cu(n, ...e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const r in n)
    t[r] = n[r];
  return e.forEach(function(r) {
    for (const i in r)
      t[i] = r[i];
  }), /** @type {T} */
  t;
}
const k_e = "</span>", nP = (n) => !!n.scope, A_e = (n, { prefix: e }) => {
  if (n.startsWith("language:"))
    return n.replace("language:", "language-");
  if (n.includes(".")) {
    const t = n.split(".");
    return [
      `${e}${t.shift()}`,
      ...t.map((r, i) => `${r}${"_".repeat(i + 1)}`)
    ].join(" ");
  }
  return `${e}${n}`;
};
class M_e {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, t) {
    this.buffer = "", this.classPrefix = t.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += z7(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!nP(e)) return;
    const t = A_e(
      e.scope,
      { prefix: this.classPrefix }
    );
    this.span(t);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    nP(e) && (this.buffer += k_e);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
}
const rP = (n = {}) => {
  const e = { children: [] };
  return Object.assign(e, n), e;
};
class rD {
  constructor() {
    this.rootNode = rP(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const t = rP({ scope: e });
    this.add(t), this.stack.push(t);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); ) ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, t) {
    return typeof t == "string" ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach((r) => this._walk(e, r)), e.closeNode(t)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((t) => typeof t == "string") ? e.children = [e.children.join("")] : e.children.forEach((t) => {
      rD._collapse(t);
    }));
  }
}
class D_e extends rD {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /** @param {string} scope */
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(e, t) {
    const r = e.root;
    t && (r.scope = `language:${t}`), this.add(r);
  }
  toHTML() {
    return new M_e(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
}
function Um(n) {
  return n ? typeof n == "string" ? n : n.source : null;
}
function F7(n) {
  return qd("(?=", n, ")");
}
function O_e(n) {
  return qd("(?:", n, ")*");
}
function I_e(n) {
  return qd("(?:", n, ")?");
}
function qd(...n) {
  return n.map((t) => Um(t)).join("");
}
function L_e(n) {
  const e = n[n.length - 1];
  return typeof e == "object" && e.constructor === Object ? (n.splice(n.length - 1, 1), e) : {};
}
function iD(...n) {
  return "(" + (L_e(n).capture ? "" : "?:") + n.map((r) => Um(r)).join("|") + ")";
}
function V7(n) {
  return new RegExp(n.toString() + "|").exec("").length - 1;
}
function N_e(n, e) {
  const t = n && n.exec(e);
  return t && t.index === 0;
}
const R_e = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function aD(n, { joinWith: e }) {
  let t = 0;
  return n.map((r) => {
    t += 1;
    const i = t;
    let a = Um(r), o = "";
    for (; a.length > 0; ) {
      const s = R_e.exec(a);
      if (!s) {
        o += a;
        break;
      }
      o += a.substring(0, s.index), a = a.substring(s.index + s[0].length), s[0][0] === "\\" && s[1] ? o += "\\" + String(Number(s[1]) + i) : (o += s[0], s[0] === "(" && t++);
    }
    return o;
  }).map((r) => `(${r})`).join(e);
}
const P_e = /\b\B/, H7 = "[a-zA-Z]\\w*", oD = "[a-zA-Z_]\\w*", G7 = "\\b\\d+(\\.\\d+)?", U7 = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", W7 = "\\b(0b[01]+)", j_e = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", B_e = (n = {}) => {
  const e = /^#![ ]*\//;
  return n.binary && (n.begin = qd(
    e,
    /.*\b/,
    n.binary,
    /\b.*/
  )), cu({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (t, r) => {
      t.index !== 0 && r.ignoreMatch();
    }
  }, n);
}, Wm = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, $_e = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [Wm]
}, z_e = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [Wm]
}, F_e = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, Px = function(n, e, t = {}) {
  const r = cu(
    {
      scope: "comment",
      begin: n,
      end: e,
      contains: []
    },
    t
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const i = iD(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: qd(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        i,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
}, V_e = Px("//", "$"), H_e = Px("/\\*", "\\*/"), G_e = Px("#", "$"), U_e = {
  scope: "number",
  begin: G7,
  relevance: 0
}, W_e = {
  scope: "number",
  begin: U7,
  relevance: 0
}, q_e = {
  scope: "number",
  begin: W7,
  relevance: 0
}, Y_e = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    Wm,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [Wm]
    }
  ]
}, K_e = {
  scope: "title",
  begin: H7,
  relevance: 0
}, X_e = {
  scope: "title",
  begin: oD,
  relevance: 0
}, Z_e = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + oD,
  relevance: 0
}, J_e = function(n) {
  return Object.assign(
    n,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, t) => {
        t.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, t) => {
        t.data._beginMatch !== e[1] && t.ignoreMatch();
      }
    }
  );
};
var qy = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: $_e,
  BACKSLASH_ESCAPE: Wm,
  BINARY_NUMBER_MODE: q_e,
  BINARY_NUMBER_RE: W7,
  COMMENT: Px,
  C_BLOCK_COMMENT_MODE: H_e,
  C_LINE_COMMENT_MODE: V_e,
  C_NUMBER_MODE: W_e,
  C_NUMBER_RE: U7,
  END_SAME_AS_BEGIN: J_e,
  HASH_COMMENT_MODE: G_e,
  IDENT_RE: H7,
  MATCH_NOTHING_RE: P_e,
  METHOD_GUARD: Z_e,
  NUMBER_MODE: U_e,
  NUMBER_RE: G7,
  PHRASAL_WORDS_MODE: F_e,
  QUOTE_STRING_MODE: z_e,
  REGEXP_MODE: Y_e,
  RE_STARTERS_RE: j_e,
  SHEBANG: B_e,
  TITLE_MODE: K_e,
  UNDERSCORE_IDENT_RE: oD,
  UNDERSCORE_TITLE_MODE: X_e
});
function Q_e(n, e) {
  n.input[n.index - 1] === "." && e.ignoreMatch();
}
function exe(n, e) {
  n.className !== void 0 && (n.scope = n.className, delete n.className);
}
function txe(n, e) {
  e && n.beginKeywords && (n.begin = "\\b(" + n.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", n.__beforeBegin = Q_e, n.keywords = n.keywords || n.beginKeywords, delete n.beginKeywords, n.relevance === void 0 && (n.relevance = 0));
}
function nxe(n, e) {
  Array.isArray(n.illegal) && (n.illegal = iD(...n.illegal));
}
function rxe(n, e) {
  if (n.match) {
    if (n.begin || n.end) throw new Error("begin & end are not supported with match");
    n.begin = n.match, delete n.match;
  }
}
function ixe(n, e) {
  n.relevance === void 0 && (n.relevance = 1);
}
const axe = (n, e) => {
  if (!n.beforeMatch) return;
  if (n.starts) throw new Error("beforeMatch cannot be used with starts");
  const t = Object.assign({}, n);
  Object.keys(n).forEach((r) => {
    delete n[r];
  }), n.keywords = t.keywords, n.begin = qd(t.beforeMatch, F7(t.begin)), n.starts = {
    relevance: 0,
    contains: [
      Object.assign(t, { endsParent: !0 })
    ]
  }, n.relevance = 0, delete t.beforeMatch;
}, oxe = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], sxe = "keyword";
function q7(n, e, t = sxe) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof n == "string" ? i(t, n.split(" ")) : Array.isArray(n) ? i(t, n) : Object.keys(n).forEach(function(a) {
    Object.assign(
      r,
      q7(n[a], e, a)
    );
  }), r;
  function i(a, o) {
    e && (o = o.map((s) => s.toLowerCase())), o.forEach(function(s) {
      const l = s.split("|");
      r[l[0]] = [a, lxe(l[0], l[1])];
    });
  }
}
function lxe(n, e) {
  return e ? Number(e) : uxe(n) ? 0 : 1;
}
function uxe(n) {
  return oxe.includes(n.toLowerCase());
}
const iP = {}, sd = (n) => {
  console.error(n);
}, aP = (n, ...e) => {
  console.log(`WARN: ${n}`, ...e);
}, yf = (n, e) => {
  iP[`${n}/${e}`] || (console.log(`Deprecated as of ${n}. ${e}`), iP[`${n}/${e}`] = !0);
}, jb = new Error();
function Y7(n, e, { key: t }) {
  let r = 0;
  const i = n[t], a = {}, o = {};
  for (let s = 1; s <= e.length; s++)
    o[s + r] = i[s], a[s + r] = !0, r += V7(e[s - 1]);
  n[t] = o, n[t]._emit = a, n[t]._multi = !0;
}
function cxe(n) {
  if (Array.isArray(n.begin)) {
    if (n.skip || n.excludeBegin || n.returnBegin)
      throw sd("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), jb;
    if (typeof n.beginScope != "object" || n.beginScope === null)
      throw sd("beginScope must be object"), jb;
    Y7(n, n.begin, { key: "beginScope" }), n.begin = aD(n.begin, { joinWith: "" });
  }
}
function dxe(n) {
  if (Array.isArray(n.end)) {
    if (n.skip || n.excludeEnd || n.returnEnd)
      throw sd("skip, excludeEnd, returnEnd not compatible with endScope: {}"), jb;
    if (typeof n.endScope != "object" || n.endScope === null)
      throw sd("endScope must be object"), jb;
    Y7(n, n.end, { key: "endScope" }), n.end = aD(n.end, { joinWith: "" });
  }
}
function fxe(n) {
  n.scope && typeof n.scope == "object" && n.scope !== null && (n.beginScope = n.scope, delete n.scope);
}
function pxe(n) {
  fxe(n), typeof n.beginScope == "string" && (n.beginScope = { _wrap: n.beginScope }), typeof n.endScope == "string" && (n.endScope = { _wrap: n.endScope }), cxe(n), dxe(n);
}
function hxe(n) {
  function e(o, s) {
    return new RegExp(
      Um(o),
      "m" + (n.case_insensitive ? "i" : "") + (n.unicodeRegex ? "u" : "") + (s ? "g" : "")
    );
  }
  class t {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(s, l) {
      l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, s]), this.matchAt += V7(s) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const s = this.regexes.map((l) => l[1]);
      this.matcherRe = e(aD(s, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(s) {
      this.matcherRe.lastIndex = this.lastIndex;
      const l = this.matcherRe.exec(s);
      if (!l)
        return null;
      const u = l.findIndex((d, f) => f > 0 && d !== void 0), c = this.matchIndexes[u];
      return l.splice(0, u), Object.assign(l, c);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(s) {
      if (this.multiRegexes[s]) return this.multiRegexes[s];
      const l = new t();
      return this.rules.slice(s).forEach(([u, c]) => l.addRule(u, c)), l.compile(), this.multiRegexes[s] = l, l;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(s, l) {
      this.rules.push([s, l]), l.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(s) {
      const l = this.getMatcher(this.regexIndex);
      l.lastIndex = this.lastIndex;
      let u = l.exec(s);
      if (this.resumingScanAtSamePosition() && !(u && u.index === this.lastIndex)) {
        const c = this.getMatcher(0);
        c.lastIndex = this.lastIndex + 1, u = c.exec(s);
      }
      return u && (this.regexIndex += u.position + 1, this.regexIndex === this.count && this.considerAll()), u;
    }
  }
  function i(o) {
    const s = new r();
    return o.contains.forEach((l) => s.addRule(l.begin, { rule: l, type: "begin" })), o.terminatorEnd && s.addRule(o.terminatorEnd, { type: "end" }), o.illegal && s.addRule(o.illegal, { type: "illegal" }), s;
  }
  function a(o, s) {
    const l = (
      /** @type CompiledMode */
      o
    );
    if (o.isCompiled) return l;
    [
      exe,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      rxe,
      pxe,
      axe
    ].forEach((c) => c(o, s)), n.compilerExtensions.forEach((c) => c(o, s)), o.__beforeBegin = null, [
      txe,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      nxe,
      // default to 1 relevance if not specified
      ixe
    ].forEach((c) => c(o, s)), o.isCompiled = !0;
    let u = null;
    return typeof o.keywords == "object" && o.keywords.$pattern && (o.keywords = Object.assign({}, o.keywords), u = o.keywords.$pattern, delete o.keywords.$pattern), u = u || /\w+/, o.keywords && (o.keywords = q7(o.keywords, n.case_insensitive)), l.keywordPatternRe = e(u, !0), s && (o.begin || (o.begin = /\B|\b/), l.beginRe = e(l.begin), !o.end && !o.endsWithParent && (o.end = /\B|\b/), o.end && (l.endRe = e(l.end)), l.terminatorEnd = Um(l.end) || "", o.endsWithParent && s.terminatorEnd && (l.terminatorEnd += (o.end ? "|" : "") + s.terminatorEnd)), o.illegal && (l.illegalRe = e(
      /** @type {RegExp | string} */
      o.illegal
    )), o.contains || (o.contains = []), o.contains = [].concat(...o.contains.map(function(c) {
      return vxe(c === "self" ? o : c);
    })), o.contains.forEach(function(c) {
      a(
        /** @type Mode */
        c,
        l
      );
    }), o.starts && a(o.starts, s), l.matcher = i(l), l;
  }
  if (n.compilerExtensions || (n.compilerExtensions = []), n.contains && n.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return n.classNameAliases = cu(n.classNameAliases || {}), a(
    /** @type Mode */
    n
  );
}
function K7(n) {
  return n ? n.endsWithParent || K7(n.starts) : !1;
}
function vxe(n) {
  return n.variants && !n.cachedVariants && (n.cachedVariants = n.variants.map(function(e) {
    return cu(n, { variants: null }, e);
  })), n.cachedVariants ? n.cachedVariants : K7(n) ? cu(n, { starts: n.starts ? cu(n.starts) : null }) : Object.isFrozen(n) ? cu(n) : n;
}
var mxe = "11.10.0";
class gxe extends Error {
  constructor(e, t) {
    super(e), this.name = "HTMLInjectionError", this.html = t;
  }
}
const NS = z7, oP = cu, sP = Symbol("nomatch"), yxe = 7, X7 = function(n) {
  const e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), r = [];
  let i = !0;
  const a = "Could not find the language '{}', did you forget to load/include a language module?", o = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let s = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: D_e
  };
  function l(B) {
    return s.noHighlightRe.test(B);
  }
  function u(B) {
    let H = B.className + " ";
    H += B.parentNode ? B.parentNode.className : "";
    const Y = s.languageDetectRe.exec(H);
    if (Y) {
      const ne = k(Y[1]);
      return ne || (aP(a.replace("{}", Y[1])), aP("Falling back to no-highlight mode for this block.", B)), ne ? Y[1] : "no-highlight";
    }
    return H.split(/\s+/).find((ne) => l(ne) || k(ne));
  }
  function c(B, H, Y) {
    let ne = "", J = "";
    typeof H == "object" ? (ne = B, Y = H.ignoreIllegals, J = H.language) : (yf("10.7.0", "highlight(lang, code, ...args) has been deprecated."), yf("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), J = B, ne = H), Y === void 0 && (Y = !0);
    const X = {
      code: ne,
      language: J
    };
    z("before:highlight", X);
    const ie = X.result ? X.result : d(X.language, X.code, Y);
    return ie.code = X.code, z("after:highlight", ie), ie;
  }
  function d(B, H, Y, ne) {
    const J = /* @__PURE__ */ Object.create(null);
    function X(be, we) {
      return be.keywords[we];
    }
    function ie() {
      if (!Qe.keywords) {
        it.addText(Nt);
        return;
      }
      let be = 0;
      Qe.keywordPatternRe.lastIndex = 0;
      let we = Qe.keywordPatternRe.exec(Nt), Ne = "";
      for (; we; ) {
        Ne += Nt.substring(be, we.index);
        const lt = Te.case_insensitive ? we[0].toLowerCase() : we[0], Gt = X(Qe, lt);
        if (Gt) {
          const [_n, Tr] = Gt;
          if (it.addText(Ne), Ne = "", J[lt] = (J[lt] || 0) + 1, J[lt] <= yxe && (Le += Tr), _n.startsWith("_"))
            Ne += we[0];
          else {
            const Se = Te.classNameAliases[_n] || _n;
            Be(we[0], Se);
          }
        } else
          Ne += we[0];
        be = Qe.keywordPatternRe.lastIndex, we = Qe.keywordPatternRe.exec(Nt);
      }
      Ne += Nt.substring(be), it.addText(Ne);
    }
    function ye() {
      if (Nt === "") return;
      let be = null;
      if (typeof Qe.subLanguage == "string") {
        if (!e[Qe.subLanguage]) {
          it.addText(Nt);
          return;
        }
        be = d(Qe.subLanguage, Nt, !0, ot[Qe.subLanguage]), ot[Qe.subLanguage] = /** @type {CompiledMode} */
        be._top;
      } else
        be = p(Nt, Qe.subLanguage.length ? Qe.subLanguage : null);
      Qe.relevance > 0 && (Le += be.relevance), it.__addSublanguage(be._emitter, be.language);
    }
    function pe() {
      Qe.subLanguage != null ? ye() : ie(), Nt = "";
    }
    function Be(be, we) {
      be !== "" && (it.startScope(we), it.addText(be), it.endScope());
    }
    function Ce(be, we) {
      let Ne = 1;
      const lt = we.length - 1;
      for (; Ne <= lt; ) {
        if (!be._emit[Ne]) {
          Ne++;
          continue;
        }
        const Gt = Te.classNameAliases[be[Ne]] || be[Ne], _n = we[Ne];
        Gt ? Be(_n, Gt) : (Nt = _n, ie(), Nt = ""), Ne++;
      }
    }
    function Ee(be, we) {
      return be.scope && typeof be.scope == "string" && it.openNode(Te.classNameAliases[be.scope] || be.scope), be.beginScope && (be.beginScope._wrap ? (Be(Nt, Te.classNameAliases[be.beginScope._wrap] || be.beginScope._wrap), Nt = "") : be.beginScope._multi && (Ce(be.beginScope, we), Nt = "")), Qe = Object.create(be, { parent: { value: Qe } }), Qe;
    }
    function ce(be, we, Ne) {
      let lt = N_e(be.endRe, Ne);
      if (lt) {
        if (be["on:end"]) {
          const Gt = new tP(be);
          be["on:end"](we, Gt), Gt.isMatchIgnored && (lt = !1);
        }
        if (lt) {
          for (; be.endsParent && be.parent; )
            be = be.parent;
          return be;
        }
      }
      if (be.endsWithParent)
        return ce(be.parent, we, Ne);
    }
    function Pe(be) {
      return Qe.matcher.regexIndex === 0 ? (Nt += be[0], 1) : (Re = !0, 0);
    }
    function Ae(be) {
      const we = be[0], Ne = be.rule, lt = new tP(Ne), Gt = [Ne.__beforeBegin, Ne["on:begin"]];
      for (const _n of Gt)
        if (_n && (_n(be, lt), lt.isMatchIgnored))
          return Pe(we);
      return Ne.skip ? Nt += we : (Ne.excludeBegin && (Nt += we), pe(), !Ne.returnBegin && !Ne.excludeBegin && (Nt = we)), Ee(Ne, be), Ne.returnBegin ? 0 : we.length;
    }
    function fe(be) {
      const we = be[0], Ne = H.substring(be.index), lt = ce(Qe, be, Ne);
      if (!lt)
        return sP;
      const Gt = Qe;
      Qe.endScope && Qe.endScope._wrap ? (pe(), Be(we, Qe.endScope._wrap)) : Qe.endScope && Qe.endScope._multi ? (pe(), Ce(Qe.endScope, be)) : Gt.skip ? Nt += we : (Gt.returnEnd || Gt.excludeEnd || (Nt += we), pe(), Gt.excludeEnd && (Nt = we));
      do
        Qe.scope && it.closeNode(), !Qe.skip && !Qe.subLanguage && (Le += Qe.relevance), Qe = Qe.parent;
      while (Qe !== lt.parent);
      return lt.starts && Ee(lt.starts, be), Gt.returnEnd ? 0 : we.length;
    }
    function oe() {
      const be = [];
      for (let we = Qe; we !== Te; we = we.parent)
        we.scope && be.unshift(we.scope);
      be.forEach((we) => it.openNode(we));
    }
    let he = {};
    function Oe(be, we) {
      const Ne = we && we[0];
      if (Nt += be, Ne == null)
        return pe(), 0;
      if (he.type === "begin" && we.type === "end" && he.index === we.index && Ne === "") {
        if (Nt += H.slice(we.index, we.index + 1), !i) {
          const lt = new Error(`0 width match regex (${B})`);
          throw lt.languageName = B, lt.badRule = he.rule, lt;
        }
        return 1;
      }
      if (he = we, we.type === "begin")
        return Ae(we);
      if (we.type === "illegal" && !Y) {
        const lt = new Error('Illegal lexeme "' + Ne + '" for mode "' + (Qe.scope || "<unnamed>") + '"');
        throw lt.mode = Qe, lt;
      } else if (we.type === "end") {
        const lt = fe(we);
        if (lt !== sP)
          return lt;
      }
      if (we.type === "illegal" && Ne === "")
        return 1;
      if (Rt > 1e5 && Rt > we.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return Nt += Ne, Ne.length;
    }
    const Te = k(B);
    if (!Te)
      throw sd(a.replace("{}", B)), new Error('Unknown language: "' + B + '"');
    const Ge = hxe(Te);
    let je = "", Qe = ne || Ge;
    const ot = {}, it = new s.__emitter(s);
    oe();
    let Nt = "", Le = 0, ft = 0, Rt = 0, Re = !1;
    try {
      if (Te.__emitTokens)
        Te.__emitTokens(H, it);
      else {
        for (Qe.matcher.considerAll(); ; ) {
          Rt++, Re ? Re = !1 : Qe.matcher.considerAll(), Qe.matcher.lastIndex = ft;
          const be = Qe.matcher.exec(H);
          if (!be) break;
          const we = H.substring(ft, be.index), Ne = Oe(we, be);
          ft = be.index + Ne;
        }
        Oe(H.substring(ft));
      }
      return it.finalize(), je = it.toHTML(), {
        language: B,
        value: je,
        relevance: Le,
        illegal: !1,
        _emitter: it,
        _top: Qe
      };
    } catch (be) {
      if (be.message && be.message.includes("Illegal"))
        return {
          language: B,
          value: NS(H),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: be.message,
            index: ft,
            context: H.slice(ft - 100, ft + 100),
            mode: be.mode,
            resultSoFar: je
          },
          _emitter: it
        };
      if (i)
        return {
          language: B,
          value: NS(H),
          illegal: !1,
          relevance: 0,
          errorRaised: be,
          _emitter: it,
          _top: Qe
        };
      throw be;
    }
  }
  function f(B) {
    const H = {
      value: NS(B),
      illegal: !1,
      relevance: 0,
      _top: o,
      _emitter: new s.__emitter(s)
    };
    return H._emitter.addText(B), H;
  }
  function p(B, H) {
    H = H || s.languages || Object.keys(e);
    const Y = f(B), ne = H.filter(k).filter(D).map(
      (pe) => d(pe, B, !1)
    );
    ne.unshift(Y);
    const J = ne.sort((pe, Be) => {
      if (pe.relevance !== Be.relevance) return Be.relevance - pe.relevance;
      if (pe.language && Be.language) {
        if (k(pe.language).supersetOf === Be.language)
          return 1;
        if (k(Be.language).supersetOf === pe.language)
          return -1;
      }
      return 0;
    }), [X, ie] = J, ye = X;
    return ye.secondBest = ie, ye;
  }
  function h(B, H, Y) {
    const ne = H && t[H] || Y;
    B.classList.add("hljs"), B.classList.add(`language-${ne}`);
  }
  function v(B) {
    let H = null;
    const Y = u(B);
    if (l(Y)) return;
    if (z(
      "before:highlightElement",
      { el: B, language: Y }
    ), B.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", B);
      return;
    }
    if (B.children.length > 0 && (s.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(B)), s.throwUnescapedHTML))
      throw new gxe(
        "One of your code blocks includes unescaped HTML.",
        B.innerHTML
      );
    H = B;
    const ne = H.textContent, J = Y ? c(ne, { language: Y, ignoreIllegals: !0 }) : p(ne);
    B.innerHTML = J.value, B.dataset.highlighted = "yes", h(B, Y, J.language), B.result = {
      language: J.language,
      // TODO: remove with version 11.0
      re: J.relevance,
      relevance: J.relevance
    }, J.secondBest && (B.secondBest = {
      language: J.secondBest.language,
      relevance: J.secondBest.relevance
    }), z("after:highlightElement", { el: B, result: J, text: ne });
  }
  function m(B) {
    s = oP(s, B);
  }
  const g = () => {
    _(), yf("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function y() {
    _(), yf("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let b = !1;
  function _() {
    if (document.readyState === "loading") {
      b = !0;
      return;
    }
    document.querySelectorAll(s.cssSelector).forEach(v);
  }
  function x() {
    b && _();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", x, !1);
  function w(B, H) {
    let Y = null;
    try {
      Y = H(n);
    } catch (ne) {
      if (sd("Language definition for '{}' could not be registered.".replace("{}", B)), i)
        sd(ne);
      else
        throw ne;
      Y = o;
    }
    Y.name || (Y.name = B), e[B] = Y, Y.rawDefinition = H.bind(null, n), Y.aliases && M(Y.aliases, { languageName: B });
  }
  function S(B) {
    delete e[B];
    for (const H of Object.keys(t))
      t[H] === B && delete t[H];
  }
  function C() {
    return Object.keys(e);
  }
  function k(B) {
    return B = (B || "").toLowerCase(), e[B] || e[t[B]];
  }
  function M(B, { languageName: H }) {
    typeof B == "string" && (B = [B]), B.forEach((Y) => {
      t[Y.toLowerCase()] = H;
    });
  }
  function D(B) {
    const H = k(B);
    return H && !H.disableAutodetect;
  }
  function N(B) {
    B["before:highlightBlock"] && !B["before:highlightElement"] && (B["before:highlightElement"] = (H) => {
      B["before:highlightBlock"](
        Object.assign({ block: H.el }, H)
      );
    }), B["after:highlightBlock"] && !B["after:highlightElement"] && (B["after:highlightElement"] = (H) => {
      B["after:highlightBlock"](
        Object.assign({ block: H.el }, H)
      );
    });
  }
  function R(B) {
    N(B), r.push(B);
  }
  function j(B) {
    const H = r.indexOf(B);
    H !== -1 && r.splice(H, 1);
  }
  function z(B, H) {
    const Y = B;
    r.forEach(function(ne) {
      ne[Y] && ne[Y](H);
    });
  }
  function F(B) {
    return yf("10.7.0", "highlightBlock will be removed entirely in v12.0"), yf("10.7.0", "Please use highlightElement now."), v(B);
  }
  Object.assign(n, {
    highlight: c,
    highlightAuto: p,
    highlightAll: _,
    highlightElement: v,
    // TODO: Remove with v12 API
    highlightBlock: F,
    configure: m,
    initHighlighting: g,
    initHighlightingOnLoad: y,
    registerLanguage: w,
    unregisterLanguage: S,
    listLanguages: C,
    getLanguage: k,
    registerAliases: M,
    autoDetection: D,
    inherit: oP,
    addPlugin: R,
    removePlugin: j
  }), n.debugMode = function() {
    i = !1;
  }, n.safeMode = function() {
    i = !0;
  }, n.versionString = mxe, n.regex = {
    concat: qd,
    lookahead: F7,
    either: iD,
    optional: I_e,
    anyNumberOfTimes: O_e
  };
  for (const B in qy)
    typeof qy[B] == "object" && $7(qy[B]);
  return Object.assign(n, qy), n;
}, jp = X7({});
jp.newInstance = () => X7({});
var bxe = jp;
jp.HighlightJS = jp;
jp.default = jp;
var _xe = /* @__PURE__ */ C_e(bxe);
function Z7(n, e = []) {
  return n.map((t) => {
    const r = [...e, ...t.properties ? t.properties.className : []];
    return t.children ? Z7(t.children, r) : {
      text: t.value,
      classes: r
    };
  }).flat();
}
function lP(n) {
  return n.value || n.children || [];
}
function xxe(n) {
  return !!_xe.getLanguage(n);
}
function uP({ doc: n, name: e, lowlight: t, defaultLanguage: r }) {
  const i = [];
  return nC(n, (a) => a.type.name === e).forEach((a) => {
    var o;
    let s = a.pos + 1;
    const l = a.node.attrs.language || r, u = t.listLanguages(), c = l && (u.includes(l) || xxe(l) || !((o = t.registered) === null || o === void 0) && o.call(t, l)) ? lP(t.highlight(l, a.node.textContent)) : lP(t.highlightAuto(a.node.textContent));
    Z7(c).forEach((d) => {
      const f = s + d.text.length;
      if (d.classes.length) {
        const p = zr.inline(s, f, {
          class: d.classes.join(" ")
        });
        i.push(p);
      }
      s = f;
    });
  }), Zn.create(n, i);
}
function wxe(n) {
  return typeof n == "function";
}
function Sxe({ name: n, lowlight: e, defaultLanguage: t }) {
  if (!["highlight", "highlightAuto", "listLanguages"].every((i) => wxe(e[i])))
    throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
  const r = new Pn({
    key: new jn("lowlight"),
    state: {
      init: (i, { doc: a }) => uP({
        doc: a,
        name: n,
        lowlight: e,
        defaultLanguage: t
      }),
      apply: (i, a, o, s) => {
        const l = o.selection.$head.parent.type.name, u = s.selection.$head.parent.type.name, c = nC(o.doc, (f) => f.type.name === n), d = nC(s.doc, (f) => f.type.name === n);
        return i.docChanged && ([l, u].includes(n) || d.length !== c.length || i.steps.some((f) => (
          // @ts-ignore
          f.from !== void 0 && f.to !== void 0 && c.some((p) => (
            // @ts-ignore
            p.pos >= f.from && p.pos + p.node.nodeSize <= f.to
          ))
        ))) ? uP({
          doc: i.doc,
          name: n,
          lowlight: e,
          defaultLanguage: t
        }) : a.map(i.mapping, i.doc);
      }
    },
    props: {
      decorations(i) {
        return r.getState(i);
      }
    }
  });
  return r;
}
const Exe = kH.extend({
  addOptions() {
    var n;
    return {
      ...(n = this.parent) === null || n === void 0 ? void 0 : n.call(this),
      lowlight: {},
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  addProseMirrorPlugins() {
    var n;
    return [
      ...((n = this.parent) === null || n === void 0 ? void 0 : n.call(this)) || [],
      Sxe({
        name: this.name,
        lowlight: this.options.lowlight,
        defaultLanguage: this.options.defaultLanguage
      })
    ];
  }
}), Txe = {
  components: {
    NodeViewWrapper: FM,
    NodeViewContent: Pve
  },
  props: CH,
  computed: {
    selectedLanguage: {
      get() {
        return this.node.attrs.language;
      },
      set(n) {
        this.updateAttributes({ language: n });
      }
    },
    languages() {
      return this.extension.options.lowlight.listLanguages().map((e) => ({
        label: e,
        value: e
      })).concat([{ label: "html", value: "xml" }]).sort((e, t) => e.label.localeCompare(t.label));
    }
  }
}, Cxe = { class: "code-block-container" }, kxe = ["value"];
function Axe(n, e, t, r, i, a) {
  const o = ol("node-view-content"), s = ol("node-view-wrapper");
  return L(), re(s, null, {
    default: ee(() => [
      G("div", Cxe, [
        ta(G("select", {
          class: "language-selector form-select py-0",
          contenteditable: "false",
          "onUpdate:modelValue": e[0] || (e[0] = (l) => a.selectedLanguage = l)
        }, [
          e[1] || (e[1] = G("option", { value: null }, "auto", -1)),
          e[2] || (e[2] = G("option", { disabled: "" }, "—", -1)),
          (L(!0), W(Ke, null, _t(a.languages, (l, u) => (L(), W("option", {
            value: l.value,
            key: l.value
          }, ke(l.label), 9, kxe))), 128))
        ], 512), [
          [RZ, a.selectedLanguage]
        ]),
        G("pre", null, [
          G("code", null, [
            se(o)
          ])
        ])
      ])
    ]),
    _: 1
  });
}
const Mxe = /* @__PURE__ */ zt(Txe, [["render", Axe]]);
function Dxe(n) {
  var e;
  const { char: t, allowSpaces: r, allowToIncludeChar: i, allowedPrefixes: a, startOfLine: o, $position: s } = n, l = r && !i, u = Zpe(t), c = new RegExp(`\\s${u}$`), d = o ? "^" : "", f = i ? "" : u, p = l ? new RegExp(`${d}${u}.*?(?=\\s${f}|$)`, "gm") : new RegExp(`${d}(?:^)?${u}[^\\s${f}]*`, "gm"), h = ((e = s.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && s.nodeBefore.text;
  if (!h)
    return null;
  const v = s.pos - h.length, m = Array.from(h.matchAll(p)).pop();
  if (!m || m.input === void 0 || m.index === void 0)
    return null;
  const g = m.input.slice(Math.max(0, m.index - 1), m.index), y = new RegExp(`^[${a == null ? void 0 : a.join("")}\0]?$`).test(g);
  if (a !== null && !y)
    return null;
  const b = v + m.index;
  let _ = b + m[0].length;
  return l && c.test(h.slice(_ - 1, _ + 1)) && (m[0] += " ", _ += 1), b < s.pos && _ >= s.pos ? {
    range: {
      from: b,
      to: _
    },
    query: m[0].slice(t.length),
    text: m[0]
  } : null;
}
const Oxe = new jn("suggestion");
function Ixe({ pluginKey: n = Oxe, editor: e, char: t = "@", allowSpaces: r = !1, allowToIncludeChar: i = !1, allowedPrefixes: a = [" "], startOfLine: o = !1, decorationTag: s = "span", decorationClass: l = "suggestion", decorationContent: u = "", decorationEmptyClass: c = "is-empty", command: d = () => null, items: f = () => [], render: p = () => ({}), allow: h = () => !0, findSuggestionMatch: v = Dxe }) {
  let m;
  const g = p == null ? void 0 : p(), y = new Pn({
    key: n,
    view() {
      return {
        update: async (b, _) => {
          var x, w, S, C, k, M, D;
          const N = (x = this.key) === null || x === void 0 ? void 0 : x.getState(_), R = (w = this.key) === null || w === void 0 ? void 0 : w.getState(b.state), j = N.active && R.active && N.range.from !== R.range.from, z = !N.active && R.active, F = N.active && !R.active, B = !z && !F && N.query !== R.query, H = z || j && B, Y = B || j, ne = F || j && B;
          if (!H && !Y && !ne)
            return;
          const J = ne && !H ? N : R, X = b.dom.querySelector(`[data-decoration-id="${J.decorationId}"]`);
          m = {
            editor: e,
            range: J.range,
            query: J.query,
            text: J.text,
            items: [],
            command: (ie) => d({
              editor: e,
              range: J.range,
              props: ie
            }),
            decorationNode: X,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: X ? () => {
              var ie;
              const { decorationId: ye } = (ie = this.key) === null || ie === void 0 ? void 0 : ie.getState(e.state), pe = b.dom.querySelector(`[data-decoration-id="${ye}"]`);
              return (pe == null ? void 0 : pe.getBoundingClientRect()) || null;
            } : null
          }, H && ((S = g == null ? void 0 : g.onBeforeStart) === null || S === void 0 || S.call(g, m)), Y && ((C = g == null ? void 0 : g.onBeforeUpdate) === null || C === void 0 || C.call(g, m)), (Y || H) && (m.items = await f({
            editor: e,
            query: J.query
          })), ne && ((k = g == null ? void 0 : g.onExit) === null || k === void 0 || k.call(g, m)), Y && ((M = g == null ? void 0 : g.onUpdate) === null || M === void 0 || M.call(g, m)), H && ((D = g == null ? void 0 : g.onStart) === null || D === void 0 || D.call(g, m));
        },
        destroy: () => {
          var b;
          m && ((b = g == null ? void 0 : g.onExit) === null || b === void 0 || b.call(g, m));
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        return {
          active: !1,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: !1
        };
      },
      // Apply changes to the plugin state from a view transaction.
      apply(b, _, x, w) {
        const { isEditable: S } = e, { composing: C } = e.view, { selection: k } = b, { empty: M, from: D } = k, N = { ..._ };
        if (N.composing = C, S && (M || e.view.composing)) {
          (D < _.range.from || D > _.range.to) && !C && !_.composing && (N.active = !1);
          const R = v({
            char: t,
            allowSpaces: r,
            allowToIncludeChar: i,
            allowedPrefixes: a,
            startOfLine: o,
            $position: k.$from
          }), j = `id_${Math.floor(Math.random() * 4294967295)}`;
          R && h({
            editor: e,
            state: w,
            range: R.range,
            isActive: _.active
          }) ? (N.active = !0, N.decorationId = _.decorationId ? _.decorationId : j, N.range = R.range, N.query = R.query, N.text = R.text) : N.active = !1;
        } else
          N.active = !1;
        return N.active || (N.decorationId = null, N.range = { from: 0, to: 0 }, N.query = null, N.text = null), N;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(b, _) {
        var x;
        const { active: w, range: S } = y.getState(b.state);
        return w && ((x = g == null ? void 0 : g.onKeyDown) === null || x === void 0 ? void 0 : x.call(g, { view: b, event: _, range: S })) || !1;
      },
      // Setup decorator on the currently active suggestion.
      decorations(b) {
        const { active: _, range: x, decorationId: w, query: S } = y.getState(b);
        if (!_)
          return null;
        const C = !(S != null && S.length), k = [l];
        return C && k.push(c), Zn.create(b.doc, [
          zr.inline(x.from, x.to, {
            nodeName: s,
            class: k.join(" "),
            "data-decoration-id": w,
            "data-decoration-content": u
          })
        ]);
      }
    }
  });
  return y;
}
function jx(n) {
  return Qn.create({
    name: n.name,
    addOptions() {
      return {
        ...n.addOptions ? n.addOptions.call(this) : {},
        suggestion: {
          char: n.char,
          pluginKey: n.pluginKey,
          items: n.items,
          command: n.command,
          allowSpaces: n.allowSpaces,
          startOfLine: n.startOfLine,
          decorationTag: n.decorationTag || "span",
          decorationClass: n.decorationClass || "suggestion",
          render: () => {
            let t, r;
            return {
              onStart: (i) => {
                if (t = new TH(n.component, {
                  editor: i.editor,
                  props: i
                }), !i.clientRect || !t.element)
                  return;
                const a = {
                  getReferenceClientRect: i.clientRect,
                  appendTo: () => document.body,
                  content: t.element,
                  showOnCreate: !0,
                  interactive: !0,
                  trigger: "manual",
                  placement: "bottom-start"
                };
                r = qu("body", {
                  ...a,
                  ...n.tippyOptions
                });
              },
              onUpdate(i) {
                t == null || t.updateProps(i), i.clientRect && r && r[0] && r[0].setProps({
                  getReferenceClientRect: i.clientRect
                });
              },
              onKeyDown(i) {
                return i.event.key === "Escape" ? (r && r[0] && r[0].hide(), !0) : t && t.ref && typeof t.ref.onKeyDown == "function" ? t.ref.onKeyDown(i) : !1;
              },
              onExit() {
                r && r[0] && r[0].destroy(), t && t.destroy(), r = null, t = null;
              }
            };
          }
        }
      };
    },
    addProseMirrorPlugins() {
      return [
        Ixe({
          editor: this.editor,
          ...this.options.suggestion
        })
      ];
    }
  });
}
const Lxe = ["onClick", "onMouseover"], Nxe = {
  key: 0,
  class: "px-3 py-1.5 text-sm text-ink-gray-5"
}, Bx = /* @__PURE__ */ ve({
  __name: "SuggestionList",
  props: {
    items: {
      type: Array,
      required: !0
    },
    command: {
      type: Function,
      required: !0
    },
    containerClass: {
      type: String,
      default: ""
    },
    itemClass: {
      type: String,
      default: ""
    },
    showNoResults: {
      type: Boolean,
      default: !1
    }
  },
  setup(n, { expose: e }) {
    const t = n, r = Z(0), i = Z(null), a = Z([]);
    PZ(() => {
      a.value = [];
    });
    const o = () => {
      Wt(() => {
        const f = a.value[r.value];
        f && f.scrollIntoView({ block: "nearest" });
      });
    }, s = (f) => {
      const p = t.items[f];
      p && t.command(p);
    }, l = ({ event: f }) => t.items.length ? f.key === "ArrowUp" ? (u(), !0) : f.key === "ArrowDown" ? (c(), !0) : f.key === "Enter" ? (d(), !0) : !1 : !1, u = () => {
      r.value = (r.value + t.items.length - 1) % t.items.length, o();
    }, c = () => {
      r.value = (r.value + 1) % t.items.length, o();
    }, d = () => {
      s(r.value);
    };
    return et(
      () => t.items,
      () => {
        r.value = 0;
      }
    ), e({
      onKeyDown: l
    }), (f, p) => n.items.length ? (L(), W("div", {
      key: 0,
      ref_key: "container",
      ref: i,
      class: _e(["relative max-h-[300px] min-w-40 overflow-y-auto rounded-lg bg-surface-white p-1 text-base shadow-lg", n.containerClass])
    }, [
      (L(!0), W(Ke, null, _t(n.items, (h, v) => (L(), W("button", {
        key: v,
        ref_for: !0,
        ref: (m) => {
          m && (a.value[v] = m);
        },
        class: _e([
          "flex w-full items-center whitespace-nowrap rounded-md px-2 py-1.5 text-sm text-ink-gray-9",
          v === r.value ? "bg-surface-gray-2" : "",
          n.itemClass
        ]),
        onClick: (m) => s(v),
        onMouseover: (m) => r.value = v
      }, [
        ue(f.$slots, "default", {
          item: h,
          index: v
        }, () => [
          G("span", null, ke(h.display || h.title || h.name), 1)
        ])
      ], 42, Lxe))), 128)),
      !n.items.length && n.showNoResults ? (L(), W("div", Nxe, " No results ")) : ge("", !0)
    ], 2)) : ge("", !0);
  }
});
function Rxe(n) {
  const e = {
    name: "mention",
    group: "inline",
    inline: !0,
    selectable: !0,
    atom: !0,
    addOptions() {
      return {
        component: void 0
      };
    },
    addAttributes() {
      return {
        id: {
          default: null,
          parseHTML: (t) => t.getAttribute("data-id"),
          renderHTML: (t) => t.id ? { "data-id": t.id } : {}
        },
        label: {
          default: null,
          parseHTML: (t) => t.getAttribute("data-label"),
          renderHTML: (t) => t.label ? { "data-label": t.label } : {}
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: 'span.mention[data-type="mention"]',
          getAttrs: (t) => {
            const r = t;
            return {
              id: r.getAttribute("data-id"),
              label: r.getAttribute("data-label")
            };
          }
        }
      ];
    },
    renderHTML({ HTMLAttributes: t }) {
      return [
        "span",
        Mn(t, {
          class: "mention",
          "data-type": "mention"
        }),
        `@${t["data-label"] || t.id || ""}`
      ];
    }
  };
  return n && (e.addNodeView = () => Ix(n)), pr.create(e);
}
const Pxe = jx({
  name: "mentionSuggestion",
  char: "@",
  pluginKey: new jn("mentionSuggestion"),
  component: Bx,
  addOptions() {
    return {
      mentions: []
    };
  },
  items: ({ query: n, editor: e }) => {
    const { mentions: t } = e.extensionManager.extensions.find(
      (a) => a.name === "mentionSuggestion"
    ).options;
    return Ir(t).filter(
      (a) => a.label.toLowerCase().startsWith(n.toLowerCase())
    ).slice(0, 10).map((a) => ({
      ...a,
      display: a.label
    }));
  },
  command: ({ editor: n, range: e, props: t }) => {
    const r = {
      id: t.id || t.value,
      label: t.label
    };
    n.chain().focus().insertContentAt(e, [
      {
        type: "mention",
        attrs: r
      },
      {
        type: "text",
        text: " "
      }
    ]).run();
  },
  tippyOptions: {
    placement: "bottom-start",
    offset: [0, 8]
  },
  allowSpaces: !1,
  decorationTag: "span",
  decorationClass: "mention-suggestion-active"
}), jxe = Qn.create({
  name: "mentionExtension",
  addOptions() {
    return {
      mentions: [],
      component: void 0
    };
  },
  addExtensions() {
    return [
      Rxe(this.options.component),
      Pxe.configure({
        mentions: this.options.mentions
      })
    ];
  }
}), Bxe = {
  name: "TipTapMenu",
  props: ["buttons"],
  inject: ["editor"],
  components: {
    Popover: th
  },
  methods: {
    onButtonClick(n) {
      n.action(this.editor);
    }
  }
}, $xe = { class: "inline-flex bg-surface-white px-1 py-1" }, zxe = { class: "inline-flex items-center gap-1" }, Fxe = {
  key: 0,
  class: "h-4 w-[2px] border-l"
}, Vxe = {
  key: 1,
  class: "shrink-0"
}, Hxe = ["onClick", "set"], Gxe = { key: 1 }, Uxe = { class: "p-1.5 mt-2 rounded-lg bg-surface-modal shadow-2xl ring-1 ring-black ring-opacity-5 focus:outline-none" }, Wxe = ["onClick"], qxe = {
  key: 1,
  class: "whitespace-nowrap text-ink-gray-7"
}, Yxe = ["onClick", "title"], Kxe = {
  key: 1,
  class: "inline-block h-4 min-w-[1rem] text-sm leading-4"
};
function Xxe(n, e, t, r, i, a) {
  const o = th;
  return L(), W("div", $xe, [
    G("div", zxe, [
      (L(!0), W(Ke, null, _t(t.buttons, (s) => (L(), W(Ke, {
        key: s.label
      }, [
        s.type === "separator" ? (L(), W("div", Fxe)) : s.map ? (L(), W("div", Vxe, [
          se(o, null, {
            target: ee(({ togglePopover: l }) => [
              G("button", {
                class: "rounded px-2 py-1 text-base font-medium text-ink-gray-8 transition-colors hover:bg-surface-gray-2",
                onClick: l,
                set: n.activeBtn = s.find((u) => u.isActive(a.editor)) || s[0]
              }, [
                n.activeBtn.icon ? (L(), re(bn(n.activeBtn.icon), {
                  key: 0,
                  class: "h-4 w-4"
                })) : (L(), W("span", Gxe, ke(n.activeBtn.label), 1))
              ], 8, Hxe)
            ]),
            body: ee(({ close: l }) => [
              G("ul", Uxe, [
                (L(!0), W(Ke, null, _t(s, (u) => ta((L(), W("li", null, [
                  G("button", {
                    class: "h-7 rounded px-2 text-base flex items-center gap-2 hover:bg-surface-gray-3",
                    onClick: () => {
                      a.onButtonClick(u), l();
                    }
                  }, [
                    u.icon ? (L(), re(bn(u.icon), {
                      key: 0,
                      class: "size-4 flex-shrink-0 text-ink-gray-6"
                    })) : ge("", !0),
                    u.label ? (L(), W("span", qxe, ke(u.label), 1)) : ge("", !0)
                  ], 8, Wxe)
                ], 512)), [
                  [hs, u.isDisabled ? !u.isDisabled(a.editor) : !0]
                ])), 256))
              ])
            ]),
            _: 2
          }, 1024)
        ])) : (L(), re(bn(s.component || "div"), He({
          key: 2,
          ref_for: !0
        }, { editor: a.editor }), {
          default: ee((l) => [
            G("button", {
              class: _e(["flex rounded p-1 text-ink-gray-8 transition-colors", [
                s.isActive(a.editor) || l != null && l.isActive ? "bg-surface-gray-3" : "hover:bg-surface-gray-2",
                s.class
              ]]),
              onClick: (u) => l != null && l.onClick ? l.onClick(s) : a.onButtonClick(s),
              title: s.label
            }, [
              s.icon ? (L(), re(bn(s.icon), {
                key: 0,
                class: "h-4 w-4"
              })) : (L(), W("span", Kxe, ke(s.text), 1))
            ], 10, Yxe)
          ]),
          _: 2
        }, 1040))
      ], 64))), 128))
    ])
  ]);
}
const $x = /* @__PURE__ */ zt(Bxe, [["render", Xxe]]), Zxe = {}, Jxe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function Qxe(n, e) {
  return L(), W("svg", Jxe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0H24V24H0z"
    }, null, -1),
    G("path", {
      d: "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm8-12v12h-2v-9.796l-2 .536V8.67L19.5 8H21z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const ewe = /* @__PURE__ */ zt(Zxe, [["render", Qxe]]), twe = {}, nwe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function rwe(n, e) {
  return L(), W("svg", nwe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0H24V24H0z"
    }, null, -1),
    G("path", {
      d: "M4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 4c2.071 0 3.75 1.679 3.75 3.75 0 .857-.288 1.648-.772 2.28l-.148.18L18.034 18H22v2h-7v-1.556l4.82-5.546c.268-.307.43-.709.43-1.148 0-.966-.784-1.75-1.75-1.75-.918 0-1.671.707-1.744 1.606l-.006.144h-2C14.75 9.679 16.429 8 18.5 8z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const iwe = /* @__PURE__ */ zt(twe, [["render", rwe]]), awe = {}, owe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function swe(n, e) {
  return L(), W("svg", owe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0H24V24H0z"
    }, null, -1),
    G("path", {
      d: "M22 8l-.002 2-2.505 2.883c1.59.435 2.757 1.89 2.757 3.617 0 2.071-1.679 3.75-3.75 3.75-1.826 0-3.347-1.305-3.682-3.033l1.964-.382c.156.806.866 1.415 1.718 1.415.966 0 1.75-.784 1.75-1.75s-.784-1.75-1.75-1.75c-.286 0-.556.069-.794.19l-1.307-1.547L19.35 10H15V8h7zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const lwe = /* @__PURE__ */ zt(awe, [["render", swe]]), uwe = {}, cwe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function dwe(n, e) {
  return L(), W("svg", cwe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0H24V24H0z"
    }, null, -1),
    G("path", {
      d: "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm9-12v8h1.5v2H22v2h-2v-2h-5.5v-1.34l5-8.66H22zm-2 3.133L17.19 16H20v-4.867z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const fwe = /* @__PURE__ */ zt(uwe, [["render", dwe]]), pwe = {}, hwe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function vwe(n, e) {
  return L(), W("svg", hwe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0H24V24H0z"
    }, null, -1),
    G("path", {
      d: "M22 8v2h-4.323l-.464 2.636c.33-.089.678-.136 1.037-.136 2.21 0 4 1.79 4 4s-1.79 4-4 4c-1.827 0-3.367-1.224-3.846-2.897l1.923-.551c.24.836 1.01 1.448 1.923 1.448 1.105 0 2-.895 2-2s-.895-2-2-2c-.63 0-1.193.292-1.56.748l-1.81-.904L16 8h6zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const mwe = /* @__PURE__ */ zt(pwe, [["render", vwe]]), gwe = {}, ywe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function bwe(n, e) {
  return L(), W("svg", ywe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0H24V24H0z"
    }, null, -1),
    G("path", {
      d: "M21.097 8l-2.598 4.5c2.21 0 4.001 1.79 4.001 4s-1.79 4-4 4-4-1.79-4-4c0-.736.199-1.426.546-2.019L18.788 8h2.309zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 10.5c-1.105 0-2 .895-2 2s.895 2 2 2 2-.895 2-2-.895-2-2-2z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const _we = /* @__PURE__ */ zt(gwe, [["render", bwe]]), xwe = {}, wwe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function Swe(n, e) {
  return L(), W("svg", wwe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M13 6v15h-2V6H5V4h14v2z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const Ewe = /* @__PURE__ */ zt(xwe, [["render", Swe]]), Twe = {}, Cwe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function kwe(n, e) {
  return L(), W("svg", Cwe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M8 11h4.5a2.5 2.5 0 1 0 0-5H8v5zm10 4.5a4.5 4.5 0 0 1-4.5 4.5H6V4h6.5a4.5 4.5 0 0 1 3.256 7.606A4.498 4.498 0 0 1 18 15.5zM8 13v5h5.5a2.5 2.5 0 1 0 0-5H8z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const Awe = /* @__PURE__ */ zt(Twe, [["render", kwe]]), Mwe = {}, Dwe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function Owe(n, e) {
  return L(), W("svg", Dwe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M15 20H7v-2h2.927l2.116-12H9V4h8v2h-2.927l-2.116 12H15z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const Iwe = /* @__PURE__ */ zt(Mwe, [["render", Owe]]), Lwe = {}, Nwe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function Rwe(n, e) {
  return L(), W("svg", Nwe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M8 3v9a4 4 0 1 0 8 0V3h2v9a6 6 0 1 1-12 0V3h2zM4 20h16v2H4v-2z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const Pwe = /* @__PURE__ */ zt(Lwe, [["render", Rwe]]), jwe = {}, Bwe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function $we(n, e) {
  return L(), W("svg", Bwe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M17.154 14c.23.516.346 1.09.346 1.72 0 1.342-.524 2.392-1.571 3.147C14.88 19.622 13.433 20 11.586 20c-1.64 0-3.263-.381-4.87-1.144V16.6c1.52.877 3.075 1.316 4.666 1.316 2.551 0 3.83-.732 3.839-2.197a2.21 2.21 0 0 0-.648-1.603l-.12-.117H3v-2h18v2h-3.846zm-4.078-3H7.629a4.086 4.086 0 0 1-.481-.522C6.716 9.92 6.5 9.246 6.5 8.452c0-1.236.466-2.287 1.397-3.153C8.83 4.433 10.271 4 12.222 4c1.471 0 2.879.328 4.222.984v2.152c-1.2-.687-2.515-1.03-3.946-1.03-2.48 0-3.719.782-3.719 2.346 0 .42.218.786.654 1.099.436.313.974.562 1.613.75.62.18 1.297.414 2.03.699z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const zwe = /* @__PURE__ */ zt(jwe, [["render", $we]]), Fwe = {}, Vwe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function Hwe(n, e) {
  return L(), W("svg", Vwe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M3 4h18v2H3V4zm2 15h14v2H5v-2zm-2-5h18v2H3v-2zm2-5h14v2H5V9z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const Gwe = /* @__PURE__ */ zt(Fwe, [["render", Hwe]]), Uwe = {}, Wwe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function qwe(n, e) {
  return L(), W("svg", Wwe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M3 4h18v2H3V4zm0 15h14v2H3v-2zm0-5h18v2H3v-2zm0-5h14v2H3V9z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const Ywe = /* @__PURE__ */ zt(Uwe, [["render", qwe]]), Kwe = {}, Xwe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function Zwe(n, e) {
  return L(), W("svg", Xwe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M3 4h18v2H3V4zm4 15h14v2H7v-2zm-4-5h18v2H3v-2zm4-5h14v2H7V9z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const Jwe = /* @__PURE__ */ zt(Kwe, [["render", Zwe]]), Qwe = {}, eSe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function tSe(n, e) {
  return L(), W("svg", eSe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M15.246 14H8.754l-1.6 4H5l6-15h2l6 15h-2.154l-1.6-4zm-.8-2L12 5.885 9.554 12h4.892zM3 20h18v2H3v-2z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const nSe = /* @__PURE__ */ zt(Qwe, [["render", tSe]]), rSe = {}, iSe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function aSe(n, e) {
  return L(), W("svg", iSe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M8 4h13v2H8V4zM5 3v3h1v1H3V6h1V4H3V3h2zM3 14v-2.5h2V11H3v-1h3v2.5H4v.5h2v1H3zm2 5.5H3v-1h2V18H3v-1h3v4H3v-1h2v-.5zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const oSe = /* @__PURE__ */ zt(rSe, [["render", aSe]]), sSe = {}, lSe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function uSe(n, e) {
  return L(), W("svg", lSe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M8 4h13v2H8V4zM4.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 6.9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const cSe = /* @__PURE__ */ zt(sSe, [["render", uSe]]), dSe = {}, fSe = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  class: "lucide lucide-list-checks-icon lucide-list-checks"
};
function pSe(n, e) {
  return L(), W("svg", fSe, [...e[0] || (e[0] = [
    Zp('<path d="m3 17 2 2 4-4"></path><path d="m3 7 2 2 4-4"></path><path d="M13 6h8"></path><path d="M13 12h8"></path><path d="M13 18h8"></path>', 5)
  ])]);
}
const hSe = /* @__PURE__ */ zt(dSe, [["render", pSe]]), vSe = {}, mSe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function gSe(n, e) {
  return L(), W("svg", mSe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M19.417 6.679C20.447 7.773 21 9 21 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311-1.804-.167-3.226-1.648-3.226-3.489a3.5 3.5 0 0 1 3.5-3.5c1.073 0 2.099.49 2.748 1.179zm-10 0C10.447 7.773 11 9 11 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311C4.591 12.322 3.17 10.841 3.17 9a3.5 3.5 0 0 1 3.5-3.5c1.073 0 2.099.49 2.748 1.179z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const ySe = /* @__PURE__ */ zt(vSe, [["render", gSe]]), bSe = {}, _Se = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function xSe(n, e) {
  return L(), W("svg", _Se, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M16.95 8.464l1.414-1.414 4.95 4.95-4.95 4.95-1.414-1.414L20.485 12 16.95 8.464zm-9.9 0L3.515 12l3.535 3.536-1.414 1.414L.686 12l4.95-4.95L7.05 8.464z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const wSe = /* @__PURE__ */ zt(bSe, [["render", xSe]]), SSe = {}, ESe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function TSe(n, e) {
  return L(), W("svg", ESe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M18.364 15.536L16.95 14.12l1.414-1.414a5 5 0 1 0-7.071-7.071L9.879 7.05 8.464 5.636 9.88 4.222a7 7 0 0 1 9.9 9.9l-1.415 1.414zm-2.828 2.828l-1.415 1.414a7 7 0 0 1-9.9-9.9l1.415-1.414L7.05 9.88l-1.414 1.414a5 5 0 1 0 7.071 7.071l1.414-1.414 1.415 1.414zm-.708-10.607l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const CSe = /* @__PURE__ */ zt(SSe, [["render", TSe]]), kSe = {}, ASe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function MSe(n, e) {
  return L(), W("svg", ASe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M21 15v3h3v2h-3v3h-2v-3h-3v-2h3v-3h2zm.008-12c.548 0 .992.445.992.993V13h-2V5H4v13.999L14 9l3 3v2.829l-3-3L6.827 19H14v2H2.992A.993.993 0 0 1 2 20.007V3.993A1 1 0 0 1 2.992 3h18.016zM8 7a2 2 0 1 1 0 4 2 2 0 0 1 0-4z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const DSe = /* @__PURE__ */ zt(kSe, [["render", MSe]]), OSe = {}, ISe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function LSe(n, e) {
  return L(), W("svg", ISe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0H24V24H0z"
    }, null, -1),
    G("path", {
      d: "M16 4c.552 0 1 .448 1 1v4.2l5.213-3.65c.226-.158.538-.103.697.124.058.084.09.184.09.286v12.08c0 .276-.224.5-.5.5-.103 0-.203-.032-.287-.09L17 14.8V19c0 .552-.448 1-1 1H2c-.552 0-1-.448-1-1V5c0-.552.448-1 1-1h14zm-1 2H3v12h12V6zM8 8h2v3h3v2H9.999L10 16H8l-.001-3H5v-2h3V8zm13 .841l-4 2.8v.718l4 2.8V8.84z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const NSe = /* @__PURE__ */ zt(OSe, [["render", LSe]]), RSe = {}, PSe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function jSe(n, e) {
  return L(), W("svg", PSe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M5.828 7l2.536 2.536L6.95 10.95 2 6l4.95-4.95 1.414 1.414L5.828 5H13a8 8 0 1 1 0 16H4v-2h9a6 6 0 1 0 0-12H5.828z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const BSe = /* @__PURE__ */ zt(RSe, [["render", jSe]]), $Se = {}, zSe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function FSe(n, e) {
  return L(), W("svg", zSe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M18.172 7H11a6 6 0 1 0 0 12h9v2h-9a8 8 0 1 1 0-16h7.172l-2.536-2.536L17.05 1.05 22 6l-4.95 4.95-1.414-1.414L18.172 7z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const VSe = /* @__PURE__ */ zt($Se, [["render", FSe]]), HSe = {}, GSe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function USe(n, e) {
  return L(), W("svg", GSe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M2 11h2v2H2v-2zm4 0h12v2H6v-2zm14 0h2v2h-2v-2z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const WSe = /* @__PURE__ */ zt(HSe, [["render", USe]]), qSe = {}, YSe = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  width: "24",
  height: "24"
};
function KSe(n, e) {
  return L(), W("svg", YSe, [...e[0] || (e[0] = [
    G("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }, null, -1),
    G("path", {
      d: "M13 10v4h6v-4h-6zm-2 0H5v4h6v-4zm2 9h6v-3h-6v3zm-2 0v-3H5v3h6zm2-14v3h6V5h-6zm-2 0H5v3h6V5zM4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z",
      fill: "currentColor"
    }, null, -1)
  ])]);
}
const XSe = /* @__PURE__ */ zt(qSe, [["render", KSe]]), ZSe = {
  Paragraph: {
    label: "Paragraph",
    icon: Ewe,
    action: (n) => n.chain().focus().setParagraph().run(),
    isActive: (n) => n.isActive("paragraph")
  },
  "Heading 1": {
    label: "Heading 1",
    text: "H1",
    icon: ewe,
    action: (n) => n.chain().focus().toggleHeading({ level: 1 }).run(),
    isActive: (n) => n.isActive("heading", { level: 1 })
  },
  "Heading 2": {
    label: "Heading 2",
    text: "H2",
    icon: iwe,
    action: (n) => n.chain().focus().toggleHeading({ level: 2 }).run(),
    isActive: (n) => n.isActive("heading", { level: 2 })
  },
  "Heading 3": {
    label: "Heading 3",
    text: "H3",
    icon: lwe,
    action: (n) => n.chain().focus().toggleHeading({ level: 3 }).run(),
    isActive: (n) => n.isActive("heading", { level: 3 })
  },
  "Heading 4": {
    label: "Heading 4",
    text: "H4",
    icon: fwe,
    action: (n) => n.chain().focus().toggleHeading({ level: 4 }).run(),
    isActive: (n) => n.isActive("heading", { level: 4 })
  },
  "Heading 5": {
    label: "Heading 5",
    text: "H5",
    icon: mwe,
    action: (n) => n.chain().focus().toggleHeading({ level: 5 }).run(),
    isActive: (n) => n.isActive("heading", { level: 5 })
  },
  "Heading 6": {
    label: "Heading 6",
    text: "H6",
    icon: _we,
    action: (n) => n.chain().focus().toggleHeading({ level: 6 }).run(),
    isActive: (n) => n.isActive("heading", { level: 6 })
  },
  Bold: {
    label: "Bold",
    icon: Awe,
    action: (n) => n.chain().focus().toggleBold().run(),
    isActive: (n) => n.isActive("bold")
  },
  Italic: {
    label: "Italic",
    icon: Iwe,
    action: (n) => n.chain().focus().toggleItalic().run(),
    isActive: (n) => n.isActive("italic")
  },
  Underline: {
    label: "Underline",
    icon: Pwe,
    action: (n) => n.chain().focus().toggleUnderline().run(),
    isActive: (n) => n.isActive("underline")
  },
  Strikethrough: {
    label: "Strikethrough",
    icon: zwe,
    action: (n) => n.chain().focus().toggleStrike().run(),
    isActive: (n) => n.isActive("strike")
  },
  "Bullet List": {
    label: "Bullet List",
    icon: cSe,
    action: (n) => n.chain().focus().toggleBulletList().run(),
    isActive: (n) => n.isActive("bulletList")
  },
  "Numbered List": {
    label: "Numbered List",
    icon: oSe,
    action: (n) => n.chain().focus().toggleOrderedList().run(),
    isActive: (n) => n.isActive("orderedList")
  },
  "Task List": {
    label: "Task List",
    icon: hSe,
    action: (n) => n.chain().focus().toggleTaskList().run(),
    isActive: (n) => n.isActive("taskList")
  },
  "Align Center": {
    label: "Align Center",
    icon: Gwe,
    action: (n) => n.chain().focus().setTextAlign("center").run(),
    isActive: (n) => n.isActive({ textAlign: "center" })
  },
  "Align Left": {
    label: "Align Left",
    icon: Ywe,
    action: (n) => n.chain().focus().setTextAlign("left").run(),
    isActive: (n) => n.isActive({ textAlign: "left" })
  },
  "Align Right": {
    label: "Align Right",
    icon: Jwe,
    action: (n) => n.chain().focus().setTextAlign("right").run(),
    isActive: (n) => n.isActive({ textAlign: "right" })
  },
  FontColor: {
    label: "Font Color",
    icon: nSe,
    isActive: (n) => n.isActive("textStyle") || n.isActive("highlight"),
    component: my(() => import("./FontColor-XkMo1nBj.js"))
  },
  Blockquote: {
    label: "Blockquote",
    icon: ySe,
    action: (n) => n.chain().focus().toggleBlockquote().run(),
    isActive: (n) => n.isActive("blockquote")
  },
  Code: {
    label: "Code",
    icon: wSe,
    action: (n) => n.chain().focus().toggleCodeBlock().run(),
    isActive: (n) => n.isActive("codeBlock")
  },
  "Horizontal Rule": {
    label: "Horizontal Rule",
    icon: WSe,
    action: (n) => n.chain().focus().setHorizontalRule().run(),
    isActive: (n) => !1
  },
  Link: {
    label: "Link",
    icon: CSe,
    isActive: (n) => n.isActive("link"),
    component: my(() => import("./InsertLink-BluZp4Pf.js"))
  },
  Image: {
    label: "Image",
    icon: DSe,
    isActive: (n) => !1,
    component: my(() => import("./InsertImage-DE3Ro9JO.js"))
  },
  Video: {
    label: "Video",
    icon: NSe,
    isActive: (n) => !1,
    component: my(() => import("./InsertVideo-DhX_NG_G.js"))
  },
  Undo: {
    label: "Undo",
    icon: BSe,
    action: (n) => n.chain().focus().undo().run(),
    isActive: (n) => !1
  },
  Redo: {
    label: "Redo",
    icon: VSe,
    action: (n) => n.chain().focus().redo().run(),
    isActive: (n) => !1
  },
  InsertTable: {
    label: "Insert Table",
    icon: XSe,
    action: (n) => n.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: !0 }).run(),
    isActive: (n) => !1
  },
  AddColumnBefore: {
    label: "Add Column Before",
    action: (n) => n.chain().focus().addColumnBefore().run(),
    isActive: (n) => !1,
    isDisabled: (n) => !n.can().addColumnBefore()
  },
  AddColumnAfter: {
    label: "Add Column After",
    action: (n) => n.chain().focus().addColumnAfter().run(),
    isActive: (n) => !1,
    isDisabled: (n) => !n.can().addColumnAfter()
  },
  DeleteColumn: {
    label: "Delete Column",
    action: (n) => n.chain().focus().deleteColumn().run(),
    isActive: (n) => !1,
    isDisabled: (n) => !n.can().deleteColumn()
  },
  AddRowBefore: {
    label: "Add Row Before",
    action: (n) => n.chain().focus().addRowBefore().run(),
    isActive: (n) => !1,
    isDisabled: (n) => !n.can().addRowBefore()
  },
  AddRowAfter: {
    label: "Add Row After",
    action: (n) => n.chain().focus().addRowAfter().run(),
    isActive: (n) => !1,
    isDisabled: (n) => !n.can().addRowAfter()
  },
  DeleteRow: {
    label: "Delete Row",
    action: (n) => n.chain().focus().deleteRow().run(),
    isActive: (n) => !1,
    isDisabled: (n) => !n.can().deleteRow()
  },
  DeleteTable: {
    label: "Delete Table",
    action: (n) => n.chain().focus().deleteTable().run(),
    isActive: (n) => !1,
    isDisabled: (n) => !n.can().deleteTable()
  },
  MergeCells: {
    label: "Merge Cells",
    action: (n) => n.chain().focus().mergeCells().run(),
    isActive: (n) => !1,
    isDisabled: (n) => !n.can().mergeCells()
  },
  SplitCell: {
    label: "Split Cell",
    action: (n) => n.chain().focus().splitCell().run(),
    isActive: (n) => !1,
    isDisabled: (n) => !n.can().splitCell()
  },
  ToggleHeaderColumn: {
    label: "Toggle Header Column",
    action: (n) => n.chain().focus().toggleHeaderColumn().run(),
    isActive: (n) => !1,
    isDisabled: (n) => !n.can().toggleHeaderColumn()
  },
  ToggleHeaderRow: {
    label: "Toggle Header Row",
    action: (n) => n.chain().focus().toggleHeaderRow().run(),
    isActive: (n) => !1,
    isDisabled: (n) => !n.can().toggleHeaderRow()
  },
  ToggleHeaderCell: {
    label: "Toggle Header Cell",
    action: (n) => n.chain().focus().toggleHeaderCell().run(),
    isActive: (n) => !1,
    isDisabled: (n) => !n.can().toggleHeaderCell()
  },
  Separator: {
    type: "separator"
  }
};
function zx(n) {
  return n instanceof Array ? n.map(zx) : typeof n == "object" ? n : ZSe[n];
}
const JSe = {
  name: "TextEditorFixedMenu",
  props: ["buttons"],
  components: { Menu: $x },
  inject: ["editor"],
  computed: {
    fixedMenuButtons() {
      if (!this.buttons) return !1;
      let n;
      return Array.isArray(this.buttons) ? n = this.buttons : n = [
        [
          "Heading 1",
          "Heading 2",
          "Heading 3",
          "Heading 4",
          "Heading 5",
          "Heading 6"
        ],
        "Paragraph",
        "Separator",
        "Bold",
        "Italic",
        "Separator",
        "Bullet List",
        "Numbered List",
        "Task List",
        "Separator",
        "Align Left",
        "Align Center",
        "Align Right",
        "FontColor",
        "Separator",
        "Image",
        "Video",
        "Link",
        "Blockquote",
        "Code",
        "Horizontal Rule",
        [
          "InsertTable",
          "AddColumnBefore",
          "AddColumnAfter",
          "DeleteColumn",
          "AddRowBefore",
          "AddRowAfter",
          "DeleteRow",
          "MergeCells",
          "SplitCell",
          "ToggleHeaderColumn",
          "ToggleHeaderRow",
          "ToggleHeaderCell",
          "DeleteTable"
        ],
        "Separator",
        "Undo",
        "Redo"
      ], n.map(zx);
    }
  }
};
function QSe(n, e, t, r, i, a) {
  const o = $x;
  return a.fixedMenuButtons ? (L(), re(o, {
    key: 0,
    buttons: a.fixedMenuButtons
  }, null, 8, ["buttons"])) : ge("", !0);
}
const e2e = /* @__PURE__ */ zt(JSe, [["render", QSe]]), t2e = {
  name: "TextEditorBubbleMenu",
  props: ["buttons", "options"],
  components: { BubbleMenu: Ive, Menu: $x },
  inject: ["editor"],
  computed: {
    bubbleMenuButtons() {
      if (!this.buttons) return !1;
      let n;
      return Array.isArray(this.buttons) ? n = this.buttons : n = [
        "Paragraph",
        "Heading 2",
        "Heading 3",
        "Separator",
        "Bold",
        "Italic",
        "Strikethrough",
        "FontColor",
        "Link",
        "Separator",
        "Bullet List",
        "Numbered List",
        "Task List",
        "Separator",
        "Align Left",
        "Align Center",
        "Align Right",
        "Separator",
        "Image",
        "Video",
        "Blockquote",
        "Code",
        [
          "InsertTable",
          "AddColumnBefore",
          "AddColumnAfter",
          "DeleteColumn",
          "AddRowBefore",
          "AddRowAfter",
          "DeleteRow",
          "MergeCells",
          "SplitCell",
          "ToggleHeaderColumn",
          "ToggleHeaderRow",
          "ToggleHeaderCell",
          "DeleteTable"
        ]
      ], n.map(zx);
    }
  }
};
function n2e(n, e, t, r, i, a) {
  const o = $x, s = ol("BubbleMenu");
  return a.bubbleMenuButtons ? (L(), re(s, He({
    key: 0,
    class: "bubble-menu rounded-md shadow-sm",
    "tippy-options": { duration: 100 },
    editor: a.editor
  }, t.options), {
    default: ee(() => [
      se(o, {
        class: "rounded-md border-gray-100 shadow-lg",
        buttons: a.bubbleMenuButtons
      }, null, 8, ["buttons"])
    ]),
    _: 1
  }, 16, ["editor"])) : ge("", !0);
}
const r2e = /* @__PURE__ */ zt(t2e, [["render", n2e]]), i2e = {
  name: "TextEditorFloatingMenu",
  props: ["buttons"],
  components: { FloatingMenu: Rve },
  inject: ["editor"],
  computed: {
    floatingMenuButtons() {
      if (!this.buttons) return !1;
      let n;
      return Array.isArray(this.buttons) ? n = this.buttons : n = [
        "Paragraph",
        "Heading 2",
        "Heading 3",
        "Bullet List",
        "Numbered List",
        "Task List",
        "Blockquote",
        "Code",
        "Horizontal Rule"
      ], n.map(zx);
    }
  }
}, a2e = ["onClick", "title"], o2e = {
  key: 1,
  class: "inline-block h-4 min-w-[1rem] text-sm leading-4"
};
function s2e(n, e, t, r, i, a) {
  const o = ol("FloatingMenu");
  return a.floatingMenuButtons ? (L(), re(o, {
    key: 0,
    "tippy-options": { duration: 100 },
    editor: a.editor,
    class: "flex"
  }, {
    default: ee(() => [
      (L(!0), W(Ke, null, _t(a.floatingMenuButtons, (s) => (L(), W("button", {
        key: s.label,
        class: _e([
          "flex rounded p-1 text-ink-gray-8 transition-colors",
          s.isActive(a.editor) ? "bg-surface-gray-2" : "hover:bg-surface-gray-2"
        ]),
        onClick: () => s.action(a.editor),
        title: s.label
      }, [
        s.icon ? (L(), re(bn(s.icon), {
          key: 0,
          class: "h-4 w-4"
        })) : (L(), W("span", o2e, ke(s.text), 1))
      ], 10, a2e))), 128))
    ]),
    _: 1
  }, 8, ["editor"])) : ge("", !0);
}
const l2e = /* @__PURE__ */ zt(i2e, [["render", s2e]]), u2e = { class: "mr-2" }, c2e = /* @__PURE__ */ ve({
  __name: "EmojiList",
  props: {
    items: {
      type: Array,
      required: !0
    },
    editor: {
      type: Object,
      required: !0
    },
    range: {
      type: Object,
      required: !0
    },
    command: {
      type: Function,
      required: !0
    }
  },
  setup(n, { expose: e }) {
    const t = n, r = Z(null), i = (o) => {
      o && t.command(o);
    };
    return e({
      onKeyDown: ({ event: o }) => {
        var s;
        return ((s = r.value) == null ? void 0 : s.onKeyDown({ event: o })) ?? !1;
      }
    }), (o, s) => (L(), re(Bx, {
      ref_key: "suggestionList",
      ref: r,
      items: n.items,
      command: (l) => i(l),
      "item-class": "py-2"
    }, {
      default: ee(({ item: l }) => [
        G("span", u2e, ke(l.emoji), 1),
        G("span", null, ke(l.name), 1)
      ]),
      _: 1
    }, 8, ["items", "command"]));
  }
}), d2e = [
  {
    name: "grinning",
    emoji: "😀"
  },
  {
    name: "grimacing",
    emoji: "😬"
  },
  {
    name: "grin",
    emoji: "😁"
  },
  {
    name: "joy",
    emoji: "😂"
  },
  {
    name: "rofl",
    emoji: "🤣"
  },
  {
    name: "smiley",
    emoji: "😃"
  },
  {
    name: "smile",
    emoji: "😄"
  },
  {
    name: "sweat_smile",
    emoji: "😅"
  },
  {
    name: "laughing",
    emoji: "😆"
  },
  {
    name: "innocent",
    emoji: "😇"
  },
  {
    name: "wink",
    emoji: "😉"
  },
  {
    name: "blush",
    emoji: "😊"
  },
  {
    name: "slightly_smiling_face",
    emoji: "🙂"
  },
  {
    name: "upside_down_face",
    emoji: "🙃"
  },
  {
    name: "relaxed",
    emoji: "☺"
  },
  {
    name: "yum",
    emoji: "😋"
  },
  {
    name: "relieved",
    emoji: "😌"
  },
  {
    name: "heart_eyes",
    emoji: "😍"
  },
  {
    name: "kissing_heart",
    emoji: "😘"
  },
  {
    name: "kissing",
    emoji: "😗"
  },
  {
    name: "kissing_smiling_eyes",
    emoji: "😙"
  },
  {
    name: "kissing_closed_eyes",
    emoji: "😚"
  },
  {
    name: "stuck_out_tongue_winking_eye",
    emoji: "😜"
  },
  {
    name: "stuck_out_tongue_closed_eyes",
    emoji: "😝"
  },
  {
    name: "stuck_out_tongue",
    emoji: "😛"
  },
  {
    name: "money_mouth_face",
    emoji: "🤑"
  },
  {
    name: "nerd_face",
    emoji: "🤓"
  },
  {
    name: "sunglasses",
    emoji: "😎"
  },
  {
    name: "clown_face",
    emoji: "🤡"
  },
  {
    name: "cowboy_hat_face",
    emoji: "🤠"
  },
  {
    name: "hugs",
    emoji: "🤗"
  },
  {
    name: "smirk",
    emoji: "😏"
  },
  {
    name: "no_mouth",
    emoji: "😶"
  },
  {
    name: "neutral_face",
    emoji: "😐"
  },
  {
    name: "expressionless",
    emoji: "😑"
  },
  {
    name: "unamused",
    emoji: "😒"
  },
  {
    name: "roll_eyes",
    emoji: "🙄"
  },
  {
    name: "thinking",
    emoji: "🤔"
  },
  {
    name: "lying_face",
    emoji: "🤥"
  },
  {
    name: "flushed",
    emoji: "😳"
  },
  {
    name: "disappointed",
    emoji: "😞"
  },
  {
    name: "worried",
    emoji: "😟"
  },
  {
    name: "angry",
    emoji: "😠"
  },
  {
    name: "rage",
    emoji: "😡"
  },
  {
    name: "pensive",
    emoji: "😔"
  },
  {
    name: "confused",
    emoji: "😕"
  },
  {
    name: "slightly_frowning_face",
    emoji: "🙁"
  },
  {
    name: "frowning_face",
    emoji: "☹"
  },
  {
    name: "persevere",
    emoji: "😣"
  },
  {
    name: "confounded",
    emoji: "😖"
  },
  {
    name: "tired_face",
    emoji: "😫"
  },
  {
    name: "weary",
    emoji: "😩"
  },
  {
    name: "triumph",
    emoji: "😤"
  },
  {
    name: "open_mouth",
    emoji: "😮"
  },
  {
    name: "scream",
    emoji: "😱"
  },
  {
    name: "fearful",
    emoji: "😨"
  },
  {
    name: "cold_sweat",
    emoji: "😰"
  },
  {
    name: "hushed",
    emoji: "😯"
  },
  {
    name: "frowning_with_open_mouth",
    emoji: "😦"
  },
  {
    name: "anguished",
    emoji: "😧"
  },
  {
    name: "cry",
    emoji: "😢"
  },
  {
    name: "disappointed_relieved",
    emoji: "😥"
  },
  {
    name: "drooling_face",
    emoji: "🤤"
  },
  {
    name: "sleepy",
    emoji: "😪"
  },
  {
    name: "sweat",
    emoji: "😓"
  },
  {
    name: "sob",
    emoji: "😭"
  },
  {
    name: "dizzy_face",
    emoji: "😵"
  },
  {
    name: "astonished",
    emoji: "😲"
  },
  {
    name: "zipper_mouth_face",
    emoji: "🤐"
  },
  {
    name: "nauseated_face",
    emoji: "🤢"
  },
  {
    name: "sneezing_face",
    emoji: "🤧"
  },
  {
    name: "mask",
    emoji: "😷"
  },
  {
    name: "face_with_thermometer",
    emoji: "🤒"
  },
  {
    name: "face_with_head_bandage",
    emoji: "🤕"
  },
  {
    name: "sleeping",
    emoji: "😴"
  },
  {
    name: "zzz",
    emoji: "💤"
  },
  {
    name: "poop",
    emoji: "💩"
  },
  {
    name: "smiling_imp",
    emoji: "😈"
  },
  {
    name: "imp",
    emoji: "👿"
  },
  {
    name: "japanese_ogre",
    emoji: "👹"
  },
  {
    name: "japanese_goblin",
    emoji: "👺"
  },
  {
    name: "skull",
    emoji: "💀"
  },
  {
    name: "ghost",
    emoji: "👻"
  },
  {
    name: "alien",
    emoji: "👽"
  },
  {
    name: "robot",
    emoji: "🤖"
  },
  {
    name: "smiley_cat",
    emoji: "😺"
  },
  {
    name: "smile_cat",
    emoji: "😸"
  },
  {
    name: "joy_cat",
    emoji: "😹"
  },
  {
    name: "heart_eyes_cat",
    emoji: "😻"
  },
  {
    name: "smirk_cat",
    emoji: "😼"
  },
  {
    name: "kissing_cat",
    emoji: "😽"
  },
  {
    name: "scream_cat",
    emoji: "🙀"
  },
  {
    name: "crying_cat_face",
    emoji: "😿"
  },
  {
    name: "pouting_cat",
    emoji: "😾"
  },
  {
    name: "raised_hands",
    emoji: "🙌"
  },
  {
    name: "clap",
    emoji: "👏"
  },
  {
    name: "wave",
    emoji: "👋"
  },
  {
    name: "call_me_hand",
    emoji: "🤙"
  },
  {
    name: "+1",
    emoji: "👍"
  },
  {
    name: "-1",
    emoji: "👎"
  },
  {
    name: "facepunch",
    emoji: "👊"
  },
  {
    name: "fist",
    emoji: "✊"
  },
  {
    name: "fist_left",
    emoji: "🤛"
  },
  {
    name: "fist_right",
    emoji: "🤜"
  },
  {
    name: "v",
    emoji: "✌"
  },
  {
    name: "ok_hand",
    emoji: "👌"
  },
  {
    name: "raised_hand",
    emoji: "✋"
  },
  {
    name: "raised_back_of_hand",
    emoji: "🤚"
  },
  {
    name: "open_hands",
    emoji: "👐"
  },
  {
    name: "muscle",
    emoji: "💪"
  },
  {
    name: "pray",
    emoji: "🙏"
  },
  {
    name: "handshake",
    emoji: "🤝"
  },
  {
    name: "point_up",
    emoji: "☝"
  },
  {
    name: "point_up_2",
    emoji: "👆"
  },
  {
    name: "point_down",
    emoji: "👇"
  },
  {
    name: "point_left",
    emoji: "👈"
  },
  {
    name: "point_right",
    emoji: "👉"
  },
  {
    name: "fu",
    emoji: "🖕"
  },
  {
    name: "raised_hand_with_fingers_splayed",
    emoji: "🖐"
  },
  {
    name: "metal",
    emoji: "🤘"
  },
  {
    name: "crossed_fingers",
    emoji: "🤞"
  },
  {
    name: "vulcan_salute",
    emoji: "🖖"
  },
  {
    name: "writing_hand",
    emoji: "✍"
  },
  {
    name: "selfie",
    emoji: "🤳"
  },
  {
    name: "nail_care",
    emoji: "💅"
  },
  {
    name: "lips",
    emoji: "👄"
  },
  {
    name: "tongue",
    emoji: "👅"
  },
  {
    name: "ear",
    emoji: "👂"
  },
  {
    name: "nose",
    emoji: "👃"
  },
  {
    name: "eye",
    emoji: "👁"
  },
  {
    name: "eyes",
    emoji: "👀"
  },
  {
    name: "bust_in_silhouette",
    emoji: "👤"
  },
  {
    name: "busts_in_silhouette",
    emoji: "👥"
  },
  {
    name: "speaking_head",
    emoji: "🗣"
  },
  {
    name: "baby",
    emoji: "👶"
  },
  {
    name: "boy",
    emoji: "👦"
  },
  {
    name: "girl",
    emoji: "👧"
  },
  {
    name: "man",
    emoji: "👨"
  },
  {
    name: "woman",
    emoji: "👩"
  },
  {
    name: "blonde_woman",
    emoji: "👱‍♀️"
  },
  {
    name: "blonde_man",
    emoji: "👱"
  },
  {
    name: "older_man",
    emoji: "👴"
  },
  {
    name: "older_woman",
    emoji: "👵"
  },
  {
    name: "man_with_gua_pi_mao",
    emoji: "👲"
  },
  {
    name: "woman_with_turban",
    emoji: "👳‍♀️"
  },
  {
    name: "man_with_turban",
    emoji: "👳"
  },
  {
    name: "policewoman",
    emoji: "👮‍♀️"
  },
  {
    name: "policeman",
    emoji: "👮"
  },
  {
    name: "construction_worker_woman",
    emoji: "👷‍♀️"
  },
  {
    name: "construction_worker_man",
    emoji: "👷"
  },
  {
    name: "guardswoman",
    emoji: "💂‍♀️"
  },
  {
    name: "guardsman",
    emoji: "💂"
  },
  {
    name: "female_detective",
    emoji: "🕵️‍♀"
  },
  {
    name: "male_detective",
    emoji: "🕵"
  },
  {
    name: "woman_health_worker",
    emoji: "👩‍⚕️"
  },
  {
    name: "man_health_worker",
    emoji: "👨‍⚕️"
  },
  {
    name: "woman_farmer",
    emoji: "👩‍🌾"
  },
  {
    name: "man_farmer",
    emoji: "👨‍🌾"
  },
  {
    name: "woman_cook",
    emoji: "👩‍🍳"
  },
  {
    name: "man_cook",
    emoji: "👨‍🍳"
  },
  {
    name: "woman_student",
    emoji: "👩‍🎓"
  },
  {
    name: "man_student",
    emoji: "👨‍🎓"
  },
  {
    name: "woman_singer",
    emoji: "👩‍🎤"
  },
  {
    name: "man_singer",
    emoji: "👨‍🎤"
  },
  {
    name: "woman_teacher",
    emoji: "👩‍🏫"
  },
  {
    name: "man_teacher",
    emoji: "👨‍🏫"
  },
  {
    name: "woman_factory_worker",
    emoji: "👩‍🏭"
  },
  {
    name: "man_factory_worker",
    emoji: "👨‍🏭"
  },
  {
    name: "woman_technologist",
    emoji: "👩‍💻"
  },
  {
    name: "man_technologist",
    emoji: "👨‍💻"
  },
  {
    name: "woman_office_worker",
    emoji: "👩‍💼"
  },
  {
    name: "man_office_worker",
    emoji: "👨‍💼"
  },
  {
    name: "woman_mechanic",
    emoji: "👩‍🔧"
  },
  {
    name: "man_mechanic",
    emoji: "👨‍🔧"
  },
  {
    name: "woman_scientist",
    emoji: "👩‍🔬"
  },
  {
    name: "man_scientist",
    emoji: "👨‍🔬"
  },
  {
    name: "woman_artist",
    emoji: "👩‍🎨"
  },
  {
    name: "man_artist",
    emoji: "👨‍🎨"
  },
  {
    name: "woman_firefighter",
    emoji: "👩‍🚒"
  },
  {
    name: "man_firefighter",
    emoji: "👨‍🚒"
  },
  {
    name: "woman_pilot",
    emoji: "👩‍✈️"
  },
  {
    name: "man_pilot",
    emoji: "👨‍✈️"
  },
  {
    name: "woman_astronaut",
    emoji: "👩‍🚀"
  },
  {
    name: "man_astronaut",
    emoji: "👨‍🚀"
  },
  {
    name: "woman_judge",
    emoji: "👩‍⚖️"
  },
  {
    name: "man_judge",
    emoji: "👨‍⚖️"
  },
  {
    name: "mrs_claus",
    emoji: "🤶"
  },
  {
    name: "santa",
    emoji: "🎅"
  },
  {
    name: "angel",
    emoji: "👼"
  },
  {
    name: "pregnant_woman",
    emoji: "🤰"
  },
  {
    name: "princess",
    emoji: "👸"
  },
  {
    name: "prince",
    emoji: "🤴"
  },
  {
    name: "bride_with_veil",
    emoji: "👰"
  },
  {
    name: "person_in_tuxedo",
    emoji: "🤵"
  },
  {
    name: "running_woman",
    emoji: "🏃‍♀️"
  },
  {
    name: "running_man",
    emoji: "🏃"
  },
  {
    name: "walking_woman",
    emoji: "🚶‍♀️"
  },
  {
    name: "walking_man",
    emoji: "🚶"
  },
  {
    name: "dancer",
    emoji: "💃"
  },
  {
    name: "man_dancing",
    emoji: "🕺"
  },
  {
    name: "dancing_women",
    emoji: "👯"
  },
  {
    name: "dancing_men",
    emoji: "👯‍♂"
  },
  {
    name: "couple",
    emoji: "👫"
  },
  {
    name: "two_men_holding_hands",
    emoji: "👬"
  },
  {
    name: "two_women_holding_hands",
    emoji: "👭"
  },
  {
    name: "bowing_woman",
    emoji: "🙇‍♀️"
  },
  {
    name: "bowing_man",
    emoji: "🙇"
  },
  {
    name: "man_facepalming",
    emoji: "🤦‍♂️"
  },
  {
    name: "woman_facepalming",
    emoji: "🤦‍♀️"
  },
  {
    name: "woman_shrugging",
    emoji: "🤷‍♀️"
  },
  {
    name: "man_shrugging",
    emoji: "🤷‍♂️"
  },
  {
    name: "tipping_hand_woman",
    emoji: "💁‍♀️"
  },
  {
    name: "tipping_hand_man",
    emoji: "💁‍♂️"
  },
  {
    name: "no_good_woman",
    emoji: "🙅‍♀️"
  },
  {
    name: "no_good_man",
    emoji: "🙅‍♂️"
  },
  {
    name: "ok_woman",
    emoji: "🙆‍♀️"
  },
  {
    name: "ok_man",
    emoji: "🙆‍♂️"
  },
  {
    name: "raising_hand_woman",
    emoji: "🙋‍♀️"
  },
  {
    name: "raising_hand_man",
    emoji: "🙋‍♂️"
  },
  {
    name: "pouting_woman",
    emoji: "🙎‍♀️"
  },
  {
    name: "pouting_man",
    emoji: "🙎‍♂️"
  },
  {
    name: "frowning_woman",
    emoji: "🙍‍♀️"
  },
  {
    name: "frowning_man",
    emoji: "🙍‍♂️"
  },
  {
    name: "haircut_woman",
    emoji: "💇‍♀️"
  },
  {
    name: "haircut_man",
    emoji: "💇‍♂️"
  },
  {
    name: "massage_woman",
    emoji: "💆‍♀️"
  },
  {
    name: "massage_man",
    emoji: "💆‍♂️"
  },
  {
    name: "couple_with_heart",
    emoji: "💑"
  },
  {
    name: "couple_with_heart_woman_woman",
    emoji: "👩‍❤️‍👩"
  },
  {
    name: "couple_with_heart_man_man",
    emoji: "👨‍❤️‍👨"
  },
  {
    name: "couplekiss_man_woman",
    emoji: "💏"
  },
  {
    name: "couplekiss_woman_woman",
    emoji: "👩‍❤️‍💋‍👩"
  },
  {
    name: "couplekiss_man_man",
    emoji: "👨‍❤️‍💋‍👨"
  },
  {
    name: "family",
    emoji: "👪"
  },
  {
    name: "family_man_woman_girl",
    emoji: "👨‍👩‍👧"
  },
  {
    name: "family_man_woman_girl_boy",
    emoji: "👨‍👩‍👧‍👦"
  },
  {
    name: "family_man_woman_boy_boy",
    emoji: "👨‍👩‍👦‍👦"
  },
  {
    name: "family_man_woman_girl_girl",
    emoji: "👨‍👩‍👧‍👧"
  },
  {
    name: "family_woman_woman_boy",
    emoji: "👩‍👩‍👦"
  },
  {
    name: "family_woman_woman_girl",
    emoji: "👩‍👩‍👧"
  },
  {
    name: "family_woman_woman_girl_boy",
    emoji: "👩‍👩‍👧‍👦"
  },
  {
    name: "family_woman_woman_boy_boy",
    emoji: "👩‍👩‍👦‍👦"
  },
  {
    name: "family_woman_woman_girl_girl",
    emoji: "👩‍👩‍👧‍👧"
  },
  {
    name: "family_man_man_boy",
    emoji: "👨‍👨‍👦"
  },
  {
    name: "family_man_man_girl",
    emoji: "👨‍👨‍👧"
  },
  {
    name: "family_man_man_girl_boy",
    emoji: "👨‍👨‍👧‍👦"
  },
  {
    name: "family_man_man_boy_boy",
    emoji: "👨‍👨‍👦‍👦"
  },
  {
    name: "family_man_man_girl_girl",
    emoji: "👨‍👨‍👧‍👧"
  },
  {
    name: "family_woman_boy",
    emoji: "👩‍👦"
  },
  {
    name: "family_woman_girl",
    emoji: "👩‍👧"
  },
  {
    name: "family_woman_girl_boy",
    emoji: "👩‍👧‍👦"
  },
  {
    name: "family_woman_boy_boy",
    emoji: "👩‍👦‍👦"
  },
  {
    name: "family_woman_girl_girl",
    emoji: "👩‍👧‍👧"
  },
  {
    name: "family_man_boy",
    emoji: "👨‍👦"
  },
  {
    name: "family_man_girl",
    emoji: "👨‍👧"
  },
  {
    name: "family_man_girl_boy",
    emoji: "👨‍👧‍👦"
  },
  {
    name: "family_man_boy_boy",
    emoji: "👨‍👦‍👦"
  },
  {
    name: "family_man_girl_girl",
    emoji: "👨‍👧‍👧"
  },
  {
    name: "womans_clothes",
    emoji: "👚"
  },
  {
    name: "tshirt",
    emoji: "👕"
  },
  {
    name: "jeans",
    emoji: "👖"
  },
  {
    name: "necktie",
    emoji: "👔"
  },
  {
    name: "dress",
    emoji: "👗"
  },
  {
    name: "bikini",
    emoji: "👙"
  },
  {
    name: "kimono",
    emoji: "👘"
  },
  {
    name: "lipstick",
    emoji: "💄"
  },
  {
    name: "kiss",
    emoji: "💋"
  },
  {
    name: "footprints",
    emoji: "👣"
  },
  {
    name: "high_heel",
    emoji: "👠"
  },
  {
    name: "sandal",
    emoji: "👡"
  },
  {
    name: "boot",
    emoji: "👢"
  },
  {
    name: "mans_shoe",
    emoji: "👞"
  },
  {
    name: "athletic_shoe",
    emoji: "👟"
  },
  {
    name: "womans_hat",
    emoji: "👒"
  },
  {
    name: "tophat",
    emoji: "🎩"
  },
  {
    name: "rescue_worker_helmet",
    emoji: "⛑"
  },
  {
    name: "mortar_board",
    emoji: "🎓"
  },
  {
    name: "crown",
    emoji: "👑"
  },
  {
    name: "school_satchel",
    emoji: "🎒"
  },
  {
    name: "pouch",
    emoji: "👝"
  },
  {
    name: "purse",
    emoji: "👛"
  },
  {
    name: "handbag",
    emoji: "👜"
  },
  {
    name: "briefcase",
    emoji: "💼"
  },
  {
    name: "eyeglasses",
    emoji: "👓"
  },
  {
    name: "dark_sunglasses",
    emoji: "🕶"
  },
  {
    name: "ring",
    emoji: "💍"
  },
  {
    name: "closed_umbrella",
    emoji: "🌂"
  },
  {
    name: "dog",
    emoji: "🐶"
  },
  {
    name: "cat",
    emoji: "🐱"
  },
  {
    name: "mouse",
    emoji: "🐭"
  },
  {
    name: "hamster",
    emoji: "🐹"
  },
  {
    name: "rabbit",
    emoji: "🐰"
  },
  {
    name: "fox_face",
    emoji: "🦊"
  },
  {
    name: "bear",
    emoji: "🐻"
  },
  {
    name: "panda_face",
    emoji: "🐼"
  },
  {
    name: "koala",
    emoji: "🐨"
  },
  {
    name: "tiger",
    emoji: "🐯"
  },
  {
    name: "lion",
    emoji: "🦁"
  },
  {
    name: "cow",
    emoji: "🐮"
  },
  {
    name: "pig",
    emoji: "🐷"
  },
  {
    name: "pig_nose",
    emoji: "🐽"
  },
  {
    name: "frog",
    emoji: "🐸"
  },
  {
    name: "squid",
    emoji: "🦑"
  },
  {
    name: "octopus",
    emoji: "🐙"
  },
  {
    name: "shrimp",
    emoji: "🦐"
  },
  {
    name: "monkey_face",
    emoji: "🐵"
  },
  {
    name: "gorilla",
    emoji: "🦍"
  },
  {
    name: "see_no_evil",
    emoji: "🙈"
  },
  {
    name: "hear_no_evil",
    emoji: "🙉"
  },
  {
    name: "speak_no_evil",
    emoji: "🙊"
  },
  {
    name: "monkey",
    emoji: "🐒"
  },
  {
    name: "chicken",
    emoji: "🐔"
  },
  {
    name: "penguin",
    emoji: "🐧"
  },
  {
    name: "bird",
    emoji: "🐦"
  },
  {
    name: "baby_chick",
    emoji: "🐤"
  },
  {
    name: "hatching_chick",
    emoji: "🐣"
  },
  {
    name: "hatched_chick",
    emoji: "🐥"
  },
  {
    name: "duck",
    emoji: "🦆"
  },
  {
    name: "eagle",
    emoji: "🦅"
  },
  {
    name: "owl",
    emoji: "🦉"
  },
  {
    name: "bat",
    emoji: "🦇"
  },
  {
    name: "wolf",
    emoji: "🐺"
  },
  {
    name: "boar",
    emoji: "🐗"
  },
  {
    name: "horse",
    emoji: "🐴"
  },
  {
    name: "unicorn",
    emoji: "🦄"
  },
  {
    name: "honeybee",
    emoji: "🐝"
  },
  {
    name: "bug",
    emoji: "🐛"
  },
  {
    name: "butterfly",
    emoji: "🦋"
  },
  {
    name: "snail",
    emoji: "🐌"
  },
  {
    name: "lady_beetle",
    emoji: "🐞"
  },
  {
    name: "ant",
    emoji: "🐜"
  },
  {
    name: "spider",
    emoji: "🕷"
  },
  {
    name: "scorpion",
    emoji: "🦂"
  },
  {
    name: "crab",
    emoji: "🦀"
  },
  {
    name: "snake",
    emoji: "🐍"
  },
  {
    name: "lizard",
    emoji: "🦎"
  },
  {
    name: "turtle",
    emoji: "🐢"
  },
  {
    name: "tropical_fish",
    emoji: "🐠"
  },
  {
    name: "fish",
    emoji: "🐟"
  },
  {
    name: "blowfish",
    emoji: "🐡"
  },
  {
    name: "dolphin",
    emoji: "🐬"
  },
  {
    name: "shark",
    emoji: "🦈"
  },
  {
    name: "whale",
    emoji: "🐳"
  },
  {
    name: "whale2",
    emoji: "🐋"
  },
  {
    name: "crocodile",
    emoji: "🐊"
  },
  {
    name: "leopard",
    emoji: "🐆"
  },
  {
    name: "tiger2",
    emoji: "🐅"
  },
  {
    name: "water_buffalo",
    emoji: "🐃"
  },
  {
    name: "ox",
    emoji: "🐂"
  },
  {
    name: "cow2",
    emoji: "🐄"
  },
  {
    name: "deer",
    emoji: "🦌"
  },
  {
    name: "dromedary_camel",
    emoji: "🐪"
  },
  {
    name: "camel",
    emoji: "🐫"
  },
  {
    name: "elephant",
    emoji: "🐘"
  },
  {
    name: "rhinoceros",
    emoji: "🦏"
  },
  {
    name: "goat",
    emoji: "🐐"
  },
  {
    name: "ram",
    emoji: "🐏"
  },
  {
    name: "sheep",
    emoji: "🐑"
  },
  {
    name: "racehorse",
    emoji: "🐎"
  },
  {
    name: "pig2",
    emoji: "🐖"
  },
  {
    name: "rat",
    emoji: "🐀"
  },
  {
    name: "mouse2",
    emoji: "🐁"
  },
  {
    name: "rooster",
    emoji: "🐓"
  },
  {
    name: "turkey",
    emoji: "🦃"
  },
  {
    name: "dove",
    emoji: "🕊"
  },
  {
    name: "dog2",
    emoji: "🐕"
  },
  {
    name: "poodle",
    emoji: "🐩"
  },
  {
    name: "cat2",
    emoji: "🐈"
  },
  {
    name: "rabbit2",
    emoji: "🐇"
  },
  {
    name: "chipmunk",
    emoji: "🐿"
  },
  {
    name: "paw_prints",
    emoji: "🐾"
  },
  {
    name: "dragon",
    emoji: "🐉"
  },
  {
    name: "dragon_face",
    emoji: "🐲"
  },
  {
    name: "cactus",
    emoji: "🌵"
  },
  {
    name: "christmas_tree",
    emoji: "🎄"
  },
  {
    name: "evergreen_tree",
    emoji: "🌲"
  },
  {
    name: "deciduous_tree",
    emoji: "🌳"
  },
  {
    name: "palm_tree",
    emoji: "🌴"
  },
  {
    name: "seedling",
    emoji: "🌱"
  },
  {
    name: "herb",
    emoji: "🌿"
  },
  {
    name: "shamrock",
    emoji: "☘"
  },
  {
    name: "four_leaf_clover",
    emoji: "🍀"
  },
  {
    name: "bamboo",
    emoji: "🎍"
  },
  {
    name: "tanabata_tree",
    emoji: "🎋"
  },
  {
    name: "leaves",
    emoji: "🍃"
  },
  {
    name: "fallen_leaf",
    emoji: "🍂"
  },
  {
    name: "maple_leaf",
    emoji: "🍁"
  },
  {
    name: "ear_of_rice",
    emoji: "🌾"
  },
  {
    name: "hibiscus",
    emoji: "🌺"
  },
  {
    name: "sunflower",
    emoji: "🌻"
  },
  {
    name: "rose",
    emoji: "🌹"
  },
  {
    name: "wilted_flower",
    emoji: "🥀"
  },
  {
    name: "tulip",
    emoji: "🌷"
  },
  {
    name: "blossom",
    emoji: "🌼"
  },
  {
    name: "cherry_blossom",
    emoji: "🌸"
  },
  {
    name: "bouquet",
    emoji: "💐"
  },
  {
    name: "mushroom",
    emoji: "🍄"
  },
  {
    name: "chestnut",
    emoji: "🌰"
  },
  {
    name: "jack_o_lantern",
    emoji: "🎃"
  },
  {
    name: "shell",
    emoji: "🐚"
  },
  {
    name: "spider_web",
    emoji: "🕸"
  },
  {
    name: "earth_americas",
    emoji: "🌎"
  },
  {
    name: "earth_africa",
    emoji: "🌍"
  },
  {
    name: "earth_asia",
    emoji: "🌏"
  },
  {
    name: "full_moon",
    emoji: "🌕"
  },
  {
    name: "waning_gibbous_moon",
    emoji: "🌖"
  },
  {
    name: "last_quarter_moon",
    emoji: "🌗"
  },
  {
    name: "waning_crescent_moon",
    emoji: "🌘"
  },
  {
    name: "new_moon",
    emoji: "🌑"
  },
  {
    name: "waxing_crescent_moon",
    emoji: "🌒"
  },
  {
    name: "first_quarter_moon",
    emoji: "🌓"
  },
  {
    name: "waxing_gibbous_moon",
    emoji: "🌔"
  },
  {
    name: "new_moon_with_face",
    emoji: "🌚"
  },
  {
    name: "full_moon_with_face",
    emoji: "🌝"
  },
  {
    name: "first_quarter_moon_with_face",
    emoji: "🌛"
  },
  {
    name: "last_quarter_moon_with_face",
    emoji: "🌜"
  },
  {
    name: "sun_with_face",
    emoji: "🌞"
  },
  {
    name: "crescent_moon",
    emoji: "🌙"
  },
  {
    name: "star",
    emoji: "⭐"
  },
  {
    name: "star2",
    emoji: "🌟"
  },
  {
    name: "dizzy",
    emoji: "💫"
  },
  {
    name: "sparkles",
    emoji: "✨"
  },
  {
    name: "comet",
    emoji: "☄"
  },
  {
    name: "sunny",
    emoji: "☀"
  },
  {
    name: "sun_behind_small_cloud",
    emoji: "🌤"
  },
  {
    name: "partly_sunny",
    emoji: "⛅"
  },
  {
    name: "sun_behind_large_cloud",
    emoji: "🌥"
  },
  {
    name: "sun_behind_rain_cloud",
    emoji: "🌦"
  },
  {
    name: "cloud",
    emoji: "☁"
  },
  {
    name: "cloud_with_rain",
    emoji: "🌧"
  },
  {
    name: "cloud_with_lightning_and_rain",
    emoji: "⛈"
  },
  {
    name: "cloud_with_lightning",
    emoji: "🌩"
  },
  {
    name: "zap",
    emoji: "⚡"
  },
  {
    name: "fire",
    emoji: "🔥"
  },
  {
    name: "boom",
    emoji: "💥"
  },
  {
    name: "snowflake",
    emoji: "❄"
  },
  {
    name: "cloud_with_snow",
    emoji: "🌨"
  },
  {
    name: "snowman",
    emoji: "⛄"
  },
  {
    name: "snowman_with_snow",
    emoji: "☃"
  },
  {
    name: "wind_face",
    emoji: "🌬"
  },
  {
    name: "dash",
    emoji: "💨"
  },
  {
    name: "tornado",
    emoji: "🌪"
  },
  {
    name: "fog",
    emoji: "🌫"
  },
  {
    name: "open_umbrella",
    emoji: "☂"
  },
  {
    name: "umbrella",
    emoji: "☔"
  },
  {
    name: "droplet",
    emoji: "💧"
  },
  {
    name: "sweat_drops",
    emoji: "💦"
  },
  {
    name: "ocean",
    emoji: "🌊"
  },
  {
    name: "green_apple",
    emoji: "🍏"
  },
  {
    name: "apple",
    emoji: "🍎"
  },
  {
    name: "pear",
    emoji: "🍐"
  },
  {
    name: "tangerine",
    emoji: "🍊"
  },
  {
    name: "lemon",
    emoji: "🍋"
  },
  {
    name: "banana",
    emoji: "🍌"
  },
  {
    name: "watermelon",
    emoji: "🍉"
  },
  {
    name: "grapes",
    emoji: "🍇"
  },
  {
    name: "strawberry",
    emoji: "🍓"
  },
  {
    name: "melon",
    emoji: "🍈"
  },
  {
    name: "cherries",
    emoji: "🍒"
  },
  {
    name: "peach",
    emoji: "🍑"
  },
  {
    name: "pineapple",
    emoji: "🍍"
  },
  {
    name: "kiwi_fruit",
    emoji: "🥝"
  },
  {
    name: "avocado",
    emoji: "🥑"
  },
  {
    name: "tomato",
    emoji: "🍅"
  },
  {
    name: "eggplant",
    emoji: "🍆"
  },
  {
    name: "cucumber",
    emoji: "🥒"
  },
  {
    name: "carrot",
    emoji: "🥕"
  },
  {
    name: "hot_pepper",
    emoji: "🌶"
  },
  {
    name: "potato",
    emoji: "🥔"
  },
  {
    name: "corn",
    emoji: "🌽"
  },
  {
    name: "sweet_potato",
    emoji: "🍠"
  },
  {
    name: "peanuts",
    emoji: "🥜"
  },
  {
    name: "honey_pot",
    emoji: "🍯"
  },
  {
    name: "croissant",
    emoji: "🥐"
  },
  {
    name: "bread",
    emoji: "🍞"
  },
  {
    name: "baguette_bread",
    emoji: "🥖"
  },
  {
    name: "cheese",
    emoji: "🧀"
  },
  {
    name: "egg",
    emoji: "🥚"
  },
  {
    name: "bacon",
    emoji: "🥓"
  },
  {
    name: "pancakes",
    emoji: "🥞"
  },
  {
    name: "poultry_leg",
    emoji: "🍗"
  },
  {
    name: "meat_on_bone",
    emoji: "🍖"
  },
  {
    name: "fried_shrimp",
    emoji: "🍤"
  },
  {
    name: "fried_egg",
    emoji: "🍳"
  },
  {
    name: "hamburger",
    emoji: "🍔"
  },
  {
    name: "fries",
    emoji: "🍟"
  },
  {
    name: "stuffed_flatbread",
    emoji: "🥙"
  },
  {
    name: "hotdog",
    emoji: "🌭"
  },
  {
    name: "pizza",
    emoji: "🍕"
  },
  {
    name: "spaghetti",
    emoji: "🍝"
  },
  {
    name: "taco",
    emoji: "🌮"
  },
  {
    name: "burrito",
    emoji: "🌯"
  },
  {
    name: "green_salad",
    emoji: "🥗"
  },
  {
    name: "shallow_pan_of_food",
    emoji: "🥘"
  },
  {
    name: "ramen",
    emoji: "🍜"
  },
  {
    name: "stew",
    emoji: "🍲"
  },
  {
    name: "fish_cake",
    emoji: "🍥"
  },
  {
    name: "sushi",
    emoji: "🍣"
  },
  {
    name: "bento",
    emoji: "🍱"
  },
  {
    name: "curry",
    emoji: "🍛"
  },
  {
    name: "rice_ball",
    emoji: "🍙"
  },
  {
    name: "rice",
    emoji: "🍚"
  },
  {
    name: "rice_cracker",
    emoji: "🍘"
  },
  {
    name: "oden",
    emoji: "🍢"
  },
  {
    name: "dango",
    emoji: "🍡"
  },
  {
    name: "shaved_ice",
    emoji: "🍧"
  },
  {
    name: "ice_cream",
    emoji: "🍨"
  },
  {
    name: "icecream",
    emoji: "🍦"
  },
  {
    name: "cake",
    emoji: "🍰"
  },
  {
    name: "birthday",
    emoji: "🎂"
  },
  {
    name: "custard",
    emoji: "🍮"
  },
  {
    name: "candy",
    emoji: "🍬"
  },
  {
    name: "lollipop",
    emoji: "🍭"
  },
  {
    name: "chocolate_bar",
    emoji: "🍫"
  },
  {
    name: "popcorn",
    emoji: "🍿"
  },
  {
    name: "doughnut",
    emoji: "🍩"
  },
  {
    name: "cookie",
    emoji: "🍪"
  },
  {
    name: "milk_glass",
    emoji: "🥛"
  },
  {
    name: "beer",
    emoji: "🍺"
  },
  {
    name: "beers",
    emoji: "🍻"
  },
  {
    name: "clinking_glasses",
    emoji: "🥂"
  },
  {
    name: "wine_glass",
    emoji: "🍷"
  },
  {
    name: "tumbler_glass",
    emoji: "🥃"
  },
  {
    name: "cocktail",
    emoji: "🍸"
  },
  {
    name: "tropical_drink",
    emoji: "🍹"
  },
  {
    name: "champagne",
    emoji: "🍾"
  },
  {
    name: "sake",
    emoji: "🍶"
  },
  {
    name: "tea",
    emoji: "🍵"
  },
  {
    name: "coffee",
    emoji: "☕"
  },
  {
    name: "baby_bottle",
    emoji: "🍼"
  },
  {
    name: "spoon",
    emoji: "🥄"
  },
  {
    name: "fork_and_knife",
    emoji: "🍴"
  },
  {
    name: "plate_with_cutlery",
    emoji: "🍽"
  },
  {
    name: "soccer",
    emoji: "⚽"
  },
  {
    name: "basketball",
    emoji: "🏀"
  },
  {
    name: "football",
    emoji: "🏈"
  },
  {
    name: "baseball",
    emoji: "⚾"
  },
  {
    name: "tennis",
    emoji: "🎾"
  },
  {
    name: "volleyball",
    emoji: "🏐"
  },
  {
    name: "rugby_football",
    emoji: "🏉"
  },
  {
    name: "8ball",
    emoji: "🎱"
  },
  {
    name: "golf",
    emoji: "⛳"
  },
  {
    name: "golfing_woman",
    emoji: "🏌️‍♀"
  },
  {
    name: "golfing_man",
    emoji: "🏌"
  },
  {
    name: "ping_pong",
    emoji: "🏓"
  },
  {
    name: "badminton",
    emoji: "🏸"
  },
  {
    name: "goal_net",
    emoji: "🥅"
  },
  {
    name: "ice_hockey",
    emoji: "🏒"
  },
  {
    name: "field_hockey",
    emoji: "🏑"
  },
  {
    name: "cricket_bat_and_ball",
    emoji: "🏏"
  },
  {
    name: "ski",
    emoji: "🎿"
  },
  {
    name: "skier",
    emoji: "⛷"
  },
  {
    name: "snowboarder",
    emoji: "🏂"
  },
  {
    name: "person_fencing",
    emoji: "🤺"
  },
  {
    name: "women_wrestling",
    emoji: "🤼‍♀"
  },
  {
    name: "men_wrestling",
    emoji: "🤼‍♂"
  },
  {
    name: "woman_cartwheeling",
    emoji: "🤸‍♀️"
  },
  {
    name: "man_cartwheeling",
    emoji: "🤸‍♂️"
  },
  {
    name: "woman_playing_handball",
    emoji: "🤾‍♀️"
  },
  {
    name: "man_playing_handball",
    emoji: "🤾‍♂️"
  },
  {
    name: "ice_skate",
    emoji: "⛸"
  },
  {
    name: "bow_and_arrow",
    emoji: "🏹"
  },
  {
    name: "fishing_pole_and_fish",
    emoji: "🎣"
  },
  {
    name: "boxing_glove",
    emoji: "🥊"
  },
  {
    name: "martial_arts_uniform",
    emoji: "🥋"
  },
  {
    name: "rowing_woman",
    emoji: "🚣‍♀️"
  },
  {
    name: "rowing_man",
    emoji: "🚣"
  },
  {
    name: "swimming_woman",
    emoji: "🏊‍♀️"
  },
  {
    name: "swimming_man",
    emoji: "🏊"
  },
  {
    name: "woman_playing_water_polo",
    emoji: "🤽‍♀️"
  },
  {
    name: "man_playing_water_polo",
    emoji: "🤽‍♂️"
  },
  {
    name: "surfing_woman",
    emoji: "🏄‍♀️"
  },
  {
    name: "surfing_man",
    emoji: "🏄"
  },
  {
    name: "bath",
    emoji: "🛀"
  },
  {
    name: "basketball_woman",
    emoji: "⛹️‍♀"
  },
  {
    name: "basketball_man",
    emoji: "⛹"
  },
  {
    name: "weight_lifting_woman",
    emoji: "🏋️‍♀"
  },
  {
    name: "weight_lifting_man",
    emoji: "🏋"
  },
  {
    name: "biking_woman",
    emoji: "🚴‍♀️"
  },
  {
    name: "biking_man",
    emoji: "🚴"
  },
  {
    name: "mountain_biking_woman",
    emoji: "🚵‍♀️"
  },
  {
    name: "mountain_biking_man",
    emoji: "🚵"
  },
  {
    name: "horse_racing",
    emoji: "🏇"
  },
  {
    name: "business_suit_levitating",
    emoji: "🕴"
  },
  {
    name: "trophy",
    emoji: "🏆"
  },
  {
    name: "running_shirt_with_sash",
    emoji: "🎽"
  },
  {
    name: "medal_sports",
    emoji: "🏅"
  },
  {
    name: "medal_military",
    emoji: "🎖"
  },
  {
    name: "1st_place_medal",
    emoji: "🥇"
  },
  {
    name: "2nd_place_medal",
    emoji: "🥈"
  },
  {
    name: "3rd_place_medal",
    emoji: "🥉"
  },
  {
    name: "reminder_ribbon",
    emoji: "🎗"
  },
  {
    name: "rosette",
    emoji: "🏵"
  },
  {
    name: "ticket",
    emoji: "🎫"
  },
  {
    name: "tickets",
    emoji: "🎟"
  },
  {
    name: "performing_arts",
    emoji: "🎭"
  },
  {
    name: "art",
    emoji: "🎨"
  },
  {
    name: "circus_tent",
    emoji: "🎪"
  },
  {
    name: "woman_juggling",
    emoji: "🤹‍♀️"
  },
  {
    name: "man_juggling",
    emoji: "🤹‍♂️"
  },
  {
    name: "microphone",
    emoji: "🎤"
  },
  {
    name: "headphones",
    emoji: "🎧"
  },
  {
    name: "musical_score",
    emoji: "🎼"
  },
  {
    name: "musical_keyboard",
    emoji: "🎹"
  },
  {
    name: "drum",
    emoji: "🥁"
  },
  {
    name: "saxophone",
    emoji: "🎷"
  },
  {
    name: "trumpet",
    emoji: "🎺"
  },
  {
    name: "guitar",
    emoji: "🎸"
  },
  {
    name: "violin",
    emoji: "🎻"
  },
  {
    name: "clapper",
    emoji: "🎬"
  },
  {
    name: "video_game",
    emoji: "🎮"
  },
  {
    name: "space_invader",
    emoji: "👾"
  },
  {
    name: "dart",
    emoji: "🎯"
  },
  {
    name: "game_die",
    emoji: "🎲"
  },
  {
    name: "slot_machine",
    emoji: "🎰"
  },
  {
    name: "bowling",
    emoji: "🎳"
  },
  {
    name: "red_car",
    emoji: "🚗"
  },
  {
    name: "taxi",
    emoji: "🚕"
  },
  {
    name: "blue_car",
    emoji: "🚙"
  },
  {
    name: "bus",
    emoji: "🚌"
  },
  {
    name: "trolleybus",
    emoji: "🚎"
  },
  {
    name: "racing_car",
    emoji: "🏎"
  },
  {
    name: "police_car",
    emoji: "🚓"
  },
  {
    name: "ambulance",
    emoji: "🚑"
  },
  {
    name: "fire_engine",
    emoji: "🚒"
  },
  {
    name: "minibus",
    emoji: "🚐"
  },
  {
    name: "truck",
    emoji: "🚚"
  },
  {
    name: "articulated_lorry",
    emoji: "🚛"
  },
  {
    name: "tractor",
    emoji: "🚜"
  },
  {
    name: "kick_scooter",
    emoji: "🛴"
  },
  {
    name: "motorcycle",
    emoji: "🏍"
  },
  {
    name: "bike",
    emoji: "🚲"
  },
  {
    name: "motor_scooter",
    emoji: "🛵"
  },
  {
    name: "rotating_light",
    emoji: "🚨"
  },
  {
    name: "oncoming_police_car",
    emoji: "🚔"
  },
  {
    name: "oncoming_bus",
    emoji: "🚍"
  },
  {
    name: "oncoming_automobile",
    emoji: "🚘"
  },
  {
    name: "oncoming_taxi",
    emoji: "🚖"
  },
  {
    name: "aerial_tramway",
    emoji: "🚡"
  },
  {
    name: "mountain_cableway",
    emoji: "🚠"
  },
  {
    name: "suspension_railway",
    emoji: "🚟"
  },
  {
    name: "railway_car",
    emoji: "🚃"
  },
  {
    name: "train",
    emoji: "🚋"
  },
  {
    name: "monorail",
    emoji: "🚝"
  },
  {
    name: "bullettrain_side",
    emoji: "🚄"
  },
  {
    name: "bullettrain_front",
    emoji: "🚅"
  },
  {
    name: "light_rail",
    emoji: "🚈"
  },
  {
    name: "mountain_railway",
    emoji: "🚞"
  },
  {
    name: "steam_locomotive",
    emoji: "🚂"
  },
  {
    name: "train2",
    emoji: "🚆"
  },
  {
    name: "metro",
    emoji: "🚇"
  },
  {
    name: "tram",
    emoji: "🚊"
  },
  {
    name: "station",
    emoji: "🚉"
  },
  {
    name: "helicopter",
    emoji: "🚁"
  },
  {
    name: "small_airplane",
    emoji: "🛩"
  },
  {
    name: "airplane",
    emoji: "✈"
  },
  {
    name: "flight_departure",
    emoji: "🛫"
  },
  {
    name: "flight_arrival",
    emoji: "🛬"
  },
  {
    name: "sailboat",
    emoji: "⛵"
  },
  {
    name: "motor_boat",
    emoji: "🛥"
  },
  {
    name: "speedboat",
    emoji: "🚤"
  },
  {
    name: "ferry",
    emoji: "⛴"
  },
  {
    name: "passenger_ship",
    emoji: "🛳"
  },
  {
    name: "rocket",
    emoji: "🚀"
  },
  {
    name: "artificial_satellite",
    emoji: "🛰"
  },
  {
    name: "seat",
    emoji: "💺"
  },
  {
    name: "canoe",
    emoji: "🛶"
  },
  {
    name: "anchor",
    emoji: "⚓"
  },
  {
    name: "construction",
    emoji: "🚧"
  },
  {
    name: "fuelpump",
    emoji: "⛽"
  },
  {
    name: "busstop",
    emoji: "🚏"
  },
  {
    name: "vertical_traffic_light",
    emoji: "🚦"
  },
  {
    name: "traffic_light",
    emoji: "🚥"
  },
  {
    name: "checkered_flag",
    emoji: "🏁"
  },
  {
    name: "ship",
    emoji: "🚢"
  },
  {
    name: "ferris_wheel",
    emoji: "🎡"
  },
  {
    name: "roller_coaster",
    emoji: "🎢"
  },
  {
    name: "carousel_horse",
    emoji: "🎠"
  },
  {
    name: "building_construction",
    emoji: "🏗"
  },
  {
    name: "foggy",
    emoji: "🌁"
  },
  {
    name: "tokyo_tower",
    emoji: "🗼"
  },
  {
    name: "factory",
    emoji: "🏭"
  },
  {
    name: "fountain",
    emoji: "⛲"
  },
  {
    name: "rice_scene",
    emoji: "🎑"
  },
  {
    name: "mountain",
    emoji: "⛰"
  },
  {
    name: "mountain_snow",
    emoji: "🏔"
  },
  {
    name: "mount_fuji",
    emoji: "🗻"
  },
  {
    name: "volcano",
    emoji: "🌋"
  },
  {
    name: "japan",
    emoji: "🗾"
  },
  {
    name: "camping",
    emoji: "🏕"
  },
  {
    name: "tent",
    emoji: "⛺"
  },
  {
    name: "national_park",
    emoji: "🏞"
  },
  {
    name: "motorway",
    emoji: "🛣"
  },
  {
    name: "railway_track",
    emoji: "🛤"
  },
  {
    name: "sunrise",
    emoji: "🌅"
  },
  {
    name: "sunrise_over_mountains",
    emoji: "🌄"
  },
  {
    name: "desert",
    emoji: "🏜"
  },
  {
    name: "beach_umbrella",
    emoji: "🏖"
  },
  {
    name: "desert_island",
    emoji: "🏝"
  },
  {
    name: "city_sunrise",
    emoji: "🌇"
  },
  {
    name: "city_sunset",
    emoji: "🌆"
  },
  {
    name: "cityscape",
    emoji: "🏙"
  },
  {
    name: "night_with_stars",
    emoji: "🌃"
  },
  {
    name: "bridge_at_night",
    emoji: "🌉"
  },
  {
    name: "milky_way",
    emoji: "🌌"
  },
  {
    name: "stars",
    emoji: "🌠"
  },
  {
    name: "sparkler",
    emoji: "🎇"
  },
  {
    name: "fireworks",
    emoji: "🎆"
  },
  {
    name: "rainbow",
    emoji: "🌈"
  },
  {
    name: "houses",
    emoji: "🏘"
  },
  {
    name: "european_castle",
    emoji: "🏰"
  },
  {
    name: "japanese_castle",
    emoji: "🏯"
  },
  {
    name: "stadium",
    emoji: "🏟"
  },
  {
    name: "statue_of_liberty",
    emoji: "🗽"
  },
  {
    name: "house",
    emoji: "🏠"
  },
  {
    name: "house_with_garden",
    emoji: "🏡"
  },
  {
    name: "derelict_house",
    emoji: "🏚"
  },
  {
    name: "office",
    emoji: "🏢"
  },
  {
    name: "department_store",
    emoji: "🏬"
  },
  {
    name: "post_office",
    emoji: "🏣"
  },
  {
    name: "european_post_office",
    emoji: "🏤"
  },
  {
    name: "hospital",
    emoji: "🏥"
  },
  {
    name: "bank",
    emoji: "🏦"
  },
  {
    name: "hotel",
    emoji: "🏨"
  },
  {
    name: "convenience_store",
    emoji: "🏪"
  },
  {
    name: "school",
    emoji: "🏫"
  },
  {
    name: "love_hotel",
    emoji: "🏩"
  },
  {
    name: "wedding",
    emoji: "💒"
  },
  {
    name: "classical_building",
    emoji: "🏛"
  },
  {
    name: "church",
    emoji: "⛪"
  },
  {
    name: "mosque",
    emoji: "🕌"
  },
  {
    name: "synagogue",
    emoji: "🕍"
  },
  {
    name: "kaaba",
    emoji: "🕋"
  },
  {
    name: "shinto_shrine",
    emoji: "⛩"
  },
  {
    name: "watch",
    emoji: "⌚"
  },
  {
    name: "iphone",
    emoji: "📱"
  },
  {
    name: "calling",
    emoji: "📲"
  },
  {
    name: "computer",
    emoji: "💻"
  },
  {
    name: "keyboard",
    emoji: "⌨"
  },
  {
    name: "desktop_computer",
    emoji: "🖥"
  },
  {
    name: "printer",
    emoji: "🖨"
  },
  {
    name: "computer_mouse",
    emoji: "🖱"
  },
  {
    name: "trackball",
    emoji: "🖲"
  },
  {
    name: "joystick",
    emoji: "🕹"
  },
  {
    name: "clamp",
    emoji: "🗜"
  },
  {
    name: "minidisc",
    emoji: "💽"
  },
  {
    name: "floppy_disk",
    emoji: "💾"
  },
  {
    name: "cd",
    emoji: "💿"
  },
  {
    name: "dvd",
    emoji: "📀"
  },
  {
    name: "vhs",
    emoji: "📼"
  },
  {
    name: "camera",
    emoji: "📷"
  },
  {
    name: "camera_flash",
    emoji: "📸"
  },
  {
    name: "video_camera",
    emoji: "📹"
  },
  {
    name: "movie_camera",
    emoji: "🎥"
  },
  {
    name: "film_projector",
    emoji: "📽"
  },
  {
    name: "film_strip",
    emoji: "🎞"
  },
  {
    name: "telephone_receiver",
    emoji: "📞"
  },
  {
    name: "phone",
    emoji: "☎"
  },
  {
    name: "pager",
    emoji: "📟"
  },
  {
    name: "fax",
    emoji: "📠"
  },
  {
    name: "tv",
    emoji: "📺"
  },
  {
    name: "radio",
    emoji: "📻"
  },
  {
    name: "studio_microphone",
    emoji: "🎙"
  },
  {
    name: "level_slider",
    emoji: "🎚"
  },
  {
    name: "control_knobs",
    emoji: "🎛"
  },
  {
    name: "stopwatch",
    emoji: "⏱"
  },
  {
    name: "timer_clock",
    emoji: "⏲"
  },
  {
    name: "alarm_clock",
    emoji: "⏰"
  },
  {
    name: "mantelpiece_clock",
    emoji: "🕰"
  },
  {
    name: "hourglass_flowing_sand",
    emoji: "⏳"
  },
  {
    name: "hourglass",
    emoji: "⌛"
  },
  {
    name: "satellite",
    emoji: "📡"
  },
  {
    name: "battery",
    emoji: "🔋"
  },
  {
    name: "electric_plug",
    emoji: "🔌"
  },
  {
    name: "bulb",
    emoji: "💡"
  },
  {
    name: "flashlight",
    emoji: "🔦"
  },
  {
    name: "candle",
    emoji: "🕯"
  },
  {
    name: "wastebasket",
    emoji: "🗑"
  },
  {
    name: "oil_drum",
    emoji: "🛢"
  },
  {
    name: "money_with_wings",
    emoji: "💸"
  },
  {
    name: "dollar",
    emoji: "💵"
  },
  {
    name: "yen",
    emoji: "💴"
  },
  {
    name: "euro",
    emoji: "💶"
  },
  {
    name: "pound",
    emoji: "💷"
  },
  {
    name: "moneybag",
    emoji: "💰"
  },
  {
    name: "credit_card",
    emoji: "💳"
  },
  {
    name: "gem",
    emoji: "💎"
  },
  {
    name: "balance_scale",
    emoji: "⚖"
  },
  {
    name: "wrench",
    emoji: "🔧"
  },
  {
    name: "hammer",
    emoji: "🔨"
  },
  {
    name: "hammer_and_pick",
    emoji: "⚒"
  },
  {
    name: "hammer_and_wrench",
    emoji: "🛠"
  },
  {
    name: "pick",
    emoji: "⛏"
  },
  {
    name: "nut_and_bolt",
    emoji: "🔩"
  },
  {
    name: "gear",
    emoji: "⚙"
  },
  {
    name: "chains",
    emoji: "⛓"
  },
  {
    name: "gun",
    emoji: "🔫"
  },
  {
    name: "bomb",
    emoji: "💣"
  },
  {
    name: "hocho",
    emoji: "🔪"
  },
  {
    name: "dagger",
    emoji: "🗡"
  },
  {
    name: "crossed_swords",
    emoji: "⚔"
  },
  {
    name: "shield",
    emoji: "🛡"
  },
  {
    name: "smoking",
    emoji: "🚬"
  },
  {
    name: "skull_and_crossbones",
    emoji: "☠"
  },
  {
    name: "coffin",
    emoji: "⚰"
  },
  {
    name: "funeral_urn",
    emoji: "⚱"
  },
  {
    name: "amphora",
    emoji: "🏺"
  },
  {
    name: "crystal_ball",
    emoji: "🔮"
  },
  {
    name: "prayer_beads",
    emoji: "📿"
  },
  {
    name: "barber",
    emoji: "💈"
  },
  {
    name: "alembic",
    emoji: "⚗"
  },
  {
    name: "telescope",
    emoji: "🔭"
  },
  {
    name: "microscope",
    emoji: "🔬"
  },
  {
    name: "hole",
    emoji: "🕳"
  },
  {
    name: "pill",
    emoji: "💊"
  },
  {
    name: "syringe",
    emoji: "💉"
  },
  {
    name: "thermometer",
    emoji: "🌡"
  },
  {
    name: "label",
    emoji: "🏷"
  },
  {
    name: "bookmark",
    emoji: "🔖"
  },
  {
    name: "toilet",
    emoji: "🚽"
  },
  {
    name: "shower",
    emoji: "🚿"
  },
  {
    name: "bathtub",
    emoji: "🛁"
  },
  {
    name: "key",
    emoji: "🔑"
  },
  {
    name: "old_key",
    emoji: "🗝"
  },
  {
    name: "couch_and_lamp",
    emoji: "🛋"
  },
  {
    name: "sleeping_bed",
    emoji: "🛌"
  },
  {
    name: "bed",
    emoji: "🛏"
  },
  {
    name: "door",
    emoji: "🚪"
  },
  {
    name: "bellhop_bell",
    emoji: "🛎"
  },
  {
    name: "framed_picture",
    emoji: "🖼"
  },
  {
    name: "world_map",
    emoji: "🗺"
  },
  {
    name: "parasol_on_ground",
    emoji: "⛱"
  },
  {
    name: "moyai",
    emoji: "🗿"
  },
  {
    name: "shopping",
    emoji: "🛍"
  },
  {
    name: "shopping_cart",
    emoji: "🛒"
  },
  {
    name: "balloon",
    emoji: "🎈"
  },
  {
    name: "flags",
    emoji: "🎏"
  },
  {
    name: "ribbon",
    emoji: "🎀"
  },
  {
    name: "gift",
    emoji: "🎁"
  },
  {
    name: "confetti_ball",
    emoji: "🎊"
  },
  {
    name: "tada",
    emoji: "🎉"
  },
  {
    name: "dolls",
    emoji: "🎎"
  },
  {
    name: "wind_chime",
    emoji: "🎐"
  },
  {
    name: "crossed_flags",
    emoji: "🎌"
  },
  {
    name: "izakaya_lantern",
    emoji: "🏮"
  },
  {
    name: "email",
    emoji: "✉"
  },
  {
    name: "envelope_with_arrow",
    emoji: "📩"
  },
  {
    name: "incoming_envelope",
    emoji: "📨"
  },
  {
    name: "e-mail",
    emoji: "📧"
  },
  {
    name: "love_letter",
    emoji: "💌"
  },
  {
    name: "postbox",
    emoji: "📮"
  },
  {
    name: "mailbox_closed",
    emoji: "📪"
  },
  {
    name: "mailbox",
    emoji: "📫"
  },
  {
    name: "mailbox_with_mail",
    emoji: "📬"
  },
  {
    name: "mailbox_with_no_mail",
    emoji: "📭"
  },
  {
    name: "package",
    emoji: "📦"
  },
  {
    name: "postal_horn",
    emoji: "📯"
  },
  {
    name: "inbox_tray",
    emoji: "📥"
  },
  {
    name: "outbox_tray",
    emoji: "📤"
  },
  {
    name: "scroll",
    emoji: "📜"
  },
  {
    name: "page_with_curl",
    emoji: "📃"
  },
  {
    name: "bookmark_tabs",
    emoji: "📑"
  },
  {
    name: "bar_chart",
    emoji: "📊"
  },
  {
    name: "chart_with_upwards_trend",
    emoji: "📈"
  },
  {
    name: "chart_with_downwards_trend",
    emoji: "📉"
  },
  {
    name: "page_facing_up",
    emoji: "📄"
  },
  {
    name: "date",
    emoji: "📅"
  },
  {
    name: "calendar",
    emoji: "📆"
  },
  {
    name: "spiral_calendar",
    emoji: "🗓"
  },
  {
    name: "card_index",
    emoji: "📇"
  },
  {
    name: "card_file_box",
    emoji: "🗃"
  },
  {
    name: "ballot_box",
    emoji: "🗳"
  },
  {
    name: "file_cabinet",
    emoji: "🗄"
  },
  {
    name: "clipboard",
    emoji: "📋"
  },
  {
    name: "spiral_notepad",
    emoji: "🗒"
  },
  {
    name: "file_folder",
    emoji: "📁"
  },
  {
    name: "open_file_folder",
    emoji: "📂"
  },
  {
    name: "card_index_dividers",
    emoji: "🗂"
  },
  {
    name: "newspaper_roll",
    emoji: "🗞"
  },
  {
    name: "newspaper",
    emoji: "📰"
  },
  {
    name: "notebook",
    emoji: "📓"
  },
  {
    name: "closed_book",
    emoji: "📕"
  },
  {
    name: "green_book",
    emoji: "📗"
  },
  {
    name: "blue_book",
    emoji: "📘"
  },
  {
    name: "orange_book",
    emoji: "📙"
  },
  {
    name: "notebook_with_decorative_cover",
    emoji: "📔"
  },
  {
    name: "ledger",
    emoji: "📒"
  },
  {
    name: "books",
    emoji: "📚"
  },
  {
    name: "open_book",
    emoji: "📖"
  },
  {
    name: "link",
    emoji: "🔗"
  },
  {
    name: "paperclip",
    emoji: "📎"
  },
  {
    name: "paperclips",
    emoji: "🖇"
  },
  {
    name: "scissors",
    emoji: "✂"
  },
  {
    name: "triangular_ruler",
    emoji: "📐"
  },
  {
    name: "straight_ruler",
    emoji: "📏"
  },
  {
    name: "pushpin",
    emoji: "📌"
  },
  {
    name: "round_pushpin",
    emoji: "📍"
  },
  {
    name: "triangular_flag_on_post",
    emoji: "🚩"
  },
  {
    name: "white_flag",
    emoji: "🏳"
  },
  {
    name: "black_flag",
    emoji: "🏴"
  },
  {
    name: "rainbow_flag",
    emoji: "🏳️‍🌈"
  },
  {
    name: "closed_lock_with_key",
    emoji: "🔐"
  },
  {
    name: "lock",
    emoji: "🔒"
  },
  {
    name: "unlock",
    emoji: "🔓"
  },
  {
    name: "lock_with_ink_pen",
    emoji: "🔏"
  },
  {
    name: "pen",
    emoji: "🖊"
  },
  {
    name: "fountain_pen",
    emoji: "🖋"
  },
  {
    name: "black_nib",
    emoji: "✒"
  },
  {
    name: "memo",
    emoji: "📝"
  },
  {
    name: "pencil2",
    emoji: "✏"
  },
  {
    name: "crayon",
    emoji: "🖍"
  },
  {
    name: "paintbrush",
    emoji: "🖌"
  },
  {
    name: "mag",
    emoji: "🔍"
  },
  {
    name: "mag_right",
    emoji: "🔎"
  },
  {
    name: "heart",
    emoji: "❤"
  },
  {
    name: "yellow_heart",
    emoji: "💛"
  },
  {
    name: "green_heart",
    emoji: "💚"
  },
  {
    name: "blue_heart",
    emoji: "💙"
  },
  {
    name: "purple_heart",
    emoji: "💜"
  },
  {
    name: "black_heart",
    emoji: "🖤"
  },
  {
    name: "broken_heart",
    emoji: "💔"
  },
  {
    name: "heavy_heart_exclamation",
    emoji: "❣"
  },
  {
    name: "two_hearts",
    emoji: "💕"
  },
  {
    name: "revolving_hearts",
    emoji: "💞"
  },
  {
    name: "heartbeat",
    emoji: "💓"
  },
  {
    name: "heartpulse",
    emoji: "💗"
  },
  {
    name: "sparkling_heart",
    emoji: "💖"
  },
  {
    name: "cupid",
    emoji: "💘"
  },
  {
    name: "gift_heart",
    emoji: "💝"
  },
  {
    name: "heart_decoration",
    emoji: "💟"
  },
  {
    name: "peace_symbol",
    emoji: "☮"
  },
  {
    name: "latin_cross",
    emoji: "✝"
  },
  {
    name: "star_and_crescent",
    emoji: "☪"
  },
  {
    name: "om",
    emoji: "🕉"
  },
  {
    name: "wheel_of_dharma",
    emoji: "☸"
  },
  {
    name: "star_of_david",
    emoji: "✡"
  },
  {
    name: "six_pointed_star",
    emoji: "🔯"
  },
  {
    name: "menorah",
    emoji: "🕎"
  },
  {
    name: "yin_yang",
    emoji: "☯"
  },
  {
    name: "orthodox_cross",
    emoji: "☦"
  },
  {
    name: "place_of_worship",
    emoji: "🛐"
  },
  {
    name: "ophiuchus",
    emoji: "⛎"
  },
  {
    name: "aries",
    emoji: "♈"
  },
  {
    name: "taurus",
    emoji: "♉"
  },
  {
    name: "gemini",
    emoji: "♊"
  },
  {
    name: "cancer",
    emoji: "♋"
  },
  {
    name: "leo",
    emoji: "♌"
  },
  {
    name: "virgo",
    emoji: "♍"
  },
  {
    name: "libra",
    emoji: "♎"
  },
  {
    name: "scorpius",
    emoji: "♏"
  },
  {
    name: "sagittarius",
    emoji: "♐"
  },
  {
    name: "capricorn",
    emoji: "♑"
  },
  {
    name: "aquarius",
    emoji: "♒"
  },
  {
    name: "pisces",
    emoji: "♓"
  },
  {
    name: "id",
    emoji: "🆔"
  },
  {
    name: "atom_symbol",
    emoji: "⚛"
  },
  {
    name: "u7a7a",
    emoji: "🈳"
  },
  {
    name: "u5272",
    emoji: "🈹"
  },
  {
    name: "radioactive",
    emoji: "☢"
  },
  {
    name: "biohazard",
    emoji: "☣"
  },
  {
    name: "mobile_phone_off",
    emoji: "📴"
  },
  {
    name: "vibration_mode",
    emoji: "📳"
  },
  {
    name: "u6709",
    emoji: "🈶"
  },
  {
    name: "u7121",
    emoji: "🈚"
  },
  {
    name: "u7533",
    emoji: "🈸"
  },
  {
    name: "u55b6",
    emoji: "🈺"
  },
  {
    name: "u6708",
    emoji: "🈷"
  },
  {
    name: "eight_pointed_black_star",
    emoji: "✴"
  },
  {
    name: "vs",
    emoji: "🆚"
  },
  {
    name: "accept",
    emoji: "🉑"
  },
  {
    name: "white_flower",
    emoji: "💮"
  },
  {
    name: "ideograph_advantage",
    emoji: "🉐"
  },
  {
    name: "secret",
    emoji: "㊙"
  },
  {
    name: "congratulations",
    emoji: "㊗"
  },
  {
    name: "u5408",
    emoji: "🈴"
  },
  {
    name: "u6e80",
    emoji: "🈵"
  },
  {
    name: "u7981",
    emoji: "🈲"
  },
  {
    name: "a",
    emoji: "🅰"
  },
  {
    name: "b",
    emoji: "🅱"
  },
  {
    name: "ab",
    emoji: "🆎"
  },
  {
    name: "cl",
    emoji: "🆑"
  },
  {
    name: "o2",
    emoji: "🅾"
  },
  {
    name: "sos",
    emoji: "🆘"
  },
  {
    name: "no_entry",
    emoji: "⛔"
  },
  {
    name: "name_badge",
    emoji: "📛"
  },
  {
    name: "no_entry_sign",
    emoji: "🚫"
  },
  {
    name: "x",
    emoji: "❌"
  },
  {
    name: "o",
    emoji: "⭕"
  },
  {
    name: "stop_sign",
    emoji: "🛑"
  },
  {
    name: "anger",
    emoji: "💢"
  },
  {
    name: "hotsprings",
    emoji: "♨"
  },
  {
    name: "no_pedestrians",
    emoji: "🚷"
  },
  {
    name: "do_not_litter",
    emoji: "🚯"
  },
  {
    name: "no_bicycles",
    emoji: "🚳"
  },
  {
    name: "non-potable_water",
    emoji: "🚱"
  },
  {
    name: "underage",
    emoji: "🔞"
  },
  {
    name: "no_mobile_phones",
    emoji: "📵"
  },
  {
    name: "exclamation",
    emoji: "❗"
  },
  {
    name: "grey_exclamation",
    emoji: "❕"
  },
  {
    name: "question",
    emoji: "❓"
  },
  {
    name: "grey_question",
    emoji: "❔"
  },
  {
    name: "bangbang",
    emoji: "‼"
  },
  {
    name: "interrobang",
    emoji: "⁉"
  },
  {
    name: "100",
    emoji: "💯"
  },
  {
    name: "low_brightness",
    emoji: "🔅"
  },
  {
    name: "high_brightness",
    emoji: "🔆"
  },
  {
    name: "trident",
    emoji: "🔱"
  },
  {
    name: "fleur_de_lis",
    emoji: "⚜"
  },
  {
    name: "part_alternation_mark",
    emoji: "〽"
  },
  {
    name: "warning",
    emoji: "⚠"
  },
  {
    name: "children_crossing",
    emoji: "🚸"
  },
  {
    name: "beginner",
    emoji: "🔰"
  },
  {
    name: "recycle",
    emoji: "♻"
  },
  {
    name: "u6307",
    emoji: "🈯"
  },
  {
    name: "chart",
    emoji: "💹"
  },
  {
    name: "sparkle",
    emoji: "❇"
  },
  {
    name: "eight_spoked_asterisk",
    emoji: "✳"
  },
  {
    name: "negative_squared_cross_mark",
    emoji: "❎"
  },
  {
    name: "white_check_mark",
    emoji: "✅"
  },
  {
    name: "diamond_shape_with_a_dot_inside",
    emoji: "💠"
  },
  {
    name: "cyclone",
    emoji: "🌀"
  },
  {
    name: "loop",
    emoji: "➿"
  },
  {
    name: "globe_with_meridians",
    emoji: "🌐"
  },
  {
    name: "m",
    emoji: "Ⓜ"
  },
  {
    name: "atm",
    emoji: "🏧"
  },
  {
    name: "sa",
    emoji: "🈂"
  },
  {
    name: "passport_control",
    emoji: "🛂"
  },
  {
    name: "customs",
    emoji: "🛃"
  },
  {
    name: "baggage_claim",
    emoji: "🛄"
  },
  {
    name: "left_luggage",
    emoji: "🛅"
  },
  {
    name: "wheelchair",
    emoji: "♿"
  },
  {
    name: "no_smoking",
    emoji: "🚭"
  },
  {
    name: "wc",
    emoji: "🚾"
  },
  {
    name: "parking",
    emoji: "🅿"
  },
  {
    name: "potable_water",
    emoji: "🚰"
  },
  {
    name: "mens",
    emoji: "🚹"
  },
  {
    name: "womens",
    emoji: "🚺"
  },
  {
    name: "baby_symbol",
    emoji: "🚼"
  },
  {
    name: "restroom",
    emoji: "🚻"
  },
  {
    name: "put_litter_in_its_place",
    emoji: "🚮"
  },
  {
    name: "cinema",
    emoji: "🎦"
  },
  {
    name: "signal_strength",
    emoji: "📶"
  },
  {
    name: "koko",
    emoji: "🈁"
  },
  {
    name: "ng",
    emoji: "🆖"
  },
  {
    name: "ok",
    emoji: "🆗"
  },
  {
    name: "up",
    emoji: "🆙"
  },
  {
    name: "cool",
    emoji: "🆒"
  },
  {
    name: "new",
    emoji: "🆕"
  },
  {
    name: "free",
    emoji: "🆓"
  },
  {
    name: "zero",
    emoji: "0️⃣"
  },
  {
    name: "one",
    emoji: "1️⃣"
  },
  {
    name: "two",
    emoji: "2️⃣"
  },
  {
    name: "three",
    emoji: "3️⃣"
  },
  {
    name: "four",
    emoji: "4️⃣"
  },
  {
    name: "five",
    emoji: "5️⃣"
  },
  {
    name: "six",
    emoji: "6️⃣"
  },
  {
    name: "seven",
    emoji: "7️⃣"
  },
  {
    name: "eight",
    emoji: "8️⃣"
  },
  {
    name: "nine",
    emoji: "9️⃣"
  },
  {
    name: "keycap_ten",
    emoji: "🔟"
  },
  {
    name: "asterisk",
    emoji: "*️⃣"
  },
  {
    name: "1234",
    emoji: "🔢"
  },
  {
    name: "arrow_forward",
    emoji: "▶"
  },
  {
    name: "pause_button",
    emoji: "⏸"
  },
  {
    name: "next_track_button",
    emoji: "⏭"
  },
  {
    name: "stop_button",
    emoji: "⏹"
  },
  {
    name: "record_button",
    emoji: "⏺"
  },
  {
    name: "play_or_pause_button",
    emoji: "⏯"
  },
  {
    name: "previous_track_button",
    emoji: "⏮"
  },
  {
    name: "fast_forward",
    emoji: "⏩"
  },
  {
    name: "rewind",
    emoji: "⏪"
  },
  {
    name: "twisted_rightwards_arrows",
    emoji: "🔀"
  },
  {
    name: "repeat",
    emoji: "🔁"
  },
  {
    name: "repeat_one",
    emoji: "🔂"
  },
  {
    name: "arrow_backward",
    emoji: "◀"
  },
  {
    name: "arrow_up_small",
    emoji: "🔼"
  },
  {
    name: "arrow_down_small",
    emoji: "🔽"
  },
  {
    name: "arrow_double_up",
    emoji: "⏫"
  },
  {
    name: "arrow_double_down",
    emoji: "⏬"
  },
  {
    name: "arrow_right",
    emoji: "➡"
  },
  {
    name: "arrow_left",
    emoji: "⬅"
  },
  {
    name: "arrow_up",
    emoji: "⬆"
  },
  {
    name: "arrow_down",
    emoji: "⬇"
  },
  {
    name: "arrow_upper_right",
    emoji: "↗"
  },
  {
    name: "arrow_lower_right",
    emoji: "↘"
  },
  {
    name: "arrow_lower_left",
    emoji: "↙"
  },
  {
    name: "arrow_upper_left",
    emoji: "↖"
  },
  {
    name: "arrow_up_down",
    emoji: "↕"
  },
  {
    name: "left_right_arrow",
    emoji: "↔"
  },
  {
    name: "arrows_counterclockwise",
    emoji: "🔄"
  },
  {
    name: "arrow_right_hook",
    emoji: "↪"
  },
  {
    name: "leftwards_arrow_with_hook",
    emoji: "↩"
  },
  {
    name: "arrow_heading_up",
    emoji: "⤴"
  },
  {
    name: "arrow_heading_down",
    emoji: "⤵"
  },
  {
    name: "hash",
    emoji: "#️⃣"
  },
  {
    name: "information_source",
    emoji: "ℹ"
  },
  {
    name: "abc",
    emoji: "🔤"
  },
  {
    name: "abcd",
    emoji: "🔡"
  },
  {
    name: "capital_abcd",
    emoji: "🔠"
  },
  {
    name: "symbols",
    emoji: "🔣"
  },
  {
    name: "musical_note",
    emoji: "🎵"
  },
  {
    name: "notes",
    emoji: "🎶"
  },
  {
    name: "wavy_dash",
    emoji: "〰"
  },
  {
    name: "curly_loop",
    emoji: "➰"
  },
  {
    name: "heavy_check_mark",
    emoji: "✔"
  },
  {
    name: "arrows_clockwise",
    emoji: "🔃"
  },
  {
    name: "heavy_plus_sign",
    emoji: "➕"
  },
  {
    name: "heavy_minus_sign",
    emoji: "➖"
  },
  {
    name: "heavy_division_sign",
    emoji: "➗"
  },
  {
    name: "heavy_multiplication_x",
    emoji: "✖"
  },
  {
    name: "heavy_dollar_sign",
    emoji: "💲"
  },
  {
    name: "currency_exchange",
    emoji: "💱"
  },
  {
    name: "copyright",
    emoji: "©"
  },
  {
    name: "registered",
    emoji: "®"
  },
  {
    name: "tm",
    emoji: "™"
  },
  {
    name: "end",
    emoji: "🔚"
  },
  {
    name: "back",
    emoji: "🔙"
  },
  {
    name: "on",
    emoji: "🔛"
  },
  {
    name: "top",
    emoji: "🔝"
  },
  {
    name: "soon",
    emoji: "🔜"
  },
  {
    name: "ballot_box_with_check",
    emoji: "☑"
  },
  {
    name: "radio_button",
    emoji: "🔘"
  },
  {
    name: "white_circle",
    emoji: "⚪"
  },
  {
    name: "black_circle",
    emoji: "⚫"
  },
  {
    name: "red_circle",
    emoji: "🔴"
  },
  {
    name: "large_blue_circle",
    emoji: "🔵"
  },
  {
    name: "small_orange_diamond",
    emoji: "🔸"
  },
  {
    name: "small_blue_diamond",
    emoji: "🔹"
  },
  {
    name: "large_orange_diamond",
    emoji: "🔶"
  },
  {
    name: "large_blue_diamond",
    emoji: "🔷"
  },
  {
    name: "small_red_triangle",
    emoji: "🔺"
  },
  {
    name: "black_small_square",
    emoji: "▪"
  },
  {
    name: "white_small_square",
    emoji: "▫"
  },
  {
    name: "black_large_square",
    emoji: "⬛"
  },
  {
    name: "white_large_square",
    emoji: "⬜"
  },
  {
    name: "small_red_triangle_down",
    emoji: "🔻"
  },
  {
    name: "black_medium_square",
    emoji: "◼"
  },
  {
    name: "white_medium_square",
    emoji: "◻"
  },
  {
    name: "black_medium_small_square",
    emoji: "◾"
  },
  {
    name: "white_medium_small_square",
    emoji: "◽"
  },
  {
    name: "black_square_button",
    emoji: "🔲"
  },
  {
    name: "white_square_button",
    emoji: "🔳"
  },
  {
    name: "speaker",
    emoji: "🔈"
  },
  {
    name: "sound",
    emoji: "🔉"
  },
  {
    name: "loud_sound",
    emoji: "🔊"
  },
  {
    name: "mute",
    emoji: "🔇"
  },
  {
    name: "mega",
    emoji: "📣"
  },
  {
    name: "loudspeaker",
    emoji: "📢"
  },
  {
    name: "bell",
    emoji: "🔔"
  },
  {
    name: "no_bell",
    emoji: "🔕"
  },
  {
    name: "black_joker",
    emoji: "🃏"
  },
  {
    name: "mahjong",
    emoji: "🀄"
  },
  {
    name: "spades",
    emoji: "♠"
  },
  {
    name: "clubs",
    emoji: "♣"
  },
  {
    name: "hearts",
    emoji: "♥"
  },
  {
    name: "diamonds",
    emoji: "♦"
  },
  {
    name: "flower_playing_cards",
    emoji: "🎴"
  },
  {
    name: "thought_balloon",
    emoji: "💭"
  },
  {
    name: "right_anger_bubble",
    emoji: "🗯"
  },
  {
    name: "speech_balloon",
    emoji: "💬"
  },
  {
    name: "left_speech_bubble",
    emoji: "🗨"
  },
  {
    name: "clock1",
    emoji: "🕐"
  },
  {
    name: "clock2",
    emoji: "🕑"
  },
  {
    name: "clock3",
    emoji: "🕒"
  },
  {
    name: "clock4",
    emoji: "🕓"
  },
  {
    name: "clock5",
    emoji: "🕔"
  },
  {
    name: "clock6",
    emoji: "🕕"
  },
  {
    name: "clock7",
    emoji: "🕖"
  },
  {
    name: "clock8",
    emoji: "🕗"
  },
  {
    name: "clock9",
    emoji: "🕘"
  },
  {
    name: "clock10",
    emoji: "🕙"
  },
  {
    name: "clock11",
    emoji: "🕚"
  },
  {
    name: "clock12",
    emoji: "🕛"
  },
  {
    name: "clock130",
    emoji: "🕜"
  },
  {
    name: "clock230",
    emoji: "🕝"
  },
  {
    name: "clock330",
    emoji: "🕞"
  },
  {
    name: "clock430",
    emoji: "🕟"
  },
  {
    name: "clock530",
    emoji: "🕠"
  },
  {
    name: "clock630",
    emoji: "🕡"
  },
  {
    name: "clock730",
    emoji: "🕢"
  },
  {
    name: "clock830",
    emoji: "🕣"
  },
  {
    name: "clock930",
    emoji: "🕤"
  },
  {
    name: "clock1030",
    emoji: "🕥"
  },
  {
    name: "clock1130",
    emoji: "🕦"
  },
  {
    name: "clock1230",
    emoji: "🕧"
  },
  {
    name: "afghanistan",
    emoji: "🇦🇫"
  },
  {
    name: "aland_islands",
    emoji: "🇦🇽"
  },
  {
    name: "albania",
    emoji: "🇦🇱"
  },
  {
    name: "algeria",
    emoji: "🇩🇿"
  },
  {
    name: "american_samoa",
    emoji: "🇦🇸"
  },
  {
    name: "andorra",
    emoji: "🇦🇩"
  },
  {
    name: "angola",
    emoji: "🇦🇴"
  },
  {
    name: "anguilla",
    emoji: "🇦🇮"
  },
  {
    name: "antarctica",
    emoji: "🇦🇶"
  },
  {
    name: "antigua_barbuda",
    emoji: "🇦🇬"
  },
  {
    name: "argentina",
    emoji: "🇦🇷"
  },
  {
    name: "armenia",
    emoji: "🇦🇲"
  },
  {
    name: "aruba",
    emoji: "🇦🇼"
  },
  {
    name: "australia",
    emoji: "🇦🇺"
  },
  {
    name: "austria",
    emoji: "🇦🇹"
  },
  {
    name: "azerbaijan",
    emoji: "🇦🇿"
  },
  {
    name: "bahamas",
    emoji: "🇧🇸"
  },
  {
    name: "bahrain",
    emoji: "🇧🇭"
  },
  {
    name: "bangladesh",
    emoji: "🇧🇩"
  },
  {
    name: "barbados",
    emoji: "🇧🇧"
  },
  {
    name: "belarus",
    emoji: "🇧🇾"
  },
  {
    name: "belgium",
    emoji: "🇧🇪"
  },
  {
    name: "belize",
    emoji: "🇧🇿"
  },
  {
    name: "benin",
    emoji: "🇧🇯"
  },
  {
    name: "bermuda",
    emoji: "🇧🇲"
  },
  {
    name: "bhutan",
    emoji: "🇧🇹"
  },
  {
    name: "bolivia",
    emoji: "🇧🇴"
  },
  {
    name: "caribbean_netherlands",
    emoji: "🇧🇶"
  },
  {
    name: "bosnia_herzegovina",
    emoji: "🇧🇦"
  },
  {
    name: "botswana",
    emoji: "🇧🇼"
  },
  {
    name: "brazil",
    emoji: "🇧🇷"
  },
  {
    name: "british_indian_ocean_territory",
    emoji: "🇮🇴"
  },
  {
    name: "british_virgin_islands",
    emoji: "🇻🇬"
  },
  {
    name: "brunei",
    emoji: "🇧🇳"
  },
  {
    name: "bulgaria",
    emoji: "🇧🇬"
  },
  {
    name: "burkina_faso",
    emoji: "🇧🇫"
  },
  {
    name: "burundi",
    emoji: "🇧🇮"
  },
  {
    name: "cape_verde",
    emoji: "🇨🇻"
  },
  {
    name: "cambodia",
    emoji: "🇰🇭"
  },
  {
    name: "cameroon",
    emoji: "🇨🇲"
  },
  {
    name: "canada",
    emoji: "🇨🇦"
  },
  {
    name: "canary_islands",
    emoji: "🇮🇨"
  },
  {
    name: "cayman_islands",
    emoji: "🇰🇾"
  },
  {
    name: "central_african_republic",
    emoji: "🇨🇫"
  },
  {
    name: "chad",
    emoji: "🇹🇩"
  },
  {
    name: "chile",
    emoji: "🇨🇱"
  },
  {
    name: "cn",
    emoji: "🇨🇳"
  },
  {
    name: "christmas_island",
    emoji: "🇨🇽"
  },
  {
    name: "cocos_islands",
    emoji: "🇨🇨"
  },
  {
    name: "colombia",
    emoji: "🇨🇴"
  },
  {
    name: "comoros",
    emoji: "🇰🇲"
  },
  {
    name: "congo_brazzaville",
    emoji: "🇨🇬"
  },
  {
    name: "congo_kinshasa",
    emoji: "🇨🇩"
  },
  {
    name: "cook_islands",
    emoji: "🇨🇰"
  },
  {
    name: "costa_rica",
    emoji: "🇨🇷"
  },
  {
    name: "croatia",
    emoji: "🇭🇷"
  },
  {
    name: "cuba",
    emoji: "🇨🇺"
  },
  {
    name: "curacao",
    emoji: "🇨🇼"
  },
  {
    name: "cyprus",
    emoji: "🇨🇾"
  },
  {
    name: "czech_republic",
    emoji: "🇨🇿"
  },
  {
    name: "denmark",
    emoji: "🇩🇰"
  },
  {
    name: "djibouti",
    emoji: "🇩🇯"
  },
  {
    name: "dominica",
    emoji: "🇩🇲"
  },
  {
    name: "dominican_republic",
    emoji: "🇩🇴"
  },
  {
    name: "ecuador",
    emoji: "🇪🇨"
  },
  {
    name: "egypt",
    emoji: "🇪🇬"
  },
  {
    name: "el_salvador",
    emoji: "🇸🇻"
  },
  {
    name: "equatorial_guinea",
    emoji: "🇬🇶"
  },
  {
    name: "eritrea",
    emoji: "🇪🇷"
  },
  {
    name: "estonia",
    emoji: "🇪🇪"
  },
  {
    name: "ethiopia",
    emoji: "🇪🇹"
  },
  {
    name: "eu",
    emoji: "🇪🇺"
  },
  {
    name: "falkland_islands",
    emoji: "🇫🇰"
  },
  {
    name: "faroe_islands",
    emoji: "🇫🇴"
  },
  {
    name: "fiji",
    emoji: "🇫🇯"
  },
  {
    name: "finland",
    emoji: "🇫🇮"
  },
  {
    name: "fr",
    emoji: "🇫🇷"
  },
  {
    name: "french_guiana",
    emoji: "🇬🇫"
  },
  {
    name: "french_polynesia",
    emoji: "🇵🇫"
  },
  {
    name: "french_southern_territories",
    emoji: "🇹🇫"
  },
  {
    name: "gabon",
    emoji: "🇬🇦"
  },
  {
    name: "gambia",
    emoji: "🇬🇲"
  },
  {
    name: "georgia",
    emoji: "🇬🇪"
  },
  {
    name: "de",
    emoji: "🇩🇪"
  },
  {
    name: "ghana",
    emoji: "🇬🇭"
  },
  {
    name: "gibraltar",
    emoji: "🇬🇮"
  },
  {
    name: "greece",
    emoji: "🇬🇷"
  },
  {
    name: "greenland",
    emoji: "🇬🇱"
  },
  {
    name: "grenada",
    emoji: "🇬🇩"
  },
  {
    name: "guadeloupe",
    emoji: "🇬🇵"
  },
  {
    name: "guam",
    emoji: "🇬🇺"
  },
  {
    name: "guatemala",
    emoji: "🇬🇹"
  },
  {
    name: "guernsey",
    emoji: "🇬🇬"
  },
  {
    name: "guinea",
    emoji: "🇬🇳"
  },
  {
    name: "guinea_bissau",
    emoji: "🇬🇼"
  },
  {
    name: "guyana",
    emoji: "🇬🇾"
  },
  {
    name: "haiti",
    emoji: "🇭🇹"
  },
  {
    name: "honduras",
    emoji: "🇭🇳"
  },
  {
    name: "hong_kong",
    emoji: "🇭🇰"
  },
  {
    name: "hungary",
    emoji: "🇭🇺"
  },
  {
    name: "iceland",
    emoji: "🇮🇸"
  },
  {
    name: "india",
    emoji: "🇮🇳"
  },
  {
    name: "indonesia",
    emoji: "🇮🇩"
  },
  {
    name: "iran",
    emoji: "🇮🇷"
  },
  {
    name: "iraq",
    emoji: "🇮🇶"
  },
  {
    name: "ireland",
    emoji: "🇮🇪"
  },
  {
    name: "isle_of_man",
    emoji: "🇮🇲"
  },
  {
    name: "israel",
    emoji: "🇮🇱"
  },
  {
    name: "it",
    emoji: "🇮🇹"
  },
  {
    name: "cote_divoire",
    emoji: "🇨🇮"
  },
  {
    name: "jamaica",
    emoji: "🇯🇲"
  },
  {
    name: "jp",
    emoji: "🇯🇵"
  },
  {
    name: "jersey",
    emoji: "🇯🇪"
  },
  {
    name: "jordan",
    emoji: "🇯🇴"
  },
  {
    name: "kazakhstan",
    emoji: "🇰🇿"
  },
  {
    name: "kenya",
    emoji: "🇰🇪"
  },
  {
    name: "kiribati",
    emoji: "🇰🇮"
  },
  {
    name: "kosovo",
    emoji: "🇽🇰"
  },
  {
    name: "kuwait",
    emoji: "🇰🇼"
  },
  {
    name: "kyrgyzstan",
    emoji: "🇰🇬"
  },
  {
    name: "laos",
    emoji: "🇱🇦"
  },
  {
    name: "latvia",
    emoji: "🇱🇻"
  },
  {
    name: "lebanon",
    emoji: "🇱🇧"
  },
  {
    name: "lesotho",
    emoji: "🇱🇸"
  },
  {
    name: "liberia",
    emoji: "🇱🇷"
  },
  {
    name: "libya",
    emoji: "🇱🇾"
  },
  {
    name: "liechtenstein",
    emoji: "🇱🇮"
  },
  {
    name: "lithuania",
    emoji: "🇱🇹"
  },
  {
    name: "luxembourg",
    emoji: "🇱🇺"
  },
  {
    name: "macau",
    emoji: "🇲🇴"
  },
  {
    name: "macedonia",
    emoji: "🇲🇰"
  },
  {
    name: "madagascar",
    emoji: "🇲🇬"
  },
  {
    name: "malawi",
    emoji: "🇲🇼"
  },
  {
    name: "malaysia",
    emoji: "🇲🇾"
  },
  {
    name: "maldives",
    emoji: "🇲🇻"
  },
  {
    name: "mali",
    emoji: "🇲🇱"
  },
  {
    name: "malta",
    emoji: "🇲🇹"
  },
  {
    name: "marshall_islands",
    emoji: "🇲🇭"
  },
  {
    name: "martinique",
    emoji: "🇲🇶"
  },
  {
    name: "mauritania",
    emoji: "🇲🇷"
  },
  {
    name: "mauritius",
    emoji: "🇲🇺"
  },
  {
    name: "mayotte",
    emoji: "🇾🇹"
  },
  {
    name: "mexico",
    emoji: "🇲🇽"
  },
  {
    name: "micronesia",
    emoji: "🇫🇲"
  },
  {
    name: "moldova",
    emoji: "🇲🇩"
  },
  {
    name: "monaco",
    emoji: "🇲🇨"
  },
  {
    name: "mongolia",
    emoji: "🇲🇳"
  },
  {
    name: "montenegro",
    emoji: "🇲🇪"
  },
  {
    name: "montserrat",
    emoji: "🇲🇸"
  },
  {
    name: "morocco",
    emoji: "🇲🇦"
  },
  {
    name: "mozambique",
    emoji: "🇲🇿"
  },
  {
    name: "myanmar",
    emoji: "🇲🇲"
  },
  {
    name: "namibia",
    emoji: "🇳🇦"
  },
  {
    name: "nauru",
    emoji: "🇳🇷"
  },
  {
    name: "nepal",
    emoji: "🇳🇵"
  },
  {
    name: "netherlands",
    emoji: "🇳🇱"
  },
  {
    name: "new_caledonia",
    emoji: "🇳🇨"
  },
  {
    name: "new_zealand",
    emoji: "🇳🇿"
  },
  {
    name: "nicaragua",
    emoji: "🇳🇮"
  },
  {
    name: "niger",
    emoji: "🇳🇪"
  },
  {
    name: "nigeria",
    emoji: "🇳🇬"
  },
  {
    name: "niue",
    emoji: "🇳🇺"
  },
  {
    name: "norfolk_island",
    emoji: "🇳🇫"
  },
  {
    name: "northern_mariana_islands",
    emoji: "🇲🇵"
  },
  {
    name: "north_korea",
    emoji: "🇰🇵"
  },
  {
    name: "norway",
    emoji: "🇳🇴"
  },
  {
    name: "oman",
    emoji: "🇴🇲"
  },
  {
    name: "pakistan",
    emoji: "🇵🇰"
  },
  {
    name: "palau",
    emoji: "🇵🇼"
  },
  {
    name: "palestinian_territories",
    emoji: "🇵🇸"
  },
  {
    name: "panama",
    emoji: "🇵🇦"
  },
  {
    name: "papua_new_guinea",
    emoji: "🇵🇬"
  },
  {
    name: "paraguay",
    emoji: "🇵🇾"
  },
  {
    name: "peru",
    emoji: "🇵🇪"
  },
  {
    name: "philippines",
    emoji: "🇵🇭"
  },
  {
    name: "pitcairn_islands",
    emoji: "🇵🇳"
  },
  {
    name: "poland",
    emoji: "🇵🇱"
  },
  {
    name: "portugal",
    emoji: "🇵🇹"
  },
  {
    name: "puerto_rico",
    emoji: "🇵🇷"
  },
  {
    name: "qatar",
    emoji: "🇶🇦"
  },
  {
    name: "reunion",
    emoji: "🇷🇪"
  },
  {
    name: "romania",
    emoji: "🇷🇴"
  },
  {
    name: "ru",
    emoji: "🇷🇺"
  },
  {
    name: "rwanda",
    emoji: "🇷🇼"
  },
  {
    name: "st_barthelemy",
    emoji: "🇧🇱"
  },
  {
    name: "st_helena",
    emoji: "🇸🇭"
  },
  {
    name: "st_kitts_nevis",
    emoji: "🇰🇳"
  },
  {
    name: "st_lucia",
    emoji: "🇱🇨"
  },
  {
    name: "st_pierre_miquelon",
    emoji: "🇵🇲"
  },
  {
    name: "st_vincent_grenadines",
    emoji: "🇻🇨"
  },
  {
    name: "samoa",
    emoji: "🇼🇸"
  },
  {
    name: "san_marino",
    emoji: "🇸🇲"
  },
  {
    name: "sao_tome_principe",
    emoji: "🇸🇹"
  },
  {
    name: "saudi_arabia",
    emoji: "🇸🇦"
  },
  {
    name: "senegal",
    emoji: "🇸🇳"
  },
  {
    name: "serbia",
    emoji: "🇷🇸"
  },
  {
    name: "seychelles",
    emoji: "🇸🇨"
  },
  {
    name: "sierra_leone",
    emoji: "🇸🇱"
  },
  {
    name: "singapore",
    emoji: "🇸🇬"
  },
  {
    name: "sint_maarten",
    emoji: "🇸🇽"
  },
  {
    name: "slovakia",
    emoji: "🇸🇰"
  },
  {
    name: "slovenia",
    emoji: "🇸🇮"
  },
  {
    name: "solomon_islands",
    emoji: "🇸🇧"
  },
  {
    name: "somalia",
    emoji: "🇸🇴"
  },
  {
    name: "south_africa",
    emoji: "🇿🇦"
  },
  {
    name: "south_georgia_south_sandwich_islands",
    emoji: "🇬🇸"
  },
  {
    name: "kr",
    emoji: "🇰🇷"
  },
  {
    name: "south_sudan",
    emoji: "🇸🇸"
  },
  {
    name: "es",
    emoji: "🇪🇸"
  },
  {
    name: "sri_lanka",
    emoji: "🇱🇰"
  },
  {
    name: "sudan",
    emoji: "🇸🇩"
  },
  {
    name: "suriname",
    emoji: "🇸🇷"
  },
  {
    name: "swaziland",
    emoji: "🇸🇿"
  },
  {
    name: "sweden",
    emoji: "🇸🇪"
  },
  {
    name: "switzerland",
    emoji: "🇨🇭"
  },
  {
    name: "syria",
    emoji: "🇸🇾"
  },
  {
    name: "taiwan",
    emoji: "🇹🇼"
  },
  {
    name: "tajikistan",
    emoji: "🇹🇯"
  },
  {
    name: "tanzania",
    emoji: "🇹🇿"
  },
  {
    name: "thailand",
    emoji: "🇹🇭"
  },
  {
    name: "timor_leste",
    emoji: "🇹🇱"
  },
  {
    name: "togo",
    emoji: "🇹🇬"
  },
  {
    name: "tokelau",
    emoji: "🇹🇰"
  },
  {
    name: "tonga",
    emoji: "🇹🇴"
  },
  {
    name: "trinidad_tobago",
    emoji: "🇹🇹"
  },
  {
    name: "tunisia",
    emoji: "🇹🇳"
  },
  {
    name: "tr",
    emoji: "🇹🇷"
  },
  {
    name: "turkmenistan",
    emoji: "🇹🇲"
  },
  {
    name: "turks_caicos_islands",
    emoji: "🇹🇨"
  },
  {
    name: "tuvalu",
    emoji: "🇹🇻"
  },
  {
    name: "uganda",
    emoji: "🇺🇬"
  },
  {
    name: "ukraine",
    emoji: "🇺🇦"
  },
  {
    name: "united_arab_emirates",
    emoji: "🇦🇪"
  },
  {
    name: "uk",
    emoji: "🇬🇧"
  },
  {
    name: "us",
    emoji: "🇺🇸"
  },
  {
    name: "us_virgin_islands",
    emoji: "🇻🇮"
  },
  {
    name: "uruguay",
    emoji: "🇺🇾"
  },
  {
    name: "uzbekistan",
    emoji: "🇺🇿"
  },
  {
    name: "vanuatu",
    emoji: "🇻🇺"
  },
  {
    name: "vatican_city",
    emoji: "🇻🇦"
  },
  {
    name: "venezuela",
    emoji: "🇻🇪"
  },
  {
    name: "vietnam",
    emoji: "🇻🇳"
  },
  {
    name: "wallis_futuna",
    emoji: "🇼🇫"
  },
  {
    name: "western_sahara",
    emoji: "🇪🇭"
  },
  {
    name: "yemen",
    emoji: "🇾🇪"
  },
  {
    name: "zambia",
    emoji: "🇿🇲"
  },
  {
    name: "zimbabwe",
    emoji: "🇿🇼"
  },
  {
    name: "star_struck",
    emoji: "🤩"
  },
  {
    name: "face_with_raised_eyebrow",
    emoji: "🤨"
  },
  {
    name: "exploding_head",
    emoji: "🤯"
  },
  {
    name: "crazy_face",
    emoji: "🤪"
  },
  {
    name: "face_with_symbols_over_mouth",
    emoji: "🤬"
  },
  {
    name: "face_vomiting",
    emoji: "🤮"
  },
  {
    name: "shushing_face",
    emoji: "🤫"
  },
  {
    name: "face_with_hand_over_mouth",
    emoji: "🤭"
  },
  {
    name: "face_with_monocle",
    emoji: "🧐"
  },
  {
    name: "child",
    emoji: "🧒"
  },
  {
    name: "adult",
    emoji: "🧑"
  },
  {
    name: "older_adult",
    emoji: "🧓"
  },
  {
    name: "woman_with_headscarf",
    emoji: "🧕"
  },
  {
    name: "bearded_person",
    emoji: "🧔"
  },
  {
    name: "breast_feeding",
    emoji: "🤱"
  },
  {
    name: "mage",
    emoji: "🧙"
  },
  {
    name: "woman_mage",
    emoji: "🧙‍♀️"
  },
  {
    name: "fairy",
    emoji: "🧚"
  },
  {
    name: "vampire",
    emoji: "🧛"
  },
  {
    name: "merperson",
    emoji: "🧜"
  },
  {
    name: "merman",
    emoji: "🧜‍♂️"
  },
  {
    name: "elf",
    emoji: "🧝"
  },
  {
    name: "genie",
    emoji: "🧞"
  },
  {
    name: "woman_genie",
    emoji: "🧞‍♀"
  },
  {
    name: "zombie",
    emoji: "🧟"
  },
  {
    name: "woman_zombie",
    emoji: "🧟‍♀"
  },
  {
    name: "person_in_steamy_room",
    emoji: "🧖"
  },
  {
    name: "woman_in_steamy_room",
    emoji: "🧖‍♀️"
  },
  {
    name: "person_climbing",
    emoji: "🧗"
  },
  {
    name: "woman_climbing",
    emoji: "🧗‍♀️"
  },
  {
    name: "person_in_lotus_position",
    emoji: "🧘"
  },
  {
    name: "woman_in_lotus_position",
    emoji: "🧘‍♀️"
  },
  {
    name: "love_you_gesture",
    emoji: "🤟"
  },
  {
    name: "palms_up_together",
    emoji: "🤲"
  },
  {
    name: "brain",
    emoji: "🧠"
  },
  {
    name: "orange_heart",
    emoji: "🧡"
  },
  {
    name: "scarf",
    emoji: "🧣"
  },
  {
    name: "gloves",
    emoji: "🧤"
  },
  {
    name: "coat",
    emoji: "🧥"
  },
  {
    name: "socks",
    emoji: "🧦"
  },
  {
    name: "billed_cap",
    emoji: "🧢"
  },
  {
    name: "zebra",
    emoji: "🦓"
  },
  {
    name: "giraffe",
    emoji: "🦒"
  },
  {
    name: "hedgehog",
    emoji: "🦔"
  },
  {
    name: "sauropod",
    emoji: "🦕"
  },
  {
    name: "t_rex",
    emoji: "🦖"
  },
  {
    name: "cricket",
    emoji: "🦗"
  },
  {
    name: "coconut",
    emoji: "🥥"
  },
  {
    name: "broccoli",
    emoji: "🥦"
  },
  {
    name: "pretzel",
    emoji: "🥨"
  },
  {
    name: "cut_of_meat",
    emoji: "🥩"
  },
  {
    name: "sandwich",
    emoji: "🥪"
  },
  {
    name: "bowl_with_spoon",
    emoji: "🥣"
  },
  {
    name: "canned_food",
    emoji: "🥫"
  },
  {
    name: "dumpling",
    emoji: "🥟"
  },
  {
    name: "fortune_cookie",
    emoji: "🥠"
  },
  {
    name: "takeout_box",
    emoji: "🥡"
  },
  {
    name: "pie",
    emoji: "🥧"
  },
  {
    name: "cup_with_straw",
    emoji: "🥤"
  },
  {
    name: "chopsticks",
    emoji: "🥢"
  },
  {
    name: "flying_saucer",
    emoji: "🛸"
  },
  {
    name: "sled",
    emoji: "🛷"
  },
  {
    name: "curling_stone",
    emoji: "🥌"
  },
  {
    name: "svalbard_and_jan_mayen",
    emoji: "🇸🇯"
  },
  {
    name: "st_martin",
    emoji: "🇲🇫"
  },
  {
    name: "us_outlying_islands",
    emoji: "🇺🇲"
  },
  {
    name: "tristan_da_cunha",
    emoji: "🇹🇦"
  },
  {
    name: "heard_and_mc_donald_islands",
    emoji: "🇭🇲"
  },
  {
    name: "ceuta_and_melilla",
    emoji: "🇪🇦"
  },
  {
    name: "diego_garcia",
    emoji: "🇩🇬"
  },
  {
    name: "ascension_island",
    emoji: "🇦🇨"
  },
  {
    name: "bouvet_island",
    emoji: "🇧🇻"
  },
  {
    name: "clipperton_island",
    emoji: "🇨🇵"
  },
  {
    name: "united_nations",
    emoji: "🇺🇳"
  },
  {
    name: "smiling_face_with_three_hearts",
    emoji: "🥰"
  },
  {
    name: "hot_face",
    emoji: "🥵"
  },
  {
    name: "cold_face",
    emoji: "🥶"
  },
  {
    name: "partying_face",
    emoji: "🥳"
  },
  {
    name: "woozy_face",
    emoji: "🥴"
  },
  {
    name: "pleading_face",
    emoji: "🥺"
  },
  {
    name: "man_red_haired",
    emoji: "👨‍🦰"
  },
  {
    name: "man_curly_haired",
    emoji: "👨‍🦱"
  },
  {
    name: "man_white_haired",
    emoji: "👨‍🦳"
  },
  {
    name: "man_bald",
    emoji: "👨‍🦲"
  },
  {
    name: "woman_red_haired",
    emoji: "👩‍🦰"
  },
  {
    name: "woman_curly_haired",
    emoji: "👩‍🦱"
  },
  {
    name: "woman_white_haired",
    emoji: "👩‍🦳"
  },
  {
    name: "woman_bald",
    emoji: "👩‍🦲"
  },
  {
    name: "superhero",
    emoji: "🦸"
  },
  {
    name: "man_superhero",
    emoji: "🦸‍♂️"
  },
  {
    name: "woman_superhero",
    emoji: "🦸‍♀️"
  },
  {
    name: "supervillain",
    emoji: "🦹"
  },
  {
    name: "woman_supervillain",
    emoji: "🦹‍♀️"
  },
  {
    name: "man_supervillain",
    emoji: "🦹‍♂️"
  },
  {
    name: "leg",
    emoji: "🦵"
  },
  {
    name: "foot",
    emoji: "🦶"
  },
  {
    name: "bone",
    emoji: "🦴"
  },
  {
    name: "tooth",
    emoji: "🦷"
  },
  {
    name: "goggles",
    emoji: "🥽"
  },
  {
    name: "lab_coat",
    emoji: "🥼"
  },
  {
    name: "hiking_boot",
    emoji: "🥾"
  },
  {
    name: "flat_shoe",
    emoji: "🥿"
  },
  {
    name: "raccoon",
    emoji: "🦝"
  },
  {
    name: "llama",
    emoji: "🦙"
  },
  {
    name: "hippopotamus",
    emoji: "🦛"
  },
  {
    name: "kangaroo",
    emoji: "🦘"
  },
  {
    name: "badger",
    emoji: "🦡"
  },
  {
    name: "swan",
    emoji: "🦢"
  },
  {
    name: "peacock",
    emoji: "🦚"
  },
  {
    name: "parrot",
    emoji: "🦜"
  },
  {
    name: "lobster",
    emoji: "🦞"
  },
  {
    name: "mosquito",
    emoji: "🦟"
  },
  {
    name: "microbe",
    emoji: "🦠"
  },
  {
    name: "mango",
    emoji: "🥭"
  },
  {
    name: "leafy_green",
    emoji: "🥬"
  },
  {
    name: "bagel",
    emoji: "🥯"
  },
  {
    name: "salt",
    emoji: "🧂"
  },
  {
    name: "moon_cake",
    emoji: "🥮"
  },
  {
    name: "cupcake",
    emoji: "🧁"
  },
  {
    name: "compass",
    emoji: "🧭"
  },
  {
    name: "brick",
    emoji: "🧱"
  },
  {
    name: "skateboard",
    emoji: "🛹"
  },
  {
    name: "luggage",
    emoji: "🧳"
  },
  {
    name: "firecracker",
    emoji: "🧨"
  },
  {
    name: "red_gift_envelope",
    emoji: "🧧"
  },
  {
    name: "softball",
    emoji: "🥎"
  },
  {
    name: "flying_disc",
    emoji: "🥏"
  },
  {
    name: "lacrosse",
    emoji: "🥍"
  },
  {
    name: "nazar_amulet",
    emoji: "🧿"
  },
  {
    name: "jigsaw",
    emoji: "🧩"
  },
  {
    name: "teddy_bear",
    emoji: "🧸"
  },
  {
    name: "chess_pawn",
    emoji: "♟"
  },
  {
    name: "thread",
    emoji: "🧵"
  },
  {
    name: "yarn",
    emoji: "🧶"
  },
  {
    name: "abacus",
    emoji: "🧮"
  },
  {
    name: "receipt",
    emoji: "🧾"
  },
  {
    name: "toolbox",
    emoji: "🧰"
  },
  {
    name: "magnet",
    emoji: "🧲"
  },
  {
    name: "test_tube",
    emoji: "🧪"
  },
  {
    name: "petri_dish",
    emoji: "🧫"
  },
  {
    name: "dna",
    emoji: "🧬"
  },
  {
    name: "lotion_bottle",
    emoji: "🧴"
  },
  {
    name: "safety_pin",
    emoji: "🧷"
  },
  {
    name: "broom",
    emoji: "🧹"
  },
  {
    name: "basket",
    emoji: "🧺"
  },
  {
    name: "roll_of_toilet_paper",
    emoji: "🧻"
  },
  {
    name: "soap",
    emoji: "🧼"
  },
  {
    name: "sponge",
    emoji: "🧽"
  },
  {
    name: "fire_extinguisher",
    emoji: "🧯"
  },
  {
    name: "infinity",
    emoji: "♾"
  },
  {
    name: "pirate_flag",
    emoji: "🏴‍☠"
  },
  {
    name: "waffle",
    emoji: "🧇"
  },
  {
    name: "otter",
    emoji: "🦦"
  },
  {
    name: "sloth",
    emoji: "🦥"
  },
  {
    name: "ice_cube",
    emoji: "🧊"
  },
  {
    name: "ringer_planet",
    emoji: "🪐"
  },
  {
    name: "flamingo",
    emoji: "🦩"
  },
  {
    name: "yawning_face",
    emoji: "🥱"
  },
  {
    name: "pinching_hand",
    emoji: "🤏"
  },
  {
    name: "service_dog",
    emoji: "🐕‍🦺"
  },
  {
    name: "orangutan",
    emoji: "🦧"
  },
  {
    name: "auto_rickshaw",
    emoji: "🛺"
  },
  {
    name: "parachute",
    emoji: "🪂"
  },
  {
    name: "yo-yo",
    emoji: "🪀"
  },
  {
    name: "kite",
    emoji: "🪁"
  },
  {
    name: "brown_square",
    emoji: "🟫"
  },
  {
    name: "purple_square",
    emoji: "🟪"
  },
  {
    name: "blue_square",
    emoji: "🟦"
  },
  {
    name: "green_square",
    emoji: "🟩"
  },
  {
    name: "yellow_square",
    emoji: "🟨"
  },
  {
    name: "orange_square",
    emoji: "🟧"
  },
  {
    name: "red_square",
    emoji: "🟥"
  },
  {
    name: "brown_circle",
    emoji: "🟤"
  },
  {
    name: "purple_circle",
    emoji: "🟣"
  },
  {
    name: "green_circle",
    emoji: "🟢"
  },
  {
    name: "yellow_circle",
    emoji: "🟡"
  },
  {
    name: "orange_circle",
    emoji: "🟠"
  },
  {
    name: "razor",
    emoji: "🪒"
  },
  {
    name: "chair",
    emoji: "🪑"
  },
  {
    name: "stethoscope",
    emoji: "🩺"
  },
  {
    name: "adhesive_bandage",
    emoji: "🩹"
  },
  {
    name: "drop_of_blood",
    emoji: "🩸"
  },
  {
    name: "probing_cane",
    emoji: "🦯"
  },
  {
    name: "axe",
    emoji: "🪓"
  },
  {
    name: "diya_lamp",
    emoji: "🪔"
  },
  {
    name: "banjo",
    emoji: "🪕"
  },
  {
    name: "ballet_shoes",
    emoji: "🩰"
  },
  {
    name: "shorts",
    emoji: "🩳"
  },
  {
    name: "briefs",
    emoji: "🩲"
  },
  {
    name: "one_piece_swimsuit",
    emoji: "🩱"
  },
  {
    name: "sari",
    emoji: "🥻"
  },
  {
    name: "safety_vest",
    emoji: "🦺"
  },
  {
    name: "diving_mask",
    emoji: "🤿"
  },
  {
    name: "motorized_wheelchair",
    emoji: "🦼"
  },
  {
    name: "manual_wheelchair",
    emoji: "🦽"
  },
  {
    name: "hindu_temple",
    emoji: "🛕"
  },
  {
    name: "maté",
    emoji: "🧉"
  },
  {
    name: "beverage_box",
    emoji: "🧃"
  },
  {
    name: "oyster",
    emoji: "🦪"
  },
  {
    name: "butter",
    emoji: "🧈"
  },
  {
    name: "falafel",
    emoji: "🧆"
  },
  {
    name: "onion",
    emoji: "🧅"
  },
  {
    name: "garlic",
    emoji: "🧄"
  },
  {
    name: "skunk",
    emoji: "🦨"
  },
  {
    name: "guide_dog",
    emoji: "🦮"
  },
  {
    name: "people_holding_hands",
    emoji: "🧑‍🤝‍🧑"
  },
  {
    name: "woman_in_manual_wheelchair",
    emoji: "👩‍🦽"
  },
  {
    name: "man_in_manual_wheelchair",
    emoji: "👨‍🦽"
  },
  {
    name: "woman_in_motorized_wheelchair",
    emoji: "👩‍🦼"
  },
  {
    name: "man_in_motorized_wheelchair",
    emoji: "👨‍🦼"
  },
  {
    name: "woman_with_probing_cane",
    emoji: "👩‍🦯"
  },
  {
    name: "man_with_probing_cane",
    emoji: "👨‍🦯"
  },
  {
    name: "woman_kneeling",
    emoji: "🧎‍♀️"
  },
  {
    name: "man_kneeling",
    emoji: "🧎‍♂️"
  },
  {
    name: "man_standing",
    emoji: "🧍‍♂️"
  },
  {
    name: "woman_standing",
    emoji: "🧍‍♀️"
  },
  {
    name: "deaf_woman",
    emoji: "🧏‍♀️"
  },
  {
    name: "deaf_man",
    emoji: "🧏‍♂️"
  },
  {
    name: "hear_with_hearing_aid",
    emoji: "🦻"
  },
  {
    name: "mechanical_leg",
    emoji: "🦿"
  },
  {
    name: "mechanical_arm",
    emoji: "🦾"
  },
  {
    name: "white_heart",
    emoji: "🤍"
  },
  {
    name: "brown_heart",
    emoji: "🤎"
  },
  {
    name: "transgender_flag",
    emoji: "🏳️‍⚧"
  },
  {
    name: "smiling_face_with_tear",
    emoji: "🥲"
  },
  {
    name: "disguised_face",
    emoji: "🥸"
  },
  {
    name: "pinched_fingers",
    emoji: "🤌"
  },
  {
    name: "anatomical_heart",
    emoji: "🫀"
  },
  {
    name: "lungs",
    emoji: "🫁"
  },
  {
    name: "ninja",
    emoji: "🥷"
  },
  {
    name: "mx_claus",
    emoji: "🧑‍🎄"
  },
  {
    name: "people_hugging",
    emoji: "🫂"
  },
  {
    name: "black_cat",
    emoji: "🐈‍⬛"
  },
  {
    name: "bison",
    emoji: "🦬"
  },
  {
    name: "mammoth",
    emoji: "🦣"
  },
  {
    name: "beaver",
    emoji: "🦫"
  },
  {
    name: "dodo",
    emoji: "🦤"
  },
  {
    name: "feather",
    emoji: "🪶"
  },
  {
    name: "seal",
    emoji: "🦭"
  },
  {
    name: "beetle",
    emoji: "🪲"
  },
  {
    name: "cockroach",
    emoji: "🪳"
  },
  {
    name: "fly",
    emoji: "🪰"
  },
  {
    name: "worm",
    emoji: "🪱"
  },
  {
    name: "potted_plant",
    emoji: "🪴"
  },
  {
    name: "blueberries",
    emoji: "🫐"
  },
  {
    name: "olive",
    emoji: "🫒"
  },
  {
    name: "bell_pepper",
    emoji: "🫑"
  },
  {
    name: "flatbread",
    emoji: "🫓"
  },
  {
    name: "tamale",
    emoji: "🫔"
  },
  {
    name: "fondue",
    emoji: "🫕"
  },
  {
    name: "teapot",
    emoji: "🫖"
  },
  {
    name: "bubble_tea",
    emoji: "🧋"
  },
  {
    name: "rock",
    emoji: "🪨"
  },
  {
    name: "wood",
    emoji: "🪵"
  },
  {
    name: "hut",
    emoji: "🛖"
  },
  {
    name: "pickup_truck",
    emoji: "🛻"
  },
  {
    name: "roller_skate",
    emoji: "🛼"
  },
  {
    name: "magic_wand",
    emoji: "🪄"
  },
  {
    name: "piñata",
    emoji: "🪅"
  },
  {
    name: "nesting_dolls",
    emoji: "🪆"
  },
  {
    name: "sewing_needle",
    emoji: "🪡"
  },
  {
    name: "knot",
    emoji: "🪢"
  },
  {
    name: "thong_sandal",
    emoji: "🩴"
  },
  {
    name: "military_helmet",
    emoji: "🪖"
  },
  {
    name: "accordion",
    emoji: "🪗"
  },
  {
    name: "long_drum",
    emoji: "🪘"
  },
  {
    name: "coin",
    emoji: "🪙"
  },
  {
    name: "boomerang",
    emoji: "🪃"
  },
  {
    name: "carpentry_saw",
    emoji: "🪚"
  },
  {
    name: "screwdriver",
    emoji: "🪛"
  },
  {
    name: "hook",
    emoji: "🪝"
  },
  {
    name: "ladder",
    emoji: "🪜"
  },
  {
    name: "mirror",
    emoji: "🪞"
  },
  {
    name: "window",
    emoji: "🪟"
  },
  {
    name: "plunger",
    emoji: "🪠"
  },
  {
    name: "mouse_trap",
    emoji: "🪤"
  },
  {
    name: "bucket",
    emoji: "🪣"
  },
  {
    name: "toothbrush",
    emoji: "🪥"
  },
  {
    name: "headstone",
    emoji: "🪦"
  },
  {
    name: "placard",
    emoji: "🪧"
  },
  {
    name: "transgender_symbol",
    emoji: "⚧"
  },
  {
    name: "man_feeding_baby",
    emoji: "👨‍🍼"
  },
  {
    name: "person_feeding_baby",
    emoji: "🧑‍🍼"
  },
  {
    name: "polar_bear",
    emoji: "🐻‍❄"
  },
  {
    name: "melting_face",
    emoji: "🫠"
  },
  {
    name: "smiling_face",
    emoji: "☺"
  },
  {
    name: "face_with_open_eyes_and_hand_over_mouth",
    emoji: "🫢"
  },
  {
    name: "face_with_peeking_eye",
    emoji: "🫣"
  },
  {
    name: "saluting_face",
    emoji: "🫡"
  },
  {
    name: "dotted_line_face",
    emoji: "🫥"
  },
  {
    name: "face_in_clouds",
    emoji: "😶‍🌫"
  },
  {
    name: "face_exhaling",
    emoji: "😮‍💨"
  },
  {
    name: "face_with_spiral_eyes",
    emoji: "😵‍💫"
  },
  {
    name: "face_with_diagonal_mouth",
    emoji: "🫤"
  },
  {
    name: "frowning_face",
    emoji: "☹"
  },
  {
    name: "face_holding_back_tears",
    emoji: "🥹"
  },
  {
    name: "heart_on_fire",
    emoji: "❤️‍🔥"
  },
  {
    name: "mending_heart",
    emoji: "❤️‍🩹"
  },
  {
    name: "eye_in_speech_bubble",
    emoji: "👁️‍🗨"
  },
  {
    name: "rightwards_hand",
    emoji: "🫱"
  },
  {
    name: "leftwards_hand",
    emoji: "🫲"
  },
  {
    name: "palm_down_hand",
    emoji: "🫳"
  },
  {
    name: "palm_up_hand",
    emoji: "🫴"
  },
  {
    name: "hand_with_index_finger_and_thumb_crossed",
    emoji: "🫰"
  },
  {
    name: "index_pointing_at_the_viewer",
    emoji: "🫵"
  },
  {
    name: "heart_hands",
    emoji: "🫶"
  },
  {
    name: "biting_lip",
    emoji: "🫦"
  },
  {
    name: "man_beard",
    emoji: "🧔‍♂"
  },
  {
    name: "woman_beard",
    emoji: "🧔‍♀"
  },
  {
    name: "person_red_hair",
    emoji: "🧑‍🦰"
  },
  {
    name: "person_curly_hair",
    emoji: "🧑‍🦱"
  },
  {
    name: "person_white_hair",
    emoji: "🧑‍🦳"
  },
  {
    name: "person_bald",
    emoji: "🧑‍🦲"
  },
  {
    name: "man_blond_hair",
    emoji: "👱‍♂️"
  },
  {
    name: "person_frowning",
    emoji: "🙍"
  },
  {
    name: "person_pouting",
    emoji: "🙎"
  },
  {
    name: "person_gesturing_no",
    emoji: "🙅"
  },
  {
    name: "person_gesturing_ok",
    emoji: "🙆"
  },
  {
    name: "person_tipping_hand",
    emoji: "💁"
  },
  {
    name: "person_raising_hand",
    emoji: "🙋"
  },
  {
    name: "deaf_person",
    emoji: "🧏"
  },
  {
    name: "man_bowing",
    emoji: "🙇‍♂️"
  },
  {
    name: "person_facepalming",
    emoji: "🤦"
  },
  {
    name: "person_shrugging",
    emoji: "🤷"
  },
  {
    name: "health_worker",
    emoji: "🧑‍⚕️"
  },
  {
    name: "student",
    emoji: "🧑‍🎓"
  },
  {
    name: "teacher",
    emoji: "🧑‍🏫"
  },
  {
    name: "judge",
    emoji: "🧑‍⚖️"
  },
  {
    name: "farmer",
    emoji: "🧑‍🌾"
  },
  {
    name: "cook",
    emoji: "🧑‍🍳"
  },
  {
    name: "mechanic",
    emoji: "🧑‍🔧"
  },
  {
    name: "factory_worker",
    emoji: "🧑‍🏭"
  },
  {
    name: "office_worker",
    emoji: "🧑‍💼"
  },
  {
    name: "scientist",
    emoji: "🧑‍🔬"
  },
  {
    name: "technologist",
    emoji: "🧑‍💻"
  },
  {
    name: "singer",
    emoji: "🧑‍🎤"
  },
  {
    name: "artist",
    emoji: "🧑‍🎨"
  },
  {
    name: "pilot",
    emoji: "🧑‍✈️"
  },
  {
    name: "astronaut",
    emoji: "🧑‍🚀"
  },
  {
    name: "firefighter",
    emoji: "🧑‍🚒"
  },
  {
    name: "man_police_officer",
    emoji: "👮‍♂️"
  },
  {
    name: "man_detective",
    emoji: "🕵️‍♂️"
  },
  {
    name: "man_guard",
    emoji: "💂‍♂️"
  },
  {
    name: "man_construction_worker",
    emoji: "👷‍♂️"
  },
  {
    name: "person_with_crown",
    emoji: "🫅"
  },
  {
    name: "man_wearing_turban",
    emoji: "👳‍♂️"
  },
  {
    name: "man_in_tuxedo",
    emoji: "🤵‍♂️"
  },
  {
    name: "woman_in_tuxedo",
    emoji: "🤵‍♀️"
  },
  {
    name: "man_with_veil",
    emoji: "👰‍♂️"
  },
  {
    name: "woman_with_veil",
    emoji: "👰‍♀️"
  },
  {
    name: "pregnant_man",
    emoji: "🫃"
  },
  {
    name: "pregnant_person",
    emoji: "🫄"
  },
  {
    name: "woman_feeding_baby",
    emoji: "👩‍🍼"
  },
  {
    name: "man_mage",
    emoji: "🧙‍♂️"
  },
  {
    name: "man_fairy",
    emoji: "🧚‍♂️"
  },
  {
    name: "woman_fairy",
    emoji: "🧚‍♀️"
  },
  {
    name: "man_vampire",
    emoji: "🧛‍♂️"
  },
  {
    name: "woman_vampire",
    emoji: "🧛‍♀️"
  },
  {
    name: "mermaid",
    emoji: "🧜‍♀️"
  },
  {
    name: "man_elf",
    emoji: "🧝‍♂️"
  },
  {
    name: "woman_elf",
    emoji: "🧝‍♀️"
  },
  {
    name: "man_genie",
    emoji: "🧞‍♂"
  },
  {
    name: "man_zombie",
    emoji: "🧟‍♂"
  },
  {
    name: "troll",
    emoji: "🧌"
  },
  {
    name: "person_getting_massage",
    emoji: "💆"
  },
  {
    name: "person_getting_haircut",
    emoji: "💇"
  },
  {
    name: "man_walking",
    emoji: "🚶‍♂️"
  },
  {
    name: "person_standing",
    emoji: "🧍"
  },
  {
    name: "person_kneeling",
    emoji: "🧎"
  },
  {
    name: "person_with_white_cane",
    emoji: "🧑‍🦯"
  },
  {
    name: "person_in_motorized_wheelchair",
    emoji: "🧑‍🦼"
  },
  {
    name: "person_in_manual_wheelchair",
    emoji: "🧑‍🦽"
  },
  {
    name: "man_running",
    emoji: "🏃‍♂️"
  },
  {
    name: "women_with_bunny_ears",
    emoji: "👯‍♀"
  },
  {
    name: "man_in_steamy_room",
    emoji: "🧖‍♂️"
  },
  {
    name: "man_climbing",
    emoji: "🧗‍♂️"
  },
  {
    name: "man_golfing",
    emoji: "🏌️‍♂️"
  },
  {
    name: "man_surfing",
    emoji: "🏄‍♂️"
  },
  {
    name: "man_rowing_boat",
    emoji: "🚣‍♂️"
  },
  {
    name: "man_swimming",
    emoji: "🏊‍♂️"
  },
  {
    name: "man_bouncing_ball",
    emoji: "⛹️‍♂️"
  },
  {
    name: "man_lifting_weights",
    emoji: "🏋️‍♂️"
  },
  {
    name: "man_biking",
    emoji: "🚴‍♂️"
  },
  {
    name: "man_mountain_biking",
    emoji: "🚵‍♂️"
  },
  {
    name: "person_cartwheeling",
    emoji: "🤸"
  },
  {
    name: "people_wrestling",
    emoji: "🤼"
  },
  {
    name: "person_playing_water_polo",
    emoji: "🤽"
  },
  {
    name: "person_playing_handball",
    emoji: "🤾"
  },
  {
    name: "person_juggling",
    emoji: "🤹"
  },
  {
    name: "man_in_lotus_position",
    emoji: "🧘‍♂️"
  },
  {
    name: "kiss_woman_man",
    emoji: "👩‍❤️‍💋‍👨"
  },
  {
    name: "couple_with_heart_woman_man",
    emoji: "👩‍❤️‍👨"
  },
  {
    name: "family_man_woman_boy",
    emoji: "👨‍👩‍👦"
  },
  {
    name: "red_hair",
    emoji: "🦰"
  },
  {
    name: "curly_hair",
    emoji: "🦱"
  },
  {
    name: "white_hair",
    emoji: "🦳"
  },
  {
    name: "bald",
    emoji: "🦲"
  },
  {
    name: "coral",
    emoji: "🪸"
  },
  {
    name: "lotus",
    emoji: "🪷"
  },
  {
    name: "empty_nest",
    emoji: "🪹"
  },
  {
    name: "nest_with_eggs",
    emoji: "🪺"
  },
  {
    name: "beans",
    emoji: "🫘"
  },
  {
    name: "pouring_liquid",
    emoji: "🫗"
  },
  {
    name: "jar",
    emoji: "🫙"
  },
  {
    name: "playground_slide",
    emoji: "🛝"
  },
  {
    name: "wheel",
    emoji: "🛞"
  },
  {
    name: "ring_buoy",
    emoji: "🛟"
  },
  {
    name: "hamsa",
    emoji: "🪬"
  },
  {
    name: "mirror_ball",
    emoji: "🪩"
  },
  {
    name: "low_battery",
    emoji: "🪫"
  },
  {
    name: "crutch",
    emoji: "🩼"
  },
  {
    name: "xray",
    emoji: "🩻"
  },
  {
    name: "elevator",
    emoji: "🛗"
  },
  {
    name: "bubbles",
    emoji: "🫧"
  },
  {
    name: "identification_card",
    emoji: "🪪"
  },
  {
    name: "eject_button",
    emoji: "⏏"
  },
  {
    name: "female_sign",
    emoji: "♀"
  },
  {
    name: "male_sign",
    emoji: "♂"
  },
  {
    name: "heavy_equals_sign",
    emoji: "🟰"
  },
  {
    name: "medical_symbol",
    emoji: "⚕"
  },
  {
    name: "england",
    emoji: "🏴󠁧󠁢󠁥󠁮󠁧󠁿"
  },
  {
    name: "scotland",
    emoji: "🏴󠁧󠁢󠁳󠁣󠁴󠁿"
  },
  {
    name: "wales",
    emoji: "🏴󠁧󠁢󠁷󠁬󠁳󠁿"
  }
], f2e = d2e, p2e = jx({
  name: "emoji",
  char: ":",
  pluginKey: new jn("emojiSuggestion"),
  items: ({ query: n }) => f2e.filter(
    (e) => e.name.toLowerCase().includes(n.toLowerCase())
  ).sort((e, t) => {
    const r = e.name.toLowerCase(), i = t.name.toLowerCase(), a = n.toLowerCase();
    return r === a && i !== a ? -1 : i === a && r !== a ? 1 : r.startsWith(a) && !i.startsWith(a) ? -1 : i.startsWith(a) && !r.startsWith(a) ? 1 : r.length - i.length;
  }).slice(0, 5),
  command: ({ editor: n, range: e, props: t }) => {
    t && t.emoji ? n.chain().focus().deleteRange(e).insertContent(t.emoji).run() : console.error(
      "Emoji command execution error: emoji property not found on selected item or item is invalid.",
      t
    );
  },
  component: c2e
}), h2e = {
  key: 1,
  class: "mr-2 h-4 w-4"
}, v2e = /* @__PURE__ */ ve({
  __name: "SlashCommandsList",
  props: {
    items: {
      type: Array,
      required: !0
    },
    editor: {
      type: Object,
      required: !0
    },
    range: {
      type: Object,
      required: !0
    },
    command: {
      type: Function,
      required: !0
    },
    query: String
  },
  setup(n, { expose: e }) {
    const t = n, r = Z(null), i = (o) => {
      o && t.command(o);
    };
    return e({
      onKeyDown: ({ event: o }) => {
        var s;
        return ((s = r.value) == null ? void 0 : s.onKeyDown({ event: o })) ?? !1;
      }
    }), (o, s) => (L(), re(Bx, {
      ref_key: "suggestionList",
      ref: r,
      items: t.items,
      command: (l) => i(l),
      "container-class": "min-w-48",
      "item-class": "h-7",
      "show-no-results": !0
    }, {
      default: ee(({ item: l }) => [
        l.icon ? (L(), re(bn(l.icon), {
          key: 0,
          class: "mr-2 h-4 w-4"
        })) : (L(), W("div", h2e)),
        G("span", null, ke(l.title), 1)
      ]),
      _: 1
    }, 8, ["items", "command"]));
  }
}), m2e = {
  class: "lucide lucide-heading-2",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function g2e(n, e) {
  return L(), W("svg", m2e, [...e[0] || (e[0] = [
    G("path", { d: "M4 12h8" }, null, -1),
    G("path", { d: "M4 18V6" }, null, -1),
    G("path", { d: "M12 18V6" }, null, -1),
    G("path", { d: "M21 18h-4c0-4 4-3 4-6 0-1.5-2-2.5-4-1" }, null, -1)
  ])]);
}
const y2e = cn({ name: "lucide-heading-2", render: g2e }), b2e = {
  class: "lucide lucide-heading-3",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function _2e(n, e) {
  return L(), W("svg", b2e, [...e[0] || (e[0] = [
    Zp('<path d="M4 12h8"></path><path d="M4 18V6"></path><path d="M12 18V6"></path><path d="M17.5 10.5c1.7-1 3.5 0 3.5 1.5a2 2 0 0 1-2 2"></path><path d="M17 17.5c2 1.5 4 .3 4-1.5a2 2 0 0 0-2-2"></path>', 5)
  ])]);
}
const x2e = cn({ name: "lucide-heading-3", render: _2e }), w2e = {
  class: "lucide lucide-list",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function S2e(n, e) {
  return L(), W("svg", w2e, [...e[0] || (e[0] = [
    Zp('<path d="M3 12h.01"></path><path d="M3 18h.01"></path><path d="M3 6h.01"></path><path d="M8 12h13"></path><path d="M8 18h13"></path><path d="M8 6h13"></path>', 6)
  ])]);
}
const E2e = cn({ name: "lucide-list", render: S2e }), T2e = {
  class: "lucide lucide-list-ordered",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function C2e(n, e) {
  return L(), W("svg", T2e, [...e[0] || (e[0] = [
    Zp('<path d="M10 12h11"></path><path d="M10 18h11"></path><path d="M10 6h11"></path><path d="M4 10h2"></path><path d="M4 6h1v4"></path><path d="M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"></path>', 6)
  ])]);
}
const k2e = cn({ name: "lucide-list-ordered", render: C2e }), A2e = {
  class: "lucide lucide-list-checks",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function M2e(n, e) {
  return L(), W("svg", A2e, [...e[0] || (e[0] = [
    Zp('<path d="m3 17 2 2 4-4"></path><path d="m3 7 2 2 4-4"></path><path d="M13 6h8"></path><path d="M13 12h8"></path><path d="M13 18h8"></path>', 5)
  ])]);
}
const D2e = cn({ name: "lucide-list-checks", render: M2e }), O2e = {
  class: "lucide lucide-code",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function I2e(n, e) {
  return L(), W("svg", O2e, [...e[0] || (e[0] = [
    G("path", { d: "m16 18 6-6-6-6" }, null, -1),
    G("path", { d: "m8 6-6 6 6 6" }, null, -1)
  ])]);
}
const L2e = cn({ name: "lucide-code", render: I2e }), N2e = {
  class: "lucide lucide-quote",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function R2e(n, e) {
  return L(), W("svg", N2e, [...e[0] || (e[0] = [
    G("path", { d: "M16 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z" }, null, -1),
    G("path", { d: "M5 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z" }, null, -1)
  ])]);
}
const P2e = cn({ name: "lucide-quote", render: R2e }), j2e = {
  class: "lucide lucide-image",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function B2e(n, e) {
  return L(), W("svg", j2e, [...e[0] || (e[0] = [
    G("rect", {
      width: "18",
      height: "18",
      x: "3",
      y: "3",
      rx: "2",
      ry: "2"
    }, null, -1),
    G("circle", {
      cx: "9",
      cy: "9",
      r: "2"
    }, null, -1),
    G("path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" }, null, -1)
  ])]);
}
const $2e = cn({ name: "lucide-image", render: B2e }), z2e = {
  class: "lucide lucide-video",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function F2e(n, e) {
  return L(), W("svg", z2e, [...e[0] || (e[0] = [
    G("path", { d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5" }, null, -1),
    G("rect", {
      x: "2",
      y: "6",
      width: "14",
      height: "12",
      rx: "2"
    }, null, -1)
  ])]);
}
const V2e = cn({ name: "lucide-video", render: F2e }), H2e = {
  class: "lucide lucide-link",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function G2e(n, e) {
  return L(), W("svg", H2e, [...e[0] || (e[0] = [
    G("path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" }, null, -1),
    G("path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" }, null, -1)
  ])]);
}
const U2e = cn({ name: "lucide-link", render: G2e }), W2e = {
  class: "lucide lucide-table-2",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function q2e(n, e) {
  return L(), W("svg", W2e, [...e[0] || (e[0] = [
    G("path", { d: "M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18" }, null, -1)
  ])]);
}
const Y2e = cn({ name: "lucide-table-2", render: q2e }), K2e = new jn(
  "slashCommandSuggestion"
), X2e = () => [
  {
    title: "Heading 2",
    icon: y2e,
    command: ({ editor: n, range: e }) => {
      n.chain().focus().deleteRange(e).setNode("heading", { level: 2 }).run();
    }
  },
  {
    title: "Heading 3",
    icon: x2e,
    command: ({ editor: n, range: e }) => {
      n.chain().focus().deleteRange(e).setNode("heading", { level: 3 }).run();
    }
  },
  {
    title: "Bullet List",
    icon: E2e,
    command: ({ editor: n, range: e }) => {
      n.chain().focus().deleteRange(e).toggleBulletList().run();
    }
  },
  {
    title: "Numbered List",
    icon: k2e,
    command: ({ editor: n, range: e }) => {
      n.chain().focus().deleteRange(e).toggleOrderedList().run();
    }
  },
  {
    title: "Task List",
    icon: D2e,
    command: ({ editor: n, range: e }) => {
      n.chain().focus().deleteRange(e).toggleTaskList().run();
    }
  },
  {
    title: "Code Block",
    icon: L2e,
    command: ({ editor: n, range: e }) => {
      n.chain().focus().deleteRange(e).toggleCodeBlock().run();
    }
  },
  {
    title: "Blockquote",
    icon: P2e,
    command: ({ editor: n, range: e }) => {
      n.chain().focus().deleteRange(e).toggleBlockquote().run();
    }
  },
  {
    title: "Image",
    icon: $2e,
    command: ({ editor: n, range: e }) => {
      n.chain().focus().deleteRange(e).selectAndUploadImage().run();
    }
  },
  {
    title: "Video",
    icon: V2e,
    command: ({ editor: n, range: e }) => {
      n.chain().focus().deleteRange(e).selectAndUploadVideo().run();
    }
  },
  {
    title: "Link",
    icon: U2e,
    command: ({ editor: n, range: e }) => {
      n.chain().focus().deleteRange(e).setLink({ href: "" }).run();
    }
  },
  {
    title: "Horizontal Rule",
    icon: WH,
    command: ({ editor: n, range: e }) => {
      n.chain().focus().deleteRange(e).setHorizontalRule().run();
    }
  },
  {
    title: "Table",
    icon: Y2e,
    command: ({ editor: n, range: e }) => {
      n.chain().focus().deleteRange(e).insertTable({ rows: 3, cols: 3, withHeaderRow: !0 }).run();
    }
  }
], Z2e = jx({
  name: "slashCommands",
  char: "/",
  pluginKey: K2e,
  items: ({ query: n }) => X2e().filter(
    (t) => t.title.toLowerCase().startsWith(n.toLowerCase())
  ),
  command: ({ editor: n, range: e, props: t }) => {
    t && typeof t.command == "function" ? t.command({ editor: n, range: e }) : console.error(
      "Slash command execution error: command function not found on selected item or item is invalid.",
      t
    );
  },
  component: v2e
});
function sD() {
  return {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null
  };
}
var Yd = sD();
function J7(n) {
  Yd = n;
}
var tm = { exec: () => null };
function Dn(n, e = "") {
  let t = typeof n == "string" ? n : n.source;
  const r = {
    replace: (i, a) => {
      let o = typeof a == "string" ? a : a.source;
      return o = o.replace(Mi.caret, "$1"), t = t.replace(i, o), r;
    },
    getRegex: () => new RegExp(t, e)
  };
  return r;
}
var Mi = {
  codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
  outputLinkReplace: /\\([\[\]])/g,
  indentCodeCompensation: /^(\s+)(?:```)/,
  beginningSpace: /^\s+/,
  endingHash: /#$/,
  startingSpaceChar: /^ /,
  endingSpaceChar: / $/,
  nonSpaceChar: /[^ ]/,
  newLineCharGlobal: /\n/g,
  tabCharGlobal: /\t/g,
  multipleSpaceGlobal: /\s+/g,
  blankLine: /^[ \t]*$/,
  doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
  blockquoteStart: /^ {0,3}>/,
  blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
  blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
  listReplaceTabs: /^\t+/,
  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
  listIsTask: /^\[[ xX]\] /,
  listReplaceTask: /^\[[ xX]\] +/,
  anyLine: /\n.*\n/,
  hrefBrackets: /^<(.*)>$/,
  tableDelimiter: /[:|]/,
  tableAlignChars: /^\||\| *$/g,
  tableRowBlankLine: /\n[ \t]*$/,
  tableAlignRight: /^ *-+: *$/,
  tableAlignCenter: /^ *:-+: *$/,
  tableAlignLeft: /^ *:-+ *$/,
  startATag: /^<a /i,
  endATag: /^<\/a>/i,
  startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
  endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
  startAngleBracket: /^</,
  endAngleBracket: />$/,
  pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
  unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
  escapeTest: /[&<>"']/,
  escapeReplace: /[&<>"']/g,
  escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
  unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
  caret: /(^|[^\[])\^/g,
  percentDecode: /%25/g,
  findPipe: /\|/g,
  splitPipe: / \|/,
  slashPipe: /\\\|/g,
  carriageReturn: /\r\n|\r/g,
  spaceLine: /^ +$/gm,
  notSpaceStart: /^\S*/,
  endingNewline: /\n$/,
  listItemRegex: (n) => new RegExp(`^( {0,3}${n})((?:[	 ][^\\n]*)?(?:\\n|$))`),
  nextBulletRegex: (n) => new RegExp(`^ {0,${Math.min(3, n - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
  hrRegex: (n) => new RegExp(`^ {0,${Math.min(3, n - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
  fencesBeginRegex: (n) => new RegExp(`^ {0,${Math.min(3, n - 1)}}(?:\`\`\`|~~~)`),
  headingBeginRegex: (n) => new RegExp(`^ {0,${Math.min(3, n - 1)}}#`),
  htmlBeginRegex: (n) => new RegExp(`^ {0,${Math.min(3, n - 1)}}<(?:[a-z].*>|!--)`, "i")
}, J2e = /^(?:[ \t]*(?:\n|$))+/, Q2e = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, eEe = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, Bg = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, tEe = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, lD = /(?:[*+-]|\d{1,9}[.)])/, Q7 = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, e9 = Dn(Q7).replace(/bull/g, lD).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), nEe = Dn(Q7).replace(/bull/g, lD).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), uD = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, rEe = /^[^\n]+/, cD = /(?!\s*\])(?:\\.|[^\[\]\\])+/, iEe = Dn(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", cD).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), aEe = Dn(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, lD).getRegex(), Fx = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", dD = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, oEe = Dn(
  "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))",
  "i"
).replace("comment", dD).replace("tag", Fx).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), t9 = Dn(uD).replace("hr", Bg).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Fx).getRegex(), sEe = Dn(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", t9).getRegex(), fD = {
  blockquote: sEe,
  code: Q2e,
  def: iEe,
  fences: eEe,
  heading: tEe,
  hr: Bg,
  html: oEe,
  lheading: e9,
  list: aEe,
  newline: J2e,
  paragraph: t9,
  table: tm,
  text: rEe
}, cP = Dn(
  "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
).replace("hr", Bg).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Fx).getRegex(), lEe = {
  ...fD,
  lheading: nEe,
  table: cP,
  paragraph: Dn(uD).replace("hr", Bg).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", cP).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Fx).getRegex()
}, uEe = {
  ...fD,
  html: Dn(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", dD).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: tm,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: Dn(uD).replace("hr", Bg).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", e9).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, cEe = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, dEe = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, n9 = /^( {2,}|\\)\n(?!\s*$)/, fEe = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, Vx = /[\p{P}\p{S}]/u, pD = /[\s\p{P}\p{S}]/u, r9 = /[^\s\p{P}\p{S}]/u, pEe = Dn(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, pD).getRegex(), i9 = /(?!~)[\p{P}\p{S}]/u, hEe = /(?!~)[\s\p{P}\p{S}]/u, vEe = /(?:[^\s\p{P}\p{S}]|~)/u, mEe = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g, a9 = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, gEe = Dn(a9, "u").replace(/punct/g, Vx).getRegex(), yEe = Dn(a9, "u").replace(/punct/g, i9).getRegex(), o9 = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", bEe = Dn(o9, "gu").replace(/notPunctSpace/g, r9).replace(/punctSpace/g, pD).replace(/punct/g, Vx).getRegex(), _Ee = Dn(o9, "gu").replace(/notPunctSpace/g, vEe).replace(/punctSpace/g, hEe).replace(/punct/g, i9).getRegex(), xEe = Dn(
  "^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)",
  "gu"
).replace(/notPunctSpace/g, r9).replace(/punctSpace/g, pD).replace(/punct/g, Vx).getRegex(), wEe = Dn(/\\(punct)/, "gu").replace(/punct/g, Vx).getRegex(), SEe = Dn(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), EEe = Dn(dD).replace("(?:-->|$)", "-->").getRegex(), TEe = Dn(
  "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>"
).replace("comment", EEe).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), Bb = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, CEe = Dn(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", Bb).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), s9 = Dn(/^!?\[(label)\]\[(ref)\]/).replace("label", Bb).replace("ref", cD).getRegex(), l9 = Dn(/^!?\[(ref)\](?:\[\])?/).replace("ref", cD).getRegex(), kEe = Dn("reflink|nolink(?!\\()", "g").replace("reflink", s9).replace("nolink", l9).getRegex(), hD = {
  _backpedal: tm,
  // only used for GFM url
  anyPunctuation: wEe,
  autolink: SEe,
  blockSkip: mEe,
  br: n9,
  code: dEe,
  del: tm,
  emStrongLDelim: gEe,
  emStrongRDelimAst: bEe,
  emStrongRDelimUnd: xEe,
  escape: cEe,
  link: CEe,
  nolink: l9,
  punctuation: pEe,
  reflink: s9,
  reflinkSearch: kEe,
  tag: TEe,
  text: fEe,
  url: tm
}, AEe = {
  ...hD,
  link: Dn(/^!?\[(label)\]\((.*?)\)/).replace("label", Bb).getRegex(),
  reflink: Dn(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", Bb).getRegex()
}, CC = {
  ...hD,
  emStrongRDelimAst: _Ee,
  emStrongLDelim: yEe,
  url: Dn(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
}, MEe = {
  ...CC,
  br: Dn(n9).replace("{2,}", "*").getRegex(),
  text: Dn(CC.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
}, Yy = {
  normal: fD,
  gfm: lEe,
  pedantic: uEe
}, $h = {
  normal: hD,
  gfm: CC,
  breaks: MEe,
  pedantic: AEe
}, DEe = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
}, dP = (n) => DEe[n];
function Uo(n, e) {
  if (e) {
    if (Mi.escapeTest.test(n))
      return n.replace(Mi.escapeReplace, dP);
  } else if (Mi.escapeTestNoEncode.test(n))
    return n.replace(Mi.escapeReplaceNoEncode, dP);
  return n;
}
function fP(n) {
  try {
    n = encodeURI(n).replace(Mi.percentDecode, "%");
  } catch {
    return null;
  }
  return n;
}
function pP(n, e) {
  var a;
  const t = n.replace(Mi.findPipe, (o, s, l) => {
    let u = !1, c = s;
    for (; --c >= 0 && l[c] === "\\"; ) u = !u;
    return u ? "|" : " |";
  }), r = t.split(Mi.splitPipe);
  let i = 0;
  if (r[0].trim() || r.shift(), r.length > 0 && !((a = r.at(-1)) != null && a.trim()) && r.pop(), e)
    if (r.length > e)
      r.splice(e);
    else
      for (; r.length < e; ) r.push("");
  for (; i < r.length; i++)
    r[i] = r[i].trim().replace(Mi.slashPipe, "|");
  return r;
}
function zh(n, e, t) {
  const r = n.length;
  if (r === 0)
    return "";
  let i = 0;
  for (; i < r && n.charAt(r - i - 1) === e; )
    i++;
  return n.slice(0, r - i);
}
function OEe(n, e) {
  if (n.indexOf(e[1]) === -1)
    return -1;
  let t = 0;
  for (let r = 0; r < n.length; r++)
    if (n[r] === "\\")
      r++;
    else if (n[r] === e[0])
      t++;
    else if (n[r] === e[1] && (t--, t < 0))
      return r;
  return t > 0 ? -2 : -1;
}
function hP(n, e, t, r, i) {
  const a = e.href, o = e.title || null, s = n[1].replace(i.other.outputLinkReplace, "$1");
  r.state.inLink = !0;
  const l = {
    type: n[0].charAt(0) === "!" ? "image" : "link",
    raw: t,
    href: a,
    title: o,
    text: s,
    tokens: r.inlineTokens(s)
  };
  return r.state.inLink = !1, l;
}
function IEe(n, e, t) {
  const r = n.match(t.other.indentCodeCompensation);
  if (r === null)
    return e;
  const i = r[1];
  return e.split(`
`).map((a) => {
    const o = a.match(t.other.beginningSpace);
    if (o === null)
      return a;
    const [s] = o;
    return s.length >= i.length ? a.slice(i.length) : a;
  }).join(`
`);
}
var $b = class {
  // set by the lexer
  constructor(n) {
    Vn(this, "options");
    Vn(this, "rules");
    // set by the lexer
    Vn(this, "lexer");
    this.options = n || Yd;
  }
  space(n) {
    const e = this.rules.block.newline.exec(n);
    if (e && e[0].length > 0)
      return {
        type: "space",
        raw: e[0]
      };
  }
  code(n) {
    const e = this.rules.block.code.exec(n);
    if (e) {
      const t = e[0].replace(this.rules.other.codeRemoveIndent, "");
      return {
        type: "code",
        raw: e[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic ? t : zh(t, `
`)
      };
    }
  }
  fences(n) {
    const e = this.rules.block.fences.exec(n);
    if (e) {
      const t = e[0], r = IEe(t, e[3] || "", this.rules);
      return {
        type: "code",
        raw: t,
        lang: e[2] ? e[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : e[2],
        text: r
      };
    }
  }
  heading(n) {
    const e = this.rules.block.heading.exec(n);
    if (e) {
      let t = e[2].trim();
      if (this.rules.other.endingHash.test(t)) {
        const r = zh(t, "#");
        (this.options.pedantic || !r || this.rules.other.endingSpaceChar.test(r)) && (t = r.trim());
      }
      return {
        type: "heading",
        raw: e[0],
        depth: e[1].length,
        text: t,
        tokens: this.lexer.inline(t)
      };
    }
  }
  hr(n) {
    const e = this.rules.block.hr.exec(n);
    if (e)
      return {
        type: "hr",
        raw: zh(e[0], `
`)
      };
  }
  blockquote(n) {
    const e = this.rules.block.blockquote.exec(n);
    if (e) {
      let t = zh(e[0], `
`).split(`
`), r = "", i = "";
      const a = [];
      for (; t.length > 0; ) {
        let o = !1;
        const s = [];
        let l;
        for (l = 0; l < t.length; l++)
          if (this.rules.other.blockquoteStart.test(t[l]))
            s.push(t[l]), o = !0;
          else if (!o)
            s.push(t[l]);
          else
            break;
        t = t.slice(l);
        const u = s.join(`
`), c = u.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        r = r ? `${r}
${u}` : u, i = i ? `${i}
${c}` : c;
        const d = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens(c, a, !0), this.lexer.state.top = d, t.length === 0)
          break;
        const f = a.at(-1);
        if ((f == null ? void 0 : f.type) === "code")
          break;
        if ((f == null ? void 0 : f.type) === "blockquote") {
          const p = f, h = p.raw + `
` + t.join(`
`), v = this.blockquote(h);
          a[a.length - 1] = v, r = r.substring(0, r.length - p.raw.length) + v.raw, i = i.substring(0, i.length - p.text.length) + v.text;
          break;
        } else if ((f == null ? void 0 : f.type) === "list") {
          const p = f, h = p.raw + `
` + t.join(`
`), v = this.list(h);
          a[a.length - 1] = v, r = r.substring(0, r.length - f.raw.length) + v.raw, i = i.substring(0, i.length - p.raw.length) + v.raw, t = h.substring(a.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return {
        type: "blockquote",
        raw: r,
        tokens: a,
        text: i
      };
    }
  }
  list(n) {
    let e = this.rules.block.list.exec(n);
    if (e) {
      let t = e[1].trim();
      const r = t.length > 1, i = {
        type: "list",
        raw: "",
        ordered: r,
        start: r ? +t.slice(0, -1) : "",
        loose: !1,
        items: []
      };
      t = r ? `\\d{1,9}\\${t.slice(-1)}` : `\\${t}`, this.options.pedantic && (t = r ? t : "[*+-]");
      const a = this.rules.other.listItemRegex(t);
      let o = !1;
      for (; n; ) {
        let l = !1, u = "", c = "";
        if (!(e = a.exec(n)) || this.rules.block.hr.test(n))
          break;
        u = e[0], n = n.substring(u.length);
        let d = e[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (g) => " ".repeat(3 * g.length)), f = n.split(`
`, 1)[0], p = !d.trim(), h = 0;
        if (this.options.pedantic ? (h = 2, c = d.trimStart()) : p ? h = e[1].length + 1 : (h = e[2].search(this.rules.other.nonSpaceChar), h = h > 4 ? 1 : h, c = d.slice(h), h += e[1].length), p && this.rules.other.blankLine.test(f) && (u += f + `
`, n = n.substring(f.length + 1), l = !0), !l) {
          const g = this.rules.other.nextBulletRegex(h), y = this.rules.other.hrRegex(h), b = this.rules.other.fencesBeginRegex(h), _ = this.rules.other.headingBeginRegex(h), x = this.rules.other.htmlBeginRegex(h);
          for (; n; ) {
            const w = n.split(`
`, 1)[0];
            let S;
            if (f = w, this.options.pedantic ? (f = f.replace(this.rules.other.listReplaceNesting, "  "), S = f) : S = f.replace(this.rules.other.tabCharGlobal, "    "), b.test(f) || _.test(f) || x.test(f) || g.test(f) || y.test(f))
              break;
            if (S.search(this.rules.other.nonSpaceChar) >= h || !f.trim())
              c += `
` + S.slice(h);
            else {
              if (p || d.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || b.test(d) || _.test(d) || y.test(d))
                break;
              c += `
` + f;
            }
            !p && !f.trim() && (p = !0), u += w + `
`, n = n.substring(w.length + 1), d = S.slice(h);
          }
        }
        i.loose || (o ? i.loose = !0 : this.rules.other.doubleBlankLine.test(u) && (o = !0));
        let v = null, m;
        this.options.gfm && (v = this.rules.other.listIsTask.exec(c), v && (m = v[0] !== "[ ] ", c = c.replace(this.rules.other.listReplaceTask, ""))), i.items.push({
          type: "list_item",
          raw: u,
          task: !!v,
          checked: m,
          loose: !1,
          text: c,
          tokens: []
        }), i.raw += u;
      }
      const s = i.items.at(-1);
      if (s)
        s.raw = s.raw.trimEnd(), s.text = s.text.trimEnd();
      else
        return;
      i.raw = i.raw.trimEnd();
      for (let l = 0; l < i.items.length; l++)
        if (this.lexer.state.top = !1, i.items[l].tokens = this.lexer.blockTokens(i.items[l].text, []), !i.loose) {
          const u = i.items[l].tokens.filter((d) => d.type === "space"), c = u.length > 0 && u.some((d) => this.rules.other.anyLine.test(d.raw));
          i.loose = c;
        }
      if (i.loose)
        for (let l = 0; l < i.items.length; l++)
          i.items[l].loose = !0;
      return i;
    }
  }
  html(n) {
    const e = this.rules.block.html.exec(n);
    if (e)
      return {
        type: "html",
        block: !0,
        raw: e[0],
        pre: e[1] === "pre" || e[1] === "script" || e[1] === "style",
        text: e[0]
      };
  }
  def(n) {
    const e = this.rules.block.def.exec(n);
    if (e) {
      const t = e[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r = e[2] ? e[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = e[3] ? e[3].substring(1, e[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : e[3];
      return {
        type: "def",
        tag: t,
        raw: e[0],
        href: r,
        title: i
      };
    }
  }
  table(n) {
    var o;
    const e = this.rules.block.table.exec(n);
    if (!e || !this.rules.other.tableDelimiter.test(e[2]))
      return;
    const t = pP(e[1]), r = e[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = (o = e[3]) != null && o.trim() ? e[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], a = {
      type: "table",
      raw: e[0],
      header: [],
      align: [],
      rows: []
    };
    if (t.length === r.length) {
      for (const s of r)
        this.rules.other.tableAlignRight.test(s) ? a.align.push("right") : this.rules.other.tableAlignCenter.test(s) ? a.align.push("center") : this.rules.other.tableAlignLeft.test(s) ? a.align.push("left") : a.align.push(null);
      for (let s = 0; s < t.length; s++)
        a.header.push({
          text: t[s],
          tokens: this.lexer.inline(t[s]),
          header: !0,
          align: a.align[s]
        });
      for (const s of i)
        a.rows.push(pP(s, a.header.length).map((l, u) => ({
          text: l,
          tokens: this.lexer.inline(l),
          header: !1,
          align: a.align[u]
        })));
      return a;
    }
  }
  lheading(n) {
    const e = this.rules.block.lheading.exec(n);
    if (e)
      return {
        type: "heading",
        raw: e[0],
        depth: e[2].charAt(0) === "=" ? 1 : 2,
        text: e[1],
        tokens: this.lexer.inline(e[1])
      };
  }
  paragraph(n) {
    const e = this.rules.block.paragraph.exec(n);
    if (e) {
      const t = e[1].charAt(e[1].length - 1) === `
` ? e[1].slice(0, -1) : e[1];
      return {
        type: "paragraph",
        raw: e[0],
        text: t,
        tokens: this.lexer.inline(t)
      };
    }
  }
  text(n) {
    const e = this.rules.block.text.exec(n);
    if (e)
      return {
        type: "text",
        raw: e[0],
        text: e[0],
        tokens: this.lexer.inline(e[0])
      };
  }
  escape(n) {
    const e = this.rules.inline.escape.exec(n);
    if (e)
      return {
        type: "escape",
        raw: e[0],
        text: e[1]
      };
  }
  tag(n) {
    const e = this.rules.inline.tag.exec(n);
    if (e)
      return !this.lexer.state.inLink && this.rules.other.startATag.test(e[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(e[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(e[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(e[0]) && (this.lexer.state.inRawBlock = !1), {
        type: "html",
        raw: e[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: !1,
        text: e[0]
      };
  }
  link(n) {
    const e = this.rules.inline.link.exec(n);
    if (e) {
      const t = e[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(t)) {
        if (!this.rules.other.endAngleBracket.test(t))
          return;
        const a = zh(t.slice(0, -1), "\\");
        if ((t.length - a.length) % 2 === 0)
          return;
      } else {
        const a = OEe(e[2], "()");
        if (a === -2)
          return;
        if (a > -1) {
          const s = (e[0].indexOf("!") === 0 ? 5 : 4) + e[1].length + a;
          e[2] = e[2].substring(0, a), e[0] = e[0].substring(0, s).trim(), e[3] = "";
        }
      }
      let r = e[2], i = "";
      if (this.options.pedantic) {
        const a = this.rules.other.pedanticHrefTitle.exec(r);
        a && (r = a[1], i = a[3]);
      } else
        i = e[3] ? e[3].slice(1, -1) : "";
      return r = r.trim(), this.rules.other.startAngleBracket.test(r) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(t) ? r = r.slice(1) : r = r.slice(1, -1)), hP(e, {
        href: r && r.replace(this.rules.inline.anyPunctuation, "$1"),
        title: i && i.replace(this.rules.inline.anyPunctuation, "$1")
      }, e[0], this.lexer, this.rules);
    }
  }
  reflink(n, e) {
    let t;
    if ((t = this.rules.inline.reflink.exec(n)) || (t = this.rules.inline.nolink.exec(n))) {
      const r = (t[2] || t[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = e[r.toLowerCase()];
      if (!i) {
        const a = t[0].charAt(0);
        return {
          type: "text",
          raw: a,
          text: a
        };
      }
      return hP(t, i, t[0], this.lexer, this.rules);
    }
  }
  emStrong(n, e, t = "") {
    let r = this.rules.inline.emStrongLDelim.exec(n);
    if (!r || r[3] && t.match(this.rules.other.unicodeAlphaNumeric)) return;
    if (!(r[1] || r[2] || "") || !t || this.rules.inline.punctuation.exec(t)) {
      const a = [...r[0]].length - 1;
      let o, s, l = a, u = 0;
      const c = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (c.lastIndex = 0, e = e.slice(-1 * n.length + a); (r = c.exec(e)) != null; ) {
        if (o = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !o) continue;
        if (s = [...o].length, r[3] || r[4]) {
          l += s;
          continue;
        } else if ((r[5] || r[6]) && a % 3 && !((a + s) % 3)) {
          u += s;
          continue;
        }
        if (l -= s, l > 0) continue;
        s = Math.min(s, s + l + u);
        const d = [...r[0]][0].length, f = n.slice(0, a + r.index + d + s);
        if (Math.min(a, s) % 2) {
          const h = f.slice(1, -1);
          return {
            type: "em",
            raw: f,
            text: h,
            tokens: this.lexer.inlineTokens(h)
          };
        }
        const p = f.slice(2, -2);
        return {
          type: "strong",
          raw: f,
          text: p,
          tokens: this.lexer.inlineTokens(p)
        };
      }
    }
  }
  codespan(n) {
    const e = this.rules.inline.code.exec(n);
    if (e) {
      let t = e[2].replace(this.rules.other.newLineCharGlobal, " ");
      const r = this.rules.other.nonSpaceChar.test(t), i = this.rules.other.startingSpaceChar.test(t) && this.rules.other.endingSpaceChar.test(t);
      return r && i && (t = t.substring(1, t.length - 1)), {
        type: "codespan",
        raw: e[0],
        text: t
      };
    }
  }
  br(n) {
    const e = this.rules.inline.br.exec(n);
    if (e)
      return {
        type: "br",
        raw: e[0]
      };
  }
  del(n) {
    const e = this.rules.inline.del.exec(n);
    if (e)
      return {
        type: "del",
        raw: e[0],
        text: e[2],
        tokens: this.lexer.inlineTokens(e[2])
      };
  }
  autolink(n) {
    const e = this.rules.inline.autolink.exec(n);
    if (e) {
      let t, r;
      return e[2] === "@" ? (t = e[1], r = "mailto:" + t) : (t = e[1], r = t), {
        type: "link",
        raw: e[0],
        text: t,
        href: r,
        tokens: [
          {
            type: "text",
            raw: t,
            text: t
          }
        ]
      };
    }
  }
  url(n) {
    var t;
    let e;
    if (e = this.rules.inline.url.exec(n)) {
      let r, i;
      if (e[2] === "@")
        r = e[0], i = "mailto:" + r;
      else {
        let a;
        do
          a = e[0], e[0] = ((t = this.rules.inline._backpedal.exec(e[0])) == null ? void 0 : t[0]) ?? "";
        while (a !== e[0]);
        r = e[0], e[1] === "www." ? i = "http://" + e[0] : i = e[0];
      }
      return {
        type: "link",
        raw: e[0],
        text: r,
        href: i,
        tokens: [
          {
            type: "text",
            raw: r,
            text: r
          }
        ]
      };
    }
  }
  inlineText(n) {
    const e = this.rules.inline.text.exec(n);
    if (e) {
      const t = this.lexer.state.inRawBlock;
      return {
        type: "text",
        raw: e[0],
        text: e[0],
        escaped: t
      };
    }
  }
}, el = class kC {
  constructor(e) {
    Vn(this, "tokens");
    Vn(this, "options");
    Vn(this, "state");
    Vn(this, "tokenizer");
    Vn(this, "inlineQueue");
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || Yd, this.options.tokenizer = this.options.tokenizer || new $b(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
      inLink: !1,
      inRawBlock: !1,
      top: !0
    };
    const t = {
      other: Mi,
      block: Yy.normal,
      inline: $h.normal
    };
    this.options.pedantic ? (t.block = Yy.pedantic, t.inline = $h.pedantic) : this.options.gfm && (t.block = Yy.gfm, this.options.breaks ? t.inline = $h.breaks : t.inline = $h.gfm), this.tokenizer.rules = t;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block: Yy,
      inline: $h
    };
  }
  /**
   * Static Lex Method
   */
  static lex(e, t) {
    return new kC(t).lex(e);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(e, t) {
    return new kC(t).inlineTokens(e);
  }
  /**
   * Preprocessing
   */
  lex(e) {
    e = e.replace(Mi.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let t = 0; t < this.inlineQueue.length; t++) {
      const r = this.inlineQueue[t];
      this.inlineTokens(r.src, r.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, t = [], r = !1) {
    var i, a, o;
    for (this.options.pedantic && (e = e.replace(Mi.tabCharGlobal, "    ").replace(Mi.spaceLine, "")); e; ) {
      let s;
      if ((a = (i = this.options.extensions) == null ? void 0 : i.block) != null && a.some((u) => (s = u.call({ lexer: this }, e, t)) ? (e = e.substring(s.raw.length), t.push(s), !0) : !1))
        continue;
      if (s = this.tokenizer.space(e)) {
        e = e.substring(s.raw.length);
        const u = t.at(-1);
        s.raw.length === 1 && u !== void 0 ? u.raw += `
` : t.push(s);
        continue;
      }
      if (s = this.tokenizer.code(e)) {
        e = e.substring(s.raw.length);
        const u = t.at(-1);
        (u == null ? void 0 : u.type) === "paragraph" || (u == null ? void 0 : u.type) === "text" ? (u.raw += `
` + s.raw, u.text += `
` + s.text, this.inlineQueue.at(-1).src = u.text) : t.push(s);
        continue;
      }
      if (s = this.tokenizer.fences(e)) {
        e = e.substring(s.raw.length), t.push(s);
        continue;
      }
      if (s = this.tokenizer.heading(e)) {
        e = e.substring(s.raw.length), t.push(s);
        continue;
      }
      if (s = this.tokenizer.hr(e)) {
        e = e.substring(s.raw.length), t.push(s);
        continue;
      }
      if (s = this.tokenizer.blockquote(e)) {
        e = e.substring(s.raw.length), t.push(s);
        continue;
      }
      if (s = this.tokenizer.list(e)) {
        e = e.substring(s.raw.length), t.push(s);
        continue;
      }
      if (s = this.tokenizer.html(e)) {
        e = e.substring(s.raw.length), t.push(s);
        continue;
      }
      if (s = this.tokenizer.def(e)) {
        e = e.substring(s.raw.length);
        const u = t.at(-1);
        (u == null ? void 0 : u.type) === "paragraph" || (u == null ? void 0 : u.type) === "text" ? (u.raw += `
` + s.raw, u.text += `
` + s.raw, this.inlineQueue.at(-1).src = u.text) : this.tokens.links[s.tag] || (this.tokens.links[s.tag] = {
          href: s.href,
          title: s.title
        });
        continue;
      }
      if (s = this.tokenizer.table(e)) {
        e = e.substring(s.raw.length), t.push(s);
        continue;
      }
      if (s = this.tokenizer.lheading(e)) {
        e = e.substring(s.raw.length), t.push(s);
        continue;
      }
      let l = e;
      if ((o = this.options.extensions) != null && o.startBlock) {
        let u = 1 / 0;
        const c = e.slice(1);
        let d;
        this.options.extensions.startBlock.forEach((f) => {
          d = f.call({ lexer: this }, c), typeof d == "number" && d >= 0 && (u = Math.min(u, d));
        }), u < 1 / 0 && u >= 0 && (l = e.substring(0, u + 1));
      }
      if (this.state.top && (s = this.tokenizer.paragraph(l))) {
        const u = t.at(-1);
        r && (u == null ? void 0 : u.type) === "paragraph" ? (u.raw += `
` + s.raw, u.text += `
` + s.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = u.text) : t.push(s), r = l.length !== e.length, e = e.substring(s.raw.length);
        continue;
      }
      if (s = this.tokenizer.text(e)) {
        e = e.substring(s.raw.length);
        const u = t.at(-1);
        (u == null ? void 0 : u.type) === "text" ? (u.raw += `
` + s.raw, u.text += `
` + s.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = u.text) : t.push(s);
        continue;
      }
      if (e) {
        const u = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(u);
          break;
        } else
          throw new Error(u);
      }
    }
    return this.state.top = !0, t;
  }
  inline(e, t = []) {
    return this.inlineQueue.push({ src: e, tokens: t }), t;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(e, t = []) {
    var s, l, u;
    let r = e, i = null;
    if (this.tokens.links) {
      const c = Object.keys(this.tokens.links);
      if (c.length > 0)
        for (; (i = this.tokenizer.rules.inline.reflinkSearch.exec(r)) != null; )
          c.includes(i[0].slice(i[0].lastIndexOf("[") + 1, -1)) && (r = r.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (i = this.tokenizer.rules.inline.anyPunctuation.exec(r)) != null; )
      r = r.slice(0, i.index) + "++" + r.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; (i = this.tokenizer.rules.inline.blockSkip.exec(r)) != null; )
      r = r.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    let a = !1, o = "";
    for (; e; ) {
      a || (o = ""), a = !1;
      let c;
      if ((l = (s = this.options.extensions) == null ? void 0 : s.inline) != null && l.some((f) => (c = f.call({ lexer: this }, e, t)) ? (e = e.substring(c.raw.length), t.push(c), !0) : !1))
        continue;
      if (c = this.tokenizer.escape(e)) {
        e = e.substring(c.raw.length), t.push(c);
        continue;
      }
      if (c = this.tokenizer.tag(e)) {
        e = e.substring(c.raw.length), t.push(c);
        continue;
      }
      if (c = this.tokenizer.link(e)) {
        e = e.substring(c.raw.length), t.push(c);
        continue;
      }
      if (c = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(c.raw.length);
        const f = t.at(-1);
        c.type === "text" && (f == null ? void 0 : f.type) === "text" ? (f.raw += c.raw, f.text += c.text) : t.push(c);
        continue;
      }
      if (c = this.tokenizer.emStrong(e, r, o)) {
        e = e.substring(c.raw.length), t.push(c);
        continue;
      }
      if (c = this.tokenizer.codespan(e)) {
        e = e.substring(c.raw.length), t.push(c);
        continue;
      }
      if (c = this.tokenizer.br(e)) {
        e = e.substring(c.raw.length), t.push(c);
        continue;
      }
      if (c = this.tokenizer.del(e)) {
        e = e.substring(c.raw.length), t.push(c);
        continue;
      }
      if (c = this.tokenizer.autolink(e)) {
        e = e.substring(c.raw.length), t.push(c);
        continue;
      }
      if (!this.state.inLink && (c = this.tokenizer.url(e))) {
        e = e.substring(c.raw.length), t.push(c);
        continue;
      }
      let d = e;
      if ((u = this.options.extensions) != null && u.startInline) {
        let f = 1 / 0;
        const p = e.slice(1);
        let h;
        this.options.extensions.startInline.forEach((v) => {
          h = v.call({ lexer: this }, p), typeof h == "number" && h >= 0 && (f = Math.min(f, h));
        }), f < 1 / 0 && f >= 0 && (d = e.substring(0, f + 1));
      }
      if (c = this.tokenizer.inlineText(d)) {
        e = e.substring(c.raw.length), c.raw.slice(-1) !== "_" && (o = c.raw.slice(-1)), a = !0;
        const f = t.at(-1);
        (f == null ? void 0 : f.type) === "text" ? (f.raw += c.raw, f.text += c.text) : t.push(c);
        continue;
      }
      if (e) {
        const f = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(f);
          break;
        } else
          throw new Error(f);
      }
    }
    return t;
  }
}, zb = class {
  // set by the parser
  constructor(n) {
    Vn(this, "options");
    Vn(this, "parser");
    this.options = n || Yd;
  }
  space(n) {
    return "";
  }
  code({ text: n, lang: e, escaped: t }) {
    var a;
    const r = (a = (e || "").match(Mi.notSpaceStart)) == null ? void 0 : a[0], i = n.replace(Mi.endingNewline, "") + `
`;
    return r ? '<pre><code class="language-' + Uo(r) + '">' + (t ? i : Uo(i, !0)) + `</code></pre>
` : "<pre><code>" + (t ? i : Uo(i, !0)) + `</code></pre>
`;
  }
  blockquote({ tokens: n }) {
    return `<blockquote>
${this.parser.parse(n)}</blockquote>
`;
  }
  html({ text: n }) {
    return n;
  }
  heading({ tokens: n, depth: e }) {
    return `<h${e}>${this.parser.parseInline(n)}</h${e}>
`;
  }
  hr(n) {
    return `<hr>
`;
  }
  list(n) {
    const e = n.ordered, t = n.start;
    let r = "";
    for (let o = 0; o < n.items.length; o++) {
      const s = n.items[o];
      r += this.listitem(s);
    }
    const i = e ? "ol" : "ul", a = e && t !== 1 ? ' start="' + t + '"' : "";
    return "<" + i + a + `>
` + r + "</" + i + `>
`;
  }
  listitem(n) {
    var t;
    let e = "";
    if (n.task) {
      const r = this.checkbox({ checked: !!n.checked });
      n.loose ? ((t = n.tokens[0]) == null ? void 0 : t.type) === "paragraph" ? (n.tokens[0].text = r + " " + n.tokens[0].text, n.tokens[0].tokens && n.tokens[0].tokens.length > 0 && n.tokens[0].tokens[0].type === "text" && (n.tokens[0].tokens[0].text = r + " " + Uo(n.tokens[0].tokens[0].text), n.tokens[0].tokens[0].escaped = !0)) : n.tokens.unshift({
        type: "text",
        raw: r + " ",
        text: r + " ",
        escaped: !0
      }) : e += r + " ";
    }
    return e += this.parser.parse(n.tokens, !!n.loose), `<li>${e}</li>
`;
  }
  checkbox({ checked: n }) {
    return "<input " + (n ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: n }) {
    return `<p>${this.parser.parseInline(n)}</p>
`;
  }
  table(n) {
    let e = "", t = "";
    for (let i = 0; i < n.header.length; i++)
      t += this.tablecell(n.header[i]);
    e += this.tablerow({ text: t });
    let r = "";
    for (let i = 0; i < n.rows.length; i++) {
      const a = n.rows[i];
      t = "";
      for (let o = 0; o < a.length; o++)
        t += this.tablecell(a[o]);
      r += this.tablerow({ text: t });
    }
    return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + e + `</thead>
` + r + `</table>
`;
  }
  tablerow({ text: n }) {
    return `<tr>
${n}</tr>
`;
  }
  tablecell(n) {
    const e = this.parser.parseInline(n.tokens), t = n.header ? "th" : "td";
    return (n.align ? `<${t} align="${n.align}">` : `<${t}>`) + e + `</${t}>
`;
  }
  /**
   * span level renderer
   */
  strong({ tokens: n }) {
    return `<strong>${this.parser.parseInline(n)}</strong>`;
  }
  em({ tokens: n }) {
    return `<em>${this.parser.parseInline(n)}</em>`;
  }
  codespan({ text: n }) {
    return `<code>${Uo(n, !0)}</code>`;
  }
  br(n) {
    return "<br>";
  }
  del({ tokens: n }) {
    return `<del>${this.parser.parseInline(n)}</del>`;
  }
  link({ href: n, title: e, tokens: t }) {
    const r = this.parser.parseInline(t), i = fP(n);
    if (i === null)
      return r;
    n = i;
    let a = '<a href="' + n + '"';
    return e && (a += ' title="' + Uo(e) + '"'), a += ">" + r + "</a>", a;
  }
  image({ href: n, title: e, text: t, tokens: r }) {
    r && (t = this.parser.parseInline(r, this.parser.textRenderer));
    const i = fP(n);
    if (i === null)
      return Uo(t);
    n = i;
    let a = `<img src="${n}" alt="${t}"`;
    return e && (a += ` title="${Uo(e)}"`), a += ">", a;
  }
  text(n) {
    return "tokens" in n && n.tokens ? this.parser.parseInline(n.tokens) : "escaped" in n && n.escaped ? n.text : Uo(n.text);
  }
}, vD = class {
  // no need for block level renderers
  strong({ text: n }) {
    return n;
  }
  em({ text: n }) {
    return n;
  }
  codespan({ text: n }) {
    return n;
  }
  del({ text: n }) {
    return n;
  }
  html({ text: n }) {
    return n;
  }
  text({ text: n }) {
    return n;
  }
  link({ text: n }) {
    return "" + n;
  }
  image({ text: n }) {
    return "" + n;
  }
  br() {
    return "";
  }
}, tl = class AC {
  constructor(e) {
    Vn(this, "options");
    Vn(this, "renderer");
    Vn(this, "textRenderer");
    this.options = e || Yd, this.options.renderer = this.options.renderer || new zb(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new vD();
  }
  /**
   * Static Parse Method
   */
  static parse(e, t) {
    return new AC(t).parse(e);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(e, t) {
    return new AC(t).parseInline(e);
  }
  /**
   * Parse Loop
   */
  parse(e, t = !0) {
    var i, a;
    let r = "";
    for (let o = 0; o < e.length; o++) {
      const s = e[o];
      if ((a = (i = this.options.extensions) == null ? void 0 : i.renderers) != null && a[s.type]) {
        const u = s, c = this.options.extensions.renderers[u.type].call({ parser: this }, u);
        if (c !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(u.type)) {
          r += c || "";
          continue;
        }
      }
      const l = s;
      switch (l.type) {
        case "space": {
          r += this.renderer.space(l);
          continue;
        }
        case "hr": {
          r += this.renderer.hr(l);
          continue;
        }
        case "heading": {
          r += this.renderer.heading(l);
          continue;
        }
        case "code": {
          r += this.renderer.code(l);
          continue;
        }
        case "table": {
          r += this.renderer.table(l);
          continue;
        }
        case "blockquote": {
          r += this.renderer.blockquote(l);
          continue;
        }
        case "list": {
          r += this.renderer.list(l);
          continue;
        }
        case "html": {
          r += this.renderer.html(l);
          continue;
        }
        case "paragraph": {
          r += this.renderer.paragraph(l);
          continue;
        }
        case "text": {
          let u = l, c = this.renderer.text(u);
          for (; o + 1 < e.length && e[o + 1].type === "text"; )
            u = e[++o], c += `
` + this.renderer.text(u);
          t ? r += this.renderer.paragraph({
            type: "paragraph",
            raw: c,
            text: c,
            tokens: [{ type: "text", raw: c, text: c, escaped: !0 }]
          }) : r += c;
          continue;
        }
        default: {
          const u = 'Token with "' + l.type + '" type was not found.';
          if (this.options.silent)
            return console.error(u), "";
          throw new Error(u);
        }
      }
    }
    return r;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(e, t = this.renderer) {
    var i, a;
    let r = "";
    for (let o = 0; o < e.length; o++) {
      const s = e[o];
      if ((a = (i = this.options.extensions) == null ? void 0 : i.renderers) != null && a[s.type]) {
        const u = this.options.extensions.renderers[s.type].call({ parser: this }, s);
        if (u !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(s.type)) {
          r += u || "";
          continue;
        }
      }
      const l = s;
      switch (l.type) {
        case "escape": {
          r += t.text(l);
          break;
        }
        case "html": {
          r += t.html(l);
          break;
        }
        case "link": {
          r += t.link(l);
          break;
        }
        case "image": {
          r += t.image(l);
          break;
        }
        case "strong": {
          r += t.strong(l);
          break;
        }
        case "em": {
          r += t.em(l);
          break;
        }
        case "codespan": {
          r += t.codespan(l);
          break;
        }
        case "br": {
          r += t.br(l);
          break;
        }
        case "del": {
          r += t.del(l);
          break;
        }
        case "text": {
          r += t.text(l);
          break;
        }
        default: {
          const u = 'Token with "' + l.type + '" type was not found.';
          if (this.options.silent)
            return console.error(u), "";
          throw new Error(u);
        }
      }
    }
    return r;
  }
}, vT, f1 = (vT = class {
  constructor(n) {
    Vn(this, "options");
    Vn(this, "block");
    this.options = n || Yd;
  }
  /**
   * Process markdown before marked
   */
  preprocess(n) {
    return n;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(n) {
    return n;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(n) {
    return n;
  }
  /**
   * Provide function to tokenize markdown
   */
  provideLexer() {
    return this.block ? el.lex : el.lexInline;
  }
  /**
   * Provide function to parse tokens
   */
  provideParser() {
    return this.block ? tl.parse : tl.parseInline;
  }
}, Vn(vT, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess",
  "processAllTokens"
])), vT), LEe = class {
  constructor(...n) {
    Vn(this, "defaults", sD());
    Vn(this, "options", this.setOptions);
    Vn(this, "parse", this.parseMarkdown(!0));
    Vn(this, "parseInline", this.parseMarkdown(!1));
    Vn(this, "Parser", tl);
    Vn(this, "Renderer", zb);
    Vn(this, "TextRenderer", vD);
    Vn(this, "Lexer", el);
    Vn(this, "Tokenizer", $b);
    Vn(this, "Hooks", f1);
    this.use(...n);
  }
  /**
   * Run callback for every token
   */
  walkTokens(n, e) {
    var r, i;
    let t = [];
    for (const a of n)
      switch (t = t.concat(e.call(this, a)), a.type) {
        case "table": {
          const o = a;
          for (const s of o.header)
            t = t.concat(this.walkTokens(s.tokens, e));
          for (const s of o.rows)
            for (const l of s)
              t = t.concat(this.walkTokens(l.tokens, e));
          break;
        }
        case "list": {
          const o = a;
          t = t.concat(this.walkTokens(o.items, e));
          break;
        }
        default: {
          const o = a;
          (i = (r = this.defaults.extensions) == null ? void 0 : r.childTokens) != null && i[o.type] ? this.defaults.extensions.childTokens[o.type].forEach((s) => {
            const l = o[s].flat(1 / 0);
            t = t.concat(this.walkTokens(l, e));
          }) : o.tokens && (t = t.concat(this.walkTokens(o.tokens, e)));
        }
      }
    return t;
  }
  use(...n) {
    const e = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return n.forEach((t) => {
      const r = { ...t };
      if (r.async = this.defaults.async || r.async || !1, t.extensions && (t.extensions.forEach((i) => {
        if (!i.name)
          throw new Error("extension name required");
        if ("renderer" in i) {
          const a = e.renderers[i.name];
          a ? e.renderers[i.name] = function(...o) {
            let s = i.renderer.apply(this, o);
            return s === !1 && (s = a.apply(this, o)), s;
          } : e.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline")
            throw new Error("extension level must be 'block' or 'inline'");
          const a = e[i.level];
          a ? a.unshift(i.tokenizer) : e[i.level] = [i.tokenizer], i.start && (i.level === "block" ? e.startBlock ? e.startBlock.push(i.start) : e.startBlock = [i.start] : i.level === "inline" && (e.startInline ? e.startInline.push(i.start) : e.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (e.childTokens[i.name] = i.childTokens);
      }), r.extensions = e), t.renderer) {
        const i = this.defaults.renderer || new zb(this.defaults);
        for (const a in t.renderer) {
          if (!(a in i))
            throw new Error(`renderer '${a}' does not exist`);
          if (["options", "parser"].includes(a))
            continue;
          const o = a, s = t.renderer[o], l = i[o];
          i[o] = (...u) => {
            let c = s.apply(i, u);
            return c === !1 && (c = l.apply(i, u)), c || "";
          };
        }
        r.renderer = i;
      }
      if (t.tokenizer) {
        const i = this.defaults.tokenizer || new $b(this.defaults);
        for (const a in t.tokenizer) {
          if (!(a in i))
            throw new Error(`tokenizer '${a}' does not exist`);
          if (["options", "rules", "lexer"].includes(a))
            continue;
          const o = a, s = t.tokenizer[o], l = i[o];
          i[o] = (...u) => {
            let c = s.apply(i, u);
            return c === !1 && (c = l.apply(i, u)), c;
          };
        }
        r.tokenizer = i;
      }
      if (t.hooks) {
        const i = this.defaults.hooks || new f1();
        for (const a in t.hooks) {
          if (!(a in i))
            throw new Error(`hook '${a}' does not exist`);
          if (["options", "block"].includes(a))
            continue;
          const o = a, s = t.hooks[o], l = i[o];
          f1.passThroughHooks.has(a) ? i[o] = (u) => {
            if (this.defaults.async)
              return Promise.resolve(s.call(i, u)).then((d) => l.call(i, d));
            const c = s.call(i, u);
            return l.call(i, c);
          } : i[o] = (...u) => {
            let c = s.apply(i, u);
            return c === !1 && (c = l.apply(i, u)), c;
          };
        }
        r.hooks = i;
      }
      if (t.walkTokens) {
        const i = this.defaults.walkTokens, a = t.walkTokens;
        r.walkTokens = function(o) {
          let s = [];
          return s.push(a.call(this, o)), i && (s = s.concat(i.call(this, o))), s;
        };
      }
      this.defaults = { ...this.defaults, ...r };
    }), this;
  }
  setOptions(n) {
    return this.defaults = { ...this.defaults, ...n }, this;
  }
  lexer(n, e) {
    return el.lex(n, e ?? this.defaults);
  }
  parser(n, e) {
    return tl.parse(n, e ?? this.defaults);
  }
  parseMarkdown(n) {
    return (t, r) => {
      const i = { ...r }, a = { ...this.defaults, ...i }, o = this.onError(!!a.silent, !!a.async);
      if (this.defaults.async === !0 && i.async === !1)
        return o(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof t > "u" || t === null)
        return o(new Error("marked(): input parameter is undefined or null"));
      if (typeof t != "string")
        return o(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(t) + ", string expected"));
      a.hooks && (a.hooks.options = a, a.hooks.block = n);
      const s = a.hooks ? a.hooks.provideLexer() : n ? el.lex : el.lexInline, l = a.hooks ? a.hooks.provideParser() : n ? tl.parse : tl.parseInline;
      if (a.async)
        return Promise.resolve(a.hooks ? a.hooks.preprocess(t) : t).then((u) => s(u, a)).then((u) => a.hooks ? a.hooks.processAllTokens(u) : u).then((u) => a.walkTokens ? Promise.all(this.walkTokens(u, a.walkTokens)).then(() => u) : u).then((u) => l(u, a)).then((u) => a.hooks ? a.hooks.postprocess(u) : u).catch(o);
      try {
        a.hooks && (t = a.hooks.preprocess(t));
        let u = s(t, a);
        a.hooks && (u = a.hooks.processAllTokens(u)), a.walkTokens && this.walkTokens(u, a.walkTokens);
        let c = l(u, a);
        return a.hooks && (c = a.hooks.postprocess(c)), c;
      } catch (u) {
        return o(u);
      }
    };
  }
  onError(n, e) {
    return (t) => {
      if (t.message += `
Please report this to https://github.com/markedjs/marked.`, n) {
        const r = "<p>An error occurred:</p><pre>" + Uo(t.message + "", !0) + "</pre>";
        return e ? Promise.resolve(r) : r;
      }
      if (e)
        return Promise.reject(t);
      throw t;
    };
  }
}, Ad = new LEe();
function In(n, e) {
  return Ad.parse(n, e);
}
In.options = In.setOptions = function(n) {
  return Ad.setOptions(n), In.defaults = Ad.defaults, J7(In.defaults), In;
};
In.getDefaults = sD;
In.defaults = Yd;
In.use = function(...n) {
  return Ad.use(...n), In.defaults = Ad.defaults, J7(In.defaults), In;
};
In.walkTokens = function(n, e) {
  return Ad.walkTokens(n, e);
};
In.parseInline = Ad.parseInline;
In.Parser = tl;
In.parser = tl.parse;
In.Renderer = zb;
In.TextRenderer = vD;
In.Lexer = el;
In.lexer = el.lex;
In.Tokenizer = $b;
In.Hooks = f1;
In.parse = In;
In.options;
In.setOptions;
In.use;
In.walkTokens;
In.parseInline;
tl.parse;
el.lex;
function NEe(n) {
  return In.parse(n, {
    gfm: !0,
    breaks: !0,
    async: !1
  });
}
function REe(n) {
  return n.split(`
`).filter(
    (r) => (
      // check for inline markdown content like images, links, italic, bold, etc.
      /!\[.*\]\(.*\)/.test(r) || /\[.*\]\(.*\)/.test(r) || /(^|\s)\*.*\*(\s|$)/.test(r) || /(^|\s)_.*_(\s|$)/.test(r) || /(^|\s)\*\*.*\*\*(\s|$)/.test(r) || /(^|\s)__.*__(\s|$)/.test(r) || /(^|\s)~~.*~~(\s|$)/.test(r) || // check for block markdown content like headings, code blocks, lists, etc.
      r.startsWith("![") || r.startsWith("#") || r.startsWith("> ") || r.startsWith("*") || r.startsWith("- ") || r.startsWith("1. ") || r.startsWith("```") || r.startsWith("`") || r.startsWith("[") || r.startsWith("---")
    )
  ).length > 0;
}
const PEe = Qn.create({
  name: "contentPaste",
  addOptions() {
    return {
      enabled: !0,
      showConfirmation: !0,
      uploadFunction: null
    };
  },
  addProseMirrorPlugins() {
    const n = this;
    return [
      new Pn({
        key: new jn("contentPaste"),
        props: {
          handlePaste: (e, t, r) => {
            var f, p;
            if (!this.options.enabled) return !1;
            const i = Array.from(
              ((f = t.clipboardData) == null ? void 0 : f.files) || []
            ), a = Array.from(i).filter(
              (h) => h.type.startsWith("image/")
            );
            if (a.length > 0)
              return mC(a, e, null, n.options), !0;
            const o = (p = t.clipboardData) == null ? void 0 : p.getData("text/plain");
            if (!o || !REe(o) || this.options.showConfirmation && !confirm(
              "Do you want to convert markdown content to HTML before pasting?"
            ))
              return !1;
            const s = NEe(o), l = document.createElement("div");
            l.innerHTML = s;
            const c = hp.fromSchema(e.state.schema).parseSlice(l, {
              preserveWhitespace: !0
            }), d = e.state.tr.replaceSelection(c);
            return e.dispatch(d), !0;
          }
        }
      })
    ];
  }
}), u9 = pr.create({
  name: "tagItem",
  group: "inline",
  inline: !0,
  selectable: !0,
  atom: !0,
  addAttributes() {
    return {
      tagId: {
        default: null,
        parseHTML: (n) => n.getAttribute("data-tag-id"),
        renderHTML: (n) => n.tagId ? { "data-tag-id": n.tagId } : {}
      },
      tagLabel: {
        default: "tag",
        parseHTML: (n) => n.getAttribute("data-tag-label"),
        renderHTML: (n) => ({ "data-tag-label": n.tagLabel })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "span.tag-item",
        getAttrs: (n) => {
          const e = n;
          return {
            tagId: e.getAttribute("data-tag-id"),
            tagLabel: e.getAttribute("data-tag-label") || e.innerText.replace(/^#/, "")
          };
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return [
      "span",
      Mn(n, { class: "tag-item" }),
      `#${n["data-tag-label"]}`
    ];
  },
  addCommands() {
    return {
      setTag: (n) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: n
      })
    };
  }
}), jEe = jx({
  name: "tagSuggestion",
  char: "#",
  pluginKey: new jn("tagSuggestion"),
  component: Bx,
  addOptions() {
    return {
      tags: []
    };
  },
  items: ({ query: n, editor: e }) => {
    const { tags: t } = e.extensionManager.extensions.find(
      (a) => a.name === "tagSuggestion"
    ).options;
    let r = Ir(t), i = r.filter(
      (a) => a.label.toLowerCase().startsWith(n.toLowerCase())
    ).map((a) => ({ ...a, display: a.label }));
    return n.length > 0 && !r.some(
      (a) => a.label.toLowerCase() === n.toLowerCase()
    ) && i.push({
      display: `New tag: "${n}"`,
      label: n,
      isNew: !0
    }), i;
  },
  command: ({ editor: n, range: e, props: t }) => {
    const r = {
      tagLabel: t.label,
      ...t.id && !t.isNew && { tagId: t.id }
    };
    n.chain().focus().insertContentAt(e, [
      {
        type: u9.name,
        attrs: r
      },
      {
        type: "text",
        text: " "
      }
    ]).run();
  },
  tippyOptions: {
    placement: "bottom-start",
    offset: [0, 8]
  },
  allowSpaces: !1,
  decorationTag: "span",
  decorationClass: "tag-suggestion-active"
}), BEe = AH.extend({
  addInputRules() {
    return this.options.levels.map((n) => {
      let e = new RegExp(`^(#{${n}}) $`);
      return rb({
        find: e,
        type: this.type,
        getAttributes: { level: n }
      });
    });
  }
}), $Ee = {
  class: "lucide lucide-square-pen",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function zEe(n, e) {
  return L(), W("svg", $Ee, [...e[0] || (e[0] = [
    G("path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" }, null, -1),
    G("path", { d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z" }, null, -1)
  ])]);
}
const FEe = cn({ name: "lucide-edit", render: zEe }), VEe = {
  class: "lucide lucide-image-plus",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function HEe(n, e) {
  return L(), W("svg", VEe, [...e[0] || (e[0] = [
    Zp('<path d="M16 5h6"></path><path d="M19 2v6"></path><path d="M21 11.5V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7.5"></path><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"></path><circle cx="9" cy="9" r="2"></circle>', 5)
  ])]);
}
const vP = cn({ name: "lucide-image-plus", render: HEe }), GEe = { class: "space-y-2" }, UEe = { class: "flex items-center gap-2" }, WEe = ["onDragstart", "onDragover", "onDragleave"], qEe = ["onClick"], YEe = ["src", "alt"], KEe = ["onClick"], XEe = ["title"], ZEe = ["onBlur", "onKeydown"], JEe = {
  key: 0,
  class: "flex flex-col items-center justify-center w-full h-full text-ink-gray-4 bg-surface-gray-1 rounded-[2px]"
}, QEe = ["title"], eTe = ["src", "alt"], tTe = ["onClick"], nTe = ["title"], rTe = ["onBlur", "onKeydown"], iTe = {
  key: 1,
  class: "text-p-sm text-ink-gray-5"
}, aTe = {
  key: 2,
  class: "flex flex-col items-center justify-center min-h-[200px]"
}, oTe = { class: "text-ink-gray-4 mb-2" }, sTe = { key: 3 }, lTe = { class: "mb-2 text-sm" }, uTe = { class: "w-full bg-gray-200 rounded h-2 overflow-hidden" }, cTe = {
  key: 0,
  class: "mt-2 text-red-500 text-xs"
}, dTe = { class: "flex justify-end gap-2" }, fTe = {
  key: 0,
  class: "fixed inset-0 z-50 bg-gray-900/60 pointer-events-none flex items-center justify-center"
}, pTe = /* @__PURE__ */ ve({
  __name: "ImageGroupUploadDialog",
  props: {
    modelValue: { type: Boolean },
    files: {},
    editor: {},
    mode: { default: "new" },
    existingImages: {},
    initialColumns: {}
  },
  emits: ["update:modelValue", "close", "update:files", "save"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = K({
      get: () => t.modelValue,
      set: (fe) => r("update:modelValue", fe)
    }), a = Z(!1), o = Z(null), s = Z(null), l = Z(!1), u = Z(null), c = Z(""), d = Z(null), f = Z(!1), p = Z(4), h = Z(0), v = Z(0), m = Z(0), g = Z([]), y = Z([]), b = Z([]);
    et(
      () => t.modelValue,
      (fe) => {
        if (fe && t.mode === "edit") {
          const oe = (t.existingImages || []).map(
            N
          ), he = (t.files || []).map(D);
          b.value = [...oe, ...he], t.initialColumns && (p.value = t.initialColumns, l.value = !0);
        } else fe && t.mode === "new" && (b.value = (t.files || []).map(D), p.value = R(b.value.length), l.value = !0);
      },
      { immediate: !0 }
    ), et(
      () => t.existingImages,
      (fe) => {
        if (t.modelValue && t.mode === "edit") {
          const oe = (fe || []).map(
            N
          ), he = (t.files || []).map(D);
          b.value = [...oe, ...he];
        }
      },
      { deep: !0 }
    ), et(
      () => t.files,
      (fe) => {
        t.mode === "new" && (b.value = (fe || []).map(D));
      },
      { deep: !0 }
    ), kt(() => {
      window.addEventListener("dragover", X), window.addEventListener("drop", M), window.addEventListener("dragleave", ie);
    }), Nn(() => {
      window.removeEventListener("dragover", X), window.removeEventListener("drop", M), window.removeEventListener("dragleave", ie);
    });
    async function _() {
      const fe = b.value.filter((Te) => Te.type === "file" && Te.file).map((Te) => Te.file);
      b.value.filter((Te) => Te.type === "existing" && Te.existing).map((Te) => Te.existing);
      let oe = [];
      fe.length > 0 && (oe = await Ae(fe));
      const he = /* @__PURE__ */ new Map();
      fe.forEach((Te, Ge) => {
        const je = oe[Ge];
        je != null && je.success && je.file && he.set(Te, {
          src: je.file.file_url || "",
          alt: je.file.file_name || ""
        });
      });
      const Oe = [];
      for (const Te of b.value)
        if (Te.type === "existing" && Te.existing)
          Oe.push(Te.existing);
        else if (Te.type === "file" && Te.file) {
          const Ge = he.get(Te.file);
          Ge && Oe.push(Ge);
        }
      r("save", {
        images: Oe,
        columns: p.value
      }), f.value = !1, i.value = !1;
    }
    async function x() {
      if (!t.files || t.files.length === 0) return;
      const oe = (await Ae(t.files)).filter((he) => he.success && he.file).map((he) => {
        var Oe, Te;
        return {
          src: ((Oe = he.file) == null ? void 0 : Oe.file_url) || "",
          alt: ((Te = he.file) == null ? void 0 : Te.file_name) || ""
        };
      });
      oe.length > 1 && t.editor.chain().focus().setImageGroup({ images: oe, columns: p.value }).run(), f.value = !1, i.value = !1, r("close");
    }
    function w() {
      i.value = !1, r("close");
    }
    function S(fe) {
      if (b.value.splice(fe, 1), t.mode === "new") {
        const oe = b.value.filter((he) => he.type === "file" && he.file).map((he) => he.file);
        r("update:files", oe);
      }
    }
    function C() {
      const fe = document.createElement("input");
      fe.type = "file", fe.accept = "image/*", fe.multiple = !0, fe.onchange = (oe) => {
        const he = oe.target.files;
        he && k(Array.from(he));
      }, fe.click();
    }
    function k(fe) {
      const he = fe.filter((Ge) => Ge.type.startsWith("image/")).map(D), Oe = b.value.filter((Ge) => Ge.type === "file" && Ge.file).map((Ge) => `${Ge.file.name}-${Ge.file.size}`), Te = he.filter(
        (Ge) => !Oe.includes(`${Ge.file.name}-${Ge.file.size}`)
      );
      if (b.value.push(...Te), t.mode === "new") {
        const Ge = b.value.filter((je) => je.type === "file" && je.file).map((je) => je.file);
        r("update:files", Ge);
      }
    }
    function M(fe) {
      var he;
      fe.preventDefault(), fe.stopPropagation();
      const oe = Array.from(((he = fe.dataTransfer) == null ? void 0 : he.files) || []);
      if (oe.length)
        k(oe);
      else if (o.value !== null && s.value !== null && o.value !== s.value) {
        const [Oe] = b.value.splice(o.value, 1);
        if (b.value.splice(s.value, 0, Oe), t.mode === "new") {
          const Te = b.value.filter((Ge) => Ge.type === "file" && Ge.file).map((Ge) => Ge.file);
          r("update:files", Te);
        }
      }
      a.value = !1, o.value = null, s.value = null;
    }
    function D(fe) {
      return {
        type: "file",
        file: fe,
        id: `file-${fe.name}-${fe.size}-${Date.now()}`
      };
    }
    function N(fe) {
      return {
        type: "existing",
        existing: fe,
        id: `existing-${fe.src}-${Date.now()}`
      };
    }
    function R(fe) {
      return fe <= 4 ? fe : fe % 4 === 0 ? 4 : fe % 3 === 0 ? 3 : fe > 10 ? 4 : 3;
    }
    function j() {
      var oe;
      const fe = t.editor.extensionManager.extensions.find(
        (he) => he.name === "imageGroup"
      );
      return (oe = fe == null ? void 0 : fe.options) == null ? void 0 : oe.uploadFunction;
    }
    function z(fe) {
      const oe = URL.createObjectURL(fe);
      return Nn(() => {
        URL.revokeObjectURL(oe);
      }), oe;
    }
    function F(fe) {
      const oe = ["image/heic", "image/heif"], he = [".heic", ".heif"], Oe = oe.includes(fe.type), Te = he.some(
        (Ge) => {
          var je;
          return (je = fe.name) == null ? void 0 : je.toLowerCase().endsWith(Ge);
        }
      );
      return !Oe && !Te;
    }
    function B(fe, oe) {
      fe.preventDefault(), s.value = oe;
    }
    function H(fe) {
      o.value = fe;
    }
    function Y() {
      o.value = null, s.value = null;
    }
    function ne(fe, oe) {
      s.value === oe && (s.value = null);
    }
    function J(fe) {
      return s.value === fe && o.value !== null && o.value !== fe;
    }
    function X(fe) {
      fe.preventDefault(), fe.dataTransfer && Array.from(fe.dataTransfer.types).includes("Files") && (a.value = !0);
    }
    function ie(fe) {
      (fe.target === window || fe.relatedTarget === null) && (a.value = !1);
    }
    const ye = K(() => ({
      gridTemplateColumns: `repeat(${p.value || 4}, minmax(0, 1fr))`
    })), pe = K({
      get: () => String(p.value ?? 4),
      set: (fe) => {
        p.value = +fe;
      }
    }), Be = [
      { label: "2 columns", value: "2" },
      { label: "3 columns", value: "3" },
      { label: "4 columns", value: "4" }
    ];
    function Ce(fe, oe) {
      u.value = fe, c.value = oe, Wt(() => {
        d.value && (d.value.focus(), d.value.select());
      });
    }
    function Ee(fe, oe) {
      var Ge;
      const [he, Oe] = fe.split("-"), Te = c.value.trim();
      he === "existing" ? (Ge = b.value[oe]) != null && Ge.existing && (b.value[oe].existing.alt = Te) : he === "file" && b.value[oe] && (b.value[oe].alt = Te), u.value = null, c.value = "";
    }
    function ce() {
      u.value = null, c.value = "";
    }
    function Pe(fe, oe) {
      u.value === fe && Ee(fe, oe);
    }
    async function Ae(fe) {
      const oe = j();
      if (!oe)
        throw console.error("uploadFunction not found"), new Error("Upload function not found");
      f.value = !0, m.value = fe.length, v.value = 0, h.value = 0, g.value = Array(fe.length).fill(null), y.value = Array(fe.length).fill(null);
      const he = fe.map(async (Te, Ge) => {
        try {
          const je = await oe(Te);
          return y.value[Ge] = { success: !0, file: je }, { success: !0, file: je };
        } catch (je) {
          const Qe = je;
          return g.value[Ge] = Qe, y.value[Ge] = { success: !1, error: Qe }, { success: !1, error: Qe };
        } finally {
          v.value++, h.value = Math.round(
            v.value / m.value * 100
          );
        }
      });
      return await Promise.all(he);
    }
    return (fe, oe) => (L(), W(Ke, null, [
      se(px, {
        modelValue: i.value,
        "onUpdate:modelValue": oe[8] || (oe[8] = (he) => i.value = he),
        options: {
          title: t.mode === "edit" ? "Edit Images" : "Upload Images",
          size: "3xl"
        },
        onClose: oe[9] || (oe[9] = (he) => fe.$emit("close")),
        disableOutsideClickToClose: !0
      }, {
        "body-content": ee(() => [
          G("div", GEe, [
            G("div", UEe, [
              se(fn, { onClick: C }, {
                prefix: ee(() => [
                  se(O(vP), { class: "size-4" })
                ]),
                default: ee(() => [
                  oe[10] || (oe[10] = gn(" Add images ", -1))
                ]),
                _: 1
              }),
              se(oM, {
                id: "columns-select",
                options: Be,
                modelValue: pe.value,
                "onUpdate:modelValue": [
                  oe[0] || (oe[0] = (he) => pe.value = he),
                  oe[1] || (oe[1] = (he) => p.value = +he)
                ],
                size: "sm",
                variant: "subtle",
                class: "w-28"
              }, null, 8, ["modelValue"])
            ]),
            b.value && b.value.length ? (L(), W("div", {
              key: 0,
              class: "grid gap-px mb-4",
              style: An(ye.value)
            }, [
              (L(!0), W(Ke, null, _t(b.value, (he, Oe) => {
                var Te, Ge, je, Qe;
                return L(), W("div", {
                  key: he.id,
                  class: _e(["relative aspect-square w-full h-full overflow-hidden group bg-surface-white", { "ring-2 ring-primary-400 z-10": J(Oe) }]),
                  draggable: !0,
                  onDragstart: (ot) => H(Oe),
                  onDragover: (ot) => B(ot, Oe),
                  onDrop: oe[6] || (oe[6] = (ot) => M(ot)),
                  onDragend: Y,
                  onDragleave: (ot) => ne(ot, Oe)
                }, [
                  G("button", {
                    type: "button",
                    class: "absolute top-1 right-1 z-10 bg-white/80 hover:bg-white rounded-full p-1 shadow transition-opacity opacity-0 group-hover:opacity-100 focus:opacity-100",
                    "aria-label": "Remove image",
                    onClick: xt((ot) => S(Oe), ["stop"])
                  }, [
                    se(O(rh), { class: "w-4 h-4 text-gray-700" })
                  ], 8, qEe),
                  he.type === "existing" ? (L(), W(Ke, { key: 0 }, [
                    G("img", {
                      src: (Te = he.existing) == null ? void 0 : Te.src,
                      alt: ((Ge = he.existing) == null ? void 0 : Ge.alt) || "",
                      class: "object-cover w-full h-full rounded-[2px]"
                    }, null, 8, YEe),
                    G("div", {
                      class: _e([
                        "absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/60 to-transparent rounded-b-[2px] transition-opacity",
                        u.value === `${he.type}-${Oe}` ? "opacity-100" : "opacity-0 group-hover:opacity-100"
                      ])
                    }, [
                      u.value !== `${he.type}-${Oe}` ? (L(), W("div", {
                        key: 0,
                        class: "p-2 cursor-pointer",
                        onClick: xt((ot) => {
                          var it;
                          return Ce(
                            `${he.type}-${Oe}`,
                            ((it = he.existing) == null ? void 0 : it.alt) || ""
                          );
                        }, ["stop"])
                      }, [
                        G("div", {
                          class: "text-white text-xs truncate",
                          title: ((je = he.existing) == null ? void 0 : je.alt) || "Click to add caption"
                        }, ke(((Qe = he.existing) == null ? void 0 : Qe.alt) || "Add caption..."), 9, XEe)
                      ], 8, KEe)) : (L(), W("div", {
                        key: 1,
                        class: "p-2",
                        onClick: oe[3] || (oe[3] = xt(() => {
                        }, ["stop"]))
                      }, [
                        ta(G("input", {
                          ref_for: !0,
                          ref: (ot) => d.value = ot,
                          "onUpdate:modelValue": oe[2] || (oe[2] = (ot) => c.value = ot),
                          onBlur: (ot) => Pe(`${he.type}-${Oe}`, Oe),
                          onKeydown: [
                            ci(xt((ot) => Ee(`${he.type}-${Oe}`, Oe), ["prevent"]), ["enter"]),
                            ci(ce, ["escape"])
                          ],
                          class: "w-full text-xs bg-white/90 text-gray-900 px-1 py-0.5 rounded-sm border-none outline-none",
                          placeholder: "Add caption...",
                          maxlength: "200"
                        }, null, 40, ZEe), [
                          [mT, c.value]
                        ])
                      ]))
                    ], 2)
                  ], 64)) : he.type === "file" && he.file ? (L(), W(Ke, { key: 1 }, [
                    F(he.file) ? he.file.type.startsWith("image/") ? (L(), W(Ke, { key: 1 }, [
                      G("img", {
                        src: z(he.file),
                        class: "object-cover w-full h-full rounded-[2px]",
                        alt: he.alt || ""
                      }, null, 8, eTe),
                      G("div", {
                        class: _e([
                          "absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/60 to-transparent rounded-b-[2px] transition-opacity",
                          u.value === `${he.type}-${Oe}` ? "opacity-100" : "opacity-0 group-hover:opacity-100"
                        ])
                      }, [
                        u.value !== `${he.type}-${Oe}` ? (L(), W("div", {
                          key: 0,
                          class: "p-2 cursor-pointer",
                          onClick: xt((ot) => Ce(`${he.type}-${Oe}`, he.alt || ""), ["stop"])
                        }, [
                          G("div", {
                            class: "text-white text-xs truncate",
                            title: he.alt || "Click to add caption"
                          }, ke(he.alt || "Add caption..."), 9, nTe)
                        ], 8, tTe)) : (L(), W("div", {
                          key: 1,
                          class: "p-2",
                          onClick: oe[5] || (oe[5] = xt(() => {
                          }, ["stop"]))
                        }, [
                          ta(G("input", {
                            ref_for: !0,
                            ref: "captionInput",
                            "onUpdate:modelValue": oe[4] || (oe[4] = (ot) => c.value = ot),
                            onBlur: (ot) => Pe(`${he.type}-${Oe}`, Oe),
                            onKeydown: [
                              ci(xt((ot) => Ee(`${he.type}-${Oe}`, Oe), ["prevent"]), ["enter"]),
                              ci(ce, ["escape"])
                            ],
                            class: "w-full text-xs bg-white/90 text-gray-900 px-1 py-0.5 rounded border-none outline-none",
                            placeholder: "Add caption...",
                            maxlength: "200"
                          }, null, 40, rTe), [
                            [mT, c.value]
                          ])
                        ]))
                      ], 2)
                    ], 64)) : ge("", !0) : (L(), W("div", JEe, [
                      G("span", {
                        class: "text-p-xs text-ink-gray-4 w-full text-center px-2 mt-1",
                        title: he.file.name
                      }, ke(he.file.name), 9, QEe)
                    ]))
                  ], 64)) : ge("", !0)
                ], 42, WEe);
              }), 128))
            ], 4)) : ge("", !0),
            b.value && b.value.length ? (L(), W("div", iTe, " Upload more images by dropping them anywhere in this window. Reorder images by dragging them. Hover over an image to edit caption. ")) : (L(), W("div", aTe, [
              G("div", {
                class: "w-full flex flex-1 flex-col items-center justify-center border border-outline-gray-2 rounded-lg bg-surface-gray-1 h-full cursor-pointer transition hover:border-primary-400 hover:bg-primary-50 text-center",
                onClick: C,
                onDragover: oe[7] || (oe[7] = xt(() => {
                }, ["prevent"])),
                onDrop: xt(M, ["prevent"])
              }, [
                G("div", oTe, [
                  se(O(vP), { class: "size-6" })
                ]),
                oe[11] || (oe[11] = G("div", { class: "text-ink-gray-5 text-sm font-medium" }, " Drag & drop images here or click to select ", -1))
              ], 32)
            ])),
            f.value ? (L(), W("div", sTe, [
              G("div", lTe, " Uploading: " + ke(v.value) + "/" + ke(m.value), 1),
              G("div", uTe, [
                G("div", {
                  class: "bg-surface-gray-5 h-2 transition-all",
                  style: An({ width: h.value + "%" })
                }, null, 4)
              ]),
              g.value && g.value.some((he) => he) ? (L(), W("div", cTe, " Some files failed to upload. ")) : ge("", !0)
            ])) : ge("", !0)
          ])
        ]),
        actions: ee(() => [
          G("div", dTe, [
            se(fn, {
              variant: "ghost",
              disabled: f.value,
              onClick: w
            }, {
              default: ee(() => [...oe[12] || (oe[12] = [
                gn(" Cancel ", -1)
              ])]),
              _: 1
            }, 8, ["disabled"]),
            t.mode === "edit" ? (L(), re(fn, {
              key: 0,
              variant: "solid",
              loading: f.value,
              onClick: _
            }, {
              default: ee(() => [...oe[13] || (oe[13] = [
                gn(" Save ", -1)
              ])]),
              _: 1
            }, 8, ["loading"])) : ge("", !0),
            t.mode === "new" ? (L(), re(fn, {
              key: 1,
              variant: "solid",
              loading: f.value,
              onClick: x
            }, {
              default: ee(() => [...oe[14] || (oe[14] = [
                gn(" Upload ", -1)
              ])]),
              _: 1
            }, 8, ["loading"])) : ge("", !0)
          ])
        ]),
        _: 1
      }, 8, ["modelValue", "options"]),
      (L(), re(wg, { to: "body" }, [
        se(H_, {
          name: "fade",
          "enter-active-class": "transition-opacity duration-200",
          "leave-active-class": "transition-opacity duration-200",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: ee(() => [
            a.value ? (L(), W("div", fTe, [...oe[15] || (oe[15] = [
              G("div", { class: "text-ink-gray-1 text-base font-medium" }, " Drop images anywhere ", -1)
            ])])) : ge("", !0)
          ]),
          _: 1
        })
      ]))
    ], 64));
  }
}), hTe = { class: "w-full" }, vTe = {
  key: 0,
  class: "flex items-center mb-2 gap-2"
}, mTe = ["onClick"], gTe = ["src", "alt", "onClick"], yTe = ["src", "alt"], bTe = {
  key: 3,
  class: "absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/60 to-transparent rounded-b-[2px] opacity-0 group-hover:opacity-100 transition-opacity"
}, _Te = { class: "p-2" }, xTe = ["title"], wTe = /* @__PURE__ */ ve({
  __name: "ImageGroupNodeView",
  props: {
    decorations: {},
    selected: { type: Boolean },
    updateAttributes: { type: Function },
    deleteNode: { type: Function },
    node: {},
    view: {},
    getPos: { type: Function },
    innerDecorations: {},
    editor: {},
    extension: {},
    HTMLAttributes: {}
  },
  setup(n) {
    const e = n, t = K(() => e.node.attrs.columns || 4), r = K(() => e.node.content.content || []), i = K(() => ({
      gridTemplateColumns: `repeat(${t.value}, minmax(0, 1fr))`
    })), a = Z(e.editor.isEditable), o = [
      { label: "2 columns", value: "2" },
      { label: "3 columns", value: "3" },
      { label: "4 columns", value: "4" }
    ], s = K({
      get: () => String(t.value),
      set: (b) => e.updateAttributes({ columns: +b })
    }), l = Z(!1), u = Z(0), c = K(
      () => r.value.map((b) => ({
        src: b.attrs.src,
        alt: b.attrs.alt || ""
      }))
    ), d = Z(!1), f = Z([]), p = K(
      () => r.value.map((b) => ({
        src: b.attrs.src,
        alt: b.attrs.alt || ""
      }))
    );
    kt(() => {
      const b = () => {
        a.value = e.editor.isEditable;
      };
      e.editor.on("update", b), Nn(() => {
        e.editor.off("update", b);
      });
    });
    function h() {
      f.value = [], d.value = !0;
    }
    function v() {
      d.value = !1, f.value = [];
    }
    async function m(b) {
      e.editor.commands.command(({ tr: _, state: x }) => {
        const w = e.getPos();
        if (typeof w == "number") {
          const S = x.doc.nodeAt(w);
          if (S && S.type.name === "imageGroup") {
            const C = b.images.map(
              (D) => x.schema.nodes.image.create({ src: D.src, alt: D.alt })
            ), k = { ...S.attrs, columns: b.columns }, M = S.type.create(k, C);
            return _.replaceWith(w, w + S.nodeSize, M), !0;
          }
        }
        return !1;
      }), d.value = !1;
    }
    function g(b) {
      e.editor.isEditable || (u.value = b, l.value = !0);
    }
    function y(b) {
      const _ = r.value.slice();
      _.splice(b, 1), _.length === 0 ? e.editor.commands.deleteNode("imageGroup") : (e.updateAttributes({}), e.editor.commands.command(({ tr: x, state: w }) => {
        const S = e.getPos();
        if (typeof S == "number") {
          const C = w.doc.nodeAt(S);
          if (C && C.type.name === "imageGroup") {
            const k = _.map(
              (M) => w.schema.nodes.image.create(M.attrs)
            );
            return x.replaceWith(S + 1, S + 1 + C.content.size, k), !0;
          }
        }
        return !1;
      }));
    }
    return (b, _) => (L(), re(O(FM), null, {
      default: ee(() => [
        G("div", hTe, [
          a.value ? (L(), W("div", vTe, [
            se(fn, { onClick: h }, {
              prefix: ee(() => [
                se(O(FEe), { class: "size-4" })
              ]),
              default: ee(() => [
                _[3] || (_[3] = gn(" Edit ", -1))
              ]),
              _: 1
            }),
            se(oM, {
              options: o,
              modelValue: s.value,
              "onUpdate:modelValue": _[0] || (_[0] = (x) => s.value = x),
              size: "sm",
              variant: "subtle",
              class: "w-28"
            }, null, 8, ["modelValue"])
          ])) : ge("", !0),
          G("div", {
            class: "grid gap-px",
            style: An(i.value)
          }, [
            (L(!0), W(Ke, null, _t(r.value, (x, w) => (L(), W("div", {
              key: x.attrs.src + w,
              class: "relative aspect-square w-full h-full overflow-hidden bg-surface-white group"
            }, [
              a.value ? (L(), W("button", {
                key: 0,
                type: "button",
                class: "absolute top-1 right-1 z-10 bg-white/80 hover:bg-white rounded-full p-1 shadow transition-opacity opacity-0 group-hover:opacity-100 focus:opacity-100",
                "aria-label": "Remove image",
                onClick: xt((S) => y(w), ["stop"])
              }, [
                se(O(rh), { class: "w-4 h-4 text-gray-700" })
              ], 8, mTe)) : ge("", !0),
              a.value ? (L(), W("img", {
                key: 2,
                src: x.attrs.src,
                alt: x.attrs.alt || "",
                class: "object-cover w-full h-full not-prose rounded-[2px]"
              }, null, 8, yTe)) : (L(), W("img", {
                key: 1,
                src: x.attrs.src,
                alt: x.attrs.alt || "",
                class: "object-cover w-full h-full not-prose cursor-pointer rounded-[2px]",
                onClick: (S) => g(w)
              }, null, 8, gTe)),
              x.attrs.alt ? (L(), W("div", bTe, [
                G("div", _Te, [
                  G("div", {
                    class: "text-white text-xs truncate",
                    title: x.attrs.alt
                  }, ke(x.attrs.alt), 9, xTe)
                ])
              ])) : ge("", !0)
            ]))), 128))
          ], 4),
          l.value ? (L(), re(qH, {
            key: 1,
            show: l.value,
            "onUpdate:show": _[1] || (_[1] = (x) => l.value = x),
            images: c.value,
            initialIndex: u.value
          }, null, 8, ["show", "images", "initialIndex"])) : ge("", !0),
          d.value ? (L(), re(pTe, {
            key: 2,
            modelValue: d.value,
            "onUpdate:modelValue": _[2] || (_[2] = (x) => d.value = x),
            files: f.value,
            editor: e.editor,
            mode: "edit",
            existingImages: p.value,
            initialColumns: t.value,
            onClose: v,
            onSave: m
          }, null, 8, ["modelValue", "files", "editor", "existingImages", "initialColumns"])) : ge("", !0),
          ue(b.$slots, "default")
        ])
      ]),
      _: 3
    }));
  }
}), STe = pr.create({
  name: "imageGroup",
  group: "block",
  content: "image+",
  // one or more images
  selectable: !0,
  draggable: !0,
  isolating: !0,
  addOptions() {
    return {
      uploadFunction: null,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return {
      columns: {
        default: 4
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'div[data-type="image-group"]',
        getAttrs: (n) => {
          if (typeof n == "string") return {};
          const e = n;
          return {
            columns: e.getAttribute("data-columns") ? Number(e.getAttribute("data-columns")) : 4
          };
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: n, node: e }) {
    return [
      "div",
      Mn(
        {
          "data-type": "image-group",
          "data-columns": e.attrs.columns
        },
        this.options.HTMLAttributes,
        n
      ),
      0
      // content placeholder for child images
    ];
  },
  addNodeView() {
    return Ix(wTe);
  },
  addCommands() {
    return {
      setImageGroup: (n) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: {
          columns: n.columns || 4
        },
        content: n.images.map((t) => ({
          type: "image",
          attrs: t
        }))
      })
    };
  }
});
function ETe() {
  const n = Sr({
    uploading: !1,
    progress: 0,
    uploaded: 0,
    total: 0,
    error: null,
    result: null
  }), e = () => {
    n.uploading = !1, n.progress = 0, n.uploaded = 0, n.total = 0, n.error = null, n.result = null;
  }, t = K(() => n.uploading), r = K(() => n.progress), i = K(() => n.error), a = K(() => n.result);
  return {
    upload: (o, s = {}) => TTe(o, s, n, e),
    reset: e,
    state: n,
    isUploading: t,
    progress: r,
    error: i,
    result: a
  };
}
async function TTe(n, e = {}, t, r) {
  return r(), t.uploading = !0, new Promise((i, a) => {
    const o = new XMLHttpRequest();
    o.upload.addEventListener("loadstart", () => {
      t.uploading = !0, t.error = null;
    }), o.upload.addEventListener("progress", (u) => {
      u.lengthComputable && (t.uploaded = u.loaded, t.total = u.total, t.progress = Math.round(u.loaded / u.total * 100));
    }), o.upload.addEventListener("load", () => {
      t.progress = 100;
    }), o.addEventListener("error", (u) => {
      t.uploading = !1, t.error = "Upload failed", a("Upload failed");
    }), o.onreadystatechange = () => {
      if (o.readyState == XMLHttpRequest.DONE) {
        let u;
        if (o.status === 200) {
          let c = null;
          try {
            c = JSON.parse(o.responseText);
          } catch {
            c = o.responseText;
          }
          const d = c.message || c;
          t.result = d, i(d);
        } else if (o.status === 403)
          u = JSON.parse(o.responseText);
        else
          try {
            u = JSON.parse(o.responseText);
          } catch {
            u = "Upload failed";
          }
        if (u) {
          let c, d = [
            [u.exc_type, u._error_message].filter(Boolean).join(" ")
          ];
          if (u.exc) {
            c = u.exc;
            try {
              c = JSON.parse(c)[0], console.log(c);
            } catch {
            }
          }
          let f = new Error(d.join(`
`)), p = u._server_messages ? JSON.parse(u._server_messages) : [];
          p = p.map((h) => {
            try {
              return JSON.parse(h).message;
            } catch {
              return h;
            }
          }).filter(Boolean), p.length || (p = u._error_message ? [u._error_message] : ["Internal Server Error"]), f.message = p.join(`
`), t.error = f, a(f);
        }
        t.uploading = !1;
      }
    };
    const s = e.upload_endpoint || "/api/method/upload_file";
    o.open("POST", s, !0), o.setRequestHeader("Accept", "application/json"), window.csrf_token && window.csrf_token !== "{{ csrf_token }}" && o.setRequestHeader("X-Frappe-CSRF-Token", window.csrf_token);
    const l = new FormData();
    if (n && l.append("file", n, n.name), l.append("is_private", e.private ? "1" : "0"), l.append("folder", e.folder || "Home"), e.file_url && l.append("file_url", e.file_url), e.doctype && l.append("doctype", e.doctype), e.docname && l.append("docname", e.docname), e.fieldname && l.append("fieldname", e.fieldname), e.method && l.append("method", e.method), e.type && l.append("type", e.type), e.optimize && (l.append("optimize", "1"), e.max_width && l.append("max_width", e.max_width.toString()), e.max_height && l.append("max_height", e.max_height.toString())), e.params)
      for (let [u, c] of Object.entries(e.params))
        l.append(u, c);
    o.send(l);
  });
}
const BUe = /* @__PURE__ */ ve({
  inheritAttrs: !1,
  __name: "TextEditor",
  props: {
    content: { default: null },
    placeholder: { type: [String, Function], default: "" },
    editorClass: { default: "" },
    editable: { type: Boolean, default: !0 },
    bubbleMenu: { type: [Boolean, Array], default: !1 },
    bubbleMenuOptions: { default: () => ({}) },
    fixedMenu: { type: [Boolean, Array], default: !1 },
    floatingMenu: { type: [Boolean, Array], default: !1 },
    extensions: { default: () => [] },
    starterkitOptions: { default: () => ({}) },
    mentions: { default: null },
    tags: { default: () => [] },
    uploadFunction: {}
  },
  emits: ["change", "focus", "blur"],
  setup(n, { expose: e, emit: t }) {
    const r = E_e(kbe);
    function i(f) {
      return ETe().upload(f);
    }
    const a = n, o = t, s = Z(null), l = $d(), u = K(() => _e(l.class)), c = K(() => An(l.style)), d = K(() => ({
      attributes: {
        class: _e([
          "prose prose-table:table-fixed prose-td:p-2 prose-th:p-2 prose-td:border prose-th:border prose-td:border-outline-gray-2 prose-th:border-outline-gray-2 prose-td:relative prose-th:relative prose-th:bg-surface-gray-2",
          a.editorClass
        ])
      }
    }));
    return et(
      () => a.content,
      (f) => {
        s.value && s.value.getHTML() !== f && s.value.commands.setContent(f);
      }
    ), et(
      () => a.editable,
      (f) => {
        s.value && s.value.setEditable(f);
      }
    ), et(
      d,
      (f) => {
        s.value && s.value.setOptions({
          editorProps: f
        });
      },
      { deep: !0 }
    ), kt(() => {
      var f;
      s.value = new Lve({
        content: a.content || null,
        editorProps: d.value,
        editable: a.editable,
        autofocus: a.autofocus,
        extensions: [
          Rme.configure({
            ...a.starterkitOptions,
            codeBlock: !1,
            heading: !1
          }),
          BEe.configure({
            ...typeof ((f = a.starterkitOptions) == null ? void 0 : f.heading) == "object" && a.starterkitOptions.heading !== null ? a.starterkitOptions.heading : {}
          }),
          zge.configure({
            resizable: !0
          }),
          n1e,
          t1e.configure({
            nested: !0
          }),
          Hge,
          Vge,
          Fge,
          Z0e,
          jme.configure({
            types: ["heading", "paragraph"]
          }),
          Q0e,
          a1e,
          o1e,
          Exe.extend({
            addNodeView() {
              return Ix(Mxe);
            }
          }).configure({ lowlight: r }),
          pye.configure({
            uploadFunction: a.uploadFunction || i
          }),
          STe.configure({
            uploadFunction: a.uploadFunction || i
          }),
          qye,
          Kye.configure({
            uploadFunction: a.uploadFunction || i
          }),
          C0e.configure({
            openOnClick: !1
          }),
          Pme.configure({
            placeholder: typeof a.placeholder == "function" ? a.placeholder : () => a.placeholder
          }),
          a.mentions && jxe.configure(
            Array.isArray(a.mentions) ? { mentions: a.mentions } : {
              mentions: a.mentions.mentions,
              component: a.mentions.component
            }
          ),
          p2e,
          Z2e,
          u9,
          jEe.configure({
            tags: () => a.tags
          }),
          PEe.configure({
            enabled: !0,
            showConfirmation: !0,
            uploadFunction: a.uploadFunction || i
          }),
          ...a.extensions || []
        ],
        onUpdate: ({ editor: p }) => {
          o("change", p.getHTML());
        },
        onFocus: ({ editor: p, event: h }) => {
          o("focus", h);
        },
        onBlur: ({ editor: p, event: h }) => {
          o("blur", h);
        }
      });
    }), Io(() => {
      s.value && (s.value.destroy(), s.value = null);
    }), zn(
      "editor",
      K(() => s.value)
    ), e({
      editor: s
    }), (f, p) => s.value ? (L(), W("div", {
      key: 0,
      class: _e(["relative w-full", u.value]),
      style: An(c.value)
    }, [
      se(r2e, {
        buttons: f.bubbleMenu,
        options: f.bubbleMenuOptions
      }, null, 8, ["buttons", "options"]),
      se(e2e, {
        class: "w-full overflow-x-auto rounded-t-lg border border-outline-gray-modals",
        buttons: f.fixedMenu
      }, null, 8, ["buttons"]),
      se(l2e, { buttons: f.floatingMenu }, null, 8, ["buttons"]),
      ue(f.$slots, "top", { editor: s.value }),
      ue(f.$slots, "editor", { editor: s.value }, () => [
        se(O(Nve), { editor: s.value }, null, 8, ["editor"])
      ]),
      ue(f.$slots, "bottom", { editor: s.value })
    ], 6)) : ge("", !0);
  }
}), CTe = { class: "flex h-full w-full flex-col items-center justify-center text-base" }, kTe = { class: "text-xl font-medium" }, ATe = { class: "mt-1 text-base text-ink-gray-5" }, MTe = {
  __name: "ListEmptyState",
  setup(n) {
    const e = Xt("list");
    return (t, r) => (L(), W("div", CTe, [
      ue(t.$slots, "default", {}, () => [
        G("div", kTe, ke(O(e).options.emptyState.title), 1),
        G("div", ATe, ke(O(e).options.emptyState.description), 1),
        O(e).options.emptyState.button ? (L(), re(O(fn), He({ key: 0 }, O(e).options.emptyState.button, { class: "mt-4" }), null, 16)) : ge("", !0)
      ])
    ]));
  }
};
function c9(n, e = !0) {
  let t = e ? "14px " : "", r = n.map((i) => {
    let a = i.width || 1;
    return typeof a == "number" ? a + "fr" : a;
  }).join(" ");
  return t + r;
}
const mD = {
  left: "justify-start",
  start: "justify-start",
  center: "justify-center",
  middle: "justify-center",
  right: "justify-end",
  end: "justify-end"
}, DTe = { class: "truncate" }, OTe = {
  __name: "ListHeaderItem",
  props: {
    item: {
      type: Object,
      required: !0
    },
    debounce: {
      type: Number,
      default: 1e3
    }
  },
  emits: ["columnWidthUpdated"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = Z(null), a = Z(null), o = K(() => {
      if (typeof t.item.width == "string") {
        const c = parseInt(t.item.width);
        if (t.item.width.includes("rem"))
          return c * 16;
        if (t.item.width.includes("px"))
          return c;
      }
      return a.value.offsetWidth;
    }), s = (c) => {
      const d = c.clientX, f = o.value, p = (v) => {
        document.body.classList.add("select-none"), document.body.classList.add("cursor-col-resize"), i.value.style.backgroundColor = "rgb(199 199 199)";
        let m = f + (v.clientX - d);
        t.item.width = `${m < 50 ? 50 : m}px`, l(t.item.width);
      }, h = () => {
        document.body.classList.remove("select-none"), document.body.classList.remove("cursor-col-resize"), i.value.style.backgroundColor = "", window.removeEventListener("mousemove", p), window.removeEventListener("mouseup", h);
      };
      window.addEventListener("mousemove", p), window.addEventListener("mouseup", h);
    }, l = Sae((c) => {
      t.item.width = c, r("columnWidthUpdated");
    }, t.debounce), u = Xt("list");
    return (c, d) => (L(), W("div", {
      ref_key: "columnRef",
      ref: a,
      class: _e(["group relative flex items-center", n.item.align ? O(mD)[n.item.align] : "justify-between"])
    }, [
      G("div", {
        class: _e(["flex items-center space-x-2 truncate text-sm text-ink-gray-5", c.$attrs.class])
      }, [
        ue(c.$slots, "prefix", Bt(Jt({ item: n.item }))),
        ue(c.$slots, "default", {}, () => [
          G("div", DTe, ke(n.item.label), 1)
        ]),
        ue(c.$slots, "suffix", Bt(Jt({ item: n.item })))
      ], 2),
      O(u).options.resizeColumn ? ue(c.$slots, "resizer", Bt(He({ key: 0 }, { item: n.item })), () => [
        G("div", {
          class: "flex h-4 absolute -right-2 w-2 cursor-col-resize justify-center",
          onMousedown: s
        }, [
          G("div", {
            ref_key: "resizer",
            ref: i,
            class: "h-full w-[2px] rounded-full transition-all duration-300 ease-in-out group-hover:bg-gray-400"
          }, null, 512)
        ], 32)
      ]) : ge("", !0)
    ], 2));
  }
}, ITe = {
  __name: "ListHeader",
  emits: ["columnWidthUpdated"],
  setup(n, { emit: e }) {
    const t = e, r = Xt("list");
    return (i, a) => (L(), W("div", {
      class: "mb-2 grid items-center space-x-4 rounded bg-surface-gray-2 p-2",
      style: An({
        gridTemplateColumns: O(c9)(
          O(r).columns,
          O(r).options.selectable
        )
      })
    }, [
      O(r).options.selectable ? (L(), re(ux, {
        key: 0,
        class: "cursor-pointer duration-300",
        modelValue: O(r).allRowsSelected,
        onClick: xt(O(r).toggleAllRows, ["stop"])
      }, null, 8, ["modelValue", "onClick"])) : ge("", !0),
      ue(i.$slots, "default", {}, () => [
        (L(!0), W(Ke, null, _t(O(r).columns, (o) => (L(), re(OTe, {
          key: o.key,
          item: o,
          onColumnWidthUpdated: (s) => t("columnWidthUpdated", o)
        }, null, 8, ["item", "onColumnWidthUpdated"]))), 128))
      ])
    ], 4));
  }
}, LTe = { class: "truncate text-base" }, NTe = {
  __name: "ListRowItem",
  props: {
    column: {
      type: Object,
      default: {}
    },
    row: {
      type: Object,
      default: {}
    },
    item: {
      type: [String, Number, Object],
      default: ""
    },
    align: {
      type: String,
      default: "left"
    }
  },
  setup(n) {
    const e = n, t = K(() => {
      var o, s;
      return (o = e.column) != null && o.getLabel ? (s = e.column) == null ? void 0 : s.getLabel({ row: e.row }) : i(e.item).label || "";
    }), r = K(() => a.value.options.showTooltip ? e.column.getTooltip ? e.column.getTooltip(e.row) : i(e.item).label : "");
    function i(o) {
      return o && typeof o == "object" ? o : { label: o };
    }
    const a = Xt("list");
    return (o, s) => (L(), W("div", {
      class: _e(["flex items-center space-x-2", O(mD)[n.align]])
    }, [
      ue(o.$slots, "prefix", {}, () => [
        n.column.prefix ? (L(), re(bn(
          typeof n.column.prefix == "function" ? n.column.prefix({ row: n.row }) : n.column.prefix
        ), { key: 0 })) : ge("", !0)
      ]),
      se(O(Ei), Bt(Jt(
        O(a).options.showTooltip ? {
          text: r.value
        } : { text: "" }
      )), {
        default: ee(() => [
          ue(o.$slots, "default", Bt(Jt({ label: t.value })), () => [
            G("div", LTe, ke(t.value), 1)
          ])
        ]),
        _: 3
      }, 16),
      ue(o.$slots, "suffix")
    ], 2));
  }
}, d9 = {
  __name: "ListRow",
  props: {
    row: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = n, t = Xt("list"), r = K(() => {
      var c;
      return (c = t.value.rows) != null && c.length ? t.value.rows[t.value.rows.length - 1][t.value.rowKey] === e.row[t.value.rowKey] : !1;
    }), i = K(() => t.value.selections.has(e.row[t.value.rowKey])), a = K(
      () => t.value.options.enableActive && t.value.activeRow.value === e.row.name
    ), o = K(() => t.value.options.getRowRoute || t.value.options.onRowClick), s = K(() => typeof t.value.options.rowHeight == "number" ? `${t.value.options.rowHeight}px` : t.value.options.rowHeight), l = K(() => {
      var f, p, h;
      if (!i.value) return "rounded";
      const c = [...t.value.selections];
      let d = (f = t.value.rows[0]) != null && f.group ? t.value.rows.map((v) => v.rows) : [t.value.rows];
      for (let v of d) {
        let m = v.findIndex((b) => b == e.row);
        if (m === -1) continue;
        let g = !c.includes((p = v[m + 1]) == null ? void 0 : p.name), y = !c.includes((h = v[m - 1]) == null ? void 0 : h.name);
        return (g ? "rounded-b " : "") + (y ? "rounded-t" : "");
      }
    }), u = (c, d) => {
      t.value.options.onRowClick && t.value.options.onRowClick(c, d), t.value.activeRow.value === c.name ? t.value.activeRow.value = null : t.value.activeRow.value = c.name;
    };
    return (c, d) => (L(), re(bn(O(t).options.getRowRoute ? "router-link" : "div"), He({
      class: [[
        l.value,
        i.value || a.value ? "bg-surface-gray-2" : "",
        o.value ? "cursor-pointer" : "",
        o.value ? i.value || a.value ? "hover:bg-surface-gray-3" : "hover:bg-surface-menu-bar" : ""
      ], "flex flex-col transition-all duration-300 ease-in-out"]
    }, {
      to: O(t).options.getRowRoute ? O(t).options.getRowRoute(n.row) : void 0,
      onClick: (f) => u(n.row, f)
    }), {
      default: ee(() => [
        (L(), re(bn(O(t).options.getRowRoute ? "template" : "button"), { class: "[all:unset] hover:[all:unset]" }, {
          default: ee(() => {
            var f, p;
            return [
              G("div", {
                class: "grid items-center space-x-4 px-2",
                style: An({
                  height: s.value,
                  gridTemplateColumns: O(c9)(
                    O(t).columns,
                    O(t).options.selectable
                  )
                })
              }, [
                O(t).options.selectable ? (L(), W("div", {
                  key: 0,
                  class: "w-fit pr-2 py-3 flex",
                  onClick: d[1] || (d[1] = xt(() => {
                  }, ["stop", "prevent"])),
                  onDblclick: d[2] || (d[2] = xt(() => {
                  }, ["stop"]))
                }, [
                  se(ux, {
                    modelValue: i.value,
                    class: "cursor-pointer duration-300",
                    onClick: d[0] || (d[0] = xt((h) => O(t).toggleRow(n.row[O(t).rowKey]), ["stop"]))
                  }, null, 8, ["modelValue"])
                ], 32)) : ge("", !0),
                (L(!0), W(Ke, null, _t(O(t).columns, (h, v) => (L(), W("div", {
                  key: h.key,
                  class: _e([
                    O(mD)[h.align],
                    v == 0 ? "text-ink-gray-9" : "text-ink-gray-7"
                  ])
                }, [
                  ue(c.$slots, "default", He({ ref_for: !0 }, { idx: v, column: h, item: n.row[h.key], isActive: a.value }), () => [
                    O(t).slots.cell ? (L(), re(bn(O(t).slots.cell), He({
                      key: 0,
                      ref_for: !0
                    }, {
                      column: h,
                      row: n.row,
                      item: n.row[h.key],
                      align: h.align
                    }), null, 16)) : (L(), re(NTe, {
                      key: 1,
                      column: h,
                      row: n.row,
                      item: n.row[h.key],
                      align: h.align
                    }, null, 8, ["column", "row", "item", "align"]))
                  ])
                ], 2))), 128))
              ], 4),
              r.value ? ge("", !0) : (L(), W("div", {
                key: 0,
                class: _e([
                  "h-px border-t",
                  l.value === "rounded" || (p = (f = l.value) == null ? void 0 : f.includes) != null && p.call(f, "rounded-b") ? "mx-2 border-outline-gray-1" : "border-t-[--surface-gray-2]"
                ])
              }, null, 2))
            ];
          }),
          _: 3
        }))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}, RTe = { class: "h-full overflow-y-auto" }, PTe = {
  __name: "ListRows",
  setup(n) {
    const e = Xt("list");
    return (t, r) => (L(), W("div", RTe, [
      ue(t.$slots, "default", {}, () => [
        (L(!0), W(Ke, null, _t(O(e).rows, (i) => (L(), re(d9, {
          key: i[O(e).rowKey],
          row: i
        }, null, 8, ["row"]))), 128))
      ])
    ]));
  }
}, jTe = {}, BTe = {
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 16 16"
};
function $Te(n, e) {
  return L(), W("svg", BTe, [...e[0] || (e[0] = [
    G("path", {
      fill: "currentColor",
      d: "M4.293 5.28h7.413a.5.5 0 0 1 .41.787l-3.707 5.295a.5.5 0 0 1-.82 0L3.884 6.067a.5.5 0 0 1 .41-.787Z"
    }, null, -1)
  ])]);
}
const zTe = /* @__PURE__ */ zt(jTe, [["render", $Te]]), FTe = { class: "flex items-center" }, VTe = { class: "w-full py-1.5 pr-2" }, HTe = {
  key: 1,
  class: "text-base font-medium leading-6"
}, GTe = {
  __name: "ListGroupHeader",
  props: {
    group: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = n, t = Xt("list");
    function r() {
      e.group.collapsed == null && (e.group.collapsed = !1), e.group.collapsed = !e.group.collapsed;
    }
    return (i, a) => (L(), W(Ke, null, [
      G("div", FTe, [
        G("button", {
          onClick: r,
          class: "ml-[3px] mr-[11px] rounded p-1 hover:bg-surface-gray-2"
        }, [
          se(zTe, {
            class: _e(["h-4 w-4 text-ink-gray-6 transition-transform duration-200", [n.group.collapsed ? "-rotate-90" : ""]])
          }, null, 8, ["class"])
        ]),
        ue(i.$slots, "default", {}, () => [
          G("div", VTe, [
            O(t).slots["group-header"] ? (L(), re(bn(O(t).slots["group-header"]), Bt(He({ key: 0 }, { group: n.group })), null, 16)) : (L(), W("span", HTe, ke(n.group.group), 1))
          ])
        ])
      ]),
      a[0] || (a[0] = G("div", { class: "mx-2 h-px border-t border-outline-gray-modals" }, null, -1))
    ], 64));
  }
}, UTe = {
  key: 0,
  class: "mb-5 mt-2"
}, WTe = {
  __name: "ListGroupRows",
  props: {
    group: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = Xt("list");
    return (t, r) => n.group.collapsed ? ge("", !0) : (L(), W("div", UTe, [
      ue(t.$slots, "default", {}, () => [
        (L(!0), W(Ke, null, _t(n.group.rows, (i) => (L(), re(d9, {
          key: i[O(e).rowKey],
          row: i
        }, null, 8, ["row"]))), 128))
      ])
    ]));
  }
}, qTe = { class: "h-full overflow-y-auto" }, YTe = {
  __name: "ListGroups",
  setup(n) {
    const e = Xt("list");
    return (t, r) => (L(), W("div", qTe, [
      (L(!0), W(Ke, null, _t(O(e).rows, (i) => (L(), W("div", {
        key: i.group
      }, [
        ue(t.$slots, "default", {}, () => [
          se(GTe, { group: i }, {
            default: ee(() => [
              t.$slots["group-header"] ? ue(t.$slots, "group-header", He({
                key: 0,
                ref_for: !0
              }, { group: i })) : ge("", !0)
            ]),
            _: 2
          }, 1032, ["group"]),
          se(WTe, { group: i }, null, 8, ["group"])
        ])
      ]))), 128))
    ]));
  }
}, KTe = {
  key: 0,
  class: "absolute inset-x-0 bottom-6 mx-auto w-max text-base"
}, XTe = { class: "flex flex-1 justify-between border-r border-outline-gray-2 text-ink-gray-9" }, ZTe = { class: "flex items-center space-x-3" }, JTe = { class: "mr-3" }, QTe = { class: "flex items-center space-x-1" }, eCe = /* @__PURE__ */ Object.assign({
  inheritAttrs: !1
}, {
  __name: "ListSelectBanner",
  setup(n) {
    const e = Xt("list");
    let t = K(() => e.value.options.selectionText(e.value.selections.size));
    return (r, i) => (L(), re(H_, {
      "enter-active-class": "duration-300 ease-out",
      "enter-from-class": "transform opacity-0",
      "enter-to-class": "opacity-100",
      "leave-active-class": "duration-300 ease-in",
      "leave-from-class": "opacity-100",
      "leave-to-class": "transform opacity-0"
    }, {
      default: ee(() => [
        O(e).selections.size ? (L(), W("div", KTe, [
          G("div", {
            class: _e(["flex min-w-[596px] items-center space-x-3 rounded-lg bg-surface-white px-4 py-2 shadow-2xl", r.$attrs.class])
          }, [
            ue(r.$slots, "default", Bt(Jt({
              selections: O(e).selections,
              allRowsSelected: O(e).allRowsSelected,
              selectAll: () => O(e).toggleAllRows(!0),
              unselectAll: () => O(e).toggleAllRows(!1)
            })), () => [
              G("div", XTe, [
                G("div", ZTe, [
                  se(ux, {
                    modelValue: !0,
                    disabled: !0,
                    class: "text-ink-gray-9"
                  }),
                  G("div", null, ke(O(t)), 1)
                ]),
                G("div", JTe, [
                  ue(r.$slots, "actions", Bt(Jt({
                    selections: O(e).selections,
                    allRowsSelected: O(e).allRowsSelected,
                    selectAll: () => O(e).toggleAllRows(!0),
                    unselectAll: () => O(e).toggleAllRows(!1)
                  })))
                ])
              ]),
              G("div", QTe, [
                se(O(fn), {
                  class: _e(["w- text-ink-gray-7", O(e).allRowsSelected ? "cursor-not-allowed" : ""]),
                  disabled: O(e).allRowsSelected,
                  variant: "ghost",
                  onClick: i[0] || (i[0] = (a) => O(e).toggleAllRows(!0))
                }, {
                  default: ee(() => [...i[2] || (i[2] = [
                    gn(" Select all ", -1)
                  ])]),
                  _: 1
                }, 8, ["disabled", "class"]),
                se(O(fn), {
                  icon: "x",
                  variant: "ghost",
                  onClick: i[1] || (i[1] = (a) => O(e).toggleAllRows(!1))
                })
              ])
            ])
          ], 2)
        ])) : ge("", !0)
      ]),
      _: 3
    }));
  }
}), tCe = { class: "relative flex w-full flex-1 flex-col overflow-x-auto" }, $Ue = /* @__PURE__ */ Object.assign({
  inheritAttrs: !1
}, {
  __name: "ListView",
  props: {
    columns: {
      type: Array,
      default: []
    },
    rows: {
      type: Array,
      default: []
    },
    rowKey: {
      type: String,
      required: !0
    },
    options: {
      type: Object,
      default: () => ({
        getRowRoute: null,
        onRowClick: null,
        showTooltip: !0,
        selectable: !0,
        resizeColumn: !1,
        rowHeight: 40,
        emptyState: {
          title: "No Data",
          description: "No data available"
        }
      })
    }
  },
  emits: ["update:selections", "update:active-row"],
  setup(n, { expose: e, emit: t }) {
    const r = n, i = Xp();
    let a = Sr(/* @__PURE__ */ new Set()), o = Z(null);
    const s = t;
    et(a, (h) => {
      a.size && (o.value = null), s("update:selections", h);
    }), et(o, (h) => {
      s("update:active-row", h);
    });
    let l = K(() => {
      function h(m) {
        return m === void 0 ? !0 : m;
      }
      function v(m) {
        return m === void 0 ? !1 : m;
      }
      return {
        getRowRoute: r.options.getRowRoute || null,
        onRowClick: r.options.onRowClick || null,
        showTooltip: h(r.options.showTooltip),
        selectionText: r.options.selectionText || ((m) => m === 1 ? "1 row selected" : `${m} rows selected`),
        enableActive: v(r.options.enableActive),
        selectable: h(r.options.selectable),
        resizeColumn: v(r.options.resizeColumn),
        rowHeight: r.options.rowHeight || 40,
        emptyState: r.options.emptyState
      };
    });
    const u = K(() => r.rows.length ? d.value ? a.size === r.rows.reduce((h, v) => h + v.rows.length, 0) : a.size === r.rows.length : !1), c = K(() => l.value.selectable);
    let d = K(() => r.rows.every(
      (h) => h.group && h.rows && Array.isArray(h.rows)
    ));
    function f(h) {
      a.delete(h) || a.add(h);
    }
    function p(h) {
      if (!h || u.value) {
        a.clear();
        return;
      }
      if (d.value) {
        r.rows.forEach((v) => {
          v.rows.forEach((m) => a.add(m[r.rowKey]));
        });
        return;
      }
      r.rows.forEach((v) => a.add(v[r.rowKey]));
    }
    return zn(
      "list",
      K(() => ({
        rowKey: r.rowKey,
        rows: r.rows,
        columns: r.columns,
        options: l.value,
        selections: a,
        activeRow: o,
        allRowsSelected: u.value,
        slots: i,
        toggleRow: f,
        toggleAllRows: p
      }))
    ), e({
      selections: a,
      allRowsSelected: u,
      toggleRow: f,
      toggleAllRows: p
    }), (h, v) => (L(), W("div", tCe, [
      G("div", {
        class: _e(["flex w-max min-w-full flex-col overflow-y-hidden", h.$attrs.class]),
        style: An(h.$attrs.style)
      }, [
        ue(h.$slots, "default", Bt(Jt({ showGroupedRows: O(d), selectable: c.value })), () => [
          se(ITe),
          r.rows.length ? (L(), W(Ke, { key: 0 }, [
            O(d) ? (L(), re(YTe, { key: 0 })) : (L(), re(PTe, { key: 1 }))
          ], 64)) : (L(), re(MTe, { key: 1 })),
          c.value ? (L(), re(eCe, { key: 2 })) : ge("", !0)
        ])
      ], 6)
    ]));
  }
}), nCe = { class: "flex justify-between gap-2" }, rCe = { class: "flex items-center" }, iCe = {
  key: 1,
  class: "mx-3 h-[80%] border-l"
}, aCe = { class: "flex items-center gap-1 text-base text-ink-gray-5" }, zUe = {
  __name: "ListFooter",
  props: {
    modelValue: {
      type: Number,
      default: 20
    },
    options: {
      type: Object,
      default: () => ({
        rowCount: 0,
        totalCount: 0,
        pageLengthOptions: [20, 50, 100]
      })
    }
  },
  emits: ["update:modelValue", "loadMore"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = K({
      get: () => t.modelValue,
      set: (s) => r("update:modelValue", s)
    }), a = Z(t.options.pageLengthOptions || [20, 50, 100]), o = K(() => t.options.rowCount && t.options.totalCount && t.options.rowCount < t.options.totalCount);
    return (s, l) => {
      const u = fn;
      return L(), W("div", nCe, [
        ue(s.$slots, "default", {}, () => [
          ue(s.$slots, "left", {}, () => [
            se(p6, {
              modelValue: i.value,
              "onUpdate:modelValue": l[0] || (l[0] = (c) => i.value = c),
              buttons: a.value.map((c) => ({ label: c, value: c }))
            }, null, 8, ["modelValue", "buttons"])
          ]),
          ue(s.$slots, "right", {}, () => [
            G("div", rCe, [
              o.value ? (L(), re(u, {
                key: 0,
                label: "Load More",
                onClick: l[1] || (l[1] = (c) => r("loadMore"))
              })) : ge("", !0),
              o.value ? (L(), W("div", iCe)) : ge("", !0),
              G("div", aCe, [
                G("div", null, ke(n.options.rowCount || "0"), 1),
                l[2] || (l[2] = G("div", null, "of", -1)),
                G("div", null, ke(n.options.totalCount || "0"), 1)
              ])
            ])
          ])
        ])
      ]);
    };
  }
}, oCe = {
  class: "lucide lucide-info",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function sCe(n, e) {
  return L(), W("svg", oCe, [...e[0] || (e[0] = [
    G("circle", {
      cx: "12",
      cy: "12",
      r: "10"
    }, null, -1),
    G("path", { d: "M12 16v-4" }, null, -1),
    G("path", { d: "M12 8h.01" }, null, -1)
  ])]);
}
const lCe = cn({ name: "lucide-info", render: sCe }), uCe = {
  class: "lucide lucide-triangle-alert",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function cCe(n, e) {
  return L(), W("svg", uCe, [...e[0] || (e[0] = [
    G("path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3" }, null, -1),
    G("path", { d: "M12 9v4" }, null, -1),
    G("path", { d: "M12 17h.01" }, null, -1)
  ])]);
}
const dCe = cn({ name: "lucide-alert-triangle", render: cCe }), fCe = {}, pCe = {
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 16 16"
};
function hCe(n, e) {
  return L(), W("svg", pCe, [...e[0] || (e[0] = [
    G("path", {
      fill: "currentColor",
      d: "M8 .75a7.25 7.25 0 1 1 0 14.5A7.25 7.25 0 0 1 8 .75Zm0 1a6.25 6.25 0 1 0 0 12.5 6.25 6.25 0 0 0 0-12.5Zm2.59 3.527a.501.501 0 0 1 .758.623l-.057.085-3.848 4.666a.501.501 0 0 1-.78-.011L4.936 8.41l-.053-.086a.501.501 0 0 1 .775-.6l.07.074 1.34 1.733 3.45-4.183.072-.072Z"
    }, null, -1)
  ])]);
}
const vCe = /* @__PURE__ */ zt(fCe, [["render", hCe]]), mCe = { class: "flex items-center gap-2 flex-grow overflow-hidden" }, gCe = { class: "flex flex-col flex-grow overflow-hidden" }, yCe = { class: "flex items-center gap-2 h-7" }, bCe = /* @__PURE__ */ ve({
  __name: "Toast",
  props: {
    open: { type: Boolean },
    message: {},
    type: {},
    duration: {},
    icon: {},
    closable: { type: Boolean },
    action: {}
  },
  emits: ["update:open", "action"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = K({
      get: () => t.open,
      set: (o) => r("update:open", o)
    });
    function a() {
      var o, s;
      (s = (o = t.action) == null ? void 0 : o.onClick) == null || s.call(o), r("action");
    }
    return (o, s) => (L(), re(O(Tie), {
      open: i.value,
      "onUpdate:open": s[0] || (s[0] = (l) => i.value = l),
      duration: o.closable ? o.duration : 0,
      class: _e([
        "toast-root-animatable",
        "bg-surface-gray-6 border-none rounded-md px-4 py-1.5 shadow-lg flex items-center justify-between gap-3 min-w-[280px] max-w-[400px] pointer-events-auto list-none"
      ])
    }, {
      default: ee(() => [
        G("div", mCe, [
          G("div", null, [
            o.icon ? (L(), re(bn(o.icon), {
              key: 0,
              class: "flex-shrink-0 size-4"
            })) : o.type == "success" ? (L(), re(vCe, {
              key: 1,
              class: "flex-shrink-0 size-4 text-ink-green-2"
            })) : o.type == "warning" ? (L(), re(O(dCe), {
              key: 2,
              class: "flex-shrink-0 size-4 text-ink-amber-2"
            })) : o.type == "error" ? (L(), re(O(lCe), {
              key: 3,
              class: "flex-shrink-0 size-4 text-ink-red-2"
            })) : ge("", !0)
          ]),
          G("div", gCe, [
            o.message ? (L(), re(O(Sie), {
              key: 0,
              class: "text-p-sm break-words text-ink-white",
              innerHTML: o.message
            }, null, 8, ["innerHTML"])) : ge("", !0)
          ])
        ]),
        G("div", yCe, [
          o.action ? (L(), re(O(xie), {
            key: 0,
            class: "flex-shrink-0 rounded px-2 py-1 text-sm text-ink-blue-link hover:text-ink-gray-3 focus:outline-none focus-visible:ring focus-visible:ring-outline-gray-4",
            "alt-text": o.action.altText || o.action.label,
            onClick: a
          }, {
            default: ee(() => [
              gn(ke(o.action.label), 1)
            ]),
            _: 1
          }, 8, ["alt-text"])) : ge("", !0),
          o.closable ? (L(), re(O(HV), {
            key: 1,
            class: "flex-shrink-0 rounded p-1 text-ink-white hover:text-ink-gray-3 focus:outline-none focus-visible:ring focus-visible:ring-outline-gray-4"
          }, {
            default: ee(() => [
              se(O(rh), { class: "size-4" })
            ]),
            _: 1
          })) : ge("", !0)
        ])
      ]),
      _: 1
    }, 8, ["open", "duration"]));
  }
});
/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */
const {
  entries: f9,
  setPrototypeOf: mP,
  isFrozen: _Ce,
  getPrototypeOf: xCe,
  getOwnPropertyDescriptor: wCe
} = Object;
let {
  freeze: Pi,
  seal: to,
  create: p9
} = Object, {
  apply: MC,
  construct: DC
} = typeof Reflect < "u" && Reflect;
Pi || (Pi = function(e) {
  return e;
});
to || (to = function(e) {
  return e;
});
MC || (MC = function(e, t, r) {
  return e.apply(t, r);
});
DC || (DC = function(e, t) {
  return new e(...t);
});
const Ky = ji(Array.prototype.forEach), SCe = ji(Array.prototype.lastIndexOf), gP = ji(Array.prototype.pop), Fh = ji(Array.prototype.push), ECe = ji(Array.prototype.splice), p1 = ji(String.prototype.toLowerCase), RS = ji(String.prototype.toString), yP = ji(String.prototype.match), Vh = ji(String.prototype.replace), TCe = ji(String.prototype.indexOf), CCe = ji(String.prototype.trim), po = ji(Object.prototype.hasOwnProperty), bi = ji(RegExp.prototype.test), Hh = kCe(TypeError);
function ji(n) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      r[i - 1] = arguments[i];
    return MC(n, e, r);
  };
}
function kCe(n) {
  return function() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return DC(n, t);
  };
}
function dn(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : p1;
  mP && mP(n, null);
  let r = e.length;
  for (; r--; ) {
    let i = e[r];
    if (typeof i == "string") {
      const a = t(i);
      a !== i && (_Ce(e) || (e[r] = a), i = a);
    }
    n[i] = !0;
  }
  return n;
}
function ACe(n) {
  for (let e = 0; e < n.length; e++)
    po(n, e) || (n[e] = null);
  return n;
}
function Gs(n) {
  const e = p9(null);
  for (const [t, r] of f9(n))
    po(n, t) && (Array.isArray(r) ? e[t] = ACe(r) : r && typeof r == "object" && r.constructor === Object ? e[t] = Gs(r) : e[t] = r);
  return e;
}
function Gh(n, e) {
  for (; n !== null; ) {
    const r = wCe(n, e);
    if (r) {
      if (r.get)
        return ji(r.get);
      if (typeof r.value == "function")
        return ji(r.value);
    }
    n = xCe(n);
  }
  function t() {
    return null;
  }
  return t;
}
const bP = Pi(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), PS = Pi(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), jS = Pi(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), MCe = Pi(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), BS = Pi(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), DCe = Pi(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), _P = Pi(["#text"]), xP = Pi(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), $S = Pi(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), wP = Pi(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Xy = Pi(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), OCe = to(/\{\{[\w\W]*|[\w\W]*\}\}/gm), ICe = to(/<%[\w\W]*|[\w\W]*%>/gm), LCe = to(/\$\{[\w\W]*/gm), NCe = to(/^data-[\-\w.\u00B7-\uFFFF]+$/), RCe = to(/^aria-[\-\w]+$/), h9 = to(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), PCe = to(/^(?:\w+script|data):/i), jCe = to(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), v9 = to(/^html$/i), BCe = to(/^[a-z][.\w]*(-[.\w]+)+$/i);
var SP = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: RCe,
  ATTR_WHITESPACE: jCe,
  CUSTOM_ELEMENT: BCe,
  DATA_ATTR: NCe,
  DOCTYPE_NAME: v9,
  ERB_EXPR: ICe,
  IS_ALLOWED_URI: h9,
  IS_SCRIPT_OR_DATA: PCe,
  MUSTACHE_EXPR: OCe,
  TMPLIT_EXPR: LCe
});
const Uh = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, $Ce = function() {
  return typeof window > "u" ? null : window;
}, zCe = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let r = null;
  const i = "data-tt-policy-suffix";
  t && t.hasAttribute(i) && (r = t.getAttribute(i));
  const a = "dompurify" + (r ? "#" + r : "");
  try {
    return e.createPolicy(a, {
      createHTML(o) {
        return o;
      },
      createScriptURL(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + a + " could not be created."), null;
  }
}, EP = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function m9() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : $Ce();
  const e = (St) => m9(St);
  if (e.version = "3.2.6", e.removed = [], !n || !n.document || n.document.nodeType !== Uh.document || !n.Element)
    return e.isSupported = !1, e;
  let {
    document: t
  } = n;
  const r = t, i = r.currentScript, {
    DocumentFragment: a,
    HTMLTemplateElement: o,
    Node: s,
    Element: l,
    NodeFilter: u,
    NamedNodeMap: c = n.NamedNodeMap || n.MozNamedAttrMap,
    HTMLFormElement: d,
    DOMParser: f,
    trustedTypes: p
  } = n, h = l.prototype, v = Gh(h, "cloneNode"), m = Gh(h, "remove"), g = Gh(h, "nextSibling"), y = Gh(h, "childNodes"), b = Gh(h, "parentNode");
  if (typeof o == "function") {
    const St = t.createElement("template");
    St.content && St.content.ownerDocument && (t = St.content.ownerDocument);
  }
  let _, x = "";
  const {
    implementation: w,
    createNodeIterator: S,
    createDocumentFragment: C,
    getElementsByTagName: k
  } = t, {
    importNode: M
  } = r;
  let D = EP();
  e.isSupported = typeof f9 == "function" && typeof b == "function" && w && w.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: N,
    ERB_EXPR: R,
    TMPLIT_EXPR: j,
    DATA_ATTR: z,
    ARIA_ATTR: F,
    IS_SCRIPT_OR_DATA: B,
    ATTR_WHITESPACE: H,
    CUSTOM_ELEMENT: Y
  } = SP;
  let {
    IS_ALLOWED_URI: ne
  } = SP, J = null;
  const X = dn({}, [...bP, ...PS, ...jS, ...BS, ..._P]);
  let ie = null;
  const ye = dn({}, [...xP, ...$S, ...wP, ...Xy]);
  let pe = Object.seal(p9(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Be = null, Ce = null, Ee = !0, ce = !0, Pe = !1, Ae = !0, fe = !1, oe = !0, he = !1, Oe = !1, Te = !1, Ge = !1, je = !1, Qe = !1, ot = !0, it = !1;
  const Nt = "user-content-";
  let Le = !0, ft = !1, Rt = {}, Re = null;
  const be = dn({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let we = null;
  const Ne = dn({}, ["audio", "video", "img", "source", "image", "track"]);
  let lt = null;
  const Gt = dn({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), _n = "http://www.w3.org/1998/Math/MathML", Tr = "http://www.w3.org/2000/svg", Se = "http://www.w3.org/1999/xhtml";
  let rt = Se, wt = !1, rn = null;
  const Kt = dn({}, [_n, Tr, Se], RS);
  let Un = dn({}, ["mi", "mo", "mn", "ms", "mtext"]), tr = dn({}, ["annotation-xml"]);
  const so = dn({}, ["title", "style", "font", "a", "script"]);
  let wa = null;
  const Sa = ["application/xhtml+xml", "text/html"], Is = "text/html";
  let Fn = null, ti = null;
  const of = t.createElement("form"), Ol = function(de) {
    return de instanceof RegExp || de instanceof Function;
  }, Ea = function() {
    let de = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(ti && ti === de)) {
      if ((!de || typeof de != "object") && (de = {}), de = Gs(de), wa = // eslint-disable-next-line unicorn/prefer-includes
      Sa.indexOf(de.PARSER_MEDIA_TYPE) === -1 ? Is : de.PARSER_MEDIA_TYPE, Fn = wa === "application/xhtml+xml" ? RS : p1, J = po(de, "ALLOWED_TAGS") ? dn({}, de.ALLOWED_TAGS, Fn) : X, ie = po(de, "ALLOWED_ATTR") ? dn({}, de.ALLOWED_ATTR, Fn) : ye, rn = po(de, "ALLOWED_NAMESPACES") ? dn({}, de.ALLOWED_NAMESPACES, RS) : Kt, lt = po(de, "ADD_URI_SAFE_ATTR") ? dn(Gs(Gt), de.ADD_URI_SAFE_ATTR, Fn) : Gt, we = po(de, "ADD_DATA_URI_TAGS") ? dn(Gs(Ne), de.ADD_DATA_URI_TAGS, Fn) : Ne, Re = po(de, "FORBID_CONTENTS") ? dn({}, de.FORBID_CONTENTS, Fn) : be, Be = po(de, "FORBID_TAGS") ? dn({}, de.FORBID_TAGS, Fn) : Gs({}), Ce = po(de, "FORBID_ATTR") ? dn({}, de.FORBID_ATTR, Fn) : Gs({}), Rt = po(de, "USE_PROFILES") ? de.USE_PROFILES : !1, Ee = de.ALLOW_ARIA_ATTR !== !1, ce = de.ALLOW_DATA_ATTR !== !1, Pe = de.ALLOW_UNKNOWN_PROTOCOLS || !1, Ae = de.ALLOW_SELF_CLOSE_IN_ATTR !== !1, fe = de.SAFE_FOR_TEMPLATES || !1, oe = de.SAFE_FOR_XML !== !1, he = de.WHOLE_DOCUMENT || !1, Ge = de.RETURN_DOM || !1, je = de.RETURN_DOM_FRAGMENT || !1, Qe = de.RETURN_TRUSTED_TYPE || !1, Te = de.FORCE_BODY || !1, ot = de.SANITIZE_DOM !== !1, it = de.SANITIZE_NAMED_PROPS || !1, Le = de.KEEP_CONTENT !== !1, ft = de.IN_PLACE || !1, ne = de.ALLOWED_URI_REGEXP || h9, rt = de.NAMESPACE || Se, Un = de.MATHML_TEXT_INTEGRATION_POINTS || Un, tr = de.HTML_INTEGRATION_POINTS || tr, pe = de.CUSTOM_ELEMENT_HANDLING || {}, de.CUSTOM_ELEMENT_HANDLING && Ol(de.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (pe.tagNameCheck = de.CUSTOM_ELEMENT_HANDLING.tagNameCheck), de.CUSTOM_ELEMENT_HANDLING && Ol(de.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (pe.attributeNameCheck = de.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), de.CUSTOM_ELEMENT_HANDLING && typeof de.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (pe.allowCustomizedBuiltInElements = de.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), fe && (ce = !1), je && (Ge = !0), Rt && (J = dn({}, _P), ie = [], Rt.html === !0 && (dn(J, bP), dn(ie, xP)), Rt.svg === !0 && (dn(J, PS), dn(ie, $S), dn(ie, Xy)), Rt.svgFilters === !0 && (dn(J, jS), dn(ie, $S), dn(ie, Xy)), Rt.mathMl === !0 && (dn(J, BS), dn(ie, wP), dn(ie, Xy))), de.ADD_TAGS && (J === X && (J = Gs(J)), dn(J, de.ADD_TAGS, Fn)), de.ADD_ATTR && (ie === ye && (ie = Gs(ie)), dn(ie, de.ADD_ATTR, Fn)), de.ADD_URI_SAFE_ATTR && dn(lt, de.ADD_URI_SAFE_ATTR, Fn), de.FORBID_CONTENTS && (Re === be && (Re = Gs(Re)), dn(Re, de.FORBID_CONTENTS, Fn)), Le && (J["#text"] = !0), he && dn(J, ["html", "head", "body"]), J.table && (dn(J, ["tbody"]), delete Be.tbody), de.TRUSTED_TYPES_POLICY) {
        if (typeof de.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Hh('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof de.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Hh('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        _ = de.TRUSTED_TYPES_POLICY, x = _.createHTML("");
      } else
        _ === void 0 && (_ = zCe(p, i)), _ !== null && typeof x == "string" && (x = _.createHTML(""));
      Pi && Pi(de), ti = de;
    }
  }, sf = dn({}, [...PS, ...jS, ...MCe]), oy = dn({}, [...BS, ...DCe]), Iw = function(de) {
    let qe = b(de);
    (!qe || !qe.tagName) && (qe = {
      namespaceURI: rt,
      tagName: "template"
    });
    const gt = p1(de.tagName), Wn = p1(qe.tagName);
    return rn[de.namespaceURI] ? de.namespaceURI === Tr ? qe.namespaceURI === Se ? gt === "svg" : qe.namespaceURI === _n ? gt === "svg" && (Wn === "annotation-xml" || Un[Wn]) : !!sf[gt] : de.namespaceURI === _n ? qe.namespaceURI === Se ? gt === "math" : qe.namespaceURI === Tr ? gt === "math" && tr[Wn] : !!oy[gt] : de.namespaceURI === Se ? qe.namespaceURI === Tr && !tr[Wn] || qe.namespaceURI === _n && !Un[Wn] ? !1 : !oy[gt] && (so[gt] || !sf[gt]) : !!(wa === "application/xhtml+xml" && rn[de.namespaceURI]) : !1;
  }, ia = function(de) {
    Fh(e.removed, {
      element: de
    });
    try {
      b(de).removeChild(de);
    } catch {
      m(de);
    }
  }, ni = function(de, qe) {
    try {
      Fh(e.removed, {
        attribute: qe.getAttributeNode(de),
        from: qe
      });
    } catch {
      Fh(e.removed, {
        attribute: null,
        from: qe
      });
    }
    if (qe.removeAttribute(de), de === "is")
      if (Ge || je)
        try {
          ia(qe);
        } catch {
        }
      else
        try {
          qe.setAttribute(de, "");
        } catch {
        }
  }, jo = function(de) {
    let qe = null, gt = null;
    if (Te)
      de = "<remove></remove>" + de;
    else {
      const ar = yP(de, /^[\r\n\t ]+/);
      gt = ar && ar[0];
    }
    wa === "application/xhtml+xml" && rt === Se && (de = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + de + "</body></html>");
    const Wn = _ ? _.createHTML(de) : de;
    if (rt === Se)
      try {
        qe = new f().parseFromString(Wn, wa);
      } catch {
      }
    if (!qe || !qe.documentElement) {
      qe = w.createDocument(rt, "template", null);
      try {
        qe.documentElement.innerHTML = wt ? x : Wn;
      } catch {
      }
    }
    const Pr = qe.body || qe.documentElement;
    return de && gt && Pr.insertBefore(t.createTextNode(gt), Pr.childNodes[0] || null), rt === Se ? k.call(qe, he ? "html" : "body")[0] : he ? qe.documentElement : Pr;
  }, Ta = function(de) {
    return S.call(
      de.ownerDocument || de,
      de,
      // eslint-disable-next-line no-bitwise
      u.SHOW_ELEMENT | u.SHOW_COMMENT | u.SHOW_TEXT | u.SHOW_PROCESSING_INSTRUCTION | u.SHOW_CDATA_SECTION,
      null
    );
  }, Sh = function(de) {
    return de instanceof d && (typeof de.nodeName != "string" || typeof de.textContent != "string" || typeof de.removeChild != "function" || !(de.attributes instanceof c) || typeof de.removeAttribute != "function" || typeof de.setAttribute != "function" || typeof de.namespaceURI != "string" || typeof de.insertBefore != "function" || typeof de.hasChildNodes != "function");
  }, sy = function(de) {
    return typeof s == "function" && de instanceof s;
  };
  function Ca(St, de, qe) {
    Ky(St, (gt) => {
      gt.call(e, de, qe, ti);
    });
  }
  const lo = function(de) {
    let qe = null;
    if (Ca(D.beforeSanitizeElements, de, null), Sh(de))
      return ia(de), !0;
    const gt = Fn(de.nodeName);
    if (Ca(D.uponSanitizeElement, de, {
      tagName: gt,
      allowedTags: J
    }), oe && de.hasChildNodes() && !sy(de.firstElementChild) && bi(/<[/\w!]/g, de.innerHTML) && bi(/<[/\w!]/g, de.textContent) || de.nodeType === Uh.progressingInstruction || oe && de.nodeType === Uh.comment && bi(/<[/\w]/g, de.data))
      return ia(de), !0;
    if (!J[gt] || Be[gt]) {
      if (!Be[gt] && Eh(gt) && (pe.tagNameCheck instanceof RegExp && bi(pe.tagNameCheck, gt) || pe.tagNameCheck instanceof Function && pe.tagNameCheck(gt)))
        return !1;
      if (Le && !Re[gt]) {
        const Wn = b(de) || de.parentNode, Pr = y(de) || de.childNodes;
        if (Pr && Wn) {
          const ar = Pr.length;
          for (let ri = ar - 1; ri >= 0; --ri) {
            const ka = v(Pr[ri], !0);
            ka.__removalCount = (de.__removalCount || 0) + 1, Wn.insertBefore(ka, g(de));
          }
        }
      }
      return ia(de), !0;
    }
    return de instanceof l && !Iw(de) || (gt === "noscript" || gt === "noembed" || gt === "noframes") && bi(/<\/no(script|embed|frames)/i, de.innerHTML) ? (ia(de), !0) : (fe && de.nodeType === Uh.text && (qe = de.textContent, Ky([N, R, j], (Wn) => {
      qe = Vh(qe, Wn, " ");
    }), de.textContent !== qe && (Fh(e.removed, {
      element: de.cloneNode()
    }), de.textContent = qe)), Ca(D.afterSanitizeElements, de, null), !1);
  }, jt = function(de, qe, gt) {
    if (ot && (qe === "id" || qe === "name") && (gt in t || gt in of))
      return !1;
    if (!(ce && !Ce[qe] && bi(z, qe))) {
      if (!(Ee && bi(F, qe))) {
        if (!ie[qe] || Ce[qe]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(Eh(de) && (pe.tagNameCheck instanceof RegExp && bi(pe.tagNameCheck, de) || pe.tagNameCheck instanceof Function && pe.tagNameCheck(de)) && (pe.attributeNameCheck instanceof RegExp && bi(pe.attributeNameCheck, qe) || pe.attributeNameCheck instanceof Function && pe.attributeNameCheck(qe)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            qe === "is" && pe.allowCustomizedBuiltInElements && (pe.tagNameCheck instanceof RegExp && bi(pe.tagNameCheck, gt) || pe.tagNameCheck instanceof Function && pe.tagNameCheck(gt)))
          ) return !1;
        } else if (!lt[qe]) {
          if (!bi(ne, Vh(gt, H, ""))) {
            if (!((qe === "src" || qe === "xlink:href" || qe === "href") && de !== "script" && TCe(gt, "data:") === 0 && we[de])) {
              if (!(Pe && !bi(B, Vh(gt, H, "")))) {
                if (gt)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Eh = function(de) {
    return de !== "annotation-xml" && yP(de, Y);
  }, Th = function(de) {
    Ca(D.beforeSanitizeAttributes, de, null);
    const {
      attributes: qe
    } = de;
    if (!qe || Sh(de))
      return;
    const gt = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: ie,
      forceKeepAttr: void 0
    };
    let Wn = qe.length;
    for (; Wn--; ) {
      const Pr = qe[Wn], {
        name: ar,
        namespaceURI: ri,
        value: ka
      } = Pr, Il = Fn(ar), Ll = ka;
      let Cr = ar === "value" ? Ll : CCe(Ll);
      if (gt.attrName = Il, gt.attrValue = Cr, gt.keepAttr = !0, gt.forceKeepAttr = void 0, Ca(D.uponSanitizeAttribute, de, gt), Cr = gt.attrValue, it && (Il === "id" || Il === "name") && (ni(ar, de), Cr = Nt + Cr), oe && bi(/((--!?|])>)|<\/(style|title)/i, Cr)) {
        ni(ar, de);
        continue;
      }
      if (gt.forceKeepAttr)
        continue;
      if (!gt.keepAttr) {
        ni(ar, de);
        continue;
      }
      if (!Ae && bi(/\/>/i, Cr)) {
        ni(ar, de);
        continue;
      }
      fe && Ky([N, R, j], (Ch) => {
        Cr = Vh(Cr, Ch, " ");
      });
      const lf = Fn(de.nodeName);
      if (!jt(lf, Il, Cr)) {
        ni(ar, de);
        continue;
      }
      if (_ && typeof p == "object" && typeof p.getAttributeType == "function" && !ri)
        switch (p.getAttributeType(lf, Il)) {
          case "TrustedHTML": {
            Cr = _.createHTML(Cr);
            break;
          }
          case "TrustedScriptURL": {
            Cr = _.createScriptURL(Cr);
            break;
          }
        }
      if (Cr !== Ll)
        try {
          ri ? de.setAttributeNS(ri, ar, Cr) : de.setAttribute(ar, Cr), Sh(de) ? ia(de) : gP(e.removed);
        } catch {
          ni(ar, de);
        }
    }
    Ca(D.afterSanitizeAttributes, de, null);
  }, Lw = function St(de) {
    let qe = null;
    const gt = Ta(de);
    for (Ca(D.beforeSanitizeShadowDOM, de, null); qe = gt.nextNode(); )
      Ca(D.uponSanitizeShadowNode, qe, null), lo(qe), Th(qe), qe.content instanceof a && St(qe.content);
    Ca(D.afterSanitizeShadowDOM, de, null);
  };
  return e.sanitize = function(St) {
    let de = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, qe = null, gt = null, Wn = null, Pr = null;
    if (wt = !St, wt && (St = "<!-->"), typeof St != "string" && !sy(St))
      if (typeof St.toString == "function") {
        if (St = St.toString(), typeof St != "string")
          throw Hh("dirty is not a string, aborting");
      } else
        throw Hh("toString is not a function");
    if (!e.isSupported)
      return St;
    if (Oe || Ea(de), e.removed = [], typeof St == "string" && (ft = !1), ft) {
      if (St.nodeName) {
        const ka = Fn(St.nodeName);
        if (!J[ka] || Be[ka])
          throw Hh("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (St instanceof s)
      qe = jo("<!---->"), gt = qe.ownerDocument.importNode(St, !0), gt.nodeType === Uh.element && gt.nodeName === "BODY" || gt.nodeName === "HTML" ? qe = gt : qe.appendChild(gt);
    else {
      if (!Ge && !fe && !he && // eslint-disable-next-line unicorn/prefer-includes
      St.indexOf("<") === -1)
        return _ && Qe ? _.createHTML(St) : St;
      if (qe = jo(St), !qe)
        return Ge ? null : Qe ? x : "";
    }
    qe && Te && ia(qe.firstChild);
    const ar = Ta(ft ? St : qe);
    for (; Wn = ar.nextNode(); )
      lo(Wn), Th(Wn), Wn.content instanceof a && Lw(Wn.content);
    if (ft)
      return St;
    if (Ge) {
      if (je)
        for (Pr = C.call(qe.ownerDocument); qe.firstChild; )
          Pr.appendChild(qe.firstChild);
      else
        Pr = qe;
      return (ie.shadowroot || ie.shadowrootmode) && (Pr = M.call(r, Pr, !0)), Pr;
    }
    let ri = he ? qe.outerHTML : qe.innerHTML;
    return he && J["!doctype"] && qe.ownerDocument && qe.ownerDocument.doctype && qe.ownerDocument.doctype.name && bi(v9, qe.ownerDocument.doctype.name) && (ri = "<!DOCTYPE " + qe.ownerDocument.doctype.name + `>
` + ri), fe && Ky([N, R, j], (ka) => {
      ri = Vh(ri, ka, " ");
    }), _ && Qe ? _.createHTML(ri) : ri;
  }, e.setConfig = function() {
    let St = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Ea(St), Oe = !0;
  }, e.clearConfig = function() {
    ti = null, Oe = !1;
  }, e.isValidAttribute = function(St, de, qe) {
    ti || Ea({});
    const gt = Fn(St), Wn = Fn(de);
    return jt(gt, Wn, qe);
  }, e.addHook = function(St, de) {
    typeof de == "function" && Fh(D[St], de);
  }, e.removeHook = function(St, de) {
    if (de !== void 0) {
      const qe = SCe(D[St], de);
      return qe === -1 ? void 0 : ECe(D[St], qe, 1)[0];
    }
    return gP(D[St]);
  }, e.removeHooks = function(St) {
    D[St] = [];
  }, e.removeAllHooks = function() {
    D = EP();
  }, e;
}
var FCe = m9();
const nl = Z([]);
let VCe = 0;
const TP = (n, e) => {
  const t = nl.value.findIndex((r) => r.id === n);
  t !== -1 && (nl.value[t] = {
    ...nl.value[t],
    ...e,
    open: !0
  });
}, Lc = {
  create: (n) => {
    const e = `toast-${VCe++}`, t = n.duration != null ? n.duration * 1e3 : 5e3, r = FCe.sanitize(n.message, {
      ALLOWED_TAGS: ["a", "em", "strong", "i", "b", "u"]
    }), i = {
      id: n.id || e,
      open: !0,
      message: r,
      type: n.type || "info",
      duration: t,
      action: n.action,
      icon: n.icon,
      closable: n.closable ?? !0
    };
    return nl.value.push(i), i.id;
  },
  remove: (n) => {
    nl.value = nl.value.filter((e) => e.id !== n);
  },
  removeAll: () => {
    nl.value = [];
  },
  promise: async (n, e) => {
    const t = e.duration ?? 0, r = Lc.create({
      message: e.loading,
      type: "info",
      icon: () => qt(nh, { class: "text-ink-white" }),
      duration: t,
      closable: !1
    });
    try {
      const i = await n, a = typeof e.success == "function" ? e.success(i) : e.success, o = e.successDuration ?? e.duration ?? 5;
      return TP(r, {
        message: a,
        type: "success",
        duration: o * 1e3,
        icon: void 0,
        closable: !0
      }), i;
    } catch (i) {
      const a = typeof e.error == "function" ? e.error(i) : e.error, o = e.errorDuration ?? e.duration ?? 5;
      throw TP(r, {
        message: a,
        type: "error",
        duration: o * 1e3,
        icon: void 0,
        closable: !0
      }), i;
    }
  },
  success: (n, e = {}) => Lc.create({ message: n, type: "success", ...e }),
  error: (n, e = {}) => Lc.create({ message: n, type: "error", ...e }),
  warning: (n, e = {}) => Lc.create({ message: n, type: "warning", ...e }),
  info: (n, e = {}) => Lc.create({ message: n, type: "info", ...e })
};
ve({
  name: "FrappeToasts",
  setup() {
    const n = (t, r) => {
      if (!r)
        Lc.remove(t);
      else {
        const i = nl.value.find((a) => a.id === t);
        i && (i.open = !0);
      }
    }, e = (t) => {
      Lc.remove(t.id);
    };
    return () => nl.value.map(
      (t) => qt(bCe, {
        key: t.id,
        open: t.open,
        message: t.message,
        type: t.type,
        duration: t.duration,
        action: t.action,
        icon: t.icon,
        closable: t.closable,
        "onUpdate:open": (r) => n(t.id, r),
        onAction: () => e(t)
      })
    );
  }
});
const HCe = { class: "relative" }, GCe = { class: "absolute inset-y-0 left-0 flex items-center pl-4.5" }, UCe = {
  key: 0,
  class: "mb-2.5 px-4.5 text-base text-ink-gray-5"
}, FUe = {
  __name: "CommandPalette",
  props: {
    show: { type: Boolean, default: !1 },
    searchQuery: { type: String, default: "" },
    groups: { type: Array, default: () => [] }
  },
  emits: ["update:show", "update:searchQuery", "select"],
  setup(n, { emit: e }) {
    const t = e, r = n, i = K({
      get: () => r.show,
      set: (l) => t("update:show", l)
    }), a = K({
      get: () => r.searchQuery,
      set: (l) => t("update:searchQuery", l)
    });
    function o(l) {
      t("select", l), i.value = !1;
    }
    function s(l) {
      l.key === "Escape" && i.value && (i.value = !1, l.preventDefault()), l.key === "k" && (l.ctrlKey || l.metaKey) && !l.target.classList.contains("ProseMirror") && (i.value = !0, l.preventDefault());
    }
    return kt(() => window.addEventListener("keydown", s)), Io(() => window.removeEventListener("keydown", s)), (l, u) => {
      const c = En, d = px;
      return L(), W("template", null, [
        se(d, {
          modelValue: i.value,
          "onUpdate:modelValue": u[1] || (u[1] = (f) => i.value = f),
          options: { size: "xl", position: "top" },
          onAfterLeave: u[2] || (u[2] = (f) => a.value = "")
        }, {
          body: ee(() => [
            G("div", null, [
              se(O(jF), {
                nullable: "",
                "onUpdate:modelValue": o
              }, {
                default: ee(() => [
                  G("div", HCe, [
                    G("div", GCe, [
                      se(c, {
                        name: "search",
                        class: "h-4 w-4"
                      })
                    ]),
                    se(O(BF), {
                      placeholder: "Search",
                      class: "w-full border-none bg-transparent py-3 pl-11.5 pr-4.5 text-base text-ink-gray-8 placeholder-ink-gray-4 focus:ring-0",
                      modelValue: a.value,
                      "onUpdate:modelValue": u[0] || (u[0] = (f) => a.value = f),
                      autocomplete: "off"
                    }, null, 8, ["modelValue"])
                  ]),
                  se(O($F), {
                    class: "max-h-96 overflow-auto border-t border-gray-100",
                    static: "",
                    hold: !0
                  }, {
                    default: ee(() => [
                      (L(!0), W(Ke, null, _t(n.groups, (f, p) => (L(), W("div", {
                        class: "mb-2 mt-4.5 first:mt-3",
                        key: f.title
                      }, [
                        f.hideTitle ? ge("", !0) : (L(), W("div", UCe, ke(f.title), 1)),
                        (L(!0), W(Ke, null, _t(f.items, (h) => (L(), re(O(zF), {
                          key: h.name,
                          value: h,
                          class: "px-2.5",
                          disabled: h.disabled
                        }, {
                          default: ee(({ active: v }) => [
                            (L(), re(bn(f.component), {
                              item: h,
                              active: v
                            }, null, 8, ["item", "active"]))
                          ]),
                          _: 2
                        }, 1032, ["value", "disabled"]))), 128))
                      ]))), 128))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ])
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]);
    };
  }
}, WCe = { class: "overflow-hidden text-ellipsis whitespace-nowrap" }, qCe = {
  key: 1,
  class: "ml-auto whitespace-nowrap pl-2 text-ink-gray-5"
}, VUe = {
  __name: "CommandPaletteItem",
  props: {
    item: { type: Object, required: !0 },
    active: { type: Boolean, default: !1 }
  },
  setup(n) {
    return (e, t) => (L(), W("div", {
      class: _e(["flex w-full min-w-0 items-center rounded px-2 py-2 text-base font-medium text-ink-gray-8", { "bg-surface-gray-3": n.active }])
    }, [
      n.item.icon ? (L(), re(bn(n.item.icon), {
        key: 0,
        class: "mr-3 h-4 w-4 text-ink-gray-7"
      })) : ge("", !0),
      G("span", WCe, ke(n.item.title), 1),
      n.item.description ? (L(), W("span", qCe, ke(n.item.description), 1)) : ge("", !0)
    ], 2));
  }
};
function YCe(n, e) {
  let t = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], r = new Date(e, n, 1), i = r.getDay(), a = d(r, i), o = c(r), s = [...a, ...o], l = f(s);
  return [...s, ...l];
  function c(v) {
    let m = v.getMonth();
    m == 1 && h(v) && (t[m] = 29);
    let g = t[m] + 1;
    return p(v, 1, g);
  }
  function d(v, m) {
    let g = p(v, 0, m, -1);
    return g = g.reverse(), g;
  }
  function f(v) {
    const m = v.length > 35 ? 42 : 35;
    let g = v.length, y = v[g - 1], b = m - g + 1;
    return p(y, 1, b, 1, !0);
  }
  function p(v, m, g, y = 1, b = !1) {
    let _ = [];
    for (let x = m; x < g; x++) {
      let w = new Date(
        v.getFullYear(),
        b ? v.getMonth() + 1 : v.getMonth(),
        x * y
      );
      _.push(w);
    }
    return _;
  }
  function h(v) {
    let m = v.getFullYear();
    return m % 400 === 0 || m % 100 !== 0 && m % 4 === 0;
  }
}
function CP(n, e) {
  if (typeof e != "function") throw new Error(`${e} should be a function`);
  return Object.keys(n).reduce((t, r) => {
    const i = e(n[r]);
    return t[i] || (t[i] = []), t[i].push(n[r]), t;
  }, {});
}
function ha(n) {
  let [e, t] = n.split(":");
  return parseInt(e) * 60 + parseInt(t);
}
function h1(n) {
  let e = Math.floor(n / 60), t = n % 60;
  return e < 10 && (e = `0${e}`), t < 10 && (t = `0${t}`), `${e}:${t}:00`;
}
function kr(n) {
  typeof n == "string" && (n = new Date(n));
  let e = n.getDate(), t = n.getMonth() + 1, r = n.getFullYear();
  return e < 10 && (e = "0" + e), t < 10 && (t = "0" + t), `${r}-${t}-${e}`;
}
function g9(n, e = !0, t = !0, r = "short") {
  const i = {
    day: "numeric"
  };
  return t && (i.month = "short"), e && (i.weekday = r), n.toLocaleDateString("en-US", i);
}
function OC(n, e = !1) {
  return e ? ZCe[n.getDay()] + ", " + n.getDate() : b9[n.getDay()] + " " + n.getDate();
}
function y9(n, e) {
  let t = ha(n);
  return ha(e) - t;
}
function kP(n) {
  return n.split(":").slice(0, 2).join(":") + ":00";
}
function KCe(n) {
  n = n.sort((t, r) => t.startTime - r.startTime);
  const e = [];
  for (const t of n) {
    const r = e.find(
      (i) => i[i.length - 1].endTime <= t.startTime
    );
    r ? r.push(t) : e.push([t]);
  }
  return e.map(
    (t, r) => t.map((i, a) => ({
      ...i,
      hallNumber: r,
      idx: a
    }))
  ).flat();
}
const XCe = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], b9 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ZCe = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
], _9 = [
  "12 am",
  "1 am",
  "2 am",
  "3 am",
  "4 am",
  "5 am",
  "6 am",
  "7 am",
  "8 am",
  "9 am",
  "10 am",
  "11 am",
  "12 pm",
  "1 pm",
  "2 pm",
  "3 pm",
  "4 pm",
  "5 pm",
  "6 pm",
  "7 pm",
  "8 pm",
  "9 pm",
  "10 pm",
  "11 pm"
], x9 = [
  "00:00",
  "01:00",
  "02:00",
  "03:00",
  "04:00",
  "05:00",
  "06:00",
  "07:00",
  "08:00",
  "09:00",
  "10:00",
  "11:00",
  "12:00",
  "13:00",
  "14:00",
  "15:00",
  "16:00",
  "17:00",
  "18:00",
  "19:00",
  "20:00",
  "21:00",
  "22:00",
  "23:00"
], sp = {
  blue: {
    background_color: "bg-blue-100",
    border_color: "border-blue-600"
  },
  green: {
    background_color: "bg-green-100",
    border_color: "border-green-600"
  },
  red: {
    background_color: "bg-red-200",
    border_color: "border-red-600"
  },
  orange: {
    background_color: "bg-orange-100",
    border_color: "border-orange-600"
  },
  yellow: {
    background_color: "bg-yellow-100",
    border_color: "border-yellow-600"
  },
  teal: {
    background_color: "bg-teal-100",
    border_color: "border-teal-600"
  },
  violet: {
    background_color: "bg-violet-100",
    border_color: "border-violet-600"
  },
  cyan: {
    background_color: "bg-cyan-100",
    border_color: "border-cyan-600"
  },
  purple: {
    background_color: "bg-purple-100",
    border_color: "border-purple-600"
  },
  pink: {
    background_color: "bg-pink-100",
    border_color: "border-pink-600"
  },
  amber: {
    background_color: "bg-amber-100",
    border_color: "border-amber-600"
  }
};
function AP(n, e, t) {
  return n = MP(n, t), e = MP(e, t), n + " - " + e;
}
function MP(n, e) {
  if (e === "12h") {
    let [t, r] = n.split(":");
    t = parseInt(t);
    const i = t >= 12 ? "pm" : "am";
    if (t = t % 12, t = t || 12, r === "00")
      return `${t} ${i}`;
    n = `${t}:${r} ${i}`;
  }
  return n;
}
const JCe = { class: "w-80 rounded bg-surface-modal text-ink-gray-8 p-4 shadow" }, QCe = { class: "flex flex-row-reverse gap-2" }, eke = { class: "flex flex-col gap-5" }, tke = { class: "flex justify-between text-xl font-semibold" }, nke = { class: "flex flex-col gap-4" }, rke = { class: "flex items-center gap-2" }, ike = { class: "text-sm font-normal" }, ake = {
  key: 0,
  class: "flex items-center gap-2"
}, oke = { class: "text-sm font-normal" }, ske = {
  key: 1,
  class: "flex items-center gap-2"
}, lke = { class: "text-sm font-normal" }, uke = {
  key: 2,
  class: "flex items-center gap-2"
}, cke = { class: "text-sm font-normal" }, dke = {
  __name: "EventModalContent",
  props: {
    calendarEvent: { type: Object, required: !0 },
    date: { type: Date, required: !0 },
    isEditMode: { type: Boolean }
  },
  emits: ["close", "edit", "delete"],
  setup(n, { emit: e }) {
    return (t, r) => (L(), W("div", JCe, [
      G("div", QCe, [
        G("span", {
          class: "cursor-pointer",
          onClick: r[0] || (r[0] = (i) => t.$emit("close"))
        }, [
          se(En, {
            name: "x",
            class: "h-4 w-4"
          })
        ]),
        n.isEditMode ? (L(), W("span", {
          key: 0,
          class: "cursor-pointer",
          onClick: r[1] || (r[1] = (i) => t.$emit("edit"))
        }, [
          se(En, {
            name: "edit-2",
            class: "h-4 w-4"
          })
        ])) : ge("", !0),
        n.isEditMode ? (L(), W("span", {
          key: 1,
          class: "cursor-pointer",
          onClick: r[2] || (r[2] = (i) => t.$emit("delete"))
        }, [
          se(En, {
            name: "trash-2",
            class: "h-4 w-4"
          })
        ])) : ge("", !0)
      ]),
      G("div", eke, [
        G("div", tke, [
          G("span", null, ke(n.calendarEvent.title || "New Event"), 1)
        ]),
        G("div", nke, [
          G("div", rke, [
            se(En, {
              name: "calendar",
              class: "h-4 w-4"
            }),
            G("span", ike, ke(O(g9)(n.date)), 1)
          ]),
          n.calendarEvent.participant ? (L(), W("div", ake, [
            se(En, {
              name: "user",
              class: "h-4 w-4"
            }),
            G("span", oke, ke(n.calendarEvent.participant), 1)
          ])) : ge("", !0),
          n.calendarEvent.from_time && n.calendarEvent.to_time ? (L(), W("div", ske, [
            se(En, {
              name: "clock",
              class: "h-4 w-4"
            }),
            G("span", lke, ke(n.calendarEvent.from_time) + " - " + ke(n.calendarEvent.to_time), 1)
          ])) : ge("", !0),
          n.calendarEvent.venue ? (L(), W("div", uke, [
            se(En, {
              name: "map-pin",
              class: "h-4 w-4"
            }),
            G("span", cke, ke(n.calendarEvent.venue), 1)
          ])) : ge("", !0)
        ])
      ])
    ]));
  }
}, fke = { class: "grid grid-cols-1 gap-4" }, pke = { class: "flex flex-row-reverse gap-2" }, w9 = {
  __name: "NewEventModal",
  props: {
    event: {
      type: Object
    }
  },
  setup(n) {
    var f, p, h, v, m, g, y, b;
    const e = Z(!1), t = n, r = Sr({
      title: ((f = t.event) == null ? void 0 : f.title) || "",
      date: ((p = t.event) == null ? void 0 : p.date) || "",
      participant: ((h = t.event) == null ? void 0 : h.participant) || "",
      from_time: ((v = t.event) == null ? void 0 : v.from_time) || "",
      to_time: ((m = t.event) == null ? void 0 : m.to_time) || "",
      venue: ((g = t.event) == null ? void 0 : g.venue) || "",
      color: ((y = t.event) == null ? void 0 : y.color) || "green",
      id: "",
      isFullDay: ((b = t.event) == null ? void 0 : b.isFullDay) || !1
    }), i = K(() => r.title !== t.event.title || r.date !== t.event.date || r.participant !== t.event.participant || r.from_time !== t.event.from_time || r.to_time !== t.event.to_time || r.venue !== t.event.venue || r.color !== t.event.color || r.isFullDay !== t.event.isFullDay), a = Object.keys(sp), o = Z("");
    function s() {
      r.date ? !r.from_time && !r.isFullDay ? o.value = "Start Time is required" : !r.to_time && !r.isFullDay ? o.value = "End Time is required" : o.value = "" : o.value = "Date is required", r.hasOwnProperty("from_time") && r.hasOwnProperty("to_time") && l();
    }
    function l() {
      y9(r.from_time, r.to_time) <= 0 && (o.value = "Start time must be less than End Time");
    }
    const u = Xt("calendarActions");
    function c(_) {
      if (s(), !o.value) {
        if (!i.value) {
          _();
          return;
        }
        if (d(), t.event.hasOwnProperty("id"))
          r.id = t.event.id, u.updateEventState(r);
        else {
          const x = "#" + Math.random().toString(36).substring(3, 9);
          r.id = x, u.createNewEvent(r);
        }
        _();
      }
    }
    function d() {
      r.isFullDay ? (r.from_time = "", r.to_time = "") : (r.from_time = kP(r.from_time), r.to_time = kP(r.to_time));
    }
    return (_, x) => (L(), re(O(hx), {
      modelValue: e.value,
      "onUpdate:modelValue": x[11] || (x[11] = (w) => e.value = w),
      options: {
        title: t.event.hasOwnProperty("id") ? "Edit Event" : "New Event",
        actions: [
          {
            label: "Submit",
            variant: "solid"
          }
        ]
      },
      class: "z-50"
    }, {
      "body-content": ee(() => [
        G("div", null, [
          G("div", fke, [
            se(O(Fs), {
              type: "Input",
              modelValue: r.title,
              "onUpdate:modelValue": x[0] || (x[0] = (w) => r.title = w),
              label: "Title",
              placeholder: "Meet with John Doe"
            }, null, 8, ["modelValue"]),
            se(O(Fs), {
              type: "Date",
              modelValue: r.date,
              "onUpdate:modelValue": x[1] || (x[1] = (w) => r.date = w),
              label: "Date",
              required: "true",
              onBlur: x[2] || (x[2] = (w) => s())
            }, null, 8, ["modelValue"]),
            se(O(Fs), {
              type: "Input",
              modelValue: r.participant,
              "onUpdate:modelValue": x[3] || (x[3] = (w) => r.participant = w),
              label: "Person",
              placeholder: "John Doe"
            }, null, 8, ["modelValue"]),
            r.isFullDay ? ge("", !0) : (L(), re(O(Fs), {
              key: 0,
              type: "time",
              modelValue: r.from_time,
              "onUpdate:modelValue": x[4] || (x[4] = (w) => r.from_time = w),
              label: "Start Time",
              onBlur: x[5] || (x[5] = (w) => s())
            }, null, 8, ["modelValue"])),
            r.isFullDay ? ge("", !0) : (L(), re(O(Fs), {
              key: 1,
              type: "time",
              modelValue: r.to_time,
              "onUpdate:modelValue": x[6] || (x[6] = (w) => r.to_time = w),
              label: "End Time",
              onBlur: x[7] || (x[7] = (w) => s())
            }, null, 8, ["modelValue"])),
            se(O(Fs), {
              type: "Input",
              modelValue: r.venue,
              "onUpdate:modelValue": x[8] || (x[8] = (w) => r.venue = w),
              label: "Venue",
              placeholder: "Frappe, Neelkanth Business Park"
            }, null, 8, ["modelValue"]),
            se(O(Fs), {
              type: "select",
              modelValue: r.color,
              "onUpdate:modelValue": x[9] || (x[9] = (w) => r.color = w),
              options: O(a),
              label: "Color",
              class: "form-control prefix"
            }, {
              prefix: ee(() => {
                var w;
                return [
                  G("div", {
                    class: _e(["h-5 w-5 rounded-full shadow-md", [
                      ((w = O(sp)[r == null ? void 0 : r.color]) == null ? void 0 : w.background_color) || "bg-green-100"
                    ]])
                  }, null, 2)
                ];
              }),
              _: 1
            }, 8, ["modelValue", "options"]),
            se(O(Fs), {
              type: "checkbox",
              label: "Full Day Event?",
              modelValue: r.isFullDay,
              "onUpdate:modelValue": x[10] || (x[10] = (w) => r.isFullDay = w)
            }, null, 8, ["modelValue"]),
            o.value ? (L(), re(O(f6), {
              key: 2,
              message: o.value
            }, null, 8, ["message"])) : ge("", !0)
          ])
        ])
      ]),
      actions: ee(({ close: w }) => [
        G("div", pke, [
          se(O(fn), {
            class: "w-full",
            variant: "solid",
            onClick: (S) => c(w),
            label: "Submit"
          }, null, 8, ["onClick"])
        ])
      ]),
      _: 1
    }, 8, ["modelValue", "options"]));
  }
}, hke = { key: 0 }, vke = { class: "flex w-fit flex-col overflow-hidden whitespace-nowrap text-gray-800" }, mke = { class: "text-ellipsis text-sm font-medium truncate" }, gke = {
  key: 0,
  class: "text-ellipsis text-xs font-normal"
}, yke = { key: 0 }, bke = { class: "flex w-fit flex-col text-start overflow-hidden whitespace-nowrap text-gray-800" }, _ke = { class: "text-sm font-medium truncate" }, xke = {
  key: 0,
  class: "text-xs font-normal"
}, wke = 40, Ske = 32.5, Bp = {
  __name: "CalendarEvent",
  props: {
    event: {
      type: Object,
      required: !0
    },
    date: {
      type: Date,
      required: !0
    }
  },
  setup(n) {
    const e = n, t = Xt("activeView"), r = Xt("config"), i = Xt("calendarActions");
    kt(() => {
      document.addEventListener("click", a);
    }), Io(() => {
      document.removeEventListener("click", a);
    });
    function a(X) {
      h.value && h.value.contains(X.target) || p.value && p.value.contains(X.target) || z();
    }
    const o = Z(e.event), s = Sr({
      ...e.event
    });
    et(
      () => e.event,
      (X) => {
        s.from_time = X.from_time, s.to_time = X.to_time, o.value = X;
      },
      { deep: !0 }
    );
    const l = r.eventIcons, u = r.hourHeight / 60, c = u * 15, d = Sr({
      xAxis: 0,
      yAxis: 0
    }), f = K(() => {
      if (e.event.isFullDay)
        return {
          transform: `translate(${d.xAxis}px, ${d.yAxis}px)`,
          zIndex: b ? 100 : e.event.idx + 1
        };
      let ie = y9(
        o.value.from_time,
        o.value.to_time
      ) * u;
      ie < wke && (ie = Ske), ie += "px";
      let ye = ha(o.value.from_time) * u;
      t.value === "Day" && (ye += r.redundantCellHeight);
      let pe = o.value.hallNumber, Be = y.value || b.value ? "100%" : `${80 - pe * 20}%`, Ce = y.value || b.value ? "0" : `${pe * 20}%`, Ee = y.value || b.value ? 100 : (e.event.idx || 1) * pe + 1, ce = pe >= 1 ? "1px solid #fff" : "";
      return {
        height: ie,
        top: ye + "px",
        zIndex: Ee,
        left: Ce,
        width: Be,
        transform: `translate(${d.xAxis}px, ${d.yAxis}px)`,
        borderLeft: ce,
        borderTop: ce
      };
    }), p = Z(null), h = Z(null), { floatingStyles: v } = OV(p, h, {
      placement: t.value === "Day" ? "top" : "right",
      middleware: [AV(10), AT(), MV()],
      whileElementsMounted: kV
    }), m = Z(!1), g = Z(null), y = Z(!1), b = Z(!1), _ = Z(!1);
    function x(X) {
      let ie = parseFloat(X) / u + ha(o.value.from_time);
      return ie = Math.floor(ie), ie > 1440 && (ie = 1440), h1(ie);
    }
    const w = Z(!1);
    function S(X) {
      y.value = !0, b.value = !1;
      let ie = o.value.to_time;
      window.addEventListener("mousemove", ye), window.addEventListener("mouseup", pe, { once: !0 });
      function ye(Be) {
        w.value = !0;
        let Ce = Be.clientY - p.value.getBoundingClientRect().top;
        p.value.style.height = Math.round(Ce / c) * c + "px", p.value.style.width = "100%", s.to_time = x(p.value.style.height), o.value.to_time = x(p.value.style.height);
      }
      function pe() {
        y.value = !1, ie !== o.value.to_time && i.updateEventState(o.value), window.removeEventListener("mousemove", ye);
      }
    }
    function C(X) {
      X.preventDefault();
      let ie = X.clientY;
      const ye = p.value.getBoundingClientRect();
      if (y.value) return;
      window.addEventListener("mousemove", pe), window.addEventListener("mouseup", Be);
      function pe(Ce) {
        b.value = !0, w.value = !0, p.value && (z(), p.value.style.cursor = "grabbing", t.value === "Week" && M(Ce.clientX, ye), e.event.isFullDay || N(Ce.clientY, ie, ye), o.value.from_time !== s.from_time || o.value.to_time !== s.to_time ? _.value = !0 : _.value = !1);
      }
      function Be(Ce) {
        Ce.preventDefault(), b.value = !1, p.value && (p.value.style.cursor = "pointer", o.value.isFullDay && t.value === "Week" && (p.value.style.width = "90%"), o.value.date !== s.date && (_.value = !0), _.value && (o.value.date = s.date, o.value.from_time = s.from_time, o.value.to_time = s.to_time, i.updateEventState(o.value), _.value = !1, d.xAxis = 0, d.yAxis = 0), window.removeEventListener("mousemove", pe), window.removeEventListener("mouseup", Be));
      }
    }
    function k(X, ie = 0) {
      return new Date(
        X.getFullYear(),
        X.getMonth(),
        X.getDate() + ie
      );
    }
    function M(X, ie) {
      const ye = new Date(
        e.event.isFullDay ? p.value.parentNode.parentNode.getAttribute("data-date-attr") : p.value.parentNode.getAttribute("data-date-attr")
      );
      e.event.isFullDay && (p.value.style.width = "100%");
      let pe = p.value.clientWidth, Be = Math.floor((X - ie.left) / pe);
      const Ce = ye.getDay(), Ee = 6 - ye.getDay();
      Be = D(Be, Ce, Ee);
      let ce = Math.ceil(Be * pe);
      d.xAxis = ce, s.date = kr(k(ye, Be));
    }
    function D(X, ie, ye) {
      return X < -ie ? X = -ie : X > ye && (X = ye), X;
    }
    function N(X, ie, ye) {
      let pe = X - ie, Be = p.value.parentNode.getBoundingClientRect().top, Ce = p.value.parentNode.getBoundingClientRect().bottom;
      X < Be && (pe = Be - ye.top), X > Ce && (pe = Ce - ye.bottom), pe = Math.round(pe / c) * c, d.yAxis = pe, s.from_time = h1(
        ha(o.value.from_time) + Math.round(pe / u)
      ), s.to_time = h1(
        ha(o.value.to_time) + Math.round(pe / u)
      ), R();
    }
    function R() {
      s.from_time < "00:00:00" && (s.from_time = "00:00:00"), s.from_time > "24:00:00" && (s.from_time = "24:00:00"), s.to_time < "00:00:00" && (s.to_time = "00:00:00"), s.to_time > "24:00:00" && (s.to_time = "24:00:00");
    }
    const j = () => m.value = !m.value, z = () => m.value = !1;
    function F(X) {
      (X.key === "Delete" || X.key === "Backspace") && (m.value = !1, J());
    }
    et(
      () => m.value,
      (X) => {
        if (X) {
          if (!r.isEditMode || !r.enableShortcuts) return;
          document.addEventListener("keydown", F, { once: !0 });
        }
      }
    );
    let B = null;
    function H(X) {
      if (w.value) {
        w.value = !1;
        return;
      }
      X.detail === 1 && (B = setTimeout(() => {
        i.props.onClick ? i.props.onClick({
          e: X,
          calendarEvent: o.value
        }) : j();
      }, 200));
    }
    const Y = Z(!1);
    function ne(X = null) {
      if (X && (X.cancelBubble = !0), clearTimeout(B), i.props.onDblClick) {
        i.props.onDblClick({
          e: X,
          calendarEvent: o.value
        });
        return;
      }
      r.isEditMode && (z(), Y.value = !0);
    }
    function J() {
      i.deleteEvent(o.value.id), z();
    }
    return (X, ie) => {
      var ye, pe, Be, Ce, Ee, ce, Pe, Ae;
      return L(), W(Ke, null, [
        O(t) !== "Month" ? (L(), W("div", He({
          key: 0,
          class: "h-min-[18px] rounded-lg p-2 transition-all duration-75",
          ref_key: "eventRef",
          ref: p
        }, X.$attrs, {
          class: [
            ((pe = O(sp)[(ye = e.event) == null ? void 0 : ye.color]) == null ? void 0 : pe.background_color) || "bg-green-100",
            "shadow-lg",
            m.value && "!z-20 drop-shadow-xl"
          ],
          style: f.value,
          onDblclick: ie[0] || (ie[0] = xt((fe) => ne(fe), ["prevent"])),
          onClick: ie[1] || (ie[1] = xt((fe) => H(fe), ["prevent"]))
        }, yF({
          mousedown: O(r).isEditMode && C
        }, !0)), [
          G("div", {
            class: _e([
              "relative flex h-full select-none items-start gap-2 overflow-hidden px-2",
              e.event.from_time && [
                "border-l-2",
                ((Ce = O(sp)[(Be = e.event) == null ? void 0 : Be.color]) == null ? void 0 : Ce.border_color) || "border-green-600"
              ]
            ])
          }, [
            O(r).showIcon && O(l)[e.event.type] ? (L(), W("div", hke, [
              O(l)[e.event.type] ? (L(), re(bn(O(l)[e.event.type]), {
                key: 0,
                class: "h-4 w-4 text-black"
              })) : ge("", !0)
            ])) : ge("", !0),
            G("div", vke, [
              G("p", mke, ke(e.event.title || "New Event"), 1),
              e.event.isFullDay ? ge("", !0) : (L(), W("p", gke, ke(O(AP)(
                s.from_time,
                s.to_time,
                O(r).timeFormat
              )), 1))
            ])
          ], 2),
          O(r).isEditMode && !n.event.isFullDay ? (L(), W("div", {
            key: 0,
            class: "absolute h-[8px] w-[100%] cursor-row-resize",
            ref_key: "resize",
            ref: g,
            onMousedown: S
          }, null, 544)) : ge("", !0)
        ], 16)) : (L(), W("div", He({
          key: 1,
          class: "h-min-[18px] rounded-lg p-2 transition-all duration-75",
          ref_key: "eventRef",
          ref: p
        }, X.$attrs, {
          class: [((ce = O(sp)[(Ee = e.event) == null ? void 0 : Ee.color]) == null ? void 0 : ce.background_color) || "bg-green-100"],
          onDblclick: ie[2] || (ie[2] = xt((fe) => ne(fe), ["prevent"])),
          onClick: ie[3] || (ie[3] = (fe) => H(fe))
        }), [
          G("div", {
            class: _e([
              "relative flex h-full select-none items-start gap-2 overflow-hidden px-2",
              e.event.from_time && [
                "border-l-2",
                ((Ae = O(sp)[(Pe = e.event) == null ? void 0 : Pe.color]) == null ? void 0 : Ae.border_color) || "border-green-600"
              ]
            ])
          }, [
            O(r).showIcon && O(l)[e.event.type] ? (L(), W("div", yke, [
              O(l)[e.event.type] ? (L(), re(bn(O(l)[e.event.type]), {
                key: 0,
                class: "h-4 w-4 text-black"
              })) : ge("", !0)
            ])) : ge("", !0),
            G("div", bke, [
              G("p", _ke, ke(e.event.title || "New Event"), 1),
              e.event.from_time ? (L(), W("p", xke, ke(O(AP)(
                s.from_time,
                s.to_time,
                O(r).timeFormat
              )), 1)) : ge("", !0)
            ])
          ], 2)
        ], 16)),
        m.value ? (L(), W("div", {
          key: 2,
          ref_key: "floating",
          ref: h,
          style: An({ ...O(v), zIndex: 100 }),
          class: "rounded shadow-xl"
        }, [
          se(dke, {
            calendarEvent: o.value,
            date: n.date,
            isEditMode: O(r).isEditMode,
            onClose: z,
            onEdit: ne,
            onDelete: J,
            class: "shadow-xl"
          }, null, 8, ["calendarEvent", "date", "isEditMode"])
        ], 4)) : ge("", !0),
        se(w9, {
          modelValue: Y.value,
          "onUpdate:modelValue": ie[4] || (ie[4] = (fe) => Y.value = fe),
          event: s
        }, null, 8, ["modelValue", "event"])
      ], 64);
    };
  }
};
function qm(n, e = "") {
  const t = K(() => {
    let i = CP(n, (o) => o.date), a = {};
    if (e === "Month")
      for (const [o, s] of Object.entries(i))
        a[o] = Eke(s);
    else
      for (let [o, s] of Object.entries(i)) {
        s = s.filter((u) => !u.isFullDay), s.forEach((u) => {
          u.startTime = ha(u.from_time), u.endTime = ha(u.to_time);
        });
        let l = s.sort((u, c) => u.startTime - c.startTime);
        a[o] = KCe(l);
      }
    return a;
  }), r = K(() => {
    let i = n.filter((o) => o.isFullDay);
    return CP(i, (o) => o.date);
  });
  return { timedEvents: t, fullDayEvents: r };
}
function Eke(n) {
  let e = n.filter((r) => r.isFullDay), t = n.filter((r) => !r.isFullDay).sort(
    (r, i) => r.from_time !== i.from_time ? ha(r.from_time) > ha(i.from_time) ? 1 : -1 : ha(r.to_time) > ha(i.to_time) ? 1 : -1
  );
  return [...e, ...t];
}
const S9 = {
  __name: "ShowMoreCalendarEvent",
  props: {
    event: {
      type: Object,
      required: !0
    },
    date: {
      type: String,
      required: !0
    },
    totalEventsCount: {
      type: Number,
      required: !0
    }
  },
  emits: ["showMoreEvents"],
  setup(n, { emit: e }) {
    const t = e;
    return (r, i) => (L(), W(Ke, null, [
      (L(), re(Bp, He({
        event: n.event,
        date: n.date,
        key: n.event.id,
        class: "mb-1 cursor-pointer"
      }, r.$attrs), null, 16, ["event", "date"])),
      n.totalEventsCount > 1 ? (L(), W("span", {
        key: 0,
        class: "w-fit rounded-sm p-px px-1.5 mx-1 text-base font-medium text-ink-gray-6 hover:cursor-pointer hover:bg-surface-gray-1",
        onClick: i[0] || (i[0] = (a) => t("showMoreEvents"))
      }, " +" + ke(n.totalEventsCount - 1) + " more ", 1)) : ge("", !0)
    ], 64));
  }
}, Tke = { class: "flex flex-1 flex-col overflow-scroll" }, Cke = { class: "grid w-full grid-cols-7 py-2" }, kke = { class: "text-center text-base text-ink-gray-5" }, Ake = ["onDrop", "onDblclick"], Mke = { class: "flex gap-1 w-full flex-col items-center text-xs text-right" }, Dke = {
  key: 1,
  class: "z-10 w-full bg-surface-white py-1 px-2 text-ink-gray-4"
}, Oke = {
  key: 2,
  class: "w-full"
}, Ike = {
  key: 3,
  class: "flex w-full flex-col justify-between"
}, Lke = {
  __name: "CalendarMonthly",
  props: {
    events: {
      type: Object,
      required: !0
    },
    currentMonthDates: {
      type: Array,
      required: !0
    },
    currentMonth: {
      type: Number,
      required: !0
    },
    config: {
      type: Object
    }
  },
  emits: ["setCurrentDate"],
  setup(n, { emit: e }) {
    const t = n, r = e, i = K(
      () => qm(t.events, "Month").timedEvents.value
    ), a = K(
      () => t.currentMonthDates.length > 35 ? 1 : 2
    );
    function o(c) {
      return c.getMonth() === t.currentMonth;
    }
    const s = Xt("calendarActions"), l = (c, d) => {
      d && (c.target.style.opacity = "0.5", c.target.style.cursor = "move", c.dataTransfer.dropEffect = "move", c.dataTransfer.effectAllowed = "move", c.dataTransfer.setData("calendarEventID", d));
    }, u = (c, d) => {
      let f = c.dataTransfer.getData("calendarEventID");
      if (!f) return;
      c.target.style.cursor = "default";
      let p = t.events.find((v) => v.id === f);
      if (kr(d) === p.date) return;
      let h = t.events.find((v) => v.id === f);
      h.date = kr(d), s.updateEventState(h);
    };
    return (c, d) => (L(), W("div", Tke, [
      G("div", Cke, [
        (L(!0), W(Ke, null, _t(O(b9), (f) => (L(), W("span", kke, ke(f), 1))), 256))
      ]),
      G("div", {
        class: _e(["grid w-full flex-1 grid-cols-7 border-outline-gray-1", [
          n.currentMonthDates.length > 35 ? "grid-rows-6" : "grid-rows-5",
          n.config.noBorder ? "border-t-[0.5px]" : "border-[0.5px]"
        ]])
      }, [
        (L(!0), W(Ke, null, _t(n.currentMonthDates, (f) => {
          var p;
          return L(), W("div", {
            class: "overflow-y-auto border-[0.5px]",
            onDragover: d[4] || (d[4] = xt(() => {
            }, ["prevent"])),
            onDrageneter: d[5] || (d[5] = xt(() => {
            }, ["prevent"])),
            onDrop: (h) => u(h, f),
            onDblclick: (h) => O(s).handleCellDblClick(h, f)
          }, [
            G("div", {
              class: _e(["flex justify-center font-normal", o(f) ? "text-gray-700" : "text-gray-200"])
            }, [
              G("div", Mke, [
                o(f) ? (L(), W("span", {
                  key: 0,
                  class: _e(["z-10 w-full flex justify-between items-center", [
                    f.toDateString() === (/* @__PURE__ */ new Date()).toDateString() ? "py-0.5 px-1" : "py-1 px-2"
                  ]])
                }, [
                  d[6] || (d[6] = G("div", null, null, -1)),
                  G("div", {
                    class: _e([
                      f.toDateString() === (/* @__PURE__ */ new Date()).toDateString() ? "bg-surface-gray-7 text-ink-white rounded-sm p-[2px]" : "bg-surface-white text-ink-gray-6"
                    ])
                  }, ke(f.getDate()), 3)
                ], 2)) : (L(), W("span", Dke, ke(O(g9)(f, c.showDay = !1)), 1)),
                ((p = i.value[O(kr)(f)]) == null ? void 0 : p.length) <= a.value ? (L(), W("div", Oke, [
                  (L(!0), W(Ke, null, _t(i.value[O(kr)(f)], (h) => (L(), re(Bp, {
                    event: h,
                    date: f,
                    class: "z-10 mb-2 w-full cursor-pointer",
                    key: h.id,
                    draggable: n.config.isEditMode,
                    onDragstart: (v) => l(v, h.id),
                    onDragend: d[0] || (d[0] = (v) => v.target.style.opacity = "1"),
                    onDragover: d[1] || (d[1] = xt(() => {
                    }, ["prevent"]))
                  }, null, 8, ["event", "date", "draggable", "onDragstart"]))), 128))
                ])) : (L(), W("div", Ike, [
                  i.value[O(kr)(f)] ? (L(), re(S9, {
                    key: 0,
                    class: "z-10 cursor-pointer",
                    draggable: n.config.isEditMode,
                    onDragstart: (h) => l(h, i.value[O(kr)(f)][0].id),
                    onDragend: d[2] || (d[2] = (h) => h.target.style.opacity = "1"),
                    onDragover: d[3] || (d[3] = xt(() => {
                    }, ["prevent"])),
                    event: i.value[O(kr)(f)][0],
                    date: f,
                    totalEventsCount: i.value[O(kr)(f)].length,
                    onShowMoreEvents: (h) => r("setCurrentDate", f)
                  }, null, 8, ["draggable", "onDragstart", "event", "date", "totalEventsCount", "onShowMoreEvents"])) : ge("", !0)
                ]))
              ])
            ], 2)
          ], 40, Ake);
        }), 256))
      ], 2)
    ]));
  }
}, Nke = {
  __name: "CalendarTimeMarker",
  props: {
    date: {
      type: String,
      required: !0
    },
    redundantCellHeight: {
      type: Number,
      default: 0
    }
  },
  setup(n) {
    const e = n, i = Xt("config").hourHeight / 60, a = K(() => {
      let o = /* @__PURE__ */ new Date(), s = o.getHours(), l = o.getMinutes();
      return { top: (s * 60 + l) * i + e.redundantCellHeight + "px" };
    });
    return (o, s) => new Date(n.date).toDateString() === (/* @__PURE__ */ new Date()).toDateString() ? (L(), W("div", {
      key: 0,
      class: "absolute top-20 z-10 w-full pl-2",
      style: An(a.value)
    }, [...s[0] || (s[0] = [
      G("div", { class: "current-time relative h-0.5 bg-red-600" }, null, -1)
    ])], 4)) : ge("", !0);
  }
}, E9 = /* @__PURE__ */ zt(Nke, [["__scopeId", "data-v-93dcdf88"]]), Rke = { class: "flex flex-col overflow-y-auto" }, Pke = { class: "flex border-b-[1px]" }, jke = { class: "mb-2 grid w-full grid-cols-7" }, Bke = {
  key: 0,
  class: "absolute left-[45%] top-0 h-[2px] w-5 bg-surface-gray-7"
}, $ke = { class: "flex" }, zke = { class: "grid w-16 grid-cols-1" }, Fke = { class: "flex w-full flex-col" }, Vke = { class: "grid w-full grid-cols-7" }, Hke = ["data-date-attr"], Gke = {
  key: 1,
  class: "w-full"
}, Uke = {
  key: 2,
  class: "flex flex-col justify-between"
}, Wke = { class: "grid w-full grid-cols-7" }, qke = ["data-date-attr"], Yke = ["data-time-attr", "onDblclick"], Kke = {
  __name: "CalendarWeekly",
  props: {
    events: {
      type: Object,
      required: !0
    },
    config: {
      type: Object
    },
    weeklyDates: {
      type: Array,
      required: !1
    }
  },
  setup(n) {
    const e = n, t = Z(null), r = Z(null), i = Z(!1), a = Z(!1), o = e.config.hourHeight, s = o / 60, l = e.config.timeFormat == "24h" ? x9 : _9, u = K(
      () => qm(e.events).timedEvents.value
    ), c = K(
      () => qm(e.events).fullDayEvents.value
    ), d = (y) => new Date(y).toDateString() === (/* @__PURE__ */ new Date()).toDateString(), f = Xt("calendarActions"), p = e.config.redundantCellHeight, h = (y) => p + 36 * (y - 1);
    function v(y, b) {
      let _ = {}, x = Object.keys(y);
      return b.forEach((w) => {
        w = kr(w), x.includes(w) && (_[w] = y[w]);
      }), _;
    }
    function m(y) {
      let b = [];
      return Object.values(y).forEach((x) => {
        b.push(x.length);
      }), Math.max(...b, 1);
    }
    function g(y, b) {
      let _ = v(
        y,
        b
      ), x = m(_);
      x > 3 ? i.value = !0 : i.value = !1;
      let w = h(x);
      a.value || r.value.forEach((S) => {
        S.style.height = w + "px";
      });
    }
    return kt(() => {
      g(c.value, e.weeklyDates);
      const y = (/* @__PURE__ */ new Date()).getHours();
      t.value.scrollBy(0, y * 60 * s);
    }), et(a, (y) => {
      y ? r.value.forEach((b) => {
        b.style.height = "56px";
      }) : g(c.value, e.weeklyDates);
    }), et(
      () => c.value,
      (y) => {
        g(y, e.weeklyDates);
      }
    ), et(
      () => e.weeklyDates,
      (y) => {
        g(c.value, y);
      }
    ), (y, b) => (L(), W("div", Rke, [
      G("div", Pke, [
        b[2] || (b[2] = G("div", { class: "w-16" }, null, -1)),
        G("div", jke, [
          (L(!0), W(Ke, null, _t(n.weeklyDates, (_) => (L(), W("span", {
            class: _e([
              "relative p-2 text-center text-sm text-gray-600",
              d(_) ? "font-semibold text-ink-gray-8" : "font-normal"
            ])
          }, [
            d(_) ? (L(), W("div", Bke)) : ge("", !0),
            gn(" " + ke(O(OC)(_)), 1)
          ], 2))), 256))
        ])
      ]),
      G("div", {
        class: _e(["relative flex h-full flex-col overflow-auto border-outline-gray-1", [n.config.noBorder ? "" : "border-b-[1px] border-l-[1px]"]]),
        ref_key: "gridRef",
        ref: t
      }, [
        G("div", $ke, [
          G("div", zke, [
            (L(), W(Ke, null, _t(24, (_) => G("span", {
              class: "flex items-end justify-center text-center text-sm font-normal text-gray-600",
              style: An({ height: `${O(o)}px` })
            }, null, 4)), 64))
          ]),
          G("div", Fke, [
            G("div", Vke, [
              (L(!0), W(Ke, null, _t(n.weeklyDates, (_, x) => {
                var w;
                return L(), W("div", null, [
                  G("div", {
                    class: _e(["flex w-full flex-col gap-1 border-b-[1px] border-r-[1px] border-outline-gray-1 transition-all", [
                      x === 0 && "relative border-l-[1px]",
                      n.config.noBorder && x === n.weeklyDates.length - 1 && "border-r-0"
                    ]]),
                    ref_for: !0,
                    ref_key: "allDayCells",
                    ref: r,
                    "data-date-attr": _
                  }, [
                    i.value ? (L(), re(O(fn), {
                      key: 0,
                      onClick: b[0] || (b[0] = (S) => a.value = !a.value),
                      class: "absolute -left-[42px] bottom-[4px] cursor-pointer font-bold",
                      icon: a.value ? "chevron-down" : "chevron-up",
                      variant: "ghost"
                    }, null, 8, ["icon"])) : ge("", !0),
                    a.value ? (L(), W("div", Uke, [
                      ((w = c.value[O(kr)(_)]) == null ? void 0 : w.length) > 0 ? (L(), re(S9, {
                        key: 0,
                        event: c.value[O(kr)(_)][0],
                        class: "w-[90%]",
                        date: _,
                        totalEventsCount: c.value[O(kr)(_)].length,
                        onShowMoreEvents: b[1] || (b[1] = (S) => a.value = !a.value)
                      }, null, 8, ["event", "date", "totalEventsCount"])) : ge("", !0)
                    ])) : (L(), W("div", Gke, [
                      (L(!0), W(Ke, null, _t(c.value[O(kr)(_)], (S, C) => (L(), re(Bp, {
                        class: "!z-1 mb-1 w-[90%] cursor-pointer",
                        event: { ...S, idx: C },
                        key: S.id,
                        date: _
                      }, null, 8, ["event", "date"]))), 128))
                    ]))
                  ], 10, Hke)
                ]);
              }), 256))
            ]),
            G("div", Wke, [
              (L(!0), W(Ke, null, _t(n.weeklyDates, (_, x) => (L(), W("div", {
                class: _e(["relative w-full border-r-[1px] border-outline-gray-1", [
                  x === 0 && "calendar-column border-l-[1px]",
                  n.config.noBorder && x == n.weeklyDates.length - 1 && "border-r-0"
                ]]),
                "data-date-attr": _
              }, [
                (L(!0), W(Ke, null, _t(O(l), (w, S) => (L(), W("div", {
                  class: "cell relative flex cursor-pointer text-ink-gray-8",
                  key: w,
                  "data-time-attr": w,
                  onDblclick: xt((C) => O(f).handleCellDblClick(C, _, w), ["prevent"])
                }, [
                  G("div", {
                    class: _e(["border-outline-gray-1 w-full border-b-[1px]", S === O(l).length - 1 && "border-b-0"]),
                    style: An({ height: `${O(o)}px` })
                  }, null, 6)
                ], 40, Yke))), 128)),
                (L(!0), W(Ke, null, _t(u.value[O(kr)(_)], (w, S) => (L(), re(Bp, {
                  class: "absolute mb-2 w-[90%] cursor-pointer",
                  event: w,
                  key: w.id,
                  date: _
                }, null, 8, ["event", "date"]))), 128)),
                se(E9, { date: _ }, null, 8, ["date"])
              ], 10, qke))), 256))
            ])
          ])
        ])
      ], 2)
    ]));
  }
}, Xke = { class: "h-[90%] min-h-[500px] min-w-[600px]" }, Zke = { class: "pb-2 text-base font-semibold text-ink-gray-8" }, Jke = { class: "h-full overflow-hidden" }, Qke = { class: "grid h-full w-16 grid-cols-1" }, eAe = { class: "grid h-full w-full grid-cols-1 pb-2" }, tAe = { class: "calendar-column relative border-r-[1px] border-l-[1px] border-outline-gray-1" }, nAe = ["data-time-attr", "onDblclick"], rAe = {
  __name: "CalendarDaily",
  props: {
    events: {
      type: Object,
      required: !1
    },
    config: {
      type: Object
    },
    currentDate: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = n, t = K(
      () => qm(e.events).timedEvents.value
    ), r = K(
      () => qm(e.events).fullDayEvents.value
    ), i = Z(null), a = e.config.hourHeight, o = a / 60, s = e.config.timeFormat == "24h" ? x9 : _9;
    kt(() => {
      const u = (/* @__PURE__ */ new Date()).getHours();
      i.value.scrollBy(0, u * 60 * o);
    });
    const l = Xt("calendarActions");
    return (u, c) => (L(), W("div", Xke, [
      ue(u.$slots, "header", Bt(Jt({ parseDateWithDay: O(OC), currentDate: n.currentDate, fullDay: u.fullDay })), () => [
        G("p", Zke, ke(O(OC)(n.currentDate, u.fullDay = !0)), 1)
      ]),
      G("div", Jke, [
        G("div", {
          class: _e(["flex h-full w-full overflow-scroll border-outline-gray-1", [
            n.config.noBorder ? "border-t-[1px]" : "border-[1px] border-r-0"
          ]]),
          ref_key: "gridRef",
          ref: i
        }, [
          G("div", Qke, [
            (L(), W(Ke, null, _t(24, (d) => G("span", {
              class: "flex h-[72px] items-end justify-center text-center text-sm font-normal text-ink-gray-5",
              style: An({ height: `${O(a)}px` })
            }, null, 4)), 64))
          ]),
          G("div", eAe, [
            G("div", tAe, [
              G("div", {
                class: "flex h-[50px] w-full flex-wrap gap-2 overflow-y-scroll border-b-[1px] border-outline-gray-1 transition-all",
                style: An({ height: `${n.config.redundantCellHeight}px` })
              }, [
                (L(!0), W(Ke, null, _t(r.value[O(kr)(n.currentDate)], (d, f) => (L(), re(Bp, {
                  class: "mb-1 w-[20%] cursor-pointer",
                  event: { ...d, idx: f },
                  key: d.id,
                  date: n.currentDate
                }, null, 8, ["event", "date"]))), 128))
              ], 4),
              (L(!0), W(Ke, null, _t(O(s), (d) => (L(), W("div", {
                class: "relative flex text-ink-gray-8",
                key: d,
                "data-time-attr": d,
                onDblclick: (f) => O(l).handleCellDblClick(f, n.currentDate, d)
              }, [
                G("div", {
                  class: "w-full border-b-[1px] border-outline-gray-1",
                  style: An({ height: `${O(a)}px` })
                }, null, 4)
              ], 40, nAe))), 128)),
              (L(!0), W(Ke, null, _t(t.value[O(kr)(n.currentDate)], (d, f) => (L(), re(Bp, {
                class: "absolute mb-2 cursor-pointer",
                event: d,
                key: d.id,
                date: n.currentDate
              }, null, 8, ["event", "date"]))), 128)),
              se(E9, {
                date: n.currentDate,
                redundantCellHeight: n.config.redundantCellHeight
              }, null, 8, ["date", "redundantCellHeight"])
            ])
          ])
        ], 2)
      ])
    ]));
  }
};
function iAe() {
  const n = Z(!1), e = Sr({
    date: "",
    participant: "",
    from_time: "",
    to_time: "",
    venue: "",
    title: ""
  });
  function t(r, i, a, o, s = "") {
    if (!o) return;
    if (a = i === "Week" ? r.target.parentNode.parentNode.getAttribute("data-date-attr") : a, e.date = kr(new Date(a)), i === "Month") {
      n.value = !0;
      return;
    }
    let l = h1(ha(s) + 60).slice(
      0,
      -3
    );
    e.from_time = s, e.to_time = l, n.value = !0;
  }
  return { showEventModal: n, newEvent: e, openNewEventModal: t };
}
const aAe = { class: "flex h-full flex-col overflow-hidden" }, oAe = { class: "mb-2 flex justify-between" }, sAe = { class: "text-lg font-medium text-ink-gray-8" }, lAe = { class: "flex gap-x-1" }, HUe = {
  __name: "Calendar",
  props: {
    events: {
      type: Object,
      required: !1,
      default: []
    },
    config: {
      type: Object
    },
    onClick: {
      type: Function,
      required: !1
    },
    onDblClick: {
      type: Function,
      required: !1
    },
    onCellDblClick: {
      type: Function,
      required: !1
    }
  },
  emits: ["create", "update", "delete"],
  setup(n, { expose: e, emit: t }) {
    const r = n, i = t, o = { ...{
      scrollToHour: 15,
      disableModes: [],
      defaultMode: "Month",
      isEditMode: !1,
      eventIcons: {},
      redundantCellHeight: 50,
      hourHeight: 50,
      enableShortcuts: !0,
      showIcon: !0,
      timeFormat: "12h"
    }, ...r.config };
    let s = Z(o.defaultMode);
    function l(oe) {
      console.log(oe), s.value = oe;
    }
    kt(() => {
      o.enableShortcuts && window.addEventListener("keydown", u);
    }), Nn(() => {
      window.removeEventListener("keydown", u);
    });
    function u(oe) {
      (oe.key === "m" || oe.key === "M") && (s.value = "Month"), (oe.key === "w" || oe.key === "W") && (s.value = "Week"), (oe.key === "d" || oe.key === "D") && (s.value = "Day"), oe.key === "ArrowLeft" && X(), oe.key === "ArrowRight" && J();
    }
    zn("activeView", s), zn("config", o);
    const c = K(() => {
      var oe;
      return ((oe = r.events) == null ? void 0 : oe.map((he) => {
        const { fromDate: Oe, toDate: Te, ...Ge } = he, je = kr(Oe), Qe = Cm(Oe).format("HH:mm:ss"), ot = Cm(Te).format("HH:mm:ss");
        return he.isFullDay ? { ...Ge, date: je } : { ...Ge, date: je, from_time: Qe, to_time: ot };
      })) || [];
    }), d = Z(c.value);
    function f() {
      d.value = c.value;
    }
    const { showEventModal: p, newEvent: h, openNewEventModal: v } = iAe();
    zn("calendarActions", {
      createNewEvent: m,
      updateEventState: g,
      deleteEvent: y,
      handleCellDblClick: _,
      props: r
    });
    function m(oe) {
      d.value.push(oe), oe.fromDate = oe.date + " " + oe.from_time, oe.toDate = oe.date + " " + oe.to_time, i("create", oe);
    }
    function g(oe) {
      const he = oe.id;
      let Oe = d.value.findIndex((Te) => Te.id === he);
      oe.fromDate = oe.date + " " + oe.from_time, oe.toDate = oe.date + " " + oe.to_time, d.value[Oe] = oe, i("update", oe);
    }
    function y(oe) {
      const he = d.value.findIndex((Oe) => Oe.id === oe);
      d.value.splice(he, 1), i("delete", oe);
    }
    function b(oe) {
      const { e: he, view: Oe, date: Te, time: Ge } = oe, je = o.isEditMode;
      v(he, Oe, Te, je, Ge);
    }
    function _(oe, he, Oe = "") {
      const Te = {
        e: oe,
        view: s.value,
        date: he,
        time: Oe
      };
      if (r.onCellDblClick) {
        r.onCellDblClick(Te);
        return;
      }
      b(Te);
    }
    let w = [
      { label: "Day", variant: "solid" },
      { label: "Week", variant: "solid" },
      { label: "Month", variant: "solid" }
    ].filter(
      (oe) => !o.disableModes.includes(oe.label)
    ), S = Z((/* @__PURE__ */ new Date()).getFullYear()), C = Z((/* @__PURE__ */ new Date()).getMonth()), k = Z(/* @__PURE__ */ new Date()), M = K(() => YCe(C.value, S.value)), D = K(() => {
      let oe = [...M.value], he = [];
      for (; oe.length; ) {
        let Oe = oe.splice(0, 7);
        he.push(Oe);
      }
      return he;
    });
    function N(oe) {
      return D.value.findIndex(
        (he) => he.find(
          (Oe) => new Date(Oe).toLocaleDateString().split("T")[0] === new Date(oe).toLocaleDateString().split("T")[0]
        )
      );
    }
    let R = Z(N(k.value)), j = Z(
      M.value.findIndex(
        (oe) => new Date(oe).toDateString() === k.value.toDateString()
      )
    ), z = K(() => M.value[j.value]);
    function F(oe) {
      s.value = "Day", j.value = Pe(oe), R.value = N(oe);
    }
    const B = {
      Month: Y,
      Week: ie,
      Day: Be
    }, H = {
      Month: ne,
      Week: ye,
      Day: Ce
    };
    function Y() {
      C.value++, j.value = ce(C.value, S.value), R.value = N(M.value[j.value]) + 1, C.value > 11 && (C.value = 0, S.value++);
    }
    function ne() {
      C.value--, j.value = Ee(C.value, S.value), R.value = N(M.value[j.value]), C.value < 0 && (C.value = 11, S.value--);
    }
    function J() {
      B[s.value]();
    }
    function X() {
      H[s.value]();
    }
    function ie() {
      R.value += 1, R.value < D.value.length && (j.value = Pe(D.value[R.value][0])), R.value > D.value.length - 1 && Y();
      let oe = pe();
      oe.length > 0 && (Y(), R.value = N(oe[0]));
    }
    function ye() {
      if (R.value -= 1, R.value < 0) {
        ne();
        return;
      }
      R.value > 0 && (j.value = Pe(D.value[R.value][0]));
      let oe = pe();
      oe.length > 0 && (ne(), R.value = N(oe[0]));
    }
    function pe() {
      return D.value[R.value].filter(
        (Oe) => Oe.getMonth() !== C.value
      );
    }
    function Be() {
      j.value++, (j.value > M.value.length - 1 || !fe(M.value[j.value])) && Y();
    }
    function Ce() {
      j.value--, (j.value < 0 || !fe(M.value[j.value])) && ne();
    }
    function Ee(oe, he) {
      let Oe = new Date(he, oe + 1, 0);
      return M.value.findIndex(
        (Ge) => new Date(Ge).toDateString() === Oe.toDateString()
      );
    }
    function ce(oe, he) {
      let Oe = new Date(he, oe, 1);
      return M.value.findIndex(
        (Ge) => new Date(Ge).toDateString() === Oe.toDateString()
      );
    }
    function Pe(oe) {
      return M.value.findIndex(
        (he) => new Date(he).toDateString() === new Date(oe).toDateString()
      );
    }
    const Ae = K(() => XCe[C.value] + ", " + S.value);
    function fe(oe) {
      return oe = new Date(oe), oe.getMonth() === C.value;
    }
    return e({ reloadEvents: f }), (oe, he) => (L(), W("div", aAe, [
      ue(oe.$slots, "header", Bt(Jt({
        currentMonthYear: Ae.value,
        enabledModes: O(w),
        activeView: O(s),
        decrement: X,
        increment: J,
        updateActiveView: l
      })), () => [
        G("div", oAe, [
          G("span", sAe, ke(Ae.value), 1),
          G("div", lAe, [
            se(O(fn), {
              onClick: he[0] || (he[0] = (Oe) => X()),
              variant: "ghost",
              class: "h-4 w-4",
              icon: "chevron-left"
            }),
            se(O(fn), {
              onClick: he[1] || (he[1] = (Oe) => J()),
              variant: "ghost",
              class: "h-4 w-4",
              icon: "chevron-right"
            }),
            se(O(p6), {
              buttons: O(w),
              class: "ml-2",
              modelValue: O(s),
              "onUpdate:modelValue": he[2] || (he[2] = (Oe) => al(s) ? s.value = Oe : s = Oe)
            }, null, 8, ["buttons", "modelValue"])
          ])
        ])
      ]),
      O(s) === "Month" ? (L(), re(Lke, {
        key: 0,
        events: d.value,
        currentMonth: O(C),
        currentMonthDates: O(M),
        config: o,
        onSetCurrentDate: he[3] || (he[3] = (Oe) => F(Oe))
      }, null, 8, ["events", "currentMonth", "currentMonthDates"])) : O(s) === "Week" ? (L(), re(Kke, {
        key: 1,
        events: d.value,
        weeklyDates: O(D)[O(R)],
        config: o
      }, null, 8, ["events", "weeklyDates"])) : O(s) === "Day" ? (L(), re(rAe, {
        key: 2,
        events: d.value,
        "current-date": O(z),
        config: o
      }, {
        header: ee(({ parseDateWithDay: Oe, currentDate: Te, fullDay: Ge }) => [
          ue(oe.$slots, "daily-header", Bt(Jt({ parseDateWithDay: Oe, currentDate: Te, fullDay: Ge })))
        ]),
        _: 3
      }, 8, ["events", "current-date"])) : ge("", !0),
      O(p) ? (L(), re(w9, {
        key: 3,
        modelValue: O(p),
        "onUpdate:modelValue": he[4] || (he[4] = (Oe) => al(p) ? p.value = Oe : null),
        event: O(h)
      }, null, 8, ["modelValue", "event"])) : ge("", !0)
    ]));
  }
}, GUe = {
  __name: "NestedPopover",
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    }
  },
  setup(n) {
    const e = n, t = Z(null), r = Z(null);
    let i = Z(null);
    function a() {
      i.value ? i.value.update() : i.value = dH(t.value.el, r.value.el, {
        placement: e.placement
      });
    }
    function o() {
      Wt(() => a());
    }
    return Io(() => {
      var s;
      (s = i.value) == null || s.destroy();
    }), (s, l) => (L(), re(O(KF), null, {
      default: ee(({ open: u }) => [
        se(O(PJ), {
          as: "div",
          ref_key: "reference",
          ref: t,
          onClick: o,
          onFocusin: o,
          onKeydown: o
        }, {
          default: ee(({ open: c }) => [
            ue(s.$slots, "target", Bt(Jt({ open: c })))
          ]),
          _: 2
        }, 1536),
        ta(G("div", null, [
          se(O(jJ), {
            ref_key: "popover",
            ref: r,
            static: "",
            class: "z-[100]"
          }, {
            default: ee(({ open: c, close: d }) => [
              ue(s.$slots, "body", Bt(Jt({ open: c, close: d })))
            ]),
            _: 2
          }, 1536)
        ], 512), [
          [hs, u]
        ])
      ]),
      _: 3
    }));
  }
}, uAe = { key: 0 }, cAe = { key: 0 }, dAe = { key: 1 }, fAe = /* @__PURE__ */ ve({
  __name: "CircularProgressBar",
  props: {
    step: { default: 1 },
    totalSteps: { default: 4 },
    showPercentage: { type: Boolean, default: !1 },
    variant: { default: "solid" },
    theme: { default: "black" },
    size: { default: "md" },
    themeComplete: { default: "lightgreen" }
  },
  setup(n) {
    jZ((l) => ({
      "3c328214": r.value.ringSize,
      "60dab606": r.value.ringBarWidth,
      "01f66360": r.value.innerTextFontSize,
      85081942: r.value.checkIconSize,
      "4ab79353": a.value.primary,
      "8f9a32f6": a.value.secondary,
      "8a86236c": l.$props.themeComplete,
      "57c7e7aa": o.value + "%"
    }));
    const e = n, t = {
      xs: {
        ringSize: "30px",
        ringBarWidth: "6px",
        innerTextFontSize: e.showPercentage ? "8px" : "12px",
        checkIconSize: "16px"
      },
      sm: {
        ringSize: "42px",
        ringBarWidth: "10px",
        innerTextFontSize: e.showPercentage ? "12px" : "16px",
        checkIconSize: "20px"
      },
      md: {
        ringSize: "60px",
        ringBarWidth: "14px",
        innerTextFontSize: e.showPercentage ? "16px" : "20px",
        checkIconSize: "24px"
      },
      lg: {
        ringSize: "84px",
        ringBarWidth: "18px",
        innerTextFontSize: e.showPercentage ? "20px" : "24px",
        checkIconSize: "40px"
      },
      xl: {
        ringSize: "108px",
        ringBarWidth: "22px",
        innerTextFontSize: e.showPercentage ? "24px" : "28px",
        checkIconSize: "48px"
      }
    }, r = K(() => t[e.size] || t.md), i = {
      black: {
        primary: "#333",
        secondary: "#888"
      },
      red: {
        primary: "#FF0000",
        secondary: "#FFD7D7"
      },
      green: {
        primary: "#22C55E",
        secondary: "#b1ffda"
      },
      blue: {
        primary: "#2376f5",
        secondary: "#D7D7FF"
      },
      orange: {
        primary: "#FFA500",
        secondary: "#FFE5CC"
      }
    }, a = K(() => typeof e.theme == "string" ? i[e.theme] || i.black : e.theme), o = K(() => e.step / e.totalSteps * 100), s = K(() => e.step === e.totalSteps);
    return (l, u) => (L(), W("div", {
      class: _e(["progressbar", {
        completed: s.value,
        fillOuter: l.variant === "outline"
      }]),
      role: "progressbar"
    }, [
      s.value ? (L(), re(En, {
        key: 1,
        name: "check",
        class: "check-icon"
      })) : (L(), W("div", uAe, [
        l.showPercentage ? (L(), W("p", dAe, ke(o.value.toFixed(0)) + "%", 1)) : (L(), W("p", cAe, ke(l.step), 1))
      ]))
    ], 2));
  }
}), UUe = /* @__PURE__ */ zt(fAe, [["__scopeId", "data-v-2fbcbc53"]]), pAe = {
  key: 0,
  class: "flex"
}, WUe = /* @__PURE__ */ ve({
  __name: "Tree",
  props: {
    node: {},
    nodeKey: {},
    options: { default: () => ({
      rowHeight: "25px",
      indentWidth: "20px",
      showIndentationGuides: !0,
      defaultCollapsed: !0
    }) }
  },
  setup(n) {
    const e = n;
    Xp();
    const t = Z(e.options.defaultCollapsed ?? !0), r = Z(""), i = K(() => {
      var s;
      return ((s = e.node.children) == null ? void 0 : s.length) > 0;
    }), a = Z(null), o = (s) => {
      s.stopPropagation(), i.value && (t.value = !t.value);
    };
    return kt(() => {
      var s;
      (s = a.value) != null && s.clientWidth && (r.value = a.value.clientWidth / 2 + "px");
    }), (s, l) => {
      const u = ol("Tree", !0);
      return L(), W(Ke, null, [
        ue(s.$slots, "node", Bt(Jt({ node: s.node, hasChildren: i.value, isCollapsed: t.value, toggleCollapsed: o })), () => [
          G("div", {
            class: "flex items-center cursor-pointer gap-1",
            style: An({ height: s.options.rowHeight }),
            onClick: o
          }, [
            G("div", {
              ref_key: "iconRef",
              ref: a
            }, [
              ue(s.$slots, "icon", Bt(Jt({ hasChildren: i.value, isCollapsed: t.value })), () => [
                i.value && !t.value ? (L(), re(En, {
                  key: 0,
                  name: "chevron-down",
                  class: "h-3.5"
                })) : i.value ? (L(), re(En, {
                  key: 1,
                  name: "chevron-right",
                  class: "h-3.5"
                })) : ge("", !0)
              ])
            ], 512),
            ue(s.$slots, "label", Bt(Jt({ node: s.node, hasChildren: i.value, isCollapsed: t.value })), () => [
              G("div", {
                class: _e(["text-base truncate", i.value ? "" : "pl-3.5"])
              }, ke(s.node.label), 3)
            ])
          ], 4)
        ]),
        i.value && !t.value ? (L(), W("div", pAe, [
          s.options.showIndentationGuides ? (L(), W("div", {
            key: 0,
            style: An({ paddingLeft: r.value }),
            class: "border-r"
          }, null, 4)) : ge("", !0),
          G("ul", {
            class: "w-full",
            style: An({ paddingLeft: s.options.indentWidth })
          }, [
            (L(!0), W(Ke, null, _t(s.node.children, (c) => (L(), W("li", {
              key: c[s.nodeKey]
            }, [
              se(u, {
                node: c,
                nodeKey: s.nodeKey,
                options: s.options
              }, {
                node: ee(({ node: d, hasChildren: f, isCollapsed: p, toggleCollapsed: h }) => [
                  ue(s.$slots, "node", He({ ref_for: !0 }, { node: d, hasChildren: f, isCollapsed: p, toggleCollapsed: h }))
                ]),
                icon: ee(({ hasChildren: d, isCollapsed: f }) => [
                  ue(s.$slots, "icon", He({ ref_for: !0 }, { hasChildren: d, isCollapsed: f }))
                ]),
                label: ee(({ node: d, hasChildren: f, isCollapsed: p }) => [
                  ue(s.$slots, "label", He({ ref_for: !0 }, { node: d, hasChildren: f, isCollapsed: p }))
                ]),
                _: 2
              }, 1032, ["node", "nodeKey", "options"])
            ]))), 128))
          ], 4)
        ])) : ge("", !0)
      ], 64);
    };
  }
}), hAe = { class: "w-8 h-8 rounded overflow-hidden" }, vAe = ["src"], mAe = {
  key: 1,
  class: "w-full h-full bg-surface-gray-4 flex items-center justify-center text-ink-gray-7"
}, gAe = { class: "text-base font-medium text-ink-gray-8 leading-none" }, yAe = { class: "mt-1 text-sm text-ink-gray-6 leading-none" }, bAe = /* @__PURE__ */ ve({
  __name: "SidebarHeader",
  props: {
    title: {},
    subtitle: {},
    logo: {},
    menuItems: {}
  },
  setup(n) {
    const e = n, t = Xt("isSidebarCollapsed", !1);
    return (r, i) => (L(), re(KV, {
      options: e.menuItems
    }, {
      default: ee(({ open: a }) => [
        G("button", {
          class: _e([
            "flex h-12 items-center rounded-md py-2 duration-300 ease-in-out w-[14rem]",
            O(t) ? "w-auto px-0" : a ? "bg-surface-white px-2 shadow-sm" : "px-2 hover:bg-surface-gray-3"
          ])
        }, [
          G("div", hAe, [
            ue(r.$slots, "logo", {}, () => [
              typeof e.logo == "string" ? (L(), W("img", {
                key: 0,
                src: e.logo,
                class: "w-full h-full object-cover",
                alt: "Logo"
              }, null, 8, vAe)) : e.logo ? (L(), re(bn(e.logo), {
                key: 2,
                class: "w-full h-full"
              })) : (L(), W("div", mAe, ke(e.title.charAt(0).toUpperCase()), 1))
            ])
          ]),
          G("div", {
            class: _e([
              "flex flex-1 flex-col text-left duration-300 ease-in-out truncate",
              O(t) ? "ml-0 w-0 overflow-hidden opacity-0" : "ml-2 w-auto opacity-100"
            ])
          }, [
            G("div", gAe, ke(e.title), 1),
            G("div", yAe, ke(e.subtitle), 1)
          ], 2),
          G("div", {
            class: _e([
              "duration-300 ease-in-out",
              O(t) ? "ml-0 w-0 overflow-hidden opacity-0" : "ml-2 w-auto opacity-100"
            ])
          }, [
            se(O(ZV), { class: "h-4 w-4 text-ink-gray-7" })
          ], 2)
        ], 2)
      ]),
      _: 3
    }, 8, ["options"]));
  }
}), _Ae = { class: "flex w-full items-center justify-between transition-all ease-in-out px-2 py-1" }, xAe = { class: "flex items-center truncate" }, wAe = { class: "grid flex-shrink-0 place-items-center" }, SAe = {
  key: 0,
  class: "size-4 text-ink-gray-6"
}, EAe = {
  key: 0,
  class: "text-sm text-ink-gray-4"
}, T9 = /* @__PURE__ */ ve({
  __name: "SidebarItem",
  props: {
    label: {},
    accessKey: {},
    icon: {},
    suffix: {},
    to: {},
    isActive: { type: Boolean },
    onClick: { type: Function }
  },
  setup(n) {
    const e = n, t = Xt("isSidebarCollapsed", !1), r = sx();
    function i() {
      e.onClick ? e.onClick() : e.to && r.replace(e.to);
    }
    return (a, o) => (L(), re(fn, {
      label: e.label,
      onClick: i,
      class: _e([
        "!w-full",
        e.isActive ? "!bg-surface-selected shadow-sm" : "hover:bg-surface-gray-2"
      ]),
      variant: "ghost",
      accesskey: e.accessKey
    }, {
      icon: ee(() => [
        G("div", _Ae, [
          G("div", xAe, [
            se(Ei, {
              text: e.label,
              placement: "right",
              disabled: !O(t)
            }, {
              default: ee(() => [
                G("span", wAe, [
                  ue(a.$slots, "icon", {}, () => [
                    e.icon && typeof e.icon == "string" ? (L(), W("span", SAe, ke(e.icon), 1)) : (L(), re(bn(e.icon), {
                      key: 1,
                      class: "size-4 text-ink-gray-6"
                    }))
                  ])
                ])
              ]),
              _: 3
            }, 8, ["text", "disabled"]),
            se(Ei, {
              text: e.label,
              placement: "right",
              disabled: O(t),
              hoverDelay: 1.5
            }, {
              default: ee(() => [
                G("span", {
                  class: _e([
                    "flex-1 flex-shrink-0 truncate text-sm transition-all ease-in-out",
                    O(t) ? "ml-0 w-0 overflow-hidden opacity-0" : "ml-2 w-auto opacity-100"
                  ])
                }, ke(e.label), 3)
              ]),
              _: 1
            }, 8, ["text", "disabled"])
          ]),
          G("div", {
            class: _e([
              "transition-all ease-in-out",
              O(t) ? "ml-0 w-0 overflow-hidden opacity-0" : "ml-auto w-auto opacity-100"
            ])
          }, [
            ue(a.$slots, "suffix", {}, () => [
              e.suffix ? (L(), W("span", EAe, ke(e.suffix), 1)) : ge("", !0)
            ])
          ], 2)
        ])
      ]),
      _: 3
    }, 8, ["label", "class", "accesskey"]));
  }
}), TAe = {
  class: "lucide lucide-panel-right-open",
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function CAe(n, e) {
  return L(), W("svg", TAe, [...e[0] || (e[0] = [
    G("rect", {
      width: "18",
      height: "18",
      x: "3",
      y: "3",
      rx: "2"
    }, null, -1),
    G("path", { d: "M15 3v18" }, null, -1),
    G("path", { d: "m10 15-3-3 3-3" }, null, -1)
  ])]);
}
const kAe = cn({ name: "lucide-panel-right-open", render: CAe }), AAe = { class: "flex flex-col mt-2" }, MAe = { key: 0 }, DAe = {
  key: 0,
  class: "space-y-0.5"
}, OAe = /* @__PURE__ */ ve({
  __name: "SidebarSection",
  props: {
    label: {},
    items: {},
    collapsible: { type: Boolean }
  },
  setup(n) {
    const e = n, t = Xt("isSidebarCollapsed", !1), r = Z(!1);
    return (i, a) => (L(), W("div", AAe, [
      e.label ? (L(), W("div", {
        key: 0,
        class: _e(["relative flex items-center gap-1 px-2 py-1.5", e.collapsible ? "cursor-pointer" : ""]),
        onClick: a[0] || (a[0] = (o) => e.collapsible ? r.value = !r.value : null)
      }, [
        G("h3", {
          class: _e([
            "h-4 text-sm text-ink-gray-5 transition-all duration-300 ease-in-out",
            O(t) ? "w-0 overflow-hidden opacity-0" : "w-auto opacity-100"
          ])
        }, ke(e.label), 3),
        e.collapsible ? (L(), W("div", MAe, [
          O(t) ? ge("", !0) : (L(), re(O(UH), {
            key: 0,
            class: _e(["w-4 h-4 text-ink-gray-5 transition-all duration-300 ease-in-out", { "rotate-90": !r.value }])
          }, null, 8, ["class"]))
        ])) : ge("", !0),
        O(t) ? (L(), W("div", {
          key: 1,
          class: _e(["absolute top-0 left-0 flex h-full w-full items-center justify-center transition-all duration-300 ease-in-out", O(t) ? "opacity-100" : "opacity-0"])
        }, [...a[1] || (a[1] = [
          G("hr", { class: "w-full border-t border-ink-gray-3" }, null, -1)
        ])], 2)) : ge("", !0)
      ], 2)) : ge("", !0),
      se(H_, {
        "enter-active-class": "duration-300 ease-in",
        "leave-active-class": "duration-300 ease-[cubic-bezier(0, 1, 0.5, 1)]",
        "enter-to-class": "max-h-[200px] overflow-hidden",
        "leave-from-class": "max-h-[200px] overflow-hidden",
        "enter-from-class": "max-h-0 overflow-hidden",
        "leave-to-class": "max-h-0 overflow-hidden"
      }, {
        default: ee(() => [
          r.value ? ge("", !0) : (L(), W("nav", DAe, [
            (L(!0), W(Ke, null, _t(e.items, (o) => (L(), re(T9, {
              key: o.label,
              label: o.label,
              accessKey: o.accessKey,
              icon: o.icon,
              suffix: o.suffix,
              to: o.to,
              isActive: o.isActive,
              isCollapsed: O(t),
              onClick: o.onClick
            }, null, 8, ["label", "accessKey", "icon", "suffix", "to", "isActive", "isCollapsed", "onClick"]))), 128))
          ]))
        ]),
        _: 1
      })
    ]));
  }
}), IAe = { class: "mt-auto flex flex-col gap-2" }, qUe = /* @__PURE__ */ ve({
  __name: "Sidebar",
  props: /* @__PURE__ */ MA({
    header: {},
    sections: {}
  }, {
    collapsed: {
      type: Boolean,
      default: null
    },
    collapsedModifiers: {}
  }),
  emits: ["update:collapsed"],
  setup(n) {
    const e = n, t = DA(n, "collapsed");
    zn("isSidebarCollapsed", t);
    const r = K(() => t.value || a.value), a = Dae(Mae).smaller("sm");
    return (o, s) => (L(), W("div", {
      class: _e(["flex h-full flex-col flex-shrink-0 overflow-y-auto overflow-x-hidden border-r border-outline-gray-1 bg-surface-menu-bar transition-all duration-300 ease-in-out p-2", r.value ? "w-12" : "w-60"])
    }, [
      e.header ? (L(), re(bAe, {
        key: 0,
        isCollapsed: r.value,
        title: e.header.title,
        subtitle: e.header.subtitle,
        logo: e.header.logo,
        "menu-items": e.header.menuItems
      }, {
        logo: ee(() => [
          ue(o.$slots, "header-logo")
        ]),
        _: 3
      }, 8, ["isCollapsed", "title", "subtitle", "logo", "menu-items"])) : ge("", !0),
      (L(!0), W(Ke, null, _t(e.sections, (l) => (L(), re(OAe, {
        key: l.label,
        label: l.label,
        items: l.items,
        collapsible: l.collapsible
      }, null, 8, ["label", "items", "collapsible"]))), 128)),
      G("div", IAe, [
        ue(o.$slots, "footer-items", Bt(Jt({ isCollapsed: r.value, isMobile: O(a) }))),
        se(T9, {
          label: r.value ? "Expand" : "Collapse",
          isCollapsed: r.value,
          onClick: s[0] || (s[0] = (l) => t.value = !t.value)
        }, {
          icon: ee(() => [
            se(O(kAe), {
              class: _e(["size-4 text-ink-gray-6 duration-300 ease-in-out", { "rotate-180": r.value }])
            }, null, 8, ["class"])
          ]),
          _: 1
        }, 8, ["label", "isCollapsed"])
      ])
    ], 2));
  }
}), LAe = typeof window < "u";
var DP;
LAe && ((DP = window == null ? void 0 : window.navigator) != null && DP.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function la(n) {
  return n == null;
}
function C9() {
}
const NAe = Object.freeze({
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
});
Object.freeze(new Set(Object.keys(NAe)));
function RAe() {
  const n = /* @__PURE__ */ new Map();
  return {
    on(e, t) {
      const r = n.get(e);
      r != null && r.add(t) || n.set(e, /* @__PURE__ */ new Set([t]));
    },
    off(e, t) {
      const r = n.get(e);
      r && r.delete(t);
    },
    clear(e) {
      const t = n.get(e);
      t && t.clear();
    },
    clearAll() {
      n.clear();
    },
    emit(e, ...t) {
      const r = n.get(e);
      r && r.forEach((i) => {
        i(...t);
      });
    }
  };
}
function OP(n, e = 16) {
  if (typeof n != "function")
    return C9;
  const t = (...a) => {
    n(...a);
  };
  if (e <= 0)
    return k9(t);
  let r = 0, i;
  return function(...a) {
    const o = Date.now(), s = o - r;
    clearTimeout(i), s >= e ? (r = o, t(...a)) : i = setTimeout(
      () => {
        r = Date.now(), t(...a);
      },
      Math.max(0, e - s)
    );
  };
}
function PAe(n, e = 100) {
  if (typeof n != "function")
    return C9;
  const t = (...i) => {
    n(...i);
  };
  if (e <= 0)
    return k9(t);
  let r;
  return function(...i) {
    clearTimeout(r), r = setTimeout(() => {
      t(...i);
    }, e);
  };
}
function k9(n) {
  if (typeof n != "function")
    return n;
  let e = !1, t, r;
  return function(...i) {
    return t = i, e || (e = !0, r = Promise.resolve().then(() => (e = !1, r = void 0, n(...t)))), r;
  };
}
const nm = /* @__PURE__ */ new Set(), A9 = /* @__PURE__ */ new WeakMap();
function jAe() {
  nm.forEach((n) => {
    n(...A9.get(n));
  }), nm.clear();
}
function _i(n, ...e) {
  if (typeof n != "function")
    return n;
  A9.set(n, e), !nm.has(n) && (nm.add(n), nm.size === 1 && Promise.resolve().then(jAe));
}
const M9 = Symbol("LAYOUT_KEY"), D9 = Symbol("EMITTER_KEY");
function BAe(n) {
  let e = 0, t;
  for (let r = 0, i = n.length; r < i; r++)
    t = n[r].y + n[r].h, t > e && (e = t);
  return e;
}
function IC(n) {
  const e = Array(n.length);
  for (let t = 0, r = n.length; t < r; t++)
    e[t] = $Ae(n[t]);
  return e;
}
function $Ae(n) {
  return { ...n };
}
function O9(n, e) {
  return !(n === e || n.x + n.w <= e.x || n.x >= e.x + e.w || n.y + n.h <= e.y || n.y >= e.y + e.h);
}
function Zf(n, e, t) {
  const r = L9(n), i = N9(n), a = Array(n.length);
  for (let o = 0, s = i.length; o < s; o++) {
    let l = i[o];
    l.static || (l = zAe(r, l, e, t), r.push(l)), a[n.findIndex((u) => u.i === l.i)] = l, l.moved = !1;
  }
  return a;
}
function zAe(n, e, t, r) {
  if (t)
    for (; e.y > 0 && !rm(n, e); )
      e.y--;
  else if (r) {
    const a = r[e.i].y;
    for (; e.y > a && !rm(n, e); )
      e.y--;
  }
  let i;
  for (; i = rm(n, e); )
    e.y = i.y + i.h;
  return e;
}
function FAe(n, e) {
  const t = L9(n);
  for (let r = 0, i = n.length; r < i; r++) {
    const a = n[r];
    if (a.x + a.w > e.cols && (a.x = e.cols - a.w), a.x < 0 && (a.x = 0, a.w = e.cols), !a.static) t.push(a);
    else
      for (; rm(t, a); )
        a.y++;
  }
  return n;
}
function IP(n, e) {
  for (let t = 0, r = n.length; t < r; t++)
    if (n[t].i === e) return n[t];
}
function rm(n, e) {
  for (let t = 0, r = n.length; t < r; t++)
    if (O9(n[t], e)) return n[t];
}
function I9(n, e) {
  return n.filter((t) => O9(t, e));
}
function L9(n) {
  return n.filter((e) => e.static);
}
function LC(n, e, t, r, i = !1, a = !1) {
  if (e.static) return n;
  const o = e.x, s = e.y, l = r && e.y > r;
  typeof t == "number" && (e.x = t), typeof r == "number" && (e.y = r), e.moved = !0;
  let u = N9(n);
  l && (u = u.reverse());
  const c = I9(u, e);
  if (a && c.length)
    return e.x = o, e.y = s, e.moved = !1, n;
  for (let d = 0, f = c.length; d < f; d++) {
    const p = c[d];
    p.moved || e.y > p.y && e.y - p.y > p.h / 4 || (p.static ? n = LP(n, p, e, i) : n = LP(n, e, p, i));
  }
  return n;
}
function LP(n, e, t, r) {
  if (r) {
    const i = {
      x: t.x,
      y: t.y,
      w: t.w,
      h: t.h
    };
    if (i.y = Math.max(e.y - t.h, 0), !rm(n, i))
      return LC(n, t, void 0, i.y, !1);
  }
  return LC(n, t, void 0, t.y + 1, !1);
}
function VAe(n, e, t, r) {
  const i = "translate3d(" + e + "px," + n + "px, 0)";
  return {
    transform: i,
    WebkitTransform: i,
    MozTransform: i,
    msTransform: i,
    OTransform: i,
    width: t + "px",
    height: r + "px",
    position: "absolute"
  };
}
function HAe(n, e, t, r) {
  const i = "translate3d(" + e * -1 + "px," + n + "px, 0)";
  return {
    transform: i,
    WebkitTransform: i,
    MozTransform: i,
    msTransform: i,
    OTransform: i,
    width: t + "px",
    height: r + "px",
    position: "absolute"
  };
}
function GAe(n, e, t, r) {
  return {
    top: n + "px",
    left: e + "px",
    width: t + "px",
    height: r + "px",
    position: "absolute"
  };
}
function UAe(n, e, t, r) {
  return {
    top: n + "px",
    right: e + "px",
    width: t + "px",
    height: r + "px",
    position: "absolute"
  };
}
function N9(n) {
  return Array.from(n).sort(function(e, t) {
    return e.y === t.y && e.x === t.x ? 0 : e.y > t.y || e.y === t.y && e.x > t.x ? 1 : -1;
  });
}
function WAe(n, e) {
  e = e || "Layout";
  const t = ["x", "y", "w", "h"], r = [];
  if (!Array.isArray(n)) throw new Error(e + " must be an array!");
  for (let i = 0, a = n.length; i < a; i++) {
    const o = n[i];
    for (let s = 0; s < t.length; s++)
      if (typeof o[t[s]] != "number")
        throw new Error(
          "VueGridLayout: " + e + "[" + i + "]." + t[s] + " must be a number!"
        );
    if (o.i === void 0 || o.i === null)
      throw new Error("VueGridLayout: " + e + "[" + i + "].i cannot be null!");
    if (typeof o.i != "number" && typeof o.i != "string")
      throw new Error("VueGridLayout: " + e + "[" + i + "].i must be a string or number!");
    if (r.indexOf(o.i) >= 0)
      throw new Error("VueGridLayout: " + e + "[" + i + "].i must be unique!");
    if (r.push(o.i), o.static !== void 0 && typeof o.static != "boolean")
      throw new Error("VueGridLayout: " + e + "[" + i + "].static must be a boolean!");
  }
}
function qAe(n, e = "vgl") {
  const t = () => `${e}-${n}`;
  return {
    b: t,
    be: (r) => `${t()}__${r}`,
    bm: (r) => `${t()}--${r}`,
    bem: (r, i) => `${t()}__${r}--${i}`
  };
}
function NP(n) {
  return YAe(n);
}
function YAe(n) {
  var e;
  const t = ((e = n.target) == null ? void 0 : e.offsetParent) || document.body, r = n.offsetParent === document.body ? { left: 0, top: 0 } : t.getBoundingClientRect(), i = n.clientX + t.scrollLeft - r.left, a = n.clientY + t.scrollTop - r.top;
  return { x: i, y: a };
}
function RP(n, e, t, r) {
  return KAe(n) ? {
    deltaX: t - n,
    deltaY: r - e,
    lastX: n,
    lastY: e,
    x: t,
    y: r
  } : {
    deltaX: 0,
    deltaY: 0,
    lastX: t,
    lastY: r,
    x: t,
    y: r
  };
}
function KAe(n) {
  return typeof n == "number" && !Number.isNaN(n);
}
function XAe(n, e) {
  const t = P9(n);
  let r = t[0];
  for (let i = 1, a = t.length; i < a; i++) {
    const o = t[i];
    e > n[o] && (r = o);
  }
  return r;
}
function R9(n, e) {
  if (!e[n])
    throw new Error(
      "ResponsiveGridLayout: `cols` entry for breakpoint " + n + " is missing!"
    );
  return e[n];
}
function ZAe(n, e, t, r, i, a, o) {
  if (e[r]) return IC(e[r]);
  let s = n;
  const l = P9(t), u = l.slice(l.indexOf(r));
  for (let c = 0, d = u.length; c < d; c++) {
    const f = u[c];
    if (e[f]) {
      s = e[f];
      break;
    }
  }
  return s = IC(s || []), Zf(FAe(s, { cols: a }), o);
}
function P9(n) {
  return Object.keys(n).sort((e, t) => n[e] - n[t]);
}
let JAe = "auto";
function QAe() {
  return typeof document < "u";
}
function PP() {
  return QAe() ? typeof document.dir < "u" ? document.dir : document.getElementsByTagName("html")[0].getAttribute("dir") : JAe;
}
var Fb = { exports: {} };
Fb.exports;
(function(n, e) {
  (function(t, r) {
    n.exports = r();
  })(WV, function() {
    function t(T, E) {
      var A = Object.keys(T);
      if (Object.getOwnPropertySymbols) {
        var I = Object.getOwnPropertySymbols(T);
        E && (I = I.filter(function(P) {
          return Object.getOwnPropertyDescriptor(T, P).enumerable;
        })), A.push.apply(A, I);
      }
      return A;
    }
    function r(T) {
      for (var E = 1; E < arguments.length; E++) {
        var A = arguments[E] != null ? arguments[E] : {};
        E % 2 ? t(Object(A), !0).forEach(function(I) {
          l(T, I, A[I]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(T, Object.getOwnPropertyDescriptors(A)) : t(Object(A)).forEach(function(I) {
          Object.defineProperty(T, I, Object.getOwnPropertyDescriptor(A, I));
        });
      }
      return T;
    }
    function i(T) {
      return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(E) {
        return typeof E;
      } : function(E) {
        return E && typeof Symbol == "function" && E.constructor === Symbol && E !== Symbol.prototype ? "symbol" : typeof E;
      }, i(T);
    }
    function a(T, E) {
      if (!(T instanceof E)) throw new TypeError("Cannot call a class as a function");
    }
    function o(T, E) {
      for (var A = 0; A < E.length; A++) {
        var I = E[A];
        I.enumerable = I.enumerable || !1, I.configurable = !0, "value" in I && (I.writable = !0), Object.defineProperty(T, v(I.key), I);
      }
    }
    function s(T, E, A) {
      return E && o(T.prototype, E), Object.defineProperty(T, "prototype", { writable: !1 }), T;
    }
    function l(T, E, A) {
      return (E = v(E)) in T ? Object.defineProperty(T, E, { value: A, enumerable: !0, configurable: !0, writable: !0 }) : T[E] = A, T;
    }
    function u(T, E) {
      if (typeof E != "function" && E !== null) throw new TypeError("Super expression must either be null or a function");
      T.prototype = Object.create(E && E.prototype, { constructor: { value: T, writable: !0, configurable: !0 } }), Object.defineProperty(T, "prototype", { writable: !1 }), E && d(T, E);
    }
    function c(T) {
      return c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(E) {
        return E.__proto__ || Object.getPrototypeOf(E);
      }, c(T);
    }
    function d(T, E) {
      return d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(A, I) {
        return A.__proto__ = I, A;
      }, d(T, E);
    }
    function f(T) {
      if (T === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return T;
    }
    function p(T) {
      var E = function() {
        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
        if (typeof Proxy == "function") return !0;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), !0;
        } catch {
          return !1;
        }
      }();
      return function() {
        var A, I = c(T);
        if (E) {
          var P = c(this).constructor;
          A = Reflect.construct(I, arguments, P);
        } else A = I.apply(this, arguments);
        return function(V, U) {
          if (U && (typeof U == "object" || typeof U == "function")) return U;
          if (U !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
          return f(V);
        }(this, A);
      };
    }
    function h() {
      return h = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(T, E, A) {
        var I = function(V, U) {
          for (; !Object.prototype.hasOwnProperty.call(V, U) && (V = c(V)) !== null; ) ;
          return V;
        }(T, E);
        if (I) {
          var P = Object.getOwnPropertyDescriptor(I, E);
          return P.get ? P.get.call(arguments.length < 3 ? T : A) : P.value;
        }
      }, h.apply(this, arguments);
    }
    function v(T) {
      var E = function(A, I) {
        if (typeof A != "object" || A === null) return A;
        var P = A[Symbol.toPrimitive];
        if (P !== void 0) {
          var V = P.call(A, I);
          if (typeof V != "object") return V;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return String(A);
      }(T, "string");
      return typeof E == "symbol" ? E : E + "";
    }
    var m = function(T) {
      return !(!T || !T.Window) && T instanceof T.Window;
    }, g = void 0, y = void 0;
    function b(T) {
      g = T;
      var E = T.document.createTextNode("");
      E.ownerDocument !== T.document && typeof T.wrap == "function" && T.wrap(E) === E && (T = T.wrap(T)), y = T;
    }
    function _(T) {
      return m(T) ? T : (T.ownerDocument || T).defaultView || y.window;
    }
    typeof window < "u" && window && b(window);
    var x = function(T) {
      return !!T && i(T) === "object";
    }, w = function(T) {
      return typeof T == "function";
    }, S = { window: function(T) {
      return T === y || m(T);
    }, docFrag: function(T) {
      return x(T) && T.nodeType === 11;
    }, object: x, func: w, number: function(T) {
      return typeof T == "number";
    }, bool: function(T) {
      return typeof T == "boolean";
    }, string: function(T) {
      return typeof T == "string";
    }, element: function(T) {
      if (!T || i(T) !== "object") return !1;
      var E = _(T) || y;
      return /object|function/.test(typeof Element > "u" ? "undefined" : i(Element)) ? T instanceof Element || T instanceof E.Element : T.nodeType === 1 && typeof T.nodeName == "string";
    }, plainObject: function(T) {
      return x(T) && !!T.constructor && /function Object\b/.test(T.constructor.toString());
    }, array: function(T) {
      return x(T) && T.length !== void 0 && w(T.splice);
    } };
    function C(T) {
      var E = T.interaction;
      if (E.prepared.name === "drag") {
        var A = E.prepared.axis;
        A === "x" ? (E.coords.cur.page.y = E.coords.start.page.y, E.coords.cur.client.y = E.coords.start.client.y, E.coords.velocity.client.y = 0, E.coords.velocity.page.y = 0) : A === "y" && (E.coords.cur.page.x = E.coords.start.page.x, E.coords.cur.client.x = E.coords.start.client.x, E.coords.velocity.client.x = 0, E.coords.velocity.page.x = 0);
      }
    }
    function k(T) {
      var E = T.iEvent, A = T.interaction;
      if (A.prepared.name === "drag") {
        var I = A.prepared.axis;
        if (I === "x" || I === "y") {
          var P = I === "x" ? "y" : "x";
          E.page[P] = A.coords.start.page[P], E.client[P] = A.coords.start.client[P], E.delta[P] = 0;
        }
      }
    }
    var M = { id: "actions/drag", install: function(T) {
      var E = T.actions, A = T.Interactable, I = T.defaults;
      A.prototype.draggable = M.draggable, E.map.drag = M, E.methodDict.drag = "draggable", I.actions.drag = M.defaults;
    }, listeners: { "interactions:before-action-move": C, "interactions:action-resume": C, "interactions:action-move": k, "auto-start:check": function(T) {
      var E = T.interaction, A = T.interactable, I = T.buttons, P = A.options.drag;
      if (P && P.enabled && (!E.pointerIsDown || !/mouse|pointer/.test(E.pointerType) || I & A.options.drag.mouseButtons)) return T.action = { name: "drag", axis: P.lockAxis === "start" ? P.startAxis : P.lockAxis }, !1;
    } }, draggable: function(T) {
      return S.object(T) ? (this.options.drag.enabled = T.enabled !== !1, this.setPerAction("drag", T), this.setOnEvents("drag", T), /^(xy|x|y|start)$/.test(T.lockAxis) && (this.options.drag.lockAxis = T.lockAxis), /^(xy|x|y)$/.test(T.startAxis) && (this.options.drag.startAxis = T.startAxis), this) : S.bool(T) ? (this.options.drag.enabled = T, this) : this.options.drag;
    }, beforeMove: C, move: k, defaults: { startAxis: "xy", lockAxis: "xy" }, getCursor: function() {
      return "move";
    }, filterEventType: function(T) {
      return T.search("drag") === 0;
    } }, D = M, N = { init: function(T) {
      var E = T;
      N.document = E.document, N.DocumentFragment = E.DocumentFragment || R, N.SVGElement = E.SVGElement || R, N.SVGSVGElement = E.SVGSVGElement || R, N.SVGElementInstance = E.SVGElementInstance || R, N.Element = E.Element || R, N.HTMLElement = E.HTMLElement || N.Element, N.Event = E.Event, N.Touch = E.Touch || R, N.PointerEvent = E.PointerEvent || E.MSPointerEvent;
    }, document: null, DocumentFragment: null, SVGElement: null, SVGSVGElement: null, SVGElementInstance: null, Element: null, HTMLElement: null, Event: null, Touch: null, PointerEvent: null };
    function R() {
    }
    var j = N, z = { init: function(T) {
      var E = j.Element, A = T.navigator || {};
      z.supportsTouch = "ontouchstart" in T || S.func(T.DocumentTouch) && j.document instanceof T.DocumentTouch, z.supportsPointerEvent = A.pointerEnabled !== !1 && !!j.PointerEvent, z.isIOS = /iP(hone|od|ad)/.test(A.platform), z.isIOS7 = /iP(hone|od|ad)/.test(A.platform) && /OS 7[^\d]/.test(A.appVersion), z.isIe9 = /MSIE 9/.test(A.userAgent), z.isOperaMobile = A.appName === "Opera" && z.supportsTouch && /Presto/.test(A.userAgent), z.prefixedMatchesSelector = "matches" in E.prototype ? "matches" : "webkitMatchesSelector" in E.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in E.prototype ? "mozMatchesSelector" : "oMatchesSelector" in E.prototype ? "oMatchesSelector" : "msMatchesSelector", z.pEventTypes = z.supportsPointerEvent ? j.PointerEvent === T.MSPointerEvent ? { up: "MSPointerUp", down: "MSPointerDown", over: "mouseover", out: "mouseout", move: "MSPointerMove", cancel: "MSPointerCancel" } : { up: "pointerup", down: "pointerdown", over: "pointerover", out: "pointerout", move: "pointermove", cancel: "pointercancel" } : null, z.wheelEvent = j.document && "onmousewheel" in j.document ? "mousewheel" : "wheel";
    }, supportsTouch: null, supportsPointerEvent: null, isIOS7: null, isIOS: null, isIe9: null, isOperaMobile: null, prefixedMatchesSelector: null, pEventTypes: null, wheelEvent: null }, F = z;
    function B(T, E) {
      if (T.contains) return T.contains(E);
      for (; E; ) {
        if (E === T) return !0;
        E = E.parentNode;
      }
      return !1;
    }
    function H(T, E) {
      for (; S.element(T); ) {
        if (ne(T, E)) return T;
        T = Y(T);
      }
      return null;
    }
    function Y(T) {
      var E = T.parentNode;
      if (S.docFrag(E)) {
        for (; (E = E.host) && S.docFrag(E); ) ;
        return E;
      }
      return E;
    }
    function ne(T, E) {
      return y !== g && (E = E.replace(/\/deep\//g, " ")), T[F.prefixedMatchesSelector](E);
    }
    var J = function(T) {
      return T.parentNode || T.host;
    };
    function X(T, E) {
      for (var A, I = [], P = T; (A = J(P)) && P !== E && A !== P.ownerDocument; ) I.unshift(P), P = A;
      return I;
    }
    function ie(T, E, A) {
      for (; S.element(T); ) {
        if (ne(T, E)) return !0;
        if ((T = Y(T)) === A) return ne(T, E);
      }
      return !1;
    }
    function ye(T) {
      return T.correspondingUseElement || T;
    }
    function pe(T) {
      var E = T instanceof j.SVGElement ? T.getBoundingClientRect() : T.getClientRects()[0];
      return E && { left: E.left, right: E.right, top: E.top, bottom: E.bottom, width: E.width || E.right - E.left, height: E.height || E.bottom - E.top };
    }
    function Be(T) {
      var E, A = pe(T);
      if (!F.isIOS7 && A) {
        var I = { x: (E = (E = _(T)) || y).scrollX || E.document.documentElement.scrollLeft, y: E.scrollY || E.document.documentElement.scrollTop };
        A.left += I.x, A.right += I.x, A.top += I.y, A.bottom += I.y;
      }
      return A;
    }
    function Ce(T) {
      for (var E = []; T; ) E.push(T), T = Y(T);
      return E;
    }
    function Ee(T) {
      return !!S.string(T) && (j.document.querySelector(T), !0);
    }
    function ce(T, E) {
      for (var A in E) T[A] = E[A];
      return T;
    }
    function Pe(T, E, A) {
      return T === "parent" ? Y(A) : T === "self" ? E.getRect(A) : H(A, T);
    }
    function Ae(T, E, A, I) {
      var P = T;
      return S.string(P) ? P = Pe(P, E, A) : S.func(P) && (P = P.apply(void 0, I)), S.element(P) && (P = Be(P)), P;
    }
    function fe(T) {
      return T && { x: "x" in T ? T.x : T.left, y: "y" in T ? T.y : T.top };
    }
    function oe(T) {
      return !T || "x" in T && "y" in T || ((T = ce({}, T)).x = T.left || 0, T.y = T.top || 0, T.width = T.width || (T.right || 0) - T.x, T.height = T.height || (T.bottom || 0) - T.y), T;
    }
    function he(T, E, A) {
      T.left && (E.left += A.x), T.right && (E.right += A.x), T.top && (E.top += A.y), T.bottom && (E.bottom += A.y), E.width = E.right - E.left, E.height = E.bottom - E.top;
    }
    function Oe(T, E, A) {
      var I = A && T.options[A];
      return fe(Ae(I && I.origin || T.options.origin, T, E, [T && E])) || { x: 0, y: 0 };
    }
    function Te(T, E) {
      var A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(Q) {
        return !0;
      }, I = arguments.length > 3 ? arguments[3] : void 0;
      if (I = I || {}, S.string(T) && T.search(" ") !== -1 && (T = Ge(T)), S.array(T)) return T.forEach(function(Q) {
        return Te(Q, E, A, I);
      }), I;
      if (S.object(T) && (E = T, T = ""), S.func(E) && A(T)) I[T] = I[T] || [], I[T].push(E);
      else if (S.array(E)) for (var P = 0, V = E; P < V.length; P++) {
        var U = V[P];
        Te(T, U, A, I);
      }
      else if (S.object(E)) for (var q in E)
        Te(Ge(q).map(function(Q) {
          return "".concat(T).concat(Q);
        }), E[q], A, I);
      return I;
    }
    function Ge(T) {
      return T.trim().split(/ +/);
    }
    var je = function(T, E) {
      return Math.sqrt(T * T + E * E);
    }, Qe = ["webkit", "moz"];
    function ot(T, E) {
      T.__set || (T.__set = {});
      var A = function(P) {
        if (Qe.some(function(V) {
          return P.indexOf(V) === 0;
        })) return 1;
        typeof T[P] != "function" && P !== "__set" && Object.defineProperty(T, P, { get: function() {
          return P in T.__set ? T.__set[P] : T.__set[P] = E[P];
        }, set: function(V) {
          T.__set[P] = V;
        }, configurable: !0 });
      };
      for (var I in E) A(I);
      return T;
    }
    function it(T, E) {
      T.page = T.page || {}, T.page.x = E.page.x, T.page.y = E.page.y, T.client = T.client || {}, T.client.x = E.client.x, T.client.y = E.client.y, T.timeStamp = E.timeStamp;
    }
    function Nt(T) {
      T.page.x = 0, T.page.y = 0, T.client.x = 0, T.client.y = 0;
    }
    function Le(T) {
      return T instanceof j.Event || T instanceof j.Touch;
    }
    function ft(T, E, A) {
      return T = T || "page", (A = A || {}).x = E[T + "X"], A.y = E[T + "Y"], A;
    }
    function Rt(T, E) {
      return E = E || { x: 0, y: 0 }, F.isOperaMobile && Le(T) ? (ft("screen", T, E), E.x += window.scrollX, E.y += window.scrollY) : ft("page", T, E), E;
    }
    function Re(T) {
      return S.number(T.pointerId) ? T.pointerId : T.identifier;
    }
    function be(T, E, A) {
      var I = E.length > 1 ? Ne(E) : E[0];
      Rt(I, T.page), function(P, V) {
        V = V || {}, F.isOperaMobile && Le(P) ? ft("screen", P, V) : ft("client", P, V);
      }(I, T.client), T.timeStamp = A;
    }
    function we(T) {
      var E = [];
      return S.array(T) ? (E[0] = T[0], E[1] = T[1]) : T.type === "touchend" ? T.touches.length === 1 ? (E[0] = T.touches[0], E[1] = T.changedTouches[0]) : T.touches.length === 0 && (E[0] = T.changedTouches[0], E[1] = T.changedTouches[1]) : (E[0] = T.touches[0], E[1] = T.touches[1]), E;
    }
    function Ne(T) {
      for (var E = { pageX: 0, pageY: 0, clientX: 0, clientY: 0, screenX: 0, screenY: 0 }, A = 0; A < T.length; A++) {
        var I = T[A];
        for (var P in E) E[P] += I[P];
      }
      for (var V in E) E[V] /= T.length;
      return E;
    }
    function lt(T) {
      if (!T.length) return null;
      var E = we(T), A = Math.min(E[0].pageX, E[1].pageX), I = Math.min(E[0].pageY, E[1].pageY), P = Math.max(E[0].pageX, E[1].pageX), V = Math.max(E[0].pageY, E[1].pageY);
      return { x: A, y: I, left: A, top: I, right: P, bottom: V, width: P - A, height: V - I };
    }
    function Gt(T, E) {
      var A = E + "X", I = E + "Y", P = we(T), V = P[0][A] - P[1][A], U = P[0][I] - P[1][I];
      return je(V, U);
    }
    function _n(T, E) {
      var A = E + "X", I = E + "Y", P = we(T), V = P[1][A] - P[0][A], U = P[1][I] - P[0][I];
      return 180 * Math.atan2(U, V) / Math.PI;
    }
    function Tr(T) {
      return S.string(T.pointerType) ? T.pointerType : S.number(T.pointerType) ? [void 0, void 0, "touch", "pen", "mouse"][T.pointerType] : /touch/.test(T.type || "") || T instanceof j.Touch ? "touch" : "mouse";
    }
    function Se(T) {
      var E = S.func(T.composedPath) ? T.composedPath() : T.path;
      return [ye(E ? E[0] : T.target), ye(T.currentTarget)];
    }
    var rt = function() {
      function T(E) {
        a(this, T), this.immediatePropagationStopped = !1, this.propagationStopped = !1, this._interaction = E;
      }
      return s(T, [{ key: "preventDefault", value: function() {
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = !0;
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
      } }]), T;
    }();
    Object.defineProperty(rt.prototype, "interaction", { get: function() {
      return this._interaction._proxy;
    }, set: function() {
    } });
    var wt = function(T, E) {
      for (var A = 0; A < E.length; A++) {
        var I = E[A];
        T.push(I);
      }
      return T;
    }, rn = function(T) {
      return wt([], T);
    }, Kt = function(T, E) {
      for (var A = 0; A < T.length; A++) if (E(T[A], A, T)) return A;
      return -1;
    }, Un = function(T, E) {
      return T[Kt(T, E)];
    }, tr = function(T) {
      u(A, T);
      var E = p(A);
      function A(I, P, V) {
        var U;
        a(this, A), (U = E.call(this, P._interaction)).dropzone = void 0, U.dragEvent = void 0, U.relatedTarget = void 0, U.draggable = void 0, U.propagationStopped = !1, U.immediatePropagationStopped = !1;
        var q = V === "dragleave" ? I.prev : I.cur, Q = q.element, ae = q.dropzone;
        return U.type = V, U.target = Q, U.currentTarget = Q, U.dropzone = ae, U.dragEvent = P, U.relatedTarget = P.target, U.draggable = P.interactable, U.timeStamp = P.timeStamp, U;
      }
      return s(A, [{ key: "reject", value: function() {
        var I = this, P = this._interaction.dropState;
        if (this.type === "dropactivate" || this.dropzone && P.cur.dropzone === this.dropzone && P.cur.element === this.target) if (P.prev.dropzone = this.dropzone, P.prev.element = this.target, P.rejected = !0, P.events.enter = null, this.stopImmediatePropagation(), this.type === "dropactivate") {
          var V = P.activeDrops, U = Kt(V, function(Q) {
            var ae = Q.dropzone, te = Q.element;
            return ae === I.dropzone && te === I.target;
          });
          P.activeDrops.splice(U, 1);
          var q = new A(P, this.dragEvent, "dropdeactivate");
          q.dropzone = this.dropzone, q.target = this.target, this.dropzone.fire(q);
        } else this.dropzone.fire(new A(P, this.dragEvent, "dragleave"));
      } }, { key: "preventDefault", value: function() {
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = !0;
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
      } }]), A;
    }(rt);
    function so(T, E) {
      for (var A = 0, I = T.slice(); A < I.length; A++) {
        var P = I[A], V = P.dropzone, U = P.element;
        E.dropzone = V, E.target = U, V.fire(E), E.propagationStopped = E.immediatePropagationStopped = !1;
      }
    }
    function wa(T, E) {
      for (var A = function(V, U) {
        for (var q = [], Q = 0, ae = V.interactables.list; Q < ae.length; Q++) {
          var te = ae[Q];
          if (te.options.drop.enabled) {
            var me = te.options.drop.accept;
            if (!(S.element(me) && me !== U || S.string(me) && !ne(U, me) || S.func(me) && !me({ dropzone: te, draggableElement: U }))) for (var Ie = 0, Ve = te.getAllElements(); Ie < Ve.length; Ie++) {
              var Fe = Ve[Ie];
              Fe !== U && q.push({ dropzone: te, element: Fe, rect: te.getRect(Fe) });
            }
          }
        }
        return q;
      }(T, E), I = 0; I < A.length; I++) {
        var P = A[I];
        P.rect = P.dropzone.getRect(P.element);
      }
      return A;
    }
    function Sa(T, E, A) {
      for (var I = T.dropState, P = T.interactable, V = T.element, U = [], q = 0, Q = I.activeDrops; q < Q.length; q++) {
        var ae = Q[q], te = ae.dropzone, me = ae.element, Ie = ae.rect, Ve = te.dropCheck(E, A, P, V, me, Ie);
        U.push(Ve ? me : null);
      }
      var Fe = function(Xe) {
        for (var pt, st, Et, Zt = [], pn = 0; pn < Xe.length; pn++) {
          var Ft = Xe[pn], tn = Xe[pt];
          if (Ft && pn !== pt) if (tn) {
            var yi = J(Ft), nr = J(tn);
            if (yi !== Ft.ownerDocument) if (nr !== Ft.ownerDocument) if (yi !== nr) {
              Zt = Zt.length ? Zt : X(tn);
              var aa = void 0;
              if (tn instanceof j.HTMLElement && Ft instanceof j.SVGElement && !(Ft instanceof j.SVGSVGElement)) {
                if (Ft === nr) continue;
                aa = Ft.ownerSVGElement;
              } else aa = Ft;
              for (var uo = X(aa, tn.ownerDocument), Ls = 0; uo[Ls] && uo[Ls] === Zt[Ls]; ) Ls++;
              var vy = [uo[Ls - 1], uo[Ls], Zt[Ls]];
              if (vy[0]) for (var Oh = vy[0].lastChild; Oh; ) {
                if (Oh === vy[1]) {
                  pt = pn, Zt = uo;
                  break;
                }
                if (Oh === vy[2]) break;
                Oh = Oh.previousSibling;
              }
            } else Et = tn, (parseInt(_(st = Ft).getComputedStyle(st).zIndex, 10) || 0) >= (parseInt(_(Et).getComputedStyle(Et).zIndex, 10) || 0) && (pt = pn);
            else pt = pn;
          } else pt = pn;
        }
        return pt;
      }(U);
      return I.activeDrops[Fe] || null;
    }
    function Is(T, E, A) {
      var I = T.dropState, P = { enter: null, leave: null, activate: null, deactivate: null, move: null, drop: null };
      return A.type === "dragstart" && (P.activate = new tr(I, A, "dropactivate"), P.activate.target = null, P.activate.dropzone = null), A.type === "dragend" && (P.deactivate = new tr(I, A, "dropdeactivate"), P.deactivate.target = null, P.deactivate.dropzone = null), I.rejected || (I.cur.element !== I.prev.element && (I.prev.dropzone && (P.leave = new tr(I, A, "dragleave"), A.dragLeave = P.leave.target = I.prev.element, A.prevDropzone = P.leave.dropzone = I.prev.dropzone), I.cur.dropzone && (P.enter = new tr(I, A, "dragenter"), A.dragEnter = I.cur.element, A.dropzone = I.cur.dropzone)), A.type === "dragend" && I.cur.dropzone && (P.drop = new tr(I, A, "drop"), A.dropzone = I.cur.dropzone, A.relatedTarget = I.cur.element), A.type === "dragmove" && I.cur.dropzone && (P.move = new tr(I, A, "dropmove"), A.dropzone = I.cur.dropzone)), P;
    }
    function Fn(T, E) {
      var A = T.dropState, I = A.activeDrops, P = A.cur, V = A.prev;
      E.leave && V.dropzone.fire(E.leave), E.enter && P.dropzone.fire(E.enter), E.move && P.dropzone.fire(E.move), E.drop && P.dropzone.fire(E.drop), E.deactivate && so(I, E.deactivate), A.prev.dropzone = P.dropzone, A.prev.element = P.element;
    }
    function ti(T, E) {
      var A = T.interaction, I = T.iEvent, P = T.event;
      if (I.type === "dragmove" || I.type === "dragend") {
        var V = A.dropState;
        E.dynamicDrop && (V.activeDrops = wa(E, A.element));
        var U = I, q = Sa(A, U, P);
        V.rejected = V.rejected && !!q && q.dropzone === V.cur.dropzone && q.element === V.cur.element, V.cur.dropzone = q && q.dropzone, V.cur.element = q && q.element, V.events = Is(A, 0, U);
      }
    }
    var of = { id: "actions/drop", install: function(T) {
      var E = T.actions, A = T.interactStatic, I = T.Interactable, P = T.defaults;
      T.usePlugin(D), I.prototype.dropzone = function(V) {
        return function(U, q) {
          if (S.object(q)) {
            if (U.options.drop.enabled = q.enabled !== !1, q.listeners) {
              var Q = Te(q.listeners), ae = Object.keys(Q).reduce(function(me, Ie) {
                return me[/^(enter|leave)/.test(Ie) ? "drag".concat(Ie) : /^(activate|deactivate|move)/.test(Ie) ? "drop".concat(Ie) : Ie] = Q[Ie], me;
              }, {}), te = U.options.drop.listeners;
              te && U.off(te), U.on(ae), U.options.drop.listeners = ae;
            }
            return S.func(q.ondrop) && U.on("drop", q.ondrop), S.func(q.ondropactivate) && U.on("dropactivate", q.ondropactivate), S.func(q.ondropdeactivate) && U.on("dropdeactivate", q.ondropdeactivate), S.func(q.ondragenter) && U.on("dragenter", q.ondragenter), S.func(q.ondragleave) && U.on("dragleave", q.ondragleave), S.func(q.ondropmove) && U.on("dropmove", q.ondropmove), /^(pointer|center)$/.test(q.overlap) ? U.options.drop.overlap = q.overlap : S.number(q.overlap) && (U.options.drop.overlap = Math.max(Math.min(1, q.overlap), 0)), "accept" in q && (U.options.drop.accept = q.accept), "checker" in q && (U.options.drop.checker = q.checker), U;
          }
          return S.bool(q) ? (U.options.drop.enabled = q, U) : U.options.drop;
        }(this, V);
      }, I.prototype.dropCheck = function(V, U, q, Q, ae, te) {
        return function(me, Ie, Ve, Fe, Xe, pt, st) {
          var Et = !1;
          if (!(st = st || me.getRect(pt))) return !!me.options.drop.checker && me.options.drop.checker(Ie, Ve, Et, me, pt, Fe, Xe);
          var Zt = me.options.drop.overlap;
          if (Zt === "pointer") {
            var pn = Oe(Fe, Xe, "drag"), Ft = Rt(Ie);
            Ft.x += pn.x, Ft.y += pn.y;
            var tn = Ft.x > st.left && Ft.x < st.right, yi = Ft.y > st.top && Ft.y < st.bottom;
            Et = tn && yi;
          }
          var nr = Fe.getRect(Xe);
          if (nr && Zt === "center") {
            var aa = nr.left + nr.width / 2, uo = nr.top + nr.height / 2;
            Et = aa >= st.left && aa <= st.right && uo >= st.top && uo <= st.bottom;
          }
          return nr && S.number(Zt) && (Et = Math.max(0, Math.min(st.right, nr.right) - Math.max(st.left, nr.left)) * Math.max(0, Math.min(st.bottom, nr.bottom) - Math.max(st.top, nr.top)) / (nr.width * nr.height) >= Zt), me.options.drop.checker && (Et = me.options.drop.checker(Ie, Ve, Et, me, pt, Fe, Xe)), Et;
        }(this, V, U, q, Q, ae, te);
      }, A.dynamicDrop = function(V) {
        return S.bool(V) ? (T.dynamicDrop = V, A) : T.dynamicDrop;
      }, ce(E.phaselessTypes, { dragenter: !0, dragleave: !0, dropactivate: !0, dropdeactivate: !0, dropmove: !0, drop: !0 }), E.methodDict.drop = "dropzone", T.dynamicDrop = !1, P.actions.drop = of.defaults;
    }, listeners: { "interactions:before-action-start": function(T) {
      var E = T.interaction;
      E.prepared.name === "drag" && (E.dropState = { cur: { dropzone: null, element: null }, prev: { dropzone: null, element: null }, rejected: null, events: null, activeDrops: [] });
    }, "interactions:after-action-start": function(T, E) {
      var A = T.interaction, I = (T.event, T.iEvent);
      if (A.prepared.name === "drag") {
        var P = A.dropState;
        P.activeDrops = [], P.events = {}, P.activeDrops = wa(E, A.element), P.events = Is(A, 0, I), P.events.activate && (so(P.activeDrops, P.events.activate), E.fire("actions/drop:start", { interaction: A, dragEvent: I }));
      }
    }, "interactions:action-move": ti, "interactions:after-action-move": function(T, E) {
      var A = T.interaction, I = T.iEvent;
      if (A.prepared.name === "drag") {
        var P = A.dropState;
        Fn(A, P.events), E.fire("actions/drop:move", { interaction: A, dragEvent: I }), P.events = {};
      }
    }, "interactions:action-end": function(T, E) {
      if (T.interaction.prepared.name === "drag") {
        var A = T.interaction, I = T.iEvent;
        ti(T, E), Fn(A, A.dropState.events), E.fire("actions/drop:end", { interaction: A, dragEvent: I });
      }
    }, "interactions:stop": function(T) {
      var E = T.interaction;
      if (E.prepared.name === "drag") {
        var A = E.dropState;
        A && (A.activeDrops = null, A.events = null, A.cur.dropzone = null, A.cur.element = null, A.prev.dropzone = null, A.prev.element = null, A.rejected = !1);
      }
    } }, getActiveDrops: wa, getDrop: Sa, getDropEvents: Is, fireDropEvents: Fn, filterEventType: function(T) {
      return T.search("drag") === 0 || T.search("drop") === 0;
    }, defaults: { enabled: !1, accept: null, overlap: "pointer" } }, Ol = of;
    function Ea(T) {
      var E = T.interaction, A = T.iEvent, I = T.phase;
      if (E.prepared.name === "gesture") {
        var P = E.pointers.map(function(ae) {
          return ae.pointer;
        }), V = I === "start", U = I === "end", q = E.interactable.options.deltaSource;
        if (A.touches = [P[0], P[1]], V) A.distance = Gt(P, q), A.box = lt(P), A.scale = 1, A.ds = 0, A.angle = _n(P, q), A.da = 0, E.gesture.startDistance = A.distance, E.gesture.startAngle = A.angle;
        else if (U || E.pointers.length < 2) {
          var Q = E.prevEvent;
          A.distance = Q.distance, A.box = Q.box, A.scale = Q.scale, A.ds = 0, A.angle = Q.angle, A.da = 0;
        } else A.distance = Gt(P, q), A.box = lt(P), A.scale = A.distance / E.gesture.startDistance, A.angle = _n(P, q), A.ds = A.scale - E.gesture.scale, A.da = A.angle - E.gesture.angle;
        E.gesture.distance = A.distance, E.gesture.angle = A.angle, S.number(A.scale) && A.scale !== 1 / 0 && !isNaN(A.scale) && (E.gesture.scale = A.scale);
      }
    }
    var sf = { id: "actions/gesture", before: ["actions/drag", "actions/resize"], install: function(T) {
      var E = T.actions, A = T.Interactable, I = T.defaults;
      A.prototype.gesturable = function(P) {
        return S.object(P) ? (this.options.gesture.enabled = P.enabled !== !1, this.setPerAction("gesture", P), this.setOnEvents("gesture", P), this) : S.bool(P) ? (this.options.gesture.enabled = P, this) : this.options.gesture;
      }, E.map.gesture = sf, E.methodDict.gesture = "gesturable", I.actions.gesture = sf.defaults;
    }, listeners: { "interactions:action-start": Ea, "interactions:action-move": Ea, "interactions:action-end": Ea, "interactions:new": function(T) {
      T.interaction.gesture = { angle: 0, distance: 0, scale: 1, startAngle: 0, startDistance: 0 };
    }, "auto-start:check": function(T) {
      if (!(T.interaction.pointers.length < 2)) {
        var E = T.interactable.options.gesture;
        if (E && E.enabled) return T.action = { name: "gesture" }, !1;
      }
    } }, defaults: {}, getCursor: function() {
      return "";
    }, filterEventType: function(T) {
      return T.search("gesture") === 0;
    } }, oy = sf;
    function Iw(T, E, A, I, P, V, U) {
      if (!E) return !1;
      if (E === !0) {
        var q = S.number(V.width) ? V.width : V.right - V.left, Q = S.number(V.height) ? V.height : V.bottom - V.top;
        if (U = Math.min(U, Math.abs((T === "left" || T === "right" ? q : Q) / 2)), q < 0 && (T === "left" ? T = "right" : T === "right" && (T = "left")), Q < 0 && (T === "top" ? T = "bottom" : T === "bottom" && (T = "top")), T === "left") {
          var ae = q >= 0 ? V.left : V.right;
          return A.x < ae + U;
        }
        if (T === "top") {
          var te = Q >= 0 ? V.top : V.bottom;
          return A.y < te + U;
        }
        if (T === "right") return A.x > (q >= 0 ? V.right : V.left) - U;
        if (T === "bottom") return A.y > (Q >= 0 ? V.bottom : V.top) - U;
      }
      return !!S.element(I) && (S.element(E) ? E === I : ie(I, E, P));
    }
    function ia(T) {
      var E = T.iEvent, A = T.interaction;
      if (A.prepared.name === "resize" && A.resizeAxes) {
        var I = E;
        A.interactable.options.resize.square ? (A.resizeAxes === "y" ? I.delta.x = I.delta.y : I.delta.y = I.delta.x, I.axes = "xy") : (I.axes = A.resizeAxes, A.resizeAxes === "x" ? I.delta.y = 0 : A.resizeAxes === "y" && (I.delta.x = 0));
      }
    }
    var ni, jo, Ta = { id: "actions/resize", before: ["actions/drag"], install: function(T) {
      var E = T.actions, A = T.browser, I = T.Interactable, P = T.defaults;
      Ta.cursors = function(V) {
        return V.isIe9 ? { x: "e-resize", y: "s-resize", xy: "se-resize", top: "n-resize", left: "w-resize", bottom: "s-resize", right: "e-resize", topleft: "se-resize", bottomright: "se-resize", topright: "ne-resize", bottomleft: "ne-resize" } : { x: "ew-resize", y: "ns-resize", xy: "nwse-resize", top: "ns-resize", left: "ew-resize", bottom: "ns-resize", right: "ew-resize", topleft: "nwse-resize", bottomright: "nwse-resize", topright: "nesw-resize", bottomleft: "nesw-resize" };
      }(A), Ta.defaultMargin = A.supportsTouch || A.supportsPointerEvent ? 20 : 10, I.prototype.resizable = function(V) {
        return function(U, q, Q) {
          return S.object(q) ? (U.options.resize.enabled = q.enabled !== !1, U.setPerAction("resize", q), U.setOnEvents("resize", q), S.string(q.axis) && /^x$|^y$|^xy$/.test(q.axis) ? U.options.resize.axis = q.axis : q.axis === null && (U.options.resize.axis = Q.defaults.actions.resize.axis), S.bool(q.preserveAspectRatio) ? U.options.resize.preserveAspectRatio = q.preserveAspectRatio : S.bool(q.square) && (U.options.resize.square = q.square), U) : S.bool(q) ? (U.options.resize.enabled = q, U) : U.options.resize;
        }(this, V, T);
      }, E.map.resize = Ta, E.methodDict.resize = "resizable", P.actions.resize = Ta.defaults;
    }, listeners: { "interactions:new": function(T) {
      T.interaction.resizeAxes = "xy";
    }, "interactions:action-start": function(T) {
      (function(E) {
        var A = E.iEvent, I = E.interaction;
        if (I.prepared.name === "resize" && I.prepared.edges) {
          var P = A, V = I.rect;
          I._rects = { start: ce({}, V), corrected: ce({}, V), previous: ce({}, V), delta: { left: 0, right: 0, width: 0, top: 0, bottom: 0, height: 0 } }, P.edges = I.prepared.edges, P.rect = I._rects.corrected, P.deltaRect = I._rects.delta;
        }
      })(T), ia(T);
    }, "interactions:action-move": function(T) {
      (function(E) {
        var A = E.iEvent, I = E.interaction;
        if (I.prepared.name === "resize" && I.prepared.edges) {
          var P = A, V = I.interactable.options.resize.invert, U = V === "reposition" || V === "negate", q = I.rect, Q = I._rects, ae = Q.start, te = Q.corrected, me = Q.delta, Ie = Q.previous;
          if (ce(Ie, te), U) {
            if (ce(te, q), V === "reposition") {
              if (te.top > te.bottom) {
                var Ve = te.top;
                te.top = te.bottom, te.bottom = Ve;
              }
              if (te.left > te.right) {
                var Fe = te.left;
                te.left = te.right, te.right = Fe;
              }
            }
          } else te.top = Math.min(q.top, ae.bottom), te.bottom = Math.max(q.bottom, ae.top), te.left = Math.min(q.left, ae.right), te.right = Math.max(q.right, ae.left);
          for (var Xe in te.width = te.right - te.left, te.height = te.bottom - te.top, te) me[Xe] = te[Xe] - Ie[Xe];
          P.edges = I.prepared.edges, P.rect = te, P.deltaRect = me;
        }
      })(T), ia(T);
    }, "interactions:action-end": function(T) {
      var E = T.iEvent, A = T.interaction;
      if (A.prepared.name === "resize" && A.prepared.edges) {
        var I = E;
        I.edges = A.prepared.edges, I.rect = A._rects.corrected, I.deltaRect = A._rects.delta;
      }
    }, "auto-start:check": function(T) {
      var E = T.interaction, A = T.interactable, I = T.element, P = T.rect, V = T.buttons;
      if (P) {
        var U = ce({}, E.coords.cur.page), q = A.options.resize;
        if (q && q.enabled && (!E.pointerIsDown || !/mouse|pointer/.test(E.pointerType) || V & q.mouseButtons)) {
          if (S.object(q.edges)) {
            var Q = { left: !1, right: !1, top: !1, bottom: !1 };
            for (var ae in Q) Q[ae] = Iw(ae, q.edges[ae], U, E._latestPointer.eventTarget, I, P, q.margin || Ta.defaultMargin);
            Q.left = Q.left && !Q.right, Q.top = Q.top && !Q.bottom, (Q.left || Q.right || Q.top || Q.bottom) && (T.action = { name: "resize", edges: Q });
          } else {
            var te = q.axis !== "y" && U.x > P.right - Ta.defaultMargin, me = q.axis !== "x" && U.y > P.bottom - Ta.defaultMargin;
            (te || me) && (T.action = { name: "resize", axes: (te ? "x" : "") + (me ? "y" : "") });
          }
          return !T.action && void 0;
        }
      }
    } }, defaults: { square: !1, preserveAspectRatio: !1, axis: "xy", margin: NaN, edges: null, invert: "none" }, cursors: null, getCursor: function(T) {
      var E = T.edges, A = T.axis, I = T.name, P = Ta.cursors, V = null;
      if (A) V = P[I + A];
      else if (E) {
        for (var U = "", q = 0, Q = ["top", "bottom", "left", "right"]; q < Q.length; q++) {
          var ae = Q[q];
          E[ae] && (U += ae);
        }
        V = P[U];
      }
      return V;
    }, filterEventType: function(T) {
      return T.search("resize") === 0;
    }, defaultMargin: null }, Sh = Ta, sy = { id: "actions", install: function(T) {
      T.usePlugin(oy), T.usePlugin(Sh), T.usePlugin(D), T.usePlugin(Ol);
    } }, Ca = 0, lo = { request: function(T) {
      return ni(T);
    }, cancel: function(T) {
      return jo(T);
    }, init: function(T) {
      if (ni = T.requestAnimationFrame, jo = T.cancelAnimationFrame, !ni) for (var E = ["ms", "moz", "webkit", "o"], A = 0; A < E.length; A++) {
        var I = E[A];
        ni = T["".concat(I, "RequestAnimationFrame")], jo = T["".concat(I, "CancelAnimationFrame")] || T["".concat(I, "CancelRequestAnimationFrame")];
      }
      ni = ni && ni.bind(T), jo = jo && jo.bind(T), ni || (ni = function(P) {
        var V = Date.now(), U = Math.max(0, 16 - (V - Ca)), q = T.setTimeout(function() {
          P(V + U);
        }, U);
        return Ca = V + U, q;
      }, jo = function(P) {
        return clearTimeout(P);
      });
    } }, jt = { defaults: { enabled: !1, margin: 60, container: null, speed: 300 }, now: Date.now, interaction: null, i: 0, x: 0, y: 0, isScrolling: !1, prevTime: 0, margin: 0, speed: 0, start: function(T) {
      jt.isScrolling = !0, lo.cancel(jt.i), T.autoScroll = jt, jt.interaction = T, jt.prevTime = jt.now(), jt.i = lo.request(jt.scroll);
    }, stop: function() {
      jt.isScrolling = !1, jt.interaction && (jt.interaction.autoScroll = null), lo.cancel(jt.i);
    }, scroll: function() {
      var T = jt.interaction, E = T.interactable, A = T.element, I = T.prepared.name, P = E.options[I].autoScroll, V = Eh(P.container, E, A), U = jt.now(), q = (U - jt.prevTime) / 1e3, Q = P.speed * q;
      if (Q >= 1) {
        var ae = { x: jt.x * Q, y: jt.y * Q };
        if (ae.x || ae.y) {
          var te = Th(V);
          S.window(V) ? V.scrollBy(ae.x, ae.y) : V && (V.scrollLeft += ae.x, V.scrollTop += ae.y);
          var me = Th(V), Ie = { x: me.x - te.x, y: me.y - te.y };
          (Ie.x || Ie.y) && E.fire({ type: "autoscroll", target: A, interactable: E, delta: Ie, interaction: T, container: V });
        }
        jt.prevTime = U;
      }
      jt.isScrolling && (lo.cancel(jt.i), jt.i = lo.request(jt.scroll));
    }, check: function(T, E) {
      var A;
      return (A = T.options[E].autoScroll) == null ? void 0 : A.enabled;
    }, onInteractionMove: function(T) {
      var E = T.interaction, A = T.pointer;
      if (E.interacting() && jt.check(E.interactable, E.prepared.name)) if (E.simulation) jt.x = jt.y = 0;
      else {
        var I, P, V, U, q = E.interactable, Q = E.element, ae = E.prepared.name, te = q.options[ae].autoScroll, me = Eh(te.container, q, Q);
        if (S.window(me)) U = A.clientX < jt.margin, I = A.clientY < jt.margin, P = A.clientX > me.innerWidth - jt.margin, V = A.clientY > me.innerHeight - jt.margin;
        else {
          var Ie = pe(me);
          U = A.clientX < Ie.left + jt.margin, I = A.clientY < Ie.top + jt.margin, P = A.clientX > Ie.right - jt.margin, V = A.clientY > Ie.bottom - jt.margin;
        }
        jt.x = P ? 1 : U ? -1 : 0, jt.y = V ? 1 : I ? -1 : 0, jt.isScrolling || (jt.margin = te.margin, jt.speed = te.speed, jt.start(E));
      }
    } };
    function Eh(T, E, A) {
      return (S.string(T) ? Pe(T, E, A) : T) || _(A);
    }
    function Th(T) {
      return S.window(T) && (T = window.document.body), { x: T.scrollLeft, y: T.scrollTop };
    }
    var Lw = { id: "auto-scroll", install: function(T) {
      var E = T.defaults, A = T.actions;
      T.autoScroll = jt, jt.now = function() {
        return T.now();
      }, A.phaselessTypes.autoscroll = !0, E.perAction.autoScroll = jt.defaults;
    }, listeners: { "interactions:new": function(T) {
      T.interaction.autoScroll = null;
    }, "interactions:destroy": function(T) {
      T.interaction.autoScroll = null, jt.stop(), jt.interaction && (jt.interaction = null);
    }, "interactions:stop": jt.stop, "interactions:action-move": function(T) {
      return jt.onInteractionMove(T);
    } } }, St = Lw;
    function de(T, E) {
      var A = !1;
      return function() {
        return A || (y.console.warn(E), A = !0), T.apply(this, arguments);
      };
    }
    function qe(T, E) {
      return T.name = E.name, T.axis = E.axis, T.edges = E.edges, T;
    }
    function gt(T) {
      return S.bool(T) ? (this.options.styleCursor = T, this) : T === null ? (delete this.options.styleCursor, this) : this.options.styleCursor;
    }
    function Wn(T) {
      return S.func(T) ? (this.options.actionChecker = T, this) : T === null ? (delete this.options.actionChecker, this) : this.options.actionChecker;
    }
    var Pr = { id: "auto-start/interactableMethods", install: function(T) {
      var E = T.Interactable;
      E.prototype.getAction = function(A, I, P, V) {
        var U = function(q, Q, ae, te, me) {
          var Ie = q.getRect(te), Ve = Q.buttons || { 0: 1, 1: 4, 3: 8, 4: 16 }[Q.button], Fe = { action: null, interactable: q, interaction: ae, element: te, rect: Ie, buttons: Ve };
          return me.fire("auto-start:check", Fe), Fe.action;
        }(this, I, P, V, T);
        return this.options.actionChecker ? this.options.actionChecker(A, I, U, this, V, P) : U;
      }, E.prototype.ignoreFrom = de(function(A) {
        return this._backCompatOption("ignoreFrom", A);
      }, "Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue})."), E.prototype.allowFrom = de(function(A) {
        return this._backCompatOption("allowFrom", A);
      }, "Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue})."), E.prototype.actionChecker = Wn, E.prototype.styleCursor = gt;
    } };
    function ar(T, E, A, I, P) {
      return E.testIgnoreAllow(E.options[T.name], A, I) && E.options[T.name].enabled && Ll(E, A, T, P) ? T : null;
    }
    function ri(T, E, A, I, P, V, U) {
      for (var q = 0, Q = I.length; q < Q; q++) {
        var ae = I[q], te = P[q], me = ae.getAction(E, A, T, te);
        if (me) {
          var Ie = ar(me, ae, te, V, U);
          if (Ie) return { action: Ie, interactable: ae, element: te };
        }
      }
      return { action: null, interactable: null, element: null };
    }
    function ka(T, E, A, I, P) {
      var V = [], U = [], q = I;
      function Q(te) {
        V.push(te), U.push(q);
      }
      for (; S.element(q); ) {
        V = [], U = [], P.interactables.forEachMatch(q, Q);
        var ae = ri(T, E, A, V, U, I, P);
        if (ae.action && !ae.interactable.options[ae.action.name].manualStart) return ae;
        q = Y(q);
      }
      return { action: null, interactable: null, element: null };
    }
    function Il(T, E, A) {
      var I = E.action, P = E.interactable, V = E.element;
      I = I || { name: null }, T.interactable = P, T.element = V, qe(T.prepared, I), T.rect = P && I.name ? P.getRect(V) : null, Ch(T, A), A.fire("autoStart:prepared", { interaction: T });
    }
    function Ll(T, E, A, I) {
      var P = T.options, V = P[A.name].max, U = P[A.name].maxPerElement, q = I.autoStart.maxInteractions, Q = 0, ae = 0, te = 0;
      if (!(V && U && q)) return !1;
      for (var me = 0, Ie = I.interactions.list; me < Ie.length; me++) {
        var Ve = Ie[me], Fe = Ve.prepared.name;
        if (Ve.interacting() && (++Q >= q || Ve.interactable === T && ((ae += Fe === A.name ? 1 : 0) >= V || Ve.element === E && (te++, Fe === A.name && te >= U))))
          return !1;
      }
      return q > 0;
    }
    function Cr(T, E) {
      return S.number(T) ? (E.autoStart.maxInteractions = T, this) : E.autoStart.maxInteractions;
    }
    function lf(T, E, A) {
      var I = A.autoStart.cursorElement;
      I && I !== T && (I.style.cursor = ""), T.ownerDocument.documentElement.style.cursor = E, T.style.cursor = E, A.autoStart.cursorElement = E ? T : null;
    }
    function Ch(T, E) {
      var A = T.interactable, I = T.element, P = T.prepared;
      if (T.pointerType === "mouse" && A && A.options.styleCursor) {
        var V = "";
        if (P.name) {
          var U = A.options[P.name].cursorChecker;
          V = S.func(U) ? U(P, A, I, T._interacting) : E.actions.map[P.name].getCursor(P);
        }
        lf(T.element, V || "", E);
      } else E.autoStart.cursorElement && lf(E.autoStart.cursorElement, "", E);
    }
    var MX = { id: "auto-start/base", before: ["actions"], install: function(T) {
      var E = T.interactStatic, A = T.defaults;
      T.usePlugin(Pr), A.base.actionChecker = null, A.base.styleCursor = !0, ce(A.perAction, { manualStart: !1, max: 1 / 0, maxPerElement: 1, allowFrom: null, ignoreFrom: null, mouseButtons: 1 }), E.maxInteractions = function(I) {
        return Cr(I, T);
      }, T.autoStart = { maxInteractions: 1 / 0, withinInteractionLimit: Ll, cursorElement: null };
    }, listeners: { "interactions:down": function(T, E) {
      var A = T.interaction, I = T.pointer, P = T.event, V = T.eventTarget;
      A.interacting() || Il(A, ka(A, I, P, V, E), E);
    }, "interactions:move": function(T, E) {
      (function(A, I) {
        var P = A.interaction, V = A.pointer, U = A.event, q = A.eventTarget;
        P.pointerType !== "mouse" || P.pointerIsDown || P.interacting() || Il(P, ka(P, V, U, q, I), I);
      })(T, E), function(A, I) {
        var P = A.interaction;
        if (P.pointerIsDown && !P.interacting() && P.pointerWasMoved && P.prepared.name) {
          I.fire("autoStart:before-start", A);
          var V = P.interactable, U = P.prepared.name;
          U && V && (V.options[U].manualStart || !Ll(V, P.element, P.prepared, I) ? P.stop() : (P.start(P.prepared, V, P.element), Ch(P, I)));
        }
      }(T, E);
    }, "interactions:stop": function(T, E) {
      var A = T.interaction, I = A.interactable;
      I && I.options.styleCursor && lf(A.element, "", E);
    } }, maxInteractions: Cr, withinInteractionLimit: Ll, validateAction: ar }, Nw = MX, DX = { id: "auto-start/dragAxis", listeners: { "autoStart:before-start": function(T, E) {
      var A = T.interaction, I = T.eventTarget, P = T.dx, V = T.dy;
      if (A.prepared.name === "drag") {
        var U = Math.abs(P), q = Math.abs(V), Q = A.interactable.options.drag, ae = Q.startAxis, te = U > q ? "x" : U < q ? "y" : "xy";
        if (A.prepared.axis = Q.lockAxis === "start" ? te[0] : Q.lockAxis, te !== "xy" && ae !== "xy" && ae !== te) {
          A.prepared.name = null;
          for (var me = I, Ie = function(Fe) {
            if (Fe !== A.interactable) {
              var Xe = A.interactable.options.drag;
              if (!Xe.manualStart && Fe.testIgnoreAllow(Xe, me, I)) {
                var pt = Fe.getAction(A.downPointer, A.downEvent, A, me);
                if (pt && pt.name === "drag" && function(st, Et) {
                  if (!Et) return !1;
                  var Zt = Et.options.drag.startAxis;
                  return st === "xy" || Zt === "xy" || Zt === st;
                }(te, Fe) && Nw.validateAction(pt, Fe, me, I, E)) return Fe;
              }
            }
          }; S.element(me); ) {
            var Ve = E.interactables.forEachMatch(me, Ie);
            if (Ve) {
              A.prepared.name = "drag", A.interactable = Ve, A.element = me;
              break;
            }
            me = Y(me);
          }
        }
      }
    } } };
    function Rw(T) {
      var E = T.prepared && T.prepared.name;
      if (!E) return null;
      var A = T.interactable.options;
      return A[E].hold || A[E].delay;
    }
    var OX = { id: "auto-start/hold", install: function(T) {
      var E = T.defaults;
      T.usePlugin(Nw), E.perAction.hold = 0, E.perAction.delay = 0;
    }, listeners: { "interactions:new": function(T) {
      T.interaction.autoStartHoldTimer = null;
    }, "autoStart:prepared": function(T) {
      var E = T.interaction, A = Rw(E);
      A > 0 && (E.autoStartHoldTimer = setTimeout(function() {
        E.start(E.prepared, E.interactable, E.element);
      }, A));
    }, "interactions:move": function(T) {
      var E = T.interaction, A = T.duplicate;
      E.autoStartHoldTimer && E.pointerWasMoved && !A && (clearTimeout(E.autoStartHoldTimer), E.autoStartHoldTimer = null);
    }, "autoStart:before-start": function(T) {
      var E = T.interaction;
      Rw(E) > 0 && (E.prepared.name = null);
    } }, getHoldDuration: Rw }, IX = OX, LX = { id: "auto-start", install: function(T) {
      T.usePlugin(Nw), T.usePlugin(IX), T.usePlugin(DX);
    } }, NX = function(T) {
      return /^(always|never|auto)$/.test(T) ? (this.options.preventDefault = T, this) : S.bool(T) ? (this.options.preventDefault = T ? "always" : "never", this) : this.options.preventDefault;
    };
    function RX(T) {
      var E = T.interaction, A = T.event;
      E.interactable && E.interactable.checkAndPreventDefault(A);
    }
    var kI = { id: "core/interactablePreventDefault", install: function(T) {
      var E = T.Interactable;
      E.prototype.preventDefault = NX, E.prototype.checkAndPreventDefault = function(A) {
        return function(I, P, V) {
          var U = I.options.preventDefault;
          if (U !== "never") if (U !== "always") {
            if (P.events.supportsPassive && /^touch(start|move)$/.test(V.type)) {
              var q = _(V.target).document, Q = P.getDocOptions(q);
              if (!Q || !Q.events || Q.events.passive !== !1) return;
            }
            /^(mouse|pointer|touch)*(down|start)/i.test(V.type) || S.element(V.target) && ne(V.target, "input,select,textarea,[contenteditable=true],[contenteditable=true] *") || V.preventDefault();
          } else V.preventDefault();
        }(this, T, A);
      }, T.interactions.docEvents.push({ type: "dragstart", listener: function(A) {
        for (var I = 0, P = T.interactions.list; I < P.length; I++) {
          var V = P[I];
          if (V.element && (V.element === A.target || B(V.element, A.target))) return void V.interactable.checkAndPreventDefault(A);
        }
      } });
    }, listeners: ["down", "move", "up", "cancel"].reduce(function(T, E) {
      return T["interactions:".concat(E)] = RX, T;
    }, {}) };
    function ly(T, E) {
      if (E.phaselessTypes[T]) return !0;
      for (var A in E.map) if (T.indexOf(A) === 0 && T.substr(A.length) in E.phases) return !0;
      return !1;
    }
    function uf(T) {
      var E = {};
      for (var A in T) {
        var I = T[A];
        S.plainObject(I) ? E[A] = uf(I) : S.array(I) ? E[A] = rn(I) : E[A] = I;
      }
      return E;
    }
    var Pw = function() {
      function T(E) {
        a(this, T), this.states = [], this.startOffset = { left: 0, right: 0, top: 0, bottom: 0 }, this.startDelta = void 0, this.result = void 0, this.endResult = void 0, this.startEdges = void 0, this.edges = void 0, this.interaction = void 0, this.interaction = E, this.result = uy(), this.edges = { left: !1, right: !1, top: !1, bottom: !1 };
      }
      return s(T, [{ key: "start", value: function(E, A) {
        var I, P, V = E.phase, U = this.interaction, q = function(ae) {
          var te = ae.interactable.options[ae.prepared.name], me = te.modifiers;
          return me && me.length ? me : ["snap", "snapSize", "snapEdges", "restrict", "restrictEdges", "restrictSize"].map(function(Ie) {
            var Ve = te[Ie];
            return Ve && Ve.enabled && { options: Ve, methods: Ve._methods };
          }).filter(function(Ie) {
            return !!Ie;
          });
        }(U);
        this.prepareStates(q), this.startEdges = ce({}, U.edges), this.edges = ce({}, this.startEdges), this.startOffset = (I = U.rect, P = A, I ? { left: P.x - I.left, top: P.y - I.top, right: I.right - P.x, bottom: I.bottom - P.y } : { left: 0, top: 0, right: 0, bottom: 0 }), this.startDelta = { x: 0, y: 0 };
        var Q = this.fillArg({ phase: V, pageCoords: A, preEnd: !1 });
        return this.result = uy(), this.startAll(Q), this.result = this.setAll(Q);
      } }, { key: "fillArg", value: function(E) {
        var A = this.interaction;
        return E.interaction = A, E.interactable = A.interactable, E.element = A.element, E.rect || (E.rect = A.rect), E.edges || (E.edges = this.startEdges), E.startOffset = this.startOffset, E;
      } }, { key: "startAll", value: function(E) {
        for (var A = 0, I = this.states; A < I.length; A++) {
          var P = I[A];
          P.methods.start && (E.state = P, P.methods.start(E));
        }
      } }, { key: "setAll", value: function(E) {
        var A = E.phase, I = E.preEnd, P = E.skipModifiers, V = E.rect, U = E.edges;
        E.coords = ce({}, E.pageCoords), E.rect = ce({}, V), E.edges = ce({}, U);
        for (var q = P ? this.states.slice(P) : this.states, Q = uy(E.coords, E.rect), ae = 0; ae < q.length; ae++) {
          var te, me = q[ae], Ie = me.options, Ve = ce({}, E.coords), Fe = null;
          (te = me.methods) != null && te.set && this.shouldDo(Ie, I, A) && (E.state = me, Fe = me.methods.set(E), he(E.edges, E.rect, { x: E.coords.x - Ve.x, y: E.coords.y - Ve.y })), Q.eventProps.push(Fe);
        }
        ce(this.edges, E.edges), Q.delta.x = E.coords.x - E.pageCoords.x, Q.delta.y = E.coords.y - E.pageCoords.y, Q.rectDelta.left = E.rect.left - V.left, Q.rectDelta.right = E.rect.right - V.right, Q.rectDelta.top = E.rect.top - V.top, Q.rectDelta.bottom = E.rect.bottom - V.bottom;
        var Xe = this.result.coords, pt = this.result.rect;
        if (Xe && pt) {
          var st = Q.rect.left !== pt.left || Q.rect.right !== pt.right || Q.rect.top !== pt.top || Q.rect.bottom !== pt.bottom;
          Q.changed = st || Xe.x !== Q.coords.x || Xe.y !== Q.coords.y;
        }
        return Q;
      } }, { key: "applyToInteraction", value: function(E) {
        var A = this.interaction, I = E.phase, P = A.coords.cur, V = A.coords.start, U = this.result, q = this.startDelta, Q = U.delta;
        I === "start" && ce(this.startDelta, U.delta);
        for (var ae = 0, te = [[V, q], [P, Q]]; ae < te.length; ae++) {
          var me = te[ae], Ie = me[0], Ve = me[1];
          Ie.page.x += Ve.x, Ie.page.y += Ve.y, Ie.client.x += Ve.x, Ie.client.y += Ve.y;
        }
        var Fe = this.result.rectDelta, Xe = E.rect || A.rect;
        Xe.left += Fe.left, Xe.right += Fe.right, Xe.top += Fe.top, Xe.bottom += Fe.bottom, Xe.width = Xe.right - Xe.left, Xe.height = Xe.bottom - Xe.top;
      } }, { key: "setAndApply", value: function(E) {
        var A = this.interaction, I = E.phase, P = E.preEnd, V = E.skipModifiers, U = this.setAll(this.fillArg({ preEnd: P, phase: I, pageCoords: E.modifiedCoords || A.coords.cur.page }));
        if (this.result = U, !U.changed && (!V || V < this.states.length) && A.interacting()) return !1;
        if (E.modifiedCoords) {
          var q = A.coords.cur.page, Q = { x: E.modifiedCoords.x - q.x, y: E.modifiedCoords.y - q.y };
          U.coords.x += Q.x, U.coords.y += Q.y, U.delta.x += Q.x, U.delta.y += Q.y;
        }
        this.applyToInteraction(E);
      } }, { key: "beforeEnd", value: function(E) {
        var A = E.interaction, I = E.event, P = this.states;
        if (P && P.length) {
          for (var V = !1, U = 0; U < P.length; U++) {
            var q = P[U];
            E.state = q;
            var Q = q.options, ae = q.methods, te = ae.beforeEnd && ae.beforeEnd(E);
            if (te) return this.endResult = te, !1;
            V = V || !V && this.shouldDo(Q, !0, E.phase, !0);
          }
          V && A.move({ event: I, preEnd: !0 });
        }
      } }, { key: "stop", value: function(E) {
        var A = E.interaction;
        if (this.states && this.states.length) {
          var I = ce({ states: this.states, interactable: A.interactable, element: A.element, rect: null }, E);
          this.fillArg(I);
          for (var P = 0, V = this.states; P < V.length; P++) {
            var U = V[P];
            I.state = U, U.methods.stop && U.methods.stop(I);
          }
          this.states = null, this.endResult = null;
        }
      } }, { key: "prepareStates", value: function(E) {
        this.states = [];
        for (var A = 0; A < E.length; A++) {
          var I = E[A], P = I.options, V = I.methods, U = I.name;
          this.states.push({ options: P, methods: V, index: A, name: U });
        }
        return this.states;
      } }, { key: "restoreInteractionCoords", value: function(E) {
        var A = E.interaction, I = A.coords, P = A.rect, V = A.modification;
        if (V.result) {
          for (var U = V.startDelta, q = V.result, Q = q.delta, ae = q.rectDelta, te = 0, me = [[I.start, U], [I.cur, Q]]; te < me.length; te++) {
            var Ie = me[te], Ve = Ie[0], Fe = Ie[1];
            Ve.page.x -= Fe.x, Ve.page.y -= Fe.y, Ve.client.x -= Fe.x, Ve.client.y -= Fe.y;
          }
          P.left -= ae.left, P.right -= ae.right, P.top -= ae.top, P.bottom -= ae.bottom;
        }
      } }, { key: "shouldDo", value: function(E, A, I, P) {
        return !(!E || E.enabled === !1 || P && !E.endOnly || E.endOnly && !A || I === "start" && !E.setStart);
      } }, { key: "copyFrom", value: function(E) {
        this.startOffset = E.startOffset, this.startDelta = E.startDelta, this.startEdges = E.startEdges, this.edges = E.edges, this.states = E.states.map(function(A) {
          return uf(A);
        }), this.result = uy(ce({}, E.result.coords), ce({}, E.result.rect));
      } }, { key: "destroy", value: function() {
        for (var E in this) this[E] = null;
      } }]), T;
    }();
    function uy(T, E) {
      return { rect: E, coords: T, delta: { x: 0, y: 0 }, rectDelta: { left: 0, right: 0, top: 0, bottom: 0 }, eventProps: [], changed: !0 };
    }
    function Nl(T, E) {
      var A = T.defaults, I = { start: T.start, set: T.set, beforeEnd: T.beforeEnd, stop: T.stop }, P = function(V) {
        var U = V || {};
        for (var q in U.enabled = U.enabled !== !1, A) q in U || (U[q] = A[q]);
        var Q = { options: U, methods: I, name: E, enable: function() {
          return U.enabled = !0, Q;
        }, disable: function() {
          return U.enabled = !1, Q;
        } };
        return Q;
      };
      return E && typeof E == "string" && (P._defaults = A, P._methods = I), P;
    }
    function kh(T) {
      var E = T.iEvent, A = T.interaction.modification.result;
      A && (E.modifiers = A.eventProps);
    }
    var PX = { id: "modifiers/base", before: ["actions"], install: function(T) {
      T.defaults.perAction.modifiers = [];
    }, listeners: { "interactions:new": function(T) {
      var E = T.interaction;
      E.modification = new Pw(E);
    }, "interactions:before-action-start": function(T) {
      var E = T.interaction, A = T.interaction.modification;
      A.start(T, E.coords.start.page), E.edges = A.edges, A.applyToInteraction(T);
    }, "interactions:before-action-move": function(T) {
      var E = T.interaction, A = E.modification, I = A.setAndApply(T);
      return E.edges = A.edges, I;
    }, "interactions:before-action-end": function(T) {
      var E = T.interaction, A = E.modification, I = A.beforeEnd(T);
      return E.edges = A.startEdges, I;
    }, "interactions:action-start": kh, "interactions:action-move": kh, "interactions:action-end": kh, "interactions:after-action-start": function(T) {
      return T.interaction.modification.restoreInteractionCoords(T);
    }, "interactions:after-action-move": function(T) {
      return T.interaction.modification.restoreInteractionCoords(T);
    }, "interactions:stop": function(T) {
      return T.interaction.modification.stop(T);
    } } }, AI = PX, MI = { base: { preventDefault: "auto", deltaSource: "page" }, perAction: { enabled: !1, origin: { x: 0, y: 0 } }, actions: {} }, jw = function(T) {
      u(A, T);
      var E = p(A);
      function A(I, P, V, U, q, Q, ae) {
        var te;
        a(this, A), (te = E.call(this, I)).relatedTarget = null, te.screenX = void 0, te.screenY = void 0, te.button = void 0, te.buttons = void 0, te.ctrlKey = void 0, te.shiftKey = void 0, te.altKey = void 0, te.metaKey = void 0, te.page = void 0, te.client = void 0, te.delta = void 0, te.rect = void 0, te.x0 = void 0, te.y0 = void 0, te.t0 = void 0, te.dt = void 0, te.duration = void 0, te.clientX0 = void 0, te.clientY0 = void 0, te.velocity = void 0, te.speed = void 0, te.swipe = void 0, te.axes = void 0, te.preEnd = void 0, q = q || I.element;
        var me = I.interactable, Ie = (me && me.options || MI).deltaSource, Ve = Oe(me, q, V), Fe = U === "start", Xe = U === "end", pt = Fe ? f(te) : I.prevEvent, st = Fe ? I.coords.start : Xe ? { page: pt.page, client: pt.client, timeStamp: I.coords.cur.timeStamp } : I.coords.cur;
        return te.page = ce({}, st.page), te.client = ce({}, st.client), te.rect = ce({}, I.rect), te.timeStamp = st.timeStamp, Xe || (te.page.x -= Ve.x, te.page.y -= Ve.y, te.client.x -= Ve.x, te.client.y -= Ve.y), te.ctrlKey = P.ctrlKey, te.altKey = P.altKey, te.shiftKey = P.shiftKey, te.metaKey = P.metaKey, te.button = P.button, te.buttons = P.buttons, te.target = q, te.currentTarget = q, te.preEnd = Q, te.type = ae || V + (U || ""), te.interactable = me, te.t0 = Fe ? I.pointers[I.pointers.length - 1].downTime : pt.t0, te.x0 = I.coords.start.page.x - Ve.x, te.y0 = I.coords.start.page.y - Ve.y, te.clientX0 = I.coords.start.client.x - Ve.x, te.clientY0 = I.coords.start.client.y - Ve.y, te.delta = Fe || Xe ? { x: 0, y: 0 } : { x: te[Ie].x - pt[Ie].x, y: te[Ie].y - pt[Ie].y }, te.dt = I.coords.delta.timeStamp, te.duration = te.timeStamp - te.t0, te.velocity = ce({}, I.coords.velocity[Ie]), te.speed = je(te.velocity.x, te.velocity.y), te.swipe = Xe || U === "inertiastart" ? te.getSwipe() : null, te;
      }
      return s(A, [{ key: "getSwipe", value: function() {
        var I = this._interaction;
        if (I.prevEvent.speed < 600 || this.timeStamp - I.prevEvent.timeStamp > 150) return null;
        var P = 180 * Math.atan2(I.prevEvent.velocityY, I.prevEvent.velocityX) / Math.PI;
        P < 0 && (P += 360);
        var V = 112.5 <= P && P < 247.5, U = 202.5 <= P && P < 337.5;
        return { up: U, down: !U && 22.5 <= P && P < 157.5, left: V, right: !V && (292.5 <= P || P < 67.5), angle: P, speed: I.prevEvent.speed, velocity: { x: I.prevEvent.velocityX, y: I.prevEvent.velocityY } };
      } }, { key: "preventDefault", value: function() {
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = !0;
      } }]), A;
    }(rt);
    Object.defineProperties(jw.prototype, { pageX: { get: function() {
      return this.page.x;
    }, set: function(T) {
      this.page.x = T;
    } }, pageY: { get: function() {
      return this.page.y;
    }, set: function(T) {
      this.page.y = T;
    } }, clientX: { get: function() {
      return this.client.x;
    }, set: function(T) {
      this.client.x = T;
    } }, clientY: { get: function() {
      return this.client.y;
    }, set: function(T) {
      this.client.y = T;
    } }, dx: { get: function() {
      return this.delta.x;
    }, set: function(T) {
      this.delta.x = T;
    } }, dy: { get: function() {
      return this.delta.y;
    }, set: function(T) {
      this.delta.y = T;
    } }, velocityX: { get: function() {
      return this.velocity.x;
    }, set: function(T) {
      this.velocity.x = T;
    } }, velocityY: { get: function() {
      return this.velocity.y;
    }, set: function(T) {
      this.velocity.y = T;
    } } });
    var jX = s(function T(E, A, I, P, V) {
      a(this, T), this.id = void 0, this.pointer = void 0, this.event = void 0, this.downTime = void 0, this.downTarget = void 0, this.id = E, this.pointer = A, this.event = I, this.downTime = P, this.downTarget = V;
    }), BX = function(T) {
      return T.interactable = "", T.element = "", T.prepared = "", T.pointerIsDown = "", T.pointerWasMoved = "", T._proxy = "", T;
    }({}), DI = function(T) {
      return T.start = "", T.move = "", T.end = "", T.stop = "", T.interacting = "", T;
    }({}), $X = 0, zX = function() {
      function T(E) {
        var A = this, I = E.pointerType, P = E.scopeFire;
        a(this, T), this.interactable = null, this.element = null, this.rect = null, this._rects = void 0, this.edges = null, this._scopeFire = void 0, this.prepared = { name: null, axis: null, edges: null }, this.pointerType = void 0, this.pointers = [], this.downEvent = null, this.downPointer = {}, this._latestPointer = { pointer: null, event: null, eventTarget: null }, this.prevEvent = null, this.pointerIsDown = !1, this.pointerWasMoved = !1, this._interacting = !1, this._ending = !1, this._stopped = !0, this._proxy = void 0, this.simulation = null, this.doMove = de(function(te) {
          this.move(te);
        }, "The interaction.doMove() method has been renamed to interaction.move()"), this.coords = { start: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, prev: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, cur: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, delta: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, velocity: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 } }, this._id = $X++, this._scopeFire = P, this.pointerType = I;
        var V = this;
        this._proxy = {};
        var U = function(te) {
          Object.defineProperty(A._proxy, te, { get: function() {
            return V[te];
          } });
        };
        for (var q in BX) U(q);
        var Q = function(te) {
          Object.defineProperty(A._proxy, te, { value: function() {
            return V[te].apply(V, arguments);
          } });
        };
        for (var ae in DI) Q(ae);
        this._scopeFire("interactions:new", { interaction: this });
      }
      return s(T, [{ key: "pointerMoveTolerance", get: function() {
        return 1;
      } }, { key: "pointerDown", value: function(E, A, I) {
        var P = this.updatePointer(E, A, I, !0), V = this.pointers[P];
        this._scopeFire("interactions:down", { pointer: E, event: A, eventTarget: I, pointerIndex: P, pointerInfo: V, type: "down", interaction: this });
      } }, { key: "start", value: function(E, A, I) {
        return !(this.interacting() || !this.pointerIsDown || this.pointers.length < (E.name === "gesture" ? 2 : 1) || !A.options[E.name].enabled) && (qe(this.prepared, E), this.interactable = A, this.element = I, this.rect = A.getRect(I), this.edges = this.prepared.edges ? ce({}, this.prepared.edges) : { left: !0, right: !0, top: !0, bottom: !0 }, this._stopped = !1, this._interacting = this._doPhase({ interaction: this, event: this.downEvent, phase: "start" }) && !this._stopped, this._interacting);
      } }, { key: "pointerMove", value: function(E, A, I) {
        this.simulation || this.modification && this.modification.endResult || this.updatePointer(E, A, I, !1);
        var P, V, U = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;
        this.pointerIsDown && !this.pointerWasMoved && (P = this.coords.cur.client.x - this.coords.start.client.x, V = this.coords.cur.client.y - this.coords.start.client.y, this.pointerWasMoved = je(P, V) > this.pointerMoveTolerance);
        var q, Q, ae, te = this.getPointerIndex(E), me = { pointer: E, pointerIndex: te, pointerInfo: this.pointers[te], event: A, type: "move", eventTarget: I, dx: P, dy: V, duplicate: U, interaction: this };
        U || (q = this.coords.velocity, Q = this.coords.delta, ae = Math.max(Q.timeStamp / 1e3, 1e-3), q.page.x = Q.page.x / ae, q.page.y = Q.page.y / ae, q.client.x = Q.client.x / ae, q.client.y = Q.client.y / ae, q.timeStamp = ae), this._scopeFire("interactions:move", me), U || this.simulation || (this.interacting() && (me.type = null, this.move(me)), this.pointerWasMoved && it(this.coords.prev, this.coords.cur));
      } }, { key: "move", value: function(E) {
        E && E.event || Nt(this.coords.delta), (E = ce({ pointer: this._latestPointer.pointer, event: this._latestPointer.event, eventTarget: this._latestPointer.eventTarget, interaction: this }, E || {})).phase = "move", this._doPhase(E);
      } }, { key: "pointerUp", value: function(E, A, I, P) {
        var V = this.getPointerIndex(E);
        V === -1 && (V = this.updatePointer(E, A, I, !1));
        var U = /cancel$/i.test(A.type) ? "cancel" : "up";
        this._scopeFire("interactions:".concat(U), { pointer: E, pointerIndex: V, pointerInfo: this.pointers[V], event: A, eventTarget: I, type: U, curEventTarget: P, interaction: this }), this.simulation || this.end(A), this.removePointer(E, A);
      } }, { key: "documentBlur", value: function(E) {
        this.end(E), this._scopeFire("interactions:blur", { event: E, type: "blur", interaction: this });
      } }, { key: "end", value: function(E) {
        var A;
        this._ending = !0, E = E || this._latestPointer.event, this.interacting() && (A = this._doPhase({ event: E, interaction: this, phase: "end" })), this._ending = !1, A === !0 && this.stop();
      } }, { key: "currentAction", value: function() {
        return this._interacting ? this.prepared.name : null;
      } }, { key: "interacting", value: function() {
        return this._interacting;
      } }, { key: "stop", value: function() {
        this._scopeFire("interactions:stop", { interaction: this }), this.interactable = this.element = null, this._interacting = !1, this._stopped = !0, this.prepared.name = this.prevEvent = null;
      } }, { key: "getPointerIndex", value: function(E) {
        var A = Re(E);
        return this.pointerType === "mouse" || this.pointerType === "pen" ? this.pointers.length - 1 : Kt(this.pointers, function(I) {
          return I.id === A;
        });
      } }, { key: "getPointerInfo", value: function(E) {
        return this.pointers[this.getPointerIndex(E)];
      } }, { key: "updatePointer", value: function(E, A, I, P) {
        var V, U, q, Q = Re(E), ae = this.getPointerIndex(E), te = this.pointers[ae];
        return P = P !== !1 && (P || /(down|start)$/i.test(A.type)), te ? te.pointer = E : (te = new jX(Q, E, A, null, null), ae = this.pointers.length, this.pointers.push(te)), be(this.coords.cur, this.pointers.map(function(me) {
          return me.pointer;
        }), this._now()), V = this.coords.delta, U = this.coords.prev, q = this.coords.cur, V.page.x = q.page.x - U.page.x, V.page.y = q.page.y - U.page.y, V.client.x = q.client.x - U.client.x, V.client.y = q.client.y - U.client.y, V.timeStamp = q.timeStamp - U.timeStamp, P && (this.pointerIsDown = !0, te.downTime = this.coords.cur.timeStamp, te.downTarget = I, ot(this.downPointer, E), this.interacting() || (it(this.coords.start, this.coords.cur), it(this.coords.prev, this.coords.cur), this.downEvent = A, this.pointerWasMoved = !1)), this._updateLatestPointer(E, A, I), this._scopeFire("interactions:update-pointer", { pointer: E, event: A, eventTarget: I, down: P, pointerInfo: te, pointerIndex: ae, interaction: this }), ae;
      } }, { key: "removePointer", value: function(E, A) {
        var I = this.getPointerIndex(E);
        if (I !== -1) {
          var P = this.pointers[I];
          this._scopeFire("interactions:remove-pointer", { pointer: E, event: A, eventTarget: null, pointerIndex: I, pointerInfo: P, interaction: this }), this.pointers.splice(I, 1), this.pointerIsDown = !1;
        }
      } }, { key: "_updateLatestPointer", value: function(E, A, I) {
        this._latestPointer.pointer = E, this._latestPointer.event = A, this._latestPointer.eventTarget = I;
      } }, { key: "destroy", value: function() {
        this._latestPointer.pointer = null, this._latestPointer.event = null, this._latestPointer.eventTarget = null;
      } }, { key: "_createPreparedEvent", value: function(E, A, I, P) {
        return new jw(this, E, this.prepared.name, A, this.element, I, P);
      } }, { key: "_fireEvent", value: function(E) {
        var A;
        (A = this.interactable) == null || A.fire(E), (!this.prevEvent || E.timeStamp >= this.prevEvent.timeStamp) && (this.prevEvent = E);
      } }, { key: "_doPhase", value: function(E) {
        var A = E.event, I = E.phase, P = E.preEnd, V = E.type, U = this.rect;
        if (U && I === "move" && (he(this.edges, U, this.coords.delta[this.interactable.options.deltaSource]), U.width = U.right - U.left, U.height = U.bottom - U.top), this._scopeFire("interactions:before-action-".concat(I), E) === !1) return !1;
        var q = E.iEvent = this._createPreparedEvent(A, I, P, V);
        return this._scopeFire("interactions:action-".concat(I), E), I === "start" && (this.prevEvent = q), this._fireEvent(q), this._scopeFire("interactions:after-action-".concat(I), E), !0;
      } }, { key: "_now", value: function() {
        return Date.now();
      } }]), T;
    }();
    function OI(T) {
      II(T.interaction);
    }
    function II(T) {
      if (!function(A) {
        return !(!A.offset.pending.x && !A.offset.pending.y);
      }(T)) return !1;
      var E = T.offset.pending;
      return Bw(T.coords.cur, E), Bw(T.coords.delta, E), he(T.edges, T.rect, E), E.x = 0, E.y = 0, !0;
    }
    function FX(T) {
      var E = T.x, A = T.y;
      this.offset.pending.x += E, this.offset.pending.y += A, this.offset.total.x += E, this.offset.total.y += A;
    }
    function Bw(T, E) {
      var A = T.page, I = T.client, P = E.x, V = E.y;
      A.x += P, A.y += V, I.x += P, I.y += V;
    }
    DI.offsetBy = "";
    var VX = { id: "offset", before: ["modifiers", "pointer-events", "actions", "inertia"], install: function(T) {
      T.Interaction.prototype.offsetBy = FX;
    }, listeners: { "interactions:new": function(T) {
      T.interaction.offset = { total: { x: 0, y: 0 }, pending: { x: 0, y: 0 } };
    }, "interactions:update-pointer": function(T) {
      return function(E) {
        E.pointerIsDown && (Bw(E.coords.cur, E.offset.total), E.offset.pending.x = 0, E.offset.pending.y = 0);
      }(T.interaction);
    }, "interactions:before-action-start": OI, "interactions:before-action-move": OI, "interactions:before-action-end": function(T) {
      var E = T.interaction;
      if (II(E)) return E.move({ offset: !0 }), E.end(), !1;
    }, "interactions:stop": function(T) {
      var E = T.interaction;
      E.offset.total.x = 0, E.offset.total.y = 0, E.offset.pending.x = 0, E.offset.pending.y = 0;
    } } }, LI = VX, HX = function() {
      function T(E) {
        a(this, T), this.active = !1, this.isModified = !1, this.smoothEnd = !1, this.allowResume = !1, this.modification = void 0, this.modifierCount = 0, this.modifierArg = void 0, this.startCoords = void 0, this.t0 = 0, this.v0 = 0, this.te = 0, this.targetOffset = void 0, this.modifiedOffset = void 0, this.currentOffset = void 0, this.lambda_v0 = 0, this.one_ve_v0 = 0, this.timeout = void 0, this.interaction = void 0, this.interaction = E;
      }
      return s(T, [{ key: "start", value: function(E) {
        var A = this.interaction, I = cy(A);
        if (!I || !I.enabled) return !1;
        var P = A.coords.velocity.client, V = je(P.x, P.y), U = this.modification || (this.modification = new Pw(A));
        if (U.copyFrom(A.modification), this.t0 = A._now(), this.allowResume = I.allowResume, this.v0 = V, this.currentOffset = { x: 0, y: 0 }, this.startCoords = A.coords.cur.page, this.modifierArg = U.fillArg({ pageCoords: this.startCoords, preEnd: !0, phase: "inertiastart" }), this.t0 - A.coords.cur.timeStamp < 50 && V > I.minSpeed && V > I.endSpeed) this.startInertia();
        else {
          if (U.result = U.setAll(this.modifierArg), !U.result.changed) return !1;
          this.startSmoothEnd();
        }
        return A.modification.result.rect = null, A.offsetBy(this.targetOffset), A._doPhase({ interaction: A, event: E, phase: "inertiastart" }), A.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y }), A.modification.result.rect = null, this.active = !0, A.simulation = this, !0;
      } }, { key: "startInertia", value: function() {
        var E = this, A = this.interaction.coords.velocity.client, I = cy(this.interaction), P = I.resistance, V = -Math.log(I.endSpeed / this.v0) / P;
        this.targetOffset = { x: (A.x - V) / P, y: (A.y - V) / P }, this.te = V, this.lambda_v0 = P / this.v0, this.one_ve_v0 = 1 - I.endSpeed / this.v0;
        var U = this.modification, q = this.modifierArg;
        q.pageCoords = { x: this.startCoords.x + this.targetOffset.x, y: this.startCoords.y + this.targetOffset.y }, U.result = U.setAll(q), U.result.changed && (this.isModified = !0, this.modifiedOffset = { x: this.targetOffset.x + U.result.delta.x, y: this.targetOffset.y + U.result.delta.y }), this.onNextFrame(function() {
          return E.inertiaTick();
        });
      } }, { key: "startSmoothEnd", value: function() {
        var E = this;
        this.smoothEnd = !0, this.isModified = !0, this.targetOffset = { x: this.modification.result.delta.x, y: this.modification.result.delta.y }, this.onNextFrame(function() {
          return E.smoothEndTick();
        });
      } }, { key: "onNextFrame", value: function(E) {
        var A = this;
        this.timeout = lo.request(function() {
          A.active && E();
        });
      } }, { key: "inertiaTick", value: function() {
        var E, A, I, P, V, U, q, Q = this, ae = this.interaction, te = cy(ae).resistance, me = (ae._now() - this.t0) / 1e3;
        if (me < this.te) {
          var Ie, Ve = 1 - (Math.exp(-te * me) - this.lambda_v0) / this.one_ve_v0;
          this.isModified ? (E = 0, A = 0, I = this.targetOffset.x, P = this.targetOffset.y, V = this.modifiedOffset.x, U = this.modifiedOffset.y, Ie = { x: NI(q = Ve, E, I, V), y: NI(q, A, P, U) }) : Ie = { x: this.targetOffset.x * Ve, y: this.targetOffset.y * Ve };
          var Fe = { x: Ie.x - this.currentOffset.x, y: Ie.y - this.currentOffset.y };
          this.currentOffset.x += Fe.x, this.currentOffset.y += Fe.y, ae.offsetBy(Fe), ae.move(), this.onNextFrame(function() {
            return Q.inertiaTick();
          });
        } else ae.offsetBy({ x: this.modifiedOffset.x - this.currentOffset.x, y: this.modifiedOffset.y - this.currentOffset.y }), this.end();
      } }, { key: "smoothEndTick", value: function() {
        var E = this, A = this.interaction, I = A._now() - this.t0, P = cy(A).smoothEndDuration;
        if (I < P) {
          var V = { x: RI(I, 0, this.targetOffset.x, P), y: RI(I, 0, this.targetOffset.y, P) }, U = { x: V.x - this.currentOffset.x, y: V.y - this.currentOffset.y };
          this.currentOffset.x += U.x, this.currentOffset.y += U.y, A.offsetBy(U), A.move({ skipModifiers: this.modifierCount }), this.onNextFrame(function() {
            return E.smoothEndTick();
          });
        } else A.offsetBy({ x: this.targetOffset.x - this.currentOffset.x, y: this.targetOffset.y - this.currentOffset.y }), this.end();
      } }, { key: "resume", value: function(E) {
        var A = E.pointer, I = E.event, P = E.eventTarget, V = this.interaction;
        V.offsetBy({ x: -this.currentOffset.x, y: -this.currentOffset.y }), V.updatePointer(A, I, P, !0), V._doPhase({ interaction: V, event: I, phase: "resume" }), it(V.coords.prev, V.coords.cur), this.stop();
      } }, { key: "end", value: function() {
        this.interaction.move(), this.interaction.end(), this.stop();
      } }, { key: "stop", value: function() {
        this.active = this.smoothEnd = !1, this.interaction.simulation = null, lo.cancel(this.timeout);
      } }]), T;
    }();
    function cy(T) {
      var E = T.interactable, A = T.prepared;
      return E && E.options && A.name && E.options[A.name].inertia;
    }
    var GX = { id: "inertia", before: ["modifiers", "actions"], install: function(T) {
      var E = T.defaults;
      T.usePlugin(LI), T.usePlugin(AI), T.actions.phases.inertiastart = !0, T.actions.phases.resume = !0, E.perAction.inertia = { enabled: !1, resistance: 10, minSpeed: 100, endSpeed: 10, allowResume: !0, smoothEndDuration: 300 };
    }, listeners: { "interactions:new": function(T) {
      var E = T.interaction;
      E.inertia = new HX(E);
    }, "interactions:before-action-end": function(T) {
      var E = T.interaction, A = T.event;
      return (!E._interacting || E.simulation || !E.inertia.start(A)) && null;
    }, "interactions:down": function(T) {
      var E = T.interaction, A = T.eventTarget, I = E.inertia;
      if (I.active) for (var P = A; S.element(P); ) {
        if (P === E.element) {
          I.resume(T);
          break;
        }
        P = Y(P);
      }
    }, "interactions:stop": function(T) {
      var E = T.interaction.inertia;
      E.active && E.stop();
    }, "interactions:before-action-resume": function(T) {
      var E = T.interaction.modification;
      E.stop(T), E.start(T, T.interaction.coords.cur.page), E.applyToInteraction(T);
    }, "interactions:before-action-inertiastart": function(T) {
      return T.interaction.modification.setAndApply(T);
    }, "interactions:action-resume": kh, "interactions:action-inertiastart": kh, "interactions:after-action-inertiastart": function(T) {
      return T.interaction.modification.restoreInteractionCoords(T);
    }, "interactions:after-action-resume": function(T) {
      return T.interaction.modification.restoreInteractionCoords(T);
    } } };
    function NI(T, E, A, I) {
      var P = 1 - T;
      return P * P * E + 2 * P * T * A + T * T * I;
    }
    function RI(T, E, A, I) {
      return -A * (T /= I) * (T - 2) + E;
    }
    var UX = GX;
    function PI(T, E) {
      for (var A = 0; A < E.length; A++) {
        var I = E[A];
        if (T.immediatePropagationStopped) break;
        I(T);
      }
    }
    var jI = function() {
      function T(E) {
        a(this, T), this.options = void 0, this.types = {}, this.propagationStopped = !1, this.immediatePropagationStopped = !1, this.global = void 0, this.options = ce({}, E || {});
      }
      return s(T, [{ key: "fire", value: function(E) {
        var A, I = this.global;
        (A = this.types[E.type]) && PI(E, A), !E.propagationStopped && I && (A = I[E.type]) && PI(E, A);
      } }, { key: "on", value: function(E, A) {
        var I = Te(E, A);
        for (E in I) this.types[E] = wt(this.types[E] || [], I[E]);
      } }, { key: "off", value: function(E, A) {
        var I = Te(E, A);
        for (E in I) {
          var P = this.types[E];
          if (P && P.length) for (var V = 0, U = I[E]; V < U.length; V++) {
            var q = U[V], Q = P.indexOf(q);
            Q !== -1 && P.splice(Q, 1);
          }
        }
      } }, { key: "getRect", value: function(E) {
        return null;
      } }]), T;
    }(), WX = function() {
      function T(E) {
        a(this, T), this.currentTarget = void 0, this.originalEvent = void 0, this.type = void 0, this.originalEvent = E, ot(this, E);
      }
      return s(T, [{ key: "preventOriginalDefault", value: function() {
        this.originalEvent.preventDefault();
      } }, { key: "stopPropagation", value: function() {
        this.originalEvent.stopPropagation();
      } }, { key: "stopImmediatePropagation", value: function() {
        this.originalEvent.stopImmediatePropagation();
      } }]), T;
    }();
    function Ah(T) {
      return S.object(T) ? { capture: !!T.capture, passive: !!T.passive } : { capture: !!T, passive: !1 };
    }
    function dy(T, E) {
      return T === E || (typeof T == "boolean" ? !!E.capture === T && !E.passive : !!T.capture == !!E.capture && !!T.passive == !!E.passive);
    }
    var qX = { id: "events", install: function(T) {
      var E, A = [], I = {}, P = [], V = { add: U, remove: q, addDelegate: function(te, me, Ie, Ve, Fe) {
        var Xe = Ah(Fe);
        if (!I[Ie]) {
          I[Ie] = [];
          for (var pt = 0; pt < P.length; pt++) {
            var st = P[pt];
            U(st, Ie, Q), U(st, Ie, ae, !0);
          }
        }
        var Et = I[Ie], Zt = Un(Et, function(pn) {
          return pn.selector === te && pn.context === me;
        });
        Zt || (Zt = { selector: te, context: me, listeners: [] }, Et.push(Zt)), Zt.listeners.push({ func: Ve, options: Xe });
      }, removeDelegate: function(te, me, Ie, Ve, Fe) {
        var Xe, pt = Ah(Fe), st = I[Ie], Et = !1;
        if (st)
          for (Xe = st.length - 1; Xe >= 0; Xe--) {
            var Zt = st[Xe];
            if (Zt.selector === te && Zt.context === me) {
              for (var pn = Zt.listeners, Ft = pn.length - 1; Ft >= 0; Ft--) {
                var tn = pn[Ft];
                if (tn.func === Ve && dy(tn.options, pt)) {
                  pn.splice(Ft, 1), pn.length || (st.splice(Xe, 1), q(me, Ie, Q), q(me, Ie, ae, !0)), Et = !0;
                  break;
                }
              }
              if (Et) break;
            }
          }
      }, delegateListener: Q, delegateUseCapture: ae, delegatedEvents: I, documents: P, targets: A, supportsOptions: !1, supportsPassive: !1 };
      function U(te, me, Ie, Ve) {
        if (te.addEventListener) {
          var Fe = Ah(Ve), Xe = Un(A, function(pt) {
            return pt.eventTarget === te;
          });
          Xe || (Xe = { eventTarget: te, events: {} }, A.push(Xe)), Xe.events[me] || (Xe.events[me] = []), Un(Xe.events[me], function(pt) {
            return pt.func === Ie && dy(pt.options, Fe);
          }) || (te.addEventListener(me, Ie, V.supportsOptions ? Fe : Fe.capture), Xe.events[me].push({ func: Ie, options: Fe }));
        }
      }
      function q(te, me, Ie, Ve) {
        if (te.addEventListener && te.removeEventListener) {
          var Fe = Kt(A, function(yi) {
            return yi.eventTarget === te;
          }), Xe = A[Fe];
          if (Xe && Xe.events) if (me !== "all") {
            var pt = !1, st = Xe.events[me];
            if (st) {
              if (Ie === "all") {
                for (var Et = st.length - 1; Et >= 0; Et--) {
                  var Zt = st[Et];
                  q(te, me, Zt.func, Zt.options);
                }
                return;
              }
              for (var pn = Ah(Ve), Ft = 0; Ft < st.length; Ft++) {
                var tn = st[Ft];
                if (tn.func === Ie && dy(tn.options, pn)) {
                  te.removeEventListener(me, Ie, V.supportsOptions ? pn : pn.capture), st.splice(Ft, 1), st.length === 0 && (delete Xe.events[me], pt = !0);
                  break;
                }
              }
            }
            pt && !Object.keys(Xe.events).length && A.splice(Fe, 1);
          } else for (me in Xe.events) Xe.events.hasOwnProperty(me) && q(te, me, "all");
        }
      }
      function Q(te, me) {
        for (var Ie = Ah(me), Ve = new WX(te), Fe = I[te.type], Xe = Se(te)[0], pt = Xe; S.element(pt); ) {
          for (var st = 0; st < Fe.length; st++) {
            var Et = Fe[st], Zt = Et.selector, pn = Et.context;
            if (ne(pt, Zt) && B(pn, Xe) && B(pn, pt)) {
              var Ft = Et.listeners;
              Ve.currentTarget = pt;
              for (var tn = 0; tn < Ft.length; tn++) {
                var yi = Ft[tn];
                dy(yi.options, Ie) && yi.func(Ve);
              }
            }
          }
          pt = Y(pt);
        }
      }
      function ae(te) {
        return Q(te, !0);
      }
      return (E = T.document) == null || E.createElement("div").addEventListener("test", null, { get capture() {
        return V.supportsOptions = !0;
      }, get passive() {
        return V.supportsPassive = !0;
      } }), T.events = V, V;
    } }, $w = { methodOrder: ["simulationResume", "mouseOrPen", "hasPointer", "idle"], search: function(T) {
      for (var E = 0, A = $w.methodOrder; E < A.length; E++) {
        var I = A[E], P = $w[I](T);
        if (P) return P;
      }
      return null;
    }, simulationResume: function(T) {
      var E = T.pointerType, A = T.eventType, I = T.eventTarget, P = T.scope;
      if (!/down|start/i.test(A)) return null;
      for (var V = 0, U = P.interactions.list; V < U.length; V++) {
        var q = U[V], Q = I;
        if (q.simulation && q.simulation.allowResume && q.pointerType === E) for (; Q; ) {
          if (Q === q.element) return q;
          Q = Y(Q);
        }
      }
      return null;
    }, mouseOrPen: function(T) {
      var E, A = T.pointerId, I = T.pointerType, P = T.eventType, V = T.scope;
      if (I !== "mouse" && I !== "pen") return null;
      for (var U = 0, q = V.interactions.list; U < q.length; U++) {
        var Q = q[U];
        if (Q.pointerType === I) {
          if (Q.simulation && !BI(Q, A)) continue;
          if (Q.interacting()) return Q;
          E || (E = Q);
        }
      }
      if (E) return E;
      for (var ae = 0, te = V.interactions.list; ae < te.length; ae++) {
        var me = te[ae];
        if (!(me.pointerType !== I || /down/i.test(P) && me.simulation)) return me;
      }
      return null;
    }, hasPointer: function(T) {
      for (var E = T.pointerId, A = 0, I = T.scope.interactions.list; A < I.length; A++) {
        var P = I[A];
        if (BI(P, E)) return P;
      }
      return null;
    }, idle: function(T) {
      for (var E = T.pointerType, A = 0, I = T.scope.interactions.list; A < I.length; A++) {
        var P = I[A];
        if (P.pointers.length === 1) {
          var V = P.interactable;
          if (V && (!V.options.gesture || !V.options.gesture.enabled)) continue;
        } else if (P.pointers.length >= 2) continue;
        if (!P.interacting() && E === P.pointerType) return P;
      }
      return null;
    } };
    function BI(T, E) {
      return T.pointers.some(function(A) {
        return A.id === E;
      });
    }
    var YX = $w, zw = ["pointerDown", "pointerMove", "pointerUp", "updatePointer", "removePointer", "windowBlur"];
    function $I(T, E) {
      return function(A) {
        var I = E.interactions.list, P = Tr(A), V = Se(A), U = V[0], q = V[1], Q = [];
        if (/^touch/.test(A.type)) {
          E.prevTouchTime = E.now();
          for (var ae = 0, te = A.changedTouches; ae < te.length; ae++) {
            var me = te[ae], Ie = { pointer: me, pointerId: Re(me), pointerType: P, eventType: A.type, eventTarget: U, curEventTarget: q, scope: E }, Ve = zI(Ie);
            Q.push([Ie.pointer, Ie.eventTarget, Ie.curEventTarget, Ve]);
          }
        } else {
          var Fe = !1;
          if (!F.supportsPointerEvent && /mouse/.test(A.type)) {
            for (var Xe = 0; Xe < I.length && !Fe; Xe++) Fe = I[Xe].pointerType !== "mouse" && I[Xe].pointerIsDown;
            Fe = Fe || E.now() - E.prevTouchTime < 500 || A.timeStamp === 0;
          }
          if (!Fe) {
            var pt = { pointer: A, pointerId: Re(A), pointerType: P, eventType: A.type, curEventTarget: q, eventTarget: U, scope: E }, st = zI(pt);
            Q.push([pt.pointer, pt.eventTarget, pt.curEventTarget, st]);
          }
        }
        for (var Et = 0; Et < Q.length; Et++) {
          var Zt = Q[Et], pn = Zt[0], Ft = Zt[1], tn = Zt[2];
          Zt[3][T](pn, A, Ft, tn);
        }
      };
    }
    function zI(T) {
      var E = T.pointerType, A = T.scope, I = { interaction: YX.search(T), searchDetails: T };
      return A.fire("interactions:find", I), I.interaction || A.interactions.new({ pointerType: E });
    }
    function Fw(T, E) {
      var A = T.doc, I = T.scope, P = T.options, V = I.interactions.docEvents, U = I.events, q = U[E];
      for (var Q in I.browser.isIOS && !P.events && (P.events = { passive: !1 }), U.delegatedEvents) q(A, Q, U.delegateListener), q(A, Q, U.delegateUseCapture, !0);
      for (var ae = P && P.events, te = 0; te < V.length; te++) {
        var me = V[te];
        q(A, me.type, me.listener, ae);
      }
    }
    var KX = { id: "core/interactions", install: function(T) {
      for (var E = {}, A = 0; A < zw.length; A++) {
        var I = zw[A];
        E[I] = $I(I, T);
      }
      var P, V = F.pEventTypes;
      function U() {
        for (var q = 0, Q = T.interactions.list; q < Q.length; q++) {
          var ae = Q[q];
          if (ae.pointerIsDown && ae.pointerType === "touch" && !ae._interacting) for (var te = function() {
            var Ve = Ie[me];
            T.documents.some(function(Fe) {
              return B(Fe.doc, Ve.downTarget);
            }) || ae.removePointer(Ve.pointer, Ve.event);
          }, me = 0, Ie = ae.pointers; me < Ie.length; me++) te();
        }
      }
      (P = j.PointerEvent ? [{ type: V.down, listener: U }, { type: V.down, listener: E.pointerDown }, { type: V.move, listener: E.pointerMove }, { type: V.up, listener: E.pointerUp }, { type: V.cancel, listener: E.pointerUp }] : [{ type: "mousedown", listener: E.pointerDown }, { type: "mousemove", listener: E.pointerMove }, { type: "mouseup", listener: E.pointerUp }, { type: "touchstart", listener: U }, { type: "touchstart", listener: E.pointerDown }, { type: "touchmove", listener: E.pointerMove }, { type: "touchend", listener: E.pointerUp }, { type: "touchcancel", listener: E.pointerUp }]).push({ type: "blur", listener: function(q) {
        for (var Q = 0, ae = T.interactions.list; Q < ae.length; Q++)
          ae[Q].documentBlur(q);
      } }), T.prevTouchTime = 0, T.Interaction = function(q) {
        u(ae, q);
        var Q = p(ae);
        function ae() {
          return a(this, ae), Q.apply(this, arguments);
        }
        return s(ae, [{ key: "pointerMoveTolerance", get: function() {
          return T.interactions.pointerMoveTolerance;
        }, set: function(te) {
          T.interactions.pointerMoveTolerance = te;
        } }, { key: "_now", value: function() {
          return T.now();
        } }]), ae;
      }(zX), T.interactions = { list: [], new: function(q) {
        q.scopeFire = function(ae, te) {
          return T.fire(ae, te);
        };
        var Q = new T.Interaction(q);
        return T.interactions.list.push(Q), Q;
      }, listeners: E, docEvents: P, pointerMoveTolerance: 1 }, T.usePlugin(kI);
    }, listeners: { "scope:add-document": function(T) {
      return Fw(T, "add");
    }, "scope:remove-document": function(T) {
      return Fw(T, "remove");
    }, "interactable:unset": function(T, E) {
      for (var A = T.interactable, I = E.interactions.list.length - 1; I >= 0; I--) {
        var P = E.interactions.list[I];
        P.interactable === A && (P.stop(), E.fire("interactions:destroy", { interaction: P }), P.destroy(), E.interactions.list.length > 2 && E.interactions.list.splice(I, 1));
      }
    } }, onDocSignal: Fw, doOnInteractions: $I, methodNames: zw }, XX = KX, Rl = function(T) {
      return T[T.On = 0] = "On", T[T.Off = 1] = "Off", T;
    }(Rl || {}), ZX = function() {
      function T(E, A, I, P) {
        a(this, T), this.target = void 0, this.options = void 0, this._actions = void 0, this.events = new jI(), this._context = void 0, this._win = void 0, this._doc = void 0, this._scopeEvents = void 0, this._actions = A.actions, this.target = E, this._context = A.context || I, this._win = _(Ee(E) ? this._context : E), this._doc = this._win.document, this._scopeEvents = P, this.set(A);
      }
      return s(T, [{ key: "_defaults", get: function() {
        return { base: {}, perAction: {}, actions: {} };
      } }, { key: "setOnEvents", value: function(E, A) {
        return S.func(A.onstart) && this.on("".concat(E, "start"), A.onstart), S.func(A.onmove) && this.on("".concat(E, "move"), A.onmove), S.func(A.onend) && this.on("".concat(E, "end"), A.onend), S.func(A.oninertiastart) && this.on("".concat(E, "inertiastart"), A.oninertiastart), this;
      } }, { key: "updatePerActionListeners", value: function(E, A, I) {
        var P, V = this, U = (P = this._actions.map[E]) == null ? void 0 : P.filterEventType, q = function(Q) {
          return (U == null || U(Q)) && ly(Q, V._actions);
        };
        (S.array(A) || S.object(A)) && this._onOff(Rl.Off, E, A, void 0, q), (S.array(I) || S.object(I)) && this._onOff(Rl.On, E, I, void 0, q);
      } }, { key: "setPerAction", value: function(E, A) {
        var I = this._defaults;
        for (var P in A) {
          var V = P, U = this.options[E], q = A[V];
          V === "listeners" && this.updatePerActionListeners(E, U.listeners, q), S.array(q) ? U[V] = rn(q) : S.plainObject(q) ? (U[V] = ce(U[V] || {}, uf(q)), S.object(I.perAction[V]) && "enabled" in I.perAction[V] && (U[V].enabled = q.enabled !== !1)) : S.bool(q) && S.object(I.perAction[V]) ? U[V].enabled = q : U[V] = q;
        }
      } }, { key: "getRect", value: function(E) {
        return E = E || (S.element(this.target) ? this.target : null), S.string(this.target) && (E = E || this._context.querySelector(this.target)), Be(E);
      } }, { key: "rectChecker", value: function(E) {
        var A = this;
        return S.func(E) ? (this.getRect = function(I) {
          var P = ce({}, E.apply(A, I));
          return "width" in P || (P.width = P.right - P.left, P.height = P.bottom - P.top), P;
        }, this) : E === null ? (delete this.getRect, this) : this.getRect;
      } }, { key: "_backCompatOption", value: function(E, A) {
        if (Ee(A) || S.object(A)) {
          for (var I in this.options[E] = A, this._actions.map) this.options[I][E] = A;
          return this;
        }
        return this.options[E];
      } }, { key: "origin", value: function(E) {
        return this._backCompatOption("origin", E);
      } }, { key: "deltaSource", value: function(E) {
        return E === "page" || E === "client" ? (this.options.deltaSource = E, this) : this.options.deltaSource;
      } }, { key: "getAllElements", value: function() {
        var E = this.target;
        return S.string(E) ? Array.from(this._context.querySelectorAll(E)) : S.func(E) && E.getAllElements ? E.getAllElements() : S.element(E) ? [E] : [];
      } }, { key: "context", value: function() {
        return this._context;
      } }, { key: "inContext", value: function(E) {
        return this._context === E.ownerDocument || B(this._context, E);
      } }, { key: "testIgnoreAllow", value: function(E, A, I) {
        return !this.testIgnore(E.ignoreFrom, A, I) && this.testAllow(E.allowFrom, A, I);
      } }, { key: "testAllow", value: function(E, A, I) {
        return !E || !!S.element(I) && (S.string(E) ? ie(I, E, A) : !!S.element(E) && B(E, I));
      } }, { key: "testIgnore", value: function(E, A, I) {
        return !(!E || !S.element(I)) && (S.string(E) ? ie(I, E, A) : !!S.element(E) && B(E, I));
      } }, { key: "fire", value: function(E) {
        return this.events.fire(E), this;
      } }, { key: "_onOff", value: function(E, A, I, P, V) {
        S.object(A) && !S.array(A) && (P = I, I = null);
        var U = Te(A, I, V);
        for (var q in U) {
          q === "wheel" && (q = F.wheelEvent);
          for (var Q = 0, ae = U[q]; Q < ae.length; Q++) {
            var te = ae[Q];
            ly(q, this._actions) ? this.events[E === Rl.On ? "on" : "off"](q, te) : S.string(this.target) ? this._scopeEvents[E === Rl.On ? "addDelegate" : "removeDelegate"](this.target, this._context, q, te, P) : this._scopeEvents[E === Rl.On ? "add" : "remove"](this.target, q, te, P);
          }
        }
        return this;
      } }, { key: "on", value: function(E, A, I) {
        return this._onOff(Rl.On, E, A, I);
      } }, { key: "off", value: function(E, A, I) {
        return this._onOff(Rl.Off, E, A, I);
      } }, { key: "set", value: function(E) {
        var A = this._defaults;
        for (var I in S.object(E) || (E = {}), this.options = uf(A.base), this._actions.methodDict) {
          var P = I, V = this._actions.methodDict[P];
          this.options[P] = {}, this.setPerAction(P, ce(ce({}, A.perAction), A.actions[P])), this[V](E[P]);
        }
        for (var U in E) U !== "getRect" ? S.func(this[U]) && this[U](E[U]) : this.rectChecker(E.getRect);
        return this;
      } }, { key: "unset", value: function() {
        if (S.string(this.target)) for (var E in this._scopeEvents.delegatedEvents) for (var A = this._scopeEvents.delegatedEvents[E], I = A.length - 1; I >= 0; I--) {
          var P = A[I], V = P.selector, U = P.context, q = P.listeners;
          V === this.target && U === this._context && A.splice(I, 1);
          for (var Q = q.length - 1; Q >= 0; Q--) this._scopeEvents.removeDelegate(this.target, this._context, E, q[Q][0], q[Q][1]);
        }
        else this._scopeEvents.remove(this.target, "all");
      } }]), T;
    }(), JX = function() {
      function T(E) {
        var A = this;
        a(this, T), this.list = [], this.selectorMap = {}, this.scope = void 0, this.scope = E, E.addListeners({ "interactable:unset": function(I) {
          var P = I.interactable, V = P.target, U = S.string(V) ? A.selectorMap[V] : V[A.scope.id], q = Kt(U, function(Q) {
            return Q === P;
          });
          U.splice(q, 1);
        } });
      }
      return s(T, [{ key: "new", value: function(E, A) {
        A = ce(A || {}, { actions: this.scope.actions });
        var I = new this.scope.Interactable(E, A, this.scope.document, this.scope.events);
        return this.scope.addDocument(I._doc), this.list.push(I), S.string(E) ? (this.selectorMap[E] || (this.selectorMap[E] = []), this.selectorMap[E].push(I)) : (I.target[this.scope.id] || Object.defineProperty(E, this.scope.id, { value: [], configurable: !0 }), E[this.scope.id].push(I)), this.scope.fire("interactable:new", { target: E, options: A, interactable: I, win: this.scope._win }), I;
      } }, { key: "getExisting", value: function(E, A) {
        var I = A && A.context || this.scope.document, P = S.string(E), V = P ? this.selectorMap[E] : E[this.scope.id];
        if (V) return Un(V, function(U) {
          return U._context === I && (P || U.inContext(E));
        });
      } }, { key: "forEachMatch", value: function(E, A) {
        for (var I = 0, P = this.list; I < P.length; I++) {
          var V = P[I], U = void 0;
          if ((S.string(V.target) ? S.element(E) && ne(E, V.target) : E === V.target) && V.inContext(E) && (U = A(V)), U !== void 0) return U;
        }
      } }]), T;
    }(), QX = function() {
      function T() {
        var E = this;
        a(this, T), this.id = "__interact_scope_".concat(Math.floor(100 * Math.random())), this.isInitialized = !1, this.listenerMaps = [], this.browser = F, this.defaults = uf(MI), this.Eventable = jI, this.actions = { map: {}, phases: { start: !0, move: !0, end: !0 }, methodDict: {}, phaselessTypes: {} }, this.interactStatic = function(I) {
          var P = function V(U, q) {
            var Q = I.interactables.getExisting(U, q);
            return Q || ((Q = I.interactables.new(U, q)).events.global = V.globalEvents), Q;
          };
          return P.getPointerAverage = Ne, P.getTouchBBox = lt, P.getTouchDistance = Gt, P.getTouchAngle = _n, P.getElementRect = Be, P.getElementClientRect = pe, P.matchesSelector = ne, P.closest = H, P.globalEvents = {}, P.version = "1.10.27", P.scope = I, P.use = function(V, U) {
            return this.scope.usePlugin(V, U), this;
          }, P.isSet = function(V, U) {
            return !!this.scope.interactables.get(V, U && U.context);
          }, P.on = de(function(V, U, q) {
            if (S.string(V) && V.search(" ") !== -1 && (V = V.trim().split(/ +/)), S.array(V)) {
              for (var Q = 0, ae = V; Q < ae.length; Q++) {
                var te = ae[Q];
                this.on(te, U, q);
              }
              return this;
            }
            if (S.object(V)) {
              for (var me in V) this.on(me, V[me], U);
              return this;
            }
            return ly(V, this.scope.actions) ? this.globalEvents[V] ? this.globalEvents[V].push(U) : this.globalEvents[V] = [U] : this.scope.events.add(this.scope.document, V, U, { options: q }), this;
          }, "The interact.on() method is being deprecated"), P.off = de(function(V, U, q) {
            if (S.string(V) && V.search(" ") !== -1 && (V = V.trim().split(/ +/)), S.array(V)) {
              for (var Q = 0, ae = V; Q < ae.length; Q++) {
                var te = ae[Q];
                this.off(te, U, q);
              }
              return this;
            }
            if (S.object(V)) {
              for (var me in V) this.off(me, V[me], U);
              return this;
            }
            var Ie;
            return ly(V, this.scope.actions) ? V in this.globalEvents && (Ie = this.globalEvents[V].indexOf(U)) !== -1 && this.globalEvents[V].splice(Ie, 1) : this.scope.events.remove(this.scope.document, V, U, q), this;
          }, "The interact.off() method is being deprecated"), P.debug = function() {
            return this.scope;
          }, P.supportsTouch = function() {
            return F.supportsTouch;
          }, P.supportsPointerEvent = function() {
            return F.supportsPointerEvent;
          }, P.stop = function() {
            for (var V = 0, U = this.scope.interactions.list; V < U.length; V++) U[V].stop();
            return this;
          }, P.pointerMoveTolerance = function(V) {
            return S.number(V) ? (this.scope.interactions.pointerMoveTolerance = V, this) : this.scope.interactions.pointerMoveTolerance;
          }, P.addDocument = function(V, U) {
            this.scope.addDocument(V, U);
          }, P.removeDocument = function(V) {
            this.scope.removeDocument(V);
          }, P;
        }(this), this.InteractEvent = jw, this.Interactable = void 0, this.interactables = new JX(this), this._win = void 0, this.document = void 0, this.window = void 0, this.documents = [], this._plugins = { list: [], map: {} }, this.onWindowUnload = function(I) {
          return E.removeDocument(I.target);
        };
        var A = this;
        this.Interactable = function(I) {
          u(V, I);
          var P = p(V);
          function V() {
            return a(this, V), P.apply(this, arguments);
          }
          return s(V, [{ key: "_defaults", get: function() {
            return A.defaults;
          } }, { key: "set", value: function(U) {
            return h(c(V.prototype), "set", this).call(this, U), A.fire("interactable:set", { options: U, interactable: this }), this;
          } }, { key: "unset", value: function() {
            h(c(V.prototype), "unset", this).call(this);
            var U = A.interactables.list.indexOf(this);
            U < 0 || (A.interactables.list.splice(U, 1), A.fire("interactable:unset", { interactable: this }));
          } }]), V;
        }(ZX);
      }
      return s(T, [{ key: "addListeners", value: function(E, A) {
        this.listenerMaps.push({ id: A, map: E });
      } }, { key: "fire", value: function(E, A) {
        for (var I = 0, P = this.listenerMaps; I < P.length; I++) {
          var V = P[I].map[E];
          if (V && V(A, this, E) === !1) return !1;
        }
      } }, { key: "init", value: function(E) {
        return this.isInitialized ? this : function(A, I) {
          return A.isInitialized = !0, S.window(I) && b(I), j.init(I), F.init(I), lo.init(I), A.window = I, A.document = I.document, A.usePlugin(XX), A.usePlugin(qX), A;
        }(this, E);
      } }, { key: "pluginIsInstalled", value: function(E) {
        var A = E.id;
        return A ? !!this._plugins.map[A] : this._plugins.list.indexOf(E) !== -1;
      } }, { key: "usePlugin", value: function(E, A) {
        if (!this.isInitialized) return this;
        if (this.pluginIsInstalled(E)) return this;
        if (E.id && (this._plugins.map[E.id] = E), this._plugins.list.push(E), E.install && E.install(this, A), E.listeners && E.before) {
          for (var I = 0, P = this.listenerMaps.length, V = E.before.reduce(function(q, Q) {
            return q[Q] = !0, q[FI(Q)] = !0, q;
          }, {}); I < P; I++) {
            var U = this.listenerMaps[I].id;
            if (U && (V[U] || V[FI(U)])) break;
          }
          this.listenerMaps.splice(I, 0, { id: E.id, map: E.listeners });
        } else E.listeners && this.listenerMaps.push({ id: E.id, map: E.listeners });
        return this;
      } }, { key: "addDocument", value: function(E, A) {
        if (this.getDocIndex(E) !== -1) return !1;
        var I = _(E);
        A = A ? ce({}, A) : {}, this.documents.push({ doc: E, options: A }), this.events.documents.push(E), E !== this.document && this.events.add(I, "unload", this.onWindowUnload), this.fire("scope:add-document", { doc: E, window: I, scope: this, options: A });
      } }, { key: "removeDocument", value: function(E) {
        var A = this.getDocIndex(E), I = _(E), P = this.documents[A].options;
        this.events.remove(I, "unload", this.onWindowUnload), this.documents.splice(A, 1), this.events.documents.splice(A, 1), this.fire("scope:remove-document", { doc: E, window: I, scope: this, options: P });
      } }, { key: "getDocIndex", value: function(E) {
        for (var A = 0; A < this.documents.length; A++) if (this.documents[A].doc === E) return A;
        return -1;
      } }, { key: "getDocOptions", value: function(E) {
        var A = this.getDocIndex(E);
        return A === -1 ? null : this.documents[A].options;
      } }, { key: "now", value: function() {
        return (this.window.Date || Date).now();
      } }]), T;
    }();
    function FI(T) {
      return T && T.replace(/\/.*$/, "");
    }
    var VI = new QX(), gi = VI.interactStatic, eZ = typeof globalThis < "u" ? globalThis : window;
    VI.init(eZ);
    var tZ = Object.freeze({ __proto__: null, edgeTarget: function() {
    }, elements: function() {
    }, grid: function(T) {
      var E = [["x", "y"], ["left", "top"], ["right", "bottom"], ["width", "height"]].filter(function(I) {
        var P = I[0], V = I[1];
        return P in T || V in T;
      }), A = function(I, P) {
        for (var V = T.range, U = T.limits, q = U === void 0 ? { left: -1 / 0, right: 1 / 0, top: -1 / 0, bottom: 1 / 0 } : U, Q = T.offset, ae = Q === void 0 ? { x: 0, y: 0 } : Q, te = { range: V, grid: T, x: null, y: null }, me = 0; me < E.length; me++) {
          var Ie = E[me], Ve = Ie[0], Fe = Ie[1], Xe = Math.round((I - ae.x) / T[Ve]), pt = Math.round((P - ae.y) / T[Fe]);
          te[Ve] = Math.max(q.left, Math.min(q.right, Xe * T[Ve] + ae.x)), te[Fe] = Math.max(q.top, Math.min(q.bottom, pt * T[Fe] + ae.y));
        }
        return te;
      };
      return A.grid = T, A.coordFields = E, A;
    } }), nZ = { id: "snappers", install: function(T) {
      var E = T.interactStatic;
      E.snappers = ce(E.snappers || {}, tZ), E.createSnapGrid = E.snappers.grid;
    } }, rZ = nZ, iZ = { start: function(T) {
      var E = T.state, A = T.rect, I = T.edges, P = T.pageCoords, V = E.options, U = V.ratio, q = V.enabled, Q = E.options, ae = Q.equalDelta, te = Q.modifiers;
      U === "preserve" && (U = A.width / A.height), E.startCoords = ce({}, P), E.startRect = ce({}, A), E.ratio = U, E.equalDelta = ae;
      var me = E.linkedEdges = { top: I.top || I.left && !I.bottom, left: I.left || I.top && !I.right, bottom: I.bottom || I.right && !I.top, right: I.right || I.bottom && !I.left };
      if (E.xIsPrimaryAxis = !(!I.left && !I.right), E.equalDelta) {
        var Ie = (me.left ? 1 : -1) * (me.top ? 1 : -1);
        E.edgeSign = { x: Ie, y: Ie };
      } else E.edgeSign = { x: me.left ? -1 : 1, y: me.top ? -1 : 1 };
      if (q !== !1 && ce(I, me), te != null && te.length) {
        var Ve = new Pw(T.interaction);
        Ve.copyFrom(T.interaction.modification), Ve.prepareStates(te), E.subModification = Ve, Ve.startAll(r({}, T));
      }
    }, set: function(T) {
      var E = T.state, A = T.rect, I = T.coords, P = E.linkedEdges, V = ce({}, I), U = E.equalDelta ? aZ : oZ;
      if (ce(T.edges, P), U(E, E.xIsPrimaryAxis, I, A), !E.subModification) return null;
      var q = ce({}, A);
      he(P, q, { x: I.x - V.x, y: I.y - V.y });
      var Q = E.subModification.setAll(r(r({}, T), {}, { rect: q, edges: P, pageCoords: I, prevCoords: I, prevRect: q })), ae = Q.delta;
      return Q.changed && (U(E, Math.abs(ae.x) > Math.abs(ae.y), Q.coords, Q.rect), ce(I, Q.coords)), Q.eventProps;
    }, defaults: { ratio: "preserve", equalDelta: !1, modifiers: [], enabled: !1 } };
    function aZ(T, E, A) {
      var I = T.startCoords, P = T.edgeSign;
      E ? A.y = I.y + (A.x - I.x) * P.y : A.x = I.x + (A.y - I.y) * P.x;
    }
    function oZ(T, E, A, I) {
      var P = T.startRect, V = T.startCoords, U = T.ratio, q = T.edgeSign;
      if (E) {
        var Q = I.width / U;
        A.y = V.y + (Q - P.height) * q.y;
      } else {
        var ae = I.height * U;
        A.x = V.x + (ae - P.width) * q.x;
      }
    }
    var sZ = Nl(iZ, "aspectRatio"), HI = function() {
    };
    HI._defaults = {};
    var fy = HI;
    function Xu(T, E, A) {
      return S.func(T) ? Ae(T, E.interactable, E.element, [A.x, A.y, E]) : Ae(T, E.interactable, E.element);
    }
    var py = { start: function(T) {
      var E = T.rect, A = T.startOffset, I = T.state, P = T.interaction, V = T.pageCoords, U = I.options, q = U.elementRect, Q = ce({ left: 0, top: 0, right: 0, bottom: 0 }, U.offset || {});
      if (E && q) {
        var ae = Xu(U.restriction, P, V);
        if (ae) {
          var te = ae.right - ae.left - E.width, me = ae.bottom - ae.top - E.height;
          te < 0 && (Q.left += te, Q.right += te), me < 0 && (Q.top += me, Q.bottom += me);
        }
        Q.left += A.left - E.width * q.left, Q.top += A.top - E.height * q.top, Q.right += A.right - E.width * (1 - q.right), Q.bottom += A.bottom - E.height * (1 - q.bottom);
      }
      I.offset = Q;
    }, set: function(T) {
      var E = T.coords, A = T.interaction, I = T.state, P = I.options, V = I.offset, U = Xu(P.restriction, A, E);
      if (U) {
        var q = function(Q) {
          return !Q || "left" in Q && "top" in Q || ((Q = ce({}, Q)).left = Q.x || 0, Q.top = Q.y || 0, Q.right = Q.right || Q.left + Q.width, Q.bottom = Q.bottom || Q.top + Q.height), Q;
        }(U);
        E.x = Math.max(Math.min(q.right - V.right, E.x), q.left + V.left), E.y = Math.max(Math.min(q.bottom - V.bottom, E.y), q.top + V.top);
      }
    }, defaults: { restriction: null, elementRect: null, offset: null, endOnly: !1, enabled: !1 } }, lZ = Nl(py, "restrict"), GI = { top: 1 / 0, left: 1 / 0, bottom: -1 / 0, right: -1 / 0 }, UI = { top: -1 / 0, left: -1 / 0, bottom: 1 / 0, right: 1 / 0 };
    function WI(T, E) {
      for (var A = 0, I = ["top", "left", "bottom", "right"]; A < I.length; A++) {
        var P = I[A];
        P in T || (T[P] = E[P]);
      }
      return T;
    }
    var Mh = { noInner: GI, noOuter: UI, start: function(T) {
      var E, A = T.interaction, I = T.startOffset, P = T.state, V = P.options;
      V && (E = fe(Xu(V.offset, A, A.coords.start.page))), E = E || { x: 0, y: 0 }, P.offset = { top: E.y + I.top, left: E.x + I.left, bottom: E.y - I.bottom, right: E.x - I.right };
    }, set: function(T) {
      var E = T.coords, A = T.edges, I = T.interaction, P = T.state, V = P.offset, U = P.options;
      if (A) {
        var q = ce({}, E), Q = Xu(U.inner, I, q) || {}, ae = Xu(U.outer, I, q) || {};
        WI(Q, GI), WI(ae, UI), A.top ? E.y = Math.min(Math.max(ae.top + V.top, q.y), Q.top + V.top) : A.bottom && (E.y = Math.max(Math.min(ae.bottom + V.bottom, q.y), Q.bottom + V.bottom)), A.left ? E.x = Math.min(Math.max(ae.left + V.left, q.x), Q.left + V.left) : A.right && (E.x = Math.max(Math.min(ae.right + V.right, q.x), Q.right + V.right));
      }
    }, defaults: { inner: null, outer: null, offset: null, endOnly: !1, enabled: !1 } }, uZ = Nl(Mh, "restrictEdges"), cZ = ce({ get elementRect() {
      return { top: 0, left: 0, bottom: 1, right: 1 };
    }, set elementRect(T) {
    } }, py.defaults), dZ = Nl({ start: py.start, set: py.set, defaults: cZ }, "restrictRect"), fZ = { width: -1 / 0, height: -1 / 0 }, pZ = { width: 1 / 0, height: 1 / 0 }, hZ = Nl({ start: function(T) {
      return Mh.start(T);
    }, set: function(T) {
      var E = T.interaction, A = T.state, I = T.rect, P = T.edges, V = A.options;
      if (P) {
        var U = oe(Xu(V.min, E, T.coords)) || fZ, q = oe(Xu(V.max, E, T.coords)) || pZ;
        A.options = { endOnly: V.endOnly, inner: ce({}, Mh.noInner), outer: ce({}, Mh.noOuter) }, P.top ? (A.options.inner.top = I.bottom - U.height, A.options.outer.top = I.bottom - q.height) : P.bottom && (A.options.inner.bottom = I.top + U.height, A.options.outer.bottom = I.top + q.height), P.left ? (A.options.inner.left = I.right - U.width, A.options.outer.left = I.right - q.width) : P.right && (A.options.inner.right = I.left + U.width, A.options.outer.right = I.left + q.width), Mh.set(T), A.options = V;
      }
    }, defaults: { min: null, max: null, endOnly: !1, enabled: !1 } }, "restrictSize"), Vw = { start: function(T) {
      var E, A = T.interaction, I = T.interactable, P = T.element, V = T.rect, U = T.state, q = T.startOffset, Q = U.options, ae = Q.offsetWithOrigin ? function(Ie) {
        var Ve = Ie.interaction.element, Fe = fe(Ae(Ie.state.options.origin, null, null, [Ve])), Xe = Fe || Oe(Ie.interactable, Ve, Ie.interaction.prepared.name);
        return Xe;
      }(T) : { x: 0, y: 0 };
      if (Q.offset === "startCoords") E = { x: A.coords.start.page.x, y: A.coords.start.page.y };
      else {
        var te = Ae(Q.offset, I, P, [A]);
        (E = fe(te) || { x: 0, y: 0 }).x += ae.x, E.y += ae.y;
      }
      var me = Q.relativePoints;
      U.offsets = V && me && me.length ? me.map(function(Ie, Ve) {
        return { index: Ve, relativePoint: Ie, x: q.left - V.width * Ie.x + E.x, y: q.top - V.height * Ie.y + E.y };
      }) : [{ index: 0, relativePoint: null, x: E.x, y: E.y }];
    }, set: function(T) {
      var E = T.interaction, A = T.coords, I = T.state, P = I.options, V = I.offsets, U = Oe(E.interactable, E.element, E.prepared.name), q = ce({}, A), Q = [];
      P.offsetWithOrigin || (q.x -= U.x, q.y -= U.y);
      for (var ae = 0, te = V; ae < te.length; ae++) for (var me = te[ae], Ie = q.x - me.x, Ve = q.y - me.y, Fe = 0, Xe = P.targets.length; Fe < Xe; Fe++) {
        var pt = P.targets[Fe], st = void 0;
        (st = S.func(pt) ? pt(Ie, Ve, E._proxy, me, Fe) : pt) && Q.push({ x: (S.number(st.x) ? st.x : Ie) + me.x, y: (S.number(st.y) ? st.y : Ve) + me.y, range: S.number(st.range) ? st.range : P.range, source: pt, index: Fe, offset: me });
      }
      for (var Et = { target: null, inRange: !1, distance: 0, range: 0, delta: { x: 0, y: 0 } }, Zt = 0; Zt < Q.length; Zt++) {
        var pn = Q[Zt], Ft = pn.range, tn = pn.x - q.x, yi = pn.y - q.y, nr = je(tn, yi), aa = nr <= Ft;
        Ft === 1 / 0 && Et.inRange && Et.range !== 1 / 0 && (aa = !1), Et.target && !(aa ? Et.inRange && Ft !== 1 / 0 ? nr / Ft < Et.distance / Et.range : Ft === 1 / 0 && Et.range !== 1 / 0 || nr < Et.distance : !Et.inRange && nr < Et.distance) || (Et.target = pn, Et.distance = nr, Et.range = Ft, Et.inRange = aa, Et.delta.x = tn, Et.delta.y = yi);
      }
      return Et.inRange && (A.x = Et.target.x, A.y = Et.target.y), I.closest = Et, Et;
    }, defaults: { range: 1 / 0, targets: null, offset: null, offsetWithOrigin: !0, origin: null, relativePoints: null, endOnly: !1, enabled: !1 } }, vZ = Nl(Vw, "snap"), hy = { start: function(T) {
      var E = T.state, A = T.edges, I = E.options;
      if (!A) return null;
      T.state = { options: { targets: null, relativePoints: [{ x: A.left ? 0 : 1, y: A.top ? 0 : 1 }], offset: I.offset || "self", origin: { x: 0, y: 0 }, range: I.range } }, E.targetFields = E.targetFields || [["width", "height"], ["x", "y"]], Vw.start(T), E.offsets = T.state.offsets, T.state = E;
    }, set: function(T) {
      var E = T.interaction, A = T.state, I = T.coords, P = A.options, V = A.offsets, U = { x: I.x - V[0].x, y: I.y - V[0].y };
      A.options = ce({}, P), A.options.targets = [];
      for (var q = 0, Q = P.targets || []; q < Q.length; q++) {
        var ae = Q[q], te = void 0;
        if (te = S.func(ae) ? ae(U.x, U.y, E) : ae) {
          for (var me = 0, Ie = A.targetFields; me < Ie.length; me++) {
            var Ve = Ie[me], Fe = Ve[0], Xe = Ve[1];
            if (Fe in te || Xe in te) {
              te.x = te[Fe], te.y = te[Xe];
              break;
            }
          }
          A.options.targets.push(te);
        }
      }
      var pt = Vw.set(T);
      return A.options = P, pt;
    }, defaults: { range: 1 / 0, targets: null, offset: null, endOnly: !1, enabled: !1 } }, mZ = Nl(hy, "snapSize"), Hw = { aspectRatio: sZ, restrictEdges: uZ, restrict: lZ, restrictRect: dZ, restrictSize: hZ, snapEdges: Nl({ start: function(T) {
      var E = T.edges;
      return E ? (T.state.targetFields = T.state.targetFields || [[E.left ? "left" : "right", E.top ? "top" : "bottom"]], hy.start(T)) : null;
    }, set: hy.set, defaults: ce(uf(hy.defaults), { targets: void 0, range: void 0, offset: { x: 0, y: 0 } }) }, "snapEdges"), snap: vZ, snapSize: mZ, spring: fy, avoid: fy, transform: fy, rubberband: fy }, gZ = { id: "modifiers", install: function(T) {
      var E = T.interactStatic;
      for (var A in T.usePlugin(AI), T.usePlugin(rZ), E.modifiers = Hw, Hw) {
        var I = Hw[A], P = I._defaults, V = I._methods;
        P._methods = V, T.defaults.perAction[A] = P;
      }
    } }, yZ = gZ, qI = function(T) {
      u(A, T);
      var E = p(A);
      function A(I, P, V, U, q, Q) {
        var ae;
        if (a(this, A), ot(f(ae = E.call(this, q)), V), V !== P && ot(f(ae), P), ae.timeStamp = Q, ae.originalEvent = V, ae.type = I, ae.pointerId = Re(P), ae.pointerType = Tr(P), ae.target = U, ae.currentTarget = null, I === "tap") {
          var te = q.getPointerIndex(P);
          ae.dt = ae.timeStamp - q.pointers[te].downTime;
          var me = ae.timeStamp - q.tapTime;
          ae.double = !!q.prevTap && q.prevTap.type !== "doubletap" && q.prevTap.target === ae.target && me < 500;
        } else I === "doubletap" && (ae.dt = P.timeStamp - q.tapTime, ae.double = !0);
        return ae;
      }
      return s(A, [{ key: "_subtractOrigin", value: function(I) {
        var P = I.x, V = I.y;
        return this.pageX -= P, this.pageY -= V, this.clientX -= P, this.clientY -= V, this;
      } }, { key: "_addOrigin", value: function(I) {
        var P = I.x, V = I.y;
        return this.pageX += P, this.pageY += V, this.clientX += P, this.clientY += V, this;
      } }, { key: "preventDefault", value: function() {
        this.originalEvent.preventDefault();
      } }]), A;
    }(rt), Dh = { id: "pointer-events/base", before: ["inertia", "modifiers", "auto-start", "actions"], install: function(T) {
      T.pointerEvents = Dh, T.defaults.actions.pointerEvents = Dh.defaults, ce(T.actions.phaselessTypes, Dh.types);
    }, listeners: { "interactions:new": function(T) {
      var E = T.interaction;
      E.prevTap = null, E.tapTime = 0;
    }, "interactions:update-pointer": function(T) {
      var E = T.down, A = T.pointerInfo;
      !E && A.hold || (A.hold = { duration: 1 / 0, timeout: null });
    }, "interactions:move": function(T, E) {
      var A = T.interaction, I = T.pointer, P = T.event, V = T.eventTarget;
      T.duplicate || A.pointerIsDown && !A.pointerWasMoved || (A.pointerIsDown && Gw(T), Pl({ interaction: A, pointer: I, event: P, eventTarget: V, type: "move" }, E));
    }, "interactions:down": function(T, E) {
      (function(A, I) {
        for (var P = A.interaction, V = A.pointer, U = A.event, q = A.eventTarget, Q = A.pointerIndex, ae = P.pointers[Q].hold, te = Ce(q), me = { interaction: P, pointer: V, event: U, eventTarget: q, type: "hold", targets: [], path: te, node: null }, Ie = 0; Ie < te.length; Ie++) {
          var Ve = te[Ie];
          me.node = Ve, I.fire("pointerEvents:collect-targets", me);
        }
        if (me.targets.length) {
          for (var Fe = 1 / 0, Xe = 0, pt = me.targets; Xe < pt.length; Xe++) {
            var st = pt[Xe].eventable.options.holdDuration;
            st < Fe && (Fe = st);
          }
          ae.duration = Fe, ae.timeout = setTimeout(function() {
            Pl({ interaction: P, eventTarget: q, pointer: V, event: U, type: "hold" }, I);
          }, Fe);
        }
      })(T, E), Pl(T, E);
    }, "interactions:up": function(T, E) {
      Gw(T), Pl(T, E), function(A, I) {
        var P = A.interaction, V = A.pointer, U = A.event, q = A.eventTarget;
        P.pointerWasMoved || Pl({ interaction: P, eventTarget: q, pointer: V, event: U, type: "tap" }, I);
      }(T, E);
    }, "interactions:cancel": function(T, E) {
      Gw(T), Pl(T, E);
    } }, PointerEvent: qI, fire: Pl, collectEventTargets: YI, defaults: { holdDuration: 600, ignoreFrom: null, allowFrom: null, origin: { x: 0, y: 0 } }, types: { down: !0, move: !0, up: !0, cancel: !0, tap: !0, doubletap: !0, hold: !0 } };
    function Pl(T, E) {
      var A = T.interaction, I = T.pointer, P = T.event, V = T.eventTarget, U = T.type, q = T.targets, Q = q === void 0 ? YI(T, E) : q, ae = new qI(U, I, P, V, A, E.now());
      E.fire("pointerEvents:new", { pointerEvent: ae });
      for (var te = { interaction: A, pointer: I, event: P, eventTarget: V, targets: Q, type: U, pointerEvent: ae }, me = 0; me < Q.length; me++) {
        var Ie = Q[me];
        for (var Ve in Ie.props || {}) ae[Ve] = Ie.props[Ve];
        var Fe = Oe(Ie.eventable, Ie.node);
        if (ae._subtractOrigin(Fe), ae.eventable = Ie.eventable, ae.currentTarget = Ie.node, Ie.eventable.fire(ae), ae._addOrigin(Fe), ae.immediatePropagationStopped || ae.propagationStopped && me + 1 < Q.length && Q[me + 1].node !== ae.currentTarget) break;
      }
      if (E.fire("pointerEvents:fired", te), U === "tap") {
        var Xe = ae.double ? Pl({ interaction: A, pointer: I, event: P, eventTarget: V, type: "doubletap" }, E) : ae;
        A.prevTap = Xe, A.tapTime = Xe.timeStamp;
      }
      return ae;
    }
    function YI(T, E) {
      var A = T.interaction, I = T.pointer, P = T.event, V = T.eventTarget, U = T.type, q = A.getPointerIndex(I), Q = A.pointers[q];
      if (U === "tap" && (A.pointerWasMoved || !Q || Q.downTarget !== V)) return [];
      for (var ae = Ce(V), te = { interaction: A, pointer: I, event: P, eventTarget: V, type: U, path: ae, targets: [], node: null }, me = 0; me < ae.length; me++) {
        var Ie = ae[me];
        te.node = Ie, E.fire("pointerEvents:collect-targets", te);
      }
      return U === "hold" && (te.targets = te.targets.filter(function(Ve) {
        var Fe, Xe;
        return Ve.eventable.options.holdDuration === ((Fe = A.pointers[q]) == null || (Xe = Fe.hold) == null ? void 0 : Xe.duration);
      })), te.targets;
    }
    function Gw(T) {
      var E = T.interaction, A = T.pointerIndex, I = E.pointers[A].hold;
      I && I.timeout && (clearTimeout(I.timeout), I.timeout = null);
    }
    var bZ = Object.freeze({ __proto__: null, default: Dh });
    function _Z(T) {
      var E = T.interaction;
      E.holdIntervalHandle && (clearInterval(E.holdIntervalHandle), E.holdIntervalHandle = null);
    }
    var xZ = { id: "pointer-events/holdRepeat", install: function(T) {
      T.usePlugin(Dh);
      var E = T.pointerEvents;
      E.defaults.holdRepeatInterval = 0, E.types.holdrepeat = T.actions.phaselessTypes.holdrepeat = !0;
    }, listeners: ["move", "up", "cancel", "endall"].reduce(function(T, E) {
      return T["pointerEvents:".concat(E)] = _Z, T;
    }, { "pointerEvents:new": function(T) {
      var E = T.pointerEvent;
      E.type === "hold" && (E.count = (E.count || 0) + 1);
    }, "pointerEvents:fired": function(T, E) {
      var A = T.interaction, I = T.pointerEvent, P = T.eventTarget, V = T.targets;
      if (I.type === "hold" && V.length) {
        var U = V[0].eventable.options.holdRepeatInterval;
        U <= 0 || (A.holdIntervalHandle = setTimeout(function() {
          E.pointerEvents.fire({ interaction: A, eventTarget: P, type: "hold", pointer: I, event: I }, E);
        }, U));
      }
    } }) }, wZ = xZ, SZ = { id: "pointer-events/interactableTargets", install: function(T) {
      var E = T.Interactable;
      E.prototype.pointerEvents = function(I) {
        return ce(this.events.options, I), this;
      };
      var A = E.prototype._backCompatOption;
      E.prototype._backCompatOption = function(I, P) {
        var V = A.call(this, I, P);
        return V === this && (this.events.options[I] = P), V;
      };
    }, listeners: { "pointerEvents:collect-targets": function(T, E) {
      var A = T.targets, I = T.node, P = T.type, V = T.eventTarget;
      E.interactables.forEachMatch(I, function(U) {
        var q = U.events, Q = q.options;
        q.types[P] && q.types[P].length && U.testIgnoreAllow(Q, I, V) && A.push({ node: I, eventable: q, props: { interactable: U } });
      });
    }, "interactable:new": function(T) {
      var E = T.interactable;
      E.events.getRect = function(A) {
        return E.getRect(A);
      };
    }, "interactable:set": function(T, E) {
      var A = T.interactable, I = T.options;
      ce(A.events.options, E.pointerEvents.defaults), ce(A.events.options, I.pointerEvents || {});
    } } }, EZ = SZ, TZ = { id: "pointer-events", install: function(T) {
      T.usePlugin(bZ), T.usePlugin(wZ), T.usePlugin(EZ);
    } }, CZ = TZ, kZ = { id: "reflow", install: function(T) {
      var E = T.Interactable;
      T.actions.phases.reflow = !0, E.prototype.reflow = function(A) {
        return function(I, P, V) {
          for (var U = I.getAllElements(), q = V.window.Promise, Q = q ? [] : null, ae = function() {
            var me = U[te], Ie = I.getRect(me);
            if (!Ie) return 1;
            var Ve, Fe = Un(V.interactions.list, function(st) {
              return st.interacting() && st.interactable === I && st.element === me && st.prepared.name === P.name;
            });
            if (Fe) Fe.move(), Q && (Ve = Fe._reflowPromise || new q(function(st) {
              Fe._reflowResolve = st;
            }));
            else {
              var Xe = oe(Ie), pt = /* @__PURE__ */ function(st) {
                return { coords: st, get page() {
                  return this.coords.page;
                }, get client() {
                  return this.coords.client;
                }, get timeStamp() {
                  return this.coords.timeStamp;
                }, get pageX() {
                  return this.coords.page.x;
                }, get pageY() {
                  return this.coords.page.y;
                }, get clientX() {
                  return this.coords.client.x;
                }, get clientY() {
                  return this.coords.client.y;
                }, get pointerId() {
                  return this.coords.pointerId;
                }, get target() {
                  return this.coords.target;
                }, get type() {
                  return this.coords.type;
                }, get pointerType() {
                  return this.coords.pointerType;
                }, get buttons() {
                  return this.coords.buttons;
                }, preventDefault: function() {
                } };
              }({ page: { x: Xe.x, y: Xe.y }, client: { x: Xe.x, y: Xe.y }, timeStamp: V.now() });
              Ve = function(st, Et, Zt, pn, Ft) {
                var tn = st.interactions.new({ pointerType: "reflow" }), yi = { interaction: tn, event: Ft, pointer: Ft, eventTarget: Zt, phase: "reflow" };
                tn.interactable = Et, tn.element = Zt, tn.prevEvent = Ft, tn.updatePointer(Ft, Ft, Zt, !0), Nt(tn.coords.delta), qe(tn.prepared, pn), tn._doPhase(yi);
                var nr = st.window, aa = nr.Promise, uo = aa ? new aa(function(Ls) {
                  tn._reflowResolve = Ls;
                }) : void 0;
                return tn._reflowPromise = uo, tn.start(pn, Et, Zt), tn._interacting ? (tn.move(yi), tn.end(Ft)) : (tn.stop(), tn._reflowResolve()), tn.removePointer(Ft, Ft), uo;
              }(V, I, me, P, pt);
            }
            Q && Q.push(Ve);
          }, te = 0; te < U.length && !ae(); te++) ;
          return Q && q.all(Q).then(function() {
            return I;
          });
        }(this, A, T);
      };
    }, listeners: { "interactions:stop": function(T, E) {
      var A = T.interaction;
      A.pointerType === "reflow" && (A._reflowResolve && A._reflowResolve(), function(I, P) {
        I.splice(I.indexOf(P), 1);
      }(E.interactions.list, A));
    } } }, AZ = kZ;
    if (gi.use(kI), gi.use(LI), gi.use(CZ), gi.use(UX), gi.use(yZ), gi.use(LX), gi.use(sy), gi.use(St), gi.use(AZ), gi.default = gi, i(n) === "object" && n) try {
      n.exports = gi;
    } catch {
    }
    return gi.default = gi, gi;
  });
})(Fb, Fb.exports);
var eMe = Fb.exports;
const jP = /* @__PURE__ */ nM(eMe), NC = /* @__PURE__ */ ve({
  __name: "grid-item",
  props: {
    isDraggable: { type: Boolean, default: void 0 },
    isResizable: { type: Boolean, default: void 0 },
    isBounded: { type: Boolean, default: void 0 },
    static: { type: Boolean, default: !1 },
    minH: { default: 1 },
    minW: { default: 1 },
    maxH: { default: 1 / 0 },
    maxW: { default: 1 / 0 },
    x: {},
    y: {},
    w: {},
    h: {},
    i: {},
    dragIgnoreFrom: { default: "a, button" },
    dragAllowFrom: { default: void 0 },
    resizeIgnoreFrom: { default: "a, button" },
    preserveAspectRatio: { type: Boolean, default: !1 },
    dragOption: { default: () => ({}) },
    resizeOption: { default: () => ({}) }
  },
  emits: ["container-resized", "resize", "resized", "move", "moved"],
  setup(n, { expose: e, emit: t }) {
    const r = n, i = t, a = Xt(M9), o = Xt(D9);
    if (!a)
      throw new Error("[grid-layout-plus]: missing layout store, GridItem must under a GridLayout.");
    const s = Z(null), l = Sr({
      cols: 1,
      containerWidth: 100,
      rowHeight: 30,
      margin: [10, 10],
      maxRows: 1 / 0,
      draggable: void 0,
      resizable: void 0,
      bounded: void 0,
      transformScale: 1,
      useCssTransforms: !0,
      useStyleCursor: !0,
      isDragging: !1,
      dragging: {
        top: -1,
        left: -1
      },
      isResizing: !1,
      resizing: {
        width: -1,
        height: -1
      },
      style: {},
      rtl: !1
    });
    let u = !1, c = !1, d = NaN, f = NaN, p = NaN, h = NaN, v = -1, m = -1, g = -1, y = -1, b = r.x, _ = r.y, x = r.w, w = r.h;
    const S = Z(), C = Sr({
      i: j1(r, "i"),
      state: l,
      wrapper: S,
      calcXY: Ae
    });
    function k(Le) {
      Te(Le);
    }
    function M() {
      Ge();
    }
    function D(Le) {
      la(r.isDraggable) && (l.draggable = Le);
    }
    function N(Le) {
      la(r.isResizable) && (l.resizable = Le);
    }
    function R(Le) {
      la(r.isBounded) && (l.bounded = Le);
    }
    function j(Le) {
      l.transformScale = Le;
    }
    function z(Le) {
      l.rowHeight = Le;
    }
    function F(Le) {
      l.maxRows = Le;
    }
    function B() {
      l.rtl = PP() === "rtl", Ge();
    }
    function H(Le) {
      l.cols = Math.floor(Le);
    }
    a.increaseItem(C), AA(() => {
      l.rtl = PP() === "rtl";
    }), kt(() => {
      a.responsive && a.lastBreakpoint ? l.cols = R9(a.lastBreakpoint, a.cols) : l.cols = a.colNum, l.rowHeight = a.rowHeight, l.containerWidth = a.width !== null ? a.width : 100, l.margin = a.margin !== void 0 ? a.margin.map(Number) : [10, 10], l.maxRows = a.maxRows, la(r.isDraggable) ? l.draggable = a.isDraggable : l.draggable = r.isDraggable, la(r.isResizable) ? l.resizable = a.isResizable : l.resizable = r.isResizable, la(r.isBounded) ? l.bounded = a.isBounded : l.bounded = r.isBounded, l.transformScale = a.transformScale, l.useCssTransforms = a.useCssTransforms, l.useStyleCursor = a.useStyleCursor, Cn(() => {
        b = r.x, _ = r.y, w = r.h, x = r.w, _i(Be);
      }), o.on("updateWidth", k), o.on("compact", M), o.on("setDraggable", D), o.on("setResizable", N), o.on("setBounded", R), o.on("setTransformScale", j), o.on("setRowHeight", z), o.on("setMaxRows", F), o.on("directionchange", B), o.on("setColNum", H);
    }), Io(() => {
      o.off("updateWidth", k), o.off("compact", M), o.off("setDraggable", D), o.off("setResizable", N), o.off("setBounded", R), o.off("setTransformScale", j), o.off("setRowHeight", z), o.off("setMaxRows", F), o.off("directionchange", B), o.off("setColNum", H), s.value && (s.value.unset(), s.value = null), a.decreaseItem(C);
    }), e({ state: l, wrapper: S });
    const Y = typeof navigator < "u" ? navigator.userAgent.toLowerCase().includes("android") : !1, ne = K(() => l.resizable && !r.static), J = K(() => a.isMirrored ? !l.rtl : l.rtl), X = K(() => (l.draggable || l.resizable) && !r.static), ie = qAe("item"), ye = K(() => ({
      [ie.b()]: !0,
      [ie.bm("resizable")]: ne.value,
      [ie.bm("static")]: r.static,
      [ie.bm("resizing")]: l.isResizing,
      [ie.bm("dragging")]: l.isDragging,
      [ie.bm("transform")]: l.useCssTransforms,
      [ie.bm("rtl")]: J.value,
      [ie.bm("no-touch")]: Y && X.value
    })), pe = K(() => [ie.be("resizer"), J.value && ie.bem("resizer", "rtl")].filter(Boolean));
    et(
      () => r.isDraggable,
      (Le) => {
        l.draggable = Le;
      }
    ), et(
      () => r.static,
      () => {
        _i(ot), _i(Nt);
      }
    ), et(
      () => l.draggable,
      () => {
        _i(ot);
      }
    ), et(
      () => r.isResizable,
      (Le) => {
        l.resizable = Le;
      }
    ), et(
      () => r.isBounded,
      (Le) => {
        l.bounded = Le;
      }
    ), et(
      () => l.resizable,
      () => {
        _i(Nt);
      }
    ), et(
      () => l.rowHeight,
      () => {
        _i(Be), _i(Ce);
      }
    ), et([() => l.cols, () => l.containerWidth], () => {
      _i(Nt), _i(Be), _i(Ce);
    }), et([() => r.minH, () => r.maxH, () => r.minW, () => r.maxW], () => {
      _i(Nt);
    }), et(J, () => {
      _i(Nt), _i(Be);
    }), et([() => a.margin, () => a.margin[0], () => a.margin[1]], () => {
      const Le = a.margin;
      !Le || Le[0] === l.margin[0] && Le[1] === l.margin[1] || (l.margin = Le.map(Number), _i(Be), _i(Ce));
    });
    function Be() {
      r.x + r.w > l.cols ? (b = 0, x = r.w > l.cols ? l.cols : r.w) : (b = r.x, x = r.w);
      const Le = Pe(b, _, x, w);
      l.isDragging && (Le.top = l.dragging.top, J.value ? Le.right = l.dragging.left : Le.left = l.dragging.left), l.isResizing && (Le.width = l.resizing.width, Le.height = l.resizing.height);
      let ft;
      l.useCssTransforms ? J.value ? ft = HAe(Le.top, Le.right, Le.width, Le.height) : ft = VAe(Le.top, Le.left, Le.width, Le.height) : J.value ? ft = UAe(Le.top, Le.right, Le.width, Le.height) : ft = GAe(Le.top, Le.left, Le.width, Le.height), l.style = ft;
    }
    function Ce() {
      const Le = {};
      for (const ft of ["width", "height"]) {
        const Rt = l.style[ft].match(/^(\d+)px$/);
        if (!Rt)
          return;
        Le[ft] = Rt[1];
      }
      i("container-resized", r.i, r.h, r.w, Le.height, Le.width);
    }
    function Ee(Le) {
      if (r.static) return;
      const ft = Le.type;
      if (ft === "resizestart" && l.isResizing || ft !== "resizestart" && !l.isResizing)
        return;
      const Rt = NP(Le);
      if (la(Rt)) return;
      const { x: Re, y: be } = Rt, we = { width: 0, height: 0 };
      let Ne;
      switch (ft) {
        case "resizestart": {
          Nt(), v = x, m = w, Ne = Pe(b, _, x, w), we.width = Ne.width, we.height = Ne.height, l.resizing = we, l.isResizing = !0;
          break;
        }
        case "resizemove": {
          !Le.edges.right && !Le.edges.left && (p = Re), !Le.edges.top && !Le.edges.bottom && (h = be);
          const lt = RP(p, h, Re, be);
          J.value ? we.width = l.resizing.width - lt.deltaX / l.transformScale : we.width = l.resizing.width + lt.deltaX / l.transformScale, we.height = l.resizing.height + lt.deltaY / l.transformScale, l.resizing = we;
          break;
        }
        case "resizeend": {
          Ne = Pe(b, _, x, w), we.width = Ne.width, we.height = Ne.height, l.resizing = { width: -1, height: -1 }, l.isResizing = !1;
          break;
        }
      }
      Ne = Oe(we.height, we.width), Ne.w < r.minW && (Ne.w = r.minW), Ne.w > r.maxW && (Ne.w = r.maxW), Ne.h < r.minH && (Ne.h = r.minH), Ne.h > r.maxH && (Ne.h = r.maxH), Ne.h < 1 && (Ne.h = 1), Ne.w < 1 && (Ne.w = 1), p = Re, h = be, (x !== Ne.w || w !== Ne.h) && i("resize", r.i, Ne.h, Ne.w, we.height, we.width), Le.type === "resizeend" && (v !== x || m !== w) && i("resized", r.i, Ne.h, Ne.w, we.height, we.width), o.emit("resizeEvent", Le.type, r.i, b, _, Ne.h, Ne.w);
    }
    function ce(Le) {
      if (r.static || l.isResizing) return;
      const ft = Le.type;
      if (ft === "dragstart" && l.isDragging || ft !== "dragstart" && !l.isDragging)
        return;
      const Rt = NP(Le);
      if (la(Rt)) return;
      const { x: Re, y: be } = Rt, we = Le.target;
      if (!we.offsetParent) return;
      const Ne = { top: 0, left: 0 };
      switch (ft) {
        case "dragstart": {
          g = b, y = _;
          const Gt = we.offsetParent.getBoundingClientRect(), _n = we.getBoundingClientRect(), Tr = _n.left / l.transformScale, Se = Gt.left / l.transformScale, rt = _n.right / l.transformScale, wt = Gt.right / l.transformScale, rn = _n.top / l.transformScale, Kt = Gt.top / l.transformScale;
          J.value ? Ne.left = (rt - wt) * -1 : Ne.left = Tr - Se, Ne.top = rn - Kt, l.dragging = Ne, l.isDragging = !0;
          break;
        }
        case "dragmove": {
          const Gt = RP(d, f, Re, be);
          if (J.value ? Ne.left = l.dragging.left - Gt.deltaX / l.transformScale : Ne.left = l.dragging.left + Gt.deltaX / l.transformScale, Ne.top = l.dragging.top + Gt.deltaY / l.transformScale, l.bounded) {
            const _n = we.offsetParent.clientHeight - oe(r.h, l.rowHeight, l.margin[1]);
            Ne.top = he(Ne.top, 0, _n);
            const Tr = fe(), Se = l.containerWidth - oe(r.w, Tr, l.margin[0]);
            Ne.left = he(Ne.left, 0, Se);
          }
          l.dragging = Ne;
          break;
        }
        case "dragend": {
          const Gt = we.offsetParent.getBoundingClientRect(), _n = we.getBoundingClientRect(), Tr = _n.left / l.transformScale, Se = Gt.left / l.transformScale, rt = _n.right / l.transformScale, wt = Gt.right / l.transformScale, rn = _n.top / l.transformScale, Kt = Gt.top / l.transformScale;
          J.value ? Ne.left = (rt - wt) * -1 : Ne.left = Tr - Se, Ne.top = rn - Kt, l.dragging = { top: -1, left: -1 }, l.isDragging = !1;
          break;
        }
      }
      let lt;
      J.value, lt = Ae(Ne.top, Ne.left), d = Re, f = be, (b !== lt.x || _ !== lt.y) && i("move", r.i, lt.x, lt.y), Le.type === "dragend" && (g !== b || y !== _) && i("moved", r.i, lt.x, lt.y), o.emit("dragEvent", Le.type, r.i, lt.x, lt.y, w, x);
    }
    function Pe(Le, ft, Rt, Re) {
      const be = fe();
      let we;
      return J.value ? we = {
        right: Math.round(be * Le + (Le + 1) * l.margin[0]),
        top: Math.round(l.rowHeight * ft + (ft + 1) * l.margin[1]),
        // 0 * Infinity === NaN, which causes problems with resize constraints;
        // Fix this if it occurs.
        // Note we do it here rather than later because Math.round(Infinity) causes depot
        width: Rt === 1 / 0 ? Rt : Math.round(be * Rt + Math.max(0, Rt - 1) * l.margin[0]),
        height: Re === 1 / 0 ? Re : Math.round(l.rowHeight * Re + Math.max(0, Re - 1) * l.margin[1])
      } : we = {
        left: Math.round(be * Le + (Le + 1) * l.margin[0]),
        top: Math.round(l.rowHeight * ft + (ft + 1) * l.margin[1]),
        // 0 * Infinity === NaN, which causes problems with resize constraints;
        // Fix this if it occurs.
        // Note we do it here rather than later because Math.round(Infinity) causes depot
        width: Rt === 1 / 0 ? Rt : Math.round(be * Rt + Math.max(0, Rt - 1) * l.margin[0]),
        height: Re === 1 / 0 ? Re : Math.round(l.rowHeight * Re + Math.max(0, Re - 1) * l.margin[1])
      }, we;
    }
    function Ae(Le, ft) {
      const Rt = fe();
      let Re = Math.round((ft - l.margin[0]) / (Rt + l.margin[0])), be = Math.round((Le - l.margin[1]) / (l.rowHeight + l.margin[1]));
      return Re = Math.max(Math.min(Re, l.cols - x), 0), be = Math.max(Math.min(be, l.maxRows - w), 0), { x: Re, y: be };
    }
    function fe() {
      return (l.containerWidth - l.margin[0] * (l.cols + 1)) / l.cols;
    }
    function oe(Le, ft, Rt) {
      return Number.isFinite(Le) ? Math.round(ft * Le + Math.max(0, Le - 1) * Rt) : Le;
    }
    function he(Le, ft, Rt) {
      return Math.max(Math.min(Le, Rt), ft);
    }
    function Oe(Le, ft, Rt = !1) {
      const Re = fe();
      let be = Math.round((ft + l.margin[0]) / (Re + l.margin[0])), we = 0;
      return Rt ? we = Math.ceil((Le + l.margin[1]) / (l.rowHeight + l.margin[1])) : we = Math.round((Le + l.margin[1]) / (l.rowHeight + l.margin[1])), be = Math.max(Math.min(be, l.cols - b), 0), we = Math.max(Math.min(we, l.maxRows - _), 0), { w: be, h: we };
    }
    function Te(Le, ft) {
      l.containerWidth = Le;
    }
    function Ge() {
      Be();
    }
    function je() {
      !s.value && S.value && (s.value = jP(S.value), l.useStyleCursor || s.value.styleCursor(!1));
    }
    const Qe = OP(ce);
    function ot() {
      if (je(), !!s.value)
        if (l.draggable && !r.static) {
          const Le = {
            ignoreFrom: r.dragIgnoreFrom,
            allowFrom: r.dragAllowFrom,
            ...r.dragOption
          };
          s.value.draggable(Le), u || (u = !0, s.value.on("dragstart dragmove dragend", (ft) => {
            ft.type === "dragmove" ? Qe(ft) : ce(ft);
          }));
        } else
          s.value.draggable({ enabled: !1 });
    }
    const it = OP(Ee);
    function Nt() {
      if (je(), !!s.value)
        if (l.resizable && !r.static) {
          const Le = Pe(0, 0, r.maxW, r.maxH), ft = Pe(0, 0, r.minW, r.minH), Rt = {
            edges: {
              left: J.value ? `.${pe.value[0]}` : !1,
              right: J.value ? !1 : `.${pe.value[0]}`,
              bottom: `.${pe.value[0]}`,
              top: !1
            },
            ignoreFrom: r.resizeIgnoreFrom,
            restrictSize: {
              min: {
                height: ft.height * l.transformScale,
                width: ft.width * l.transformScale
              },
              max: {
                height: Le.height * l.transformScale,
                width: Le.width * l.transformScale
              }
            },
            ...r.resizeOption
          };
          r.preserveAspectRatio && (Rt.modifiers = [jP.modifiers.aspectRatio({ ratio: "preserve" })]), s.value.resizable(Rt), c || (c = !0, s.value.on("resizestart resizemove resizeend", (Re) => {
            Re.type === "resizemove" ? it(Re) : Ee(Re);
          }));
        } else
          s.value.resizable({ enabled: !1 });
    }
    return (Le, ft) => (L(), W("section", {
      ref_key: "wrapper",
      ref: S,
      class: _e(ye.value),
      style: An(l.style)
    }, [
      ue(Le.$slots, "default"),
      ne.value ? (L(), W("span", {
        key: 0,
        class: _e(pe.value)
      }, null, 2)) : ge("", !0)
    ], 6));
  }
}), Kd = typeof window < "u";
var BP;
Kd && (BP = window == null ? void 0 : window.navigator) != null && BP.userAgent && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function $P(n) {
  return n != null;
}
function zP() {
}
const tMe = Object.freeze({
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
});
Object.freeze(new Set(Object.keys(tMe)));
const nMe = Kd && ("ontouchstart" in window || iMe() > 0), rMe = nMe ? "pointerdown" : "click";
function iMe() {
  return typeof navigator < "u" && (navigator.maxTouchPoints || navigator.msMaxTouchPoints) || 0;
}
function aMe(n, e, t = window.Event) {
  const { type: r, bubbles: i = !1, cancelable: a = !1, ...o } = e;
  if (!$P(r) || r === "") return !1;
  let s;
  return $P(t) ? s = new t(r, { bubbles: i, cancelable: a }) : (s = document.createEvent("HTMLEvents"), s.initEvent(r, i, a)), Object.assign(s, o), n.dispatchEvent(s);
}
const oMe = "clickoutside", sMe = /* @__PURE__ */ new Set();
Kd && document.addEventListener(
  rMe,
  (n) => {
    const e = n.target, t = n.composedPath && n.composedPath();
    sMe.forEach((r) => {
      r !== e && (t ? !t.includes(r) : !r.contains(e)) && (!r.__transferElement || r.__transferElement !== e && !r.__transferElement.contains(e)) && aMe(r, { type: oMe });
    });
  },
  !0
);
const lMe = [
  [
    "requestFullscreen",
    "exitFullscreen",
    "fullscreenElement",
    "fullscreenEnabled",
    "fullscreenchange",
    "fullscreenerror"
  ],
  // New WebKit
  [
    "webkitRequestFullscreen",
    "webkitExitFullscreen",
    "webkitFullscreenElement",
    "webkitFullscreenEnabled",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  // Old WebKit
  [
    "webkitRequestFullScreen",
    "webkitCancelFullScreen",
    "webkitCurrentFullScreenElement",
    "webkitCancelFullScreen",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  [
    "mozRequestFullScreen",
    "mozCancelFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozfullscreenchange",
    "mozfullscreenerror"
  ],
  [
    "msRequestFullscreen",
    "msExitFullscreen",
    "msFullscreenElement",
    "msFullscreenEnabled",
    "MSFullscreenChange",
    "MSFullscreenError"
  ]
];
let v1;
if (Kd) {
  for (const n of lMe)
    if (n[1] in document) {
      v1 = n;
      break;
    }
}
K(() => !1);
const uMe = /* @__PURE__ */ new Set(), cMe = /* @__PURE__ */ new WeakMap();
if (Kd && v1) {
  const n = v1[2], e = v1[4];
  document.addEventListener(
    e,
    () => {
      if (uMe.forEach((t) => {
        t.value = !1;
      }), document[n]) {
        const t = cMe.get(document[n]);
        t && (t.value = !0);
      }
    },
    !1
  );
}
const j9 = /* @__PURE__ */ new Map();
j9.set("x", 0);
j9.set("y", 0);
var ld = [], dMe = function() {
  return ld.some(function(n) {
    return n.activeTargets.length > 0;
  });
}, fMe = function() {
  return ld.some(function(n) {
    return n.skippedTargets.length > 0;
  });
}, FP = "ResizeObserver loop completed with undelivered notifications.", pMe = function() {
  var n;
  typeof ErrorEvent == "function" ? n = new ErrorEvent("error", {
    message: FP
  }) : (n = document.createEvent("Event"), n.initEvent("error", !1, !1), n.message = FP), window.dispatchEvent(n);
}, Ym;
(function(n) {
  n.BORDER_BOX = "border-box", n.CONTENT_BOX = "content-box", n.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Ym || (Ym = {}));
var ud = function(n) {
  return Object.freeze(n);
}, hMe = /* @__PURE__ */ function() {
  function n(e, t) {
    this.inlineSize = e, this.blockSize = t, ud(this);
  }
  return n;
}(), B9 = function() {
  function n(e, t, r, i) {
    return this.x = e, this.y = t, this.width = r, this.height = i, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, ud(this);
  }
  return n.prototype.toJSON = function() {
    var e = this, t = e.x, r = e.y, i = e.top, a = e.right, o = e.bottom, s = e.left, l = e.width, u = e.height;
    return { x: t, y: r, top: i, right: a, bottom: o, left: s, width: l, height: u };
  }, n.fromRect = function(e) {
    return new n(e.x, e.y, e.width, e.height);
  }, n;
}(), gD = function(n) {
  return n instanceof SVGElement && "getBBox" in n;
}, $9 = function(n) {
  if (gD(n)) {
    var e = n.getBBox(), t = e.width, r = e.height;
    return !t && !r;
  }
  var i = n, a = i.offsetWidth, o = i.offsetHeight;
  return !(a || o || n.getClientRects().length);
}, VP = function(n) {
  var e;
  if (n instanceof Element)
    return !0;
  var t = (e = n == null ? void 0 : n.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView;
  return !!(t && n instanceof t.Element);
}, vMe = function(n) {
  switch (n.tagName) {
    case "INPUT":
      if (n.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, im = typeof window < "u" ? window : {}, Zy = /* @__PURE__ */ new WeakMap(), HP = /auto|scroll/, mMe = /^tb|vertical/, gMe = /msie|trident/i.test(im.navigator && im.navigator.userAgent), Bo = function(n) {
  return parseFloat(n || "0");
}, gp = function(n, e, t) {
  return n === void 0 && (n = 0), e === void 0 && (e = 0), t === void 0 && (t = !1), new hMe((t ? e : n) || 0, (t ? n : e) || 0);
}, GP = ud({
  devicePixelContentBoxSize: gp(),
  borderBoxSize: gp(),
  contentBoxSize: gp(),
  contentRect: new B9(0, 0, 0, 0)
}), z9 = function(n, e) {
  if (e === void 0 && (e = !1), Zy.has(n) && !e)
    return Zy.get(n);
  if ($9(n))
    return Zy.set(n, GP), GP;
  var t = getComputedStyle(n), r = gD(n) && n.ownerSVGElement && n.getBBox(), i = !gMe && t.boxSizing === "border-box", a = mMe.test(t.writingMode || ""), o = !r && HP.test(t.overflowY || ""), s = !r && HP.test(t.overflowX || ""), l = r ? 0 : Bo(t.paddingTop), u = r ? 0 : Bo(t.paddingRight), c = r ? 0 : Bo(t.paddingBottom), d = r ? 0 : Bo(t.paddingLeft), f = r ? 0 : Bo(t.borderTopWidth), p = r ? 0 : Bo(t.borderRightWidth), h = r ? 0 : Bo(t.borderBottomWidth), v = r ? 0 : Bo(t.borderLeftWidth), m = d + u, g = l + c, y = v + p, b = f + h, _ = s ? n.offsetHeight - b - n.clientHeight : 0, x = o ? n.offsetWidth - y - n.clientWidth : 0, w = i ? m + y : 0, S = i ? g + b : 0, C = r ? r.width : Bo(t.width) - w - x, k = r ? r.height : Bo(t.height) - S - _, M = C + m + x + y, D = k + g + _ + b, N = ud({
    devicePixelContentBoxSize: gp(Math.round(C * devicePixelRatio), Math.round(k * devicePixelRatio), a),
    borderBoxSize: gp(M, D, a),
    contentBoxSize: gp(C, k, a),
    contentRect: new B9(d, l, C, k)
  });
  return Zy.set(n, N), N;
}, F9 = function(n, e, t) {
  var r = z9(n, t), i = r.borderBoxSize, a = r.contentBoxSize, o = r.devicePixelContentBoxSize;
  switch (e) {
    case Ym.DEVICE_PIXEL_CONTENT_BOX:
      return o;
    case Ym.BORDER_BOX:
      return i;
    default:
      return a;
  }
}, yMe = /* @__PURE__ */ function() {
  function n(e) {
    var t = z9(e);
    this.target = e, this.contentRect = t.contentRect, this.borderBoxSize = ud([t.borderBoxSize]), this.contentBoxSize = ud([t.contentBoxSize]), this.devicePixelContentBoxSize = ud([t.devicePixelContentBoxSize]);
  }
  return n;
}(), V9 = function(n) {
  if ($9(n))
    return 1 / 0;
  for (var e = 0, t = n.parentNode; t; )
    e += 1, t = t.parentNode;
  return e;
}, bMe = function() {
  var n = 1 / 0, e = [];
  ld.forEach(function(a) {
    if (a.activeTargets.length !== 0) {
      var o = [];
      a.activeTargets.forEach(function(s) {
        var l = new yMe(s.target), u = V9(s.target);
        o.push(l), s.lastReportedSize = F9(s.target, s.observedBox), u < n && (n = u);
      }), e.push(function() {
        a.callback.call(a.observer, o, a.observer);
      }), a.activeTargets.splice(0, a.activeTargets.length);
    }
  });
  for (var t = 0, r = e; t < r.length; t++) {
    var i = r[t];
    i();
  }
  return n;
}, UP = function(n) {
  ld.forEach(function(e) {
    e.activeTargets.splice(0, e.activeTargets.length), e.skippedTargets.splice(0, e.skippedTargets.length), e.observationTargets.forEach(function(t) {
      t.isActive() && (V9(t.target) > n ? e.activeTargets.push(t) : e.skippedTargets.push(t));
    });
  });
}, _Me = function() {
  var n = 0;
  for (UP(n); dMe(); )
    n = bMe(), UP(n);
  return fMe() && pMe(), n > 0;
}, zS, H9 = [], xMe = function() {
  return H9.splice(0).forEach(function(n) {
    return n();
  });
}, wMe = function(n) {
  if (!zS) {
    var e = 0, t = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return xMe();
    }).observe(t, r), zS = function() {
      t.textContent = "".concat(e ? e-- : e++);
    };
  }
  H9.push(n), zS();
}, SMe = function(n) {
  wMe(function() {
    requestAnimationFrame(n);
  });
}, m1 = 0, EMe = function() {
  return !!m1;
}, TMe = 250, CMe = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, WP = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], qP = function(n) {
  return n === void 0 && (n = 0), Date.now() + n;
}, FS = !1, kMe = function() {
  function n() {
    var e = this;
    this.stopped = !0, this.listener = function() {
      return e.schedule();
    };
  }
  return n.prototype.run = function(e) {
    var t = this;
    if (e === void 0 && (e = TMe), !FS) {
      FS = !0;
      var r = qP(e);
      SMe(function() {
        var i = !1;
        try {
          i = _Me();
        } finally {
          if (FS = !1, e = r - qP(), !EMe())
            return;
          i ? t.run(1e3) : e > 0 ? t.run(e) : t.start();
        }
      });
    }
  }, n.prototype.schedule = function() {
    this.stop(), this.run();
  }, n.prototype.observe = function() {
    var e = this, t = function() {
      return e.observer && e.observer.observe(document.body, CMe);
    };
    document.body ? t() : im.addEventListener("DOMContentLoaded", t);
  }, n.prototype.start = function() {
    var e = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), WP.forEach(function(t) {
      return im.addEventListener(t, e.listener, !0);
    }));
  }, n.prototype.stop = function() {
    var e = this;
    this.stopped || (this.observer && this.observer.disconnect(), WP.forEach(function(t) {
      return im.removeEventListener(t, e.listener, !0);
    }), this.stopped = !0);
  }, n;
}(), RC = new kMe(), YP = function(n) {
  !m1 && n > 0 && RC.start(), m1 += n, !m1 && RC.stop();
}, AMe = function(n) {
  return !gD(n) && !vMe(n) && getComputedStyle(n).display === "inline";
}, MMe = function() {
  function n(e, t) {
    this.target = e, this.observedBox = t || Ym.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return n.prototype.isActive = function() {
    var e = F9(this.target, this.observedBox, !0);
    return AMe(this.target) && (this.lastReportedSize = e), this.lastReportedSize.inlineSize !== e.inlineSize || this.lastReportedSize.blockSize !== e.blockSize;
  }, n;
}(), DMe = /* @__PURE__ */ function() {
  function n(e, t) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = e, this.callback = t;
  }
  return n;
}(), Jy = /* @__PURE__ */ new WeakMap(), KP = function(n, e) {
  for (var t = 0; t < n.length; t += 1)
    if (n[t].target === e)
      return t;
  return -1;
}, Qy = function() {
  function n() {
  }
  return n.connect = function(e, t) {
    var r = new DMe(e, t);
    Jy.set(e, r);
  }, n.observe = function(e, t, r) {
    var i = Jy.get(e), a = i.observationTargets.length === 0;
    KP(i.observationTargets, t) < 0 && (a && ld.push(i), i.observationTargets.push(new MMe(t, r && r.box)), YP(1), RC.schedule());
  }, n.unobserve = function(e, t) {
    var r = Jy.get(e), i = KP(r.observationTargets, t), a = r.observationTargets.length === 1;
    i >= 0 && (a && ld.splice(ld.indexOf(r), 1), r.observationTargets.splice(i, 1), YP(-1));
  }, n.disconnect = function(e) {
    var t = this, r = Jy.get(e);
    r.observationTargets.slice().forEach(function(i) {
      return t.unobserve(e, i.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, n;
}(), OMe = function() {
  function n(e) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof e != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Qy.connect(this, e);
  }
  return n.prototype.observe = function(e, t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!VP(e))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Qy.observe(this, e, t);
  }, n.prototype.unobserve = function(e) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!VP(e))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Qy.unobserve(this, e);
  }, n.prototype.disconnect = function() {
    Qy.disconnect(this);
  }, n.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, n;
}();
const Vb = /* @__PURE__ */ new WeakMap();
function IMe(n) {
  var e;
  for (let t = 0, r = n.length; t < r; ++t) {
    const i = n[t], a = Vb.get(i.target);
    if (typeof a == "function") {
      const { inlineSize: o, blockSize: s } = ((e = i.borderBoxSize) == null ? void 0 : e[0]) ?? {}, { offsetWidth: l, offsetHeight: u } = i.target;
      a(
        Object.assign(i, {
          offsetWidth: l,
          offsetHeight: u,
          width: o ?? l,
          height: s ?? u
        })
      );
    }
  }
}
const G9 = new (Kd && window.ResizeObserver || OMe)(
  IMe
);
function XP(n, e) {
  Vb.set(n, e), G9.observe(n);
}
function ZP(n) {
  Vb.has(n) && (G9.unobserve(n), Vb.delete(n));
}
function LMe(n = {}) {
  let e = zP;
  const t = et(
    () => O(n.target),
    (i) => {
      e(), !(!i || typeof n.onResize != "function") && (XP(i, n.onResize), e = () => {
        ZP(i), e = zP;
      });
    },
    { immediate: !0 }
  ), r = () => {
    t(), e();
  };
  return V_() && xg(r), {
    /**
     * @deprecated Will be removed in next major version, please directly use `observeResize` from imports.
     */
    observeResize: XP,
    /**
     * @deprecated Will be removed in next major version, please directly use `unobserveResize` from imports.
     */
    unobserveResize: ZP,
    unobserve: r
  };
}
const NMe = Z(!1);
K(() => NMe.value);
const JP = "__theme_style__", VS = "__theme_observer__", QP = Sr(/* @__PURE__ */ new Map()), e3 = /* @__PURE__ */ new Map();
et(QP, () => {
  if (!Kd) return;
  e3.clear();
  const n = document.head.querySelector(`#${JP}`);
  n && document.head.removeChild(n);
  const e = document.createElement("style");
  let t = `.${VS} { width: 1px }`, r = 1;
  for (const [i, [a, o]] of QP.entries())
    t += ` html.${a} .${VS}, .${o} .${VS} { width: ${++r}px }`, e3.set(r, i);
  e.textContent = t, e.id = JP, document.head.appendChild(e);
});
const RMe = /* @__PURE__ */ ve({
  __name: "grid-layout",
  props: {
    autoSize: { type: Boolean, default: !0 },
    colNum: { default: 12 },
    rowHeight: { default: 150 },
    maxRows: { default: 1 / 0 },
    margin: { default: () => [10, 10] },
    isDraggable: { type: Boolean, default: !0 },
    isResizable: { type: Boolean, default: !0 },
    isMirrored: { type: Boolean, default: !1 },
    isBounded: { type: Boolean, default: !1 },
    useCssTransforms: { type: Boolean, default: !0 },
    verticalCompact: { type: Boolean, default: !0 },
    restoreOnDrag: { type: Boolean, default: !1 },
    layout: {},
    responsive: { type: Boolean, default: !1 },
    responsiveLayouts: { default: () => ({}) },
    transformScale: { default: 1 },
    breakpoints: { default: () => ({ lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 }) },
    cols: { default: () => ({ lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 }) },
    preventCollision: { type: Boolean, default: !1 },
    useStyleCursor: { type: Boolean, default: !0 }
  },
  emits: [
    "layout-before-mount",
    "layout-mounted",
    "layout-updated",
    "breakpoint-changed",
    "update:layout",
    "layout-ready"
  ],
  setup(n, { expose: e, emit: t }) {
    const r = n, i = t, a = Sr({
      width: -1,
      mergedStyle: {},
      lastLayoutLength: 0,
      isDragging: !1,
      placeholder: {
        x: 0,
        y: 0,
        w: 0,
        h: 0,
        i: ""
      },
      layouts: {},
      // array to store all layouts from different breakpoints
      lastBreakpoint: null,
      // store last active breakpoint
      originalLayout: null
      // store original Layout
    }), o = /* @__PURE__ */ new Map(), s = Z(r.layout), l = Z(), { observeResize: u, unobserveResize: c } = LMe(), d = RAe();
    d.on("resizeEvent", f), d.on("dragEvent", p), AA(() => {
      i("layout-before-mount", s.value);
    }), kt(() => {
      i("layout-mounted", s.value), Wt(() => {
        WAe(s.value), a.originalLayout = s.value, Wt(() => {
          k(), l.value && u(l.value, PAe(b, 16)), Zf(s.value, r.verticalCompact), i("layout-updated", s.value), y(), b();
        });
      });
    }), Io(() => {
      d.clearAll(), l.value && c(l.value);
    });
    function f(D, N, R, j, z, F) {
      S(D, N, R, j, z, F);
    }
    function p(D, N, R, j, z, F) {
      w(D, N, R, j, z, F);
    }
    et(
      () => a.width,
      (D, N) => {
        Wt(() => {
          d.emit("updateWidth", D), N === -1 && Wt(() => {
            i("layout-ready", s.value);
          }), y();
        });
      }
    ), et(
      () => [r.layout, r.layout.length],
      () => {
        s.value = r.layout, g();
      }
    ), et(
      () => r.colNum,
      (D) => {
        d.emit("setColNum", D);
      }
    ), et(
      () => r.rowHeight,
      (D) => {
        d.emit("setRowHeight", D);
      }
    ), et(
      () => r.isDraggable,
      (D) => {
        d.emit("setDraggable", D);
      }
    ), et(
      () => r.isResizable,
      (D) => {
        d.emit("setResizable", D);
      }
    ), et(
      () => r.isBounded,
      (D) => {
        d.emit("setBounded", D);
      }
    ), et(
      () => r.transformScale,
      (D) => {
        d.emit("setTransformScale", D);
      }
    ), et(
      () => r.responsive,
      (D) => {
        D || (i("update:layout", a.originalLayout), d.emit("setColNum", r.colNum)), b();
      }
    ), et(
      () => r.maxRows,
      (D) => {
        d.emit("setMaxRows", D);
      }
    ), et([() => r.margin, () => r.margin[1]], y), zn(
      M9,
      Sr({
        ...fi(r),
        ...fi(a),
        increaseItem: h,
        decreaseItem: v
      })
    ), zn(D9, d), e({ state: a, getItem: m, resizeEvent: S, dragEvent: w, layoutUpdate: g });
    function h(D) {
      o.set(D.i, D);
    }
    function v(D) {
      o.delete(D.i);
    }
    function m(D) {
      return o.get(D);
    }
    function g() {
      if (!la(s.value) && !la(a.originalLayout)) {
        if (s.value.length !== a.originalLayout.length) {
          const D = M(s.value, a.originalLayout);
          if (D.length > 0)
            if (s.value.length > a.originalLayout.length)
              a.originalLayout = a.originalLayout.concat(D);
            else {
              const N = new Set(D.map((R) => R.i));
              a.originalLayout = a.originalLayout.filter((R) => !N.has(R.i));
            }
          a.lastLayoutLength = s.value.length, k();
        }
        Zf(s.value, r.verticalCompact), d.emit("updateWidth", a.width), y(), i("layout-updated", s.value);
      }
    }
    function y() {
      a.mergedStyle = {
        height: _()
      };
    }
    function b() {
      l.value && (a.width = l.value.offsetWidth), d.emit("resizeEvent");
    }
    function _() {
      if (!r.autoSize) return;
      const D = parseFloat(r.margin[1]);
      return BAe(s.value) * (r.rowHeight + D) + D + "px";
    }
    let x;
    function w(D, N, R, j, z, F) {
      let B = IP(s.value, N);
      la(B) && (B = { h: 0, w: 0, x: 0, y: 0, i: "" }), D === "dragstart" && !r.verticalCompact && (x = s.value.reduce(
        (H, { i: Y, x: ne, y: J }) => ({
          ...H,
          [Y]: { x: ne, y: J }
        }),
        {}
      )), D === "dragmove" || D === "dragstart" ? (a.placeholder.i = N, a.placeholder.x = B.x, a.placeholder.y = B.y, a.placeholder.w = F, a.placeholder.h = z, Wt(() => {
        a.isDragging = !0;
      }), d.emit("updateWidth", a.width)) : Wt(() => {
        a.isDragging = !1;
      }), s.value = LC(s.value, B, R, j, !0, r.preventCollision), r.restoreOnDrag ? (B.static = !0, Zf(s.value, r.verticalCompact, x), B.static = !1) : Zf(s.value, r.verticalCompact), d.emit("compact"), y(), D === "dragend" && (x = void 0, i("layout-updated", s.value));
    }
    function S(D, N, R, j, z, F) {
      let B = IP(s.value, N);
      la(B) && (B = { h: 0, w: 0, x: 0, y: 0, i: "" });
      let H;
      if (r.preventCollision) {
        const Y = I9(s.value, { ...B, w: F, h: z }).filter(
          (ne) => ne.i !== B.i
        );
        if (H = Y.length > 0, H) {
          let ne = 1 / 0, J = 1 / 0;
          Y.forEach((X) => {
            X.x > B.x && (ne = Math.min(ne, X.x)), X.y > B.y && (J = Math.min(J, X.y));
          }), Number.isFinite(ne) && (B.w = ne - B.x), Number.isFinite(J) && (B.h = J - B.y);
        }
      }
      H || (B.w = F, B.h = z), D === "resizestart" || D === "resizemove" ? (a.placeholder.i = N, a.placeholder.x = R, a.placeholder.y = j, a.placeholder.w = B.w, a.placeholder.h = B.h, Wt(() => {
        a.isDragging = !0;
      }), d.emit("updateWidth", a.width)) : D && Wt(() => {
        a.isDragging = !1;
      }), r.responsive && C(), Zf(s.value, r.verticalCompact), d.emit("compact"), y(), D === "resizeend" && i("layout-updated", s.value);
    }
    function C() {
      const D = XAe(r.breakpoints, a.width);
      if (D === a.lastBreakpoint)
        return;
      const N = R9(D, r.cols);
      !la(a.lastBreakpoint) && !a.layouts[a.lastBreakpoint] && (a.layouts[a.lastBreakpoint] = IC(s.value));
      const R = ZAe(
        a.originalLayout,
        a.layouts,
        r.breakpoints,
        D,
        a.lastBreakpoint,
        N,
        r.verticalCompact
      );
      a.layouts[D] = R, a.lastBreakpoint !== D && i("breakpoint-changed", D, R), s.value = R, i("update:layout", R), a.lastBreakpoint = D, d.emit("setColNum", N);
    }
    function k() {
      a.layouts = Object.assign({}, r.responsiveLayouts);
    }
    function M(D, N) {
      const R = new Set(N.map((B) => B.i)), j = new Set(D.map((B) => B.i)), z = D.filter((B) => !R.has(B.i)), F = N.filter((B) => !j.has(B.i));
      return z.concat(F);
    }
    return (D, N) => (L(), W("div", {
      ref_key: "wrapper",
      ref: l,
      class: "vgl-layout",
      style: An(a.mergedStyle)
    }, [
      D.$slots.default ? ue(D.$slots, "default", { key: 0 }) : (L(!0), W(Ke, { key: 1 }, _t(s.value, (R) => (L(), re(NC, He({
        key: R.i,
        ref_for: !0
      }, R), {
        default: ee(() => [
          ue(D.$slots, "item", { item: R })
        ]),
        _: 2
      }, 1040))), 128)),
      ta(se(NC, {
        class: "vgl-item--placeholder",
        x: a.placeholder.x,
        y: a.placeholder.y,
        w: a.placeholder.w,
        h: a.placeholder.h,
        i: a.placeholder.i
      }, null, 8, ["x", "y", "w", "h", "i"]), [
        [hs, a.isDragging]
      ])
    ], 4));
  }
});
(function() {
  try {
    if (typeof document < "u") {
      var n = document.createElement("style");
      n.appendChild(document.createTextNode('.vgl-layout{--vgl-placeholder-bg: red;--vgl-placeholder-opacity: 20%;--vgl-placeholder-z-index: 2;--vgl-item-resizing-z-index: 3;--vgl-item-resizing-opacity: 60%;--vgl-item-dragging-z-index: 3;--vgl-item-dragging-opacity: 100%;--vgl-resizer-size: 10px;--vgl-resizer-border-color: #444;--vgl-resizer-border-width: 2px;position:relative;box-sizing:border-box;transition:height .2s ease}.vgl-item{position:absolute;box-sizing:border-box;transition:.2s ease;transition-property:left,top,right}.vgl-item--placeholder{z-index:var(--vgl-placeholder-z-index, 2);-webkit-user-select:none;-moz-user-select:none;user-select:none;background-color:var(--vgl-placeholder-bg, red);opacity:var(--vgl-placeholder-opacity, 20%);transition-duration:.1s}.vgl-item--no-touch{touch-action:none}.vgl-item--transform{right:auto;left:0;transition-property:transform}.vgl-item--transform.vgl-item--rtl{right:0;left:auto}.vgl-item--resizing{z-index:var(--vgl-item-resizing-z-index, 3);-webkit-user-select:none;-moz-user-select:none;user-select:none;opacity:var(--vgl-item-resizing-opacity, 60%)}.vgl-item--dragging{z-index:var(--vgl-item-dragging-z-index, 3);-webkit-user-select:none;-moz-user-select:none;user-select:none;opacity:var(--vgl-item-dragging-opacity, 100%);transition:none}.vgl-item__resizer{position:absolute;right:0;bottom:0;box-sizing:border-box;width:var(--vgl-resizer-size);height:var(--vgl-resizer-size);cursor:se-resize}.vgl-item__resizer:before{position:absolute;top:0;right:3px;bottom:3px;left:0;content:"";border:0 solid var(--vgl-resizer-border-color);border-right-width:var(--vgl-resizer-border-width);border-bottom-width:var(--vgl-resizer-border-width)}.vgl-item__resizer--rtl{right:auto;left:0;cursor:sw-resize}.vgl-item__resizer--rtl:before{top:0;right:0;bottom:3px;left:3px;border-right-width:0;border-bottom-width:var(--vgl-resizer-border-width);border-left-width:var(--vgl-resizer-border-width)}')), document.head.appendChild(n);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
const PMe = { class: "h-full w-full rounded bg-surface-white p-4 shadow" }, jMe = /* @__PURE__ */ ve({
  __name: "Layout",
  props: /* @__PURE__ */ MA({
    cols: {},
    rowHeight: {},
    disabled: {}
  }, {
    modelValue: {
      type: Array,
      default: () => []
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(n) {
    const e = n, t = DA(n, "modelValue"), r = Z(!1), i = Sr({
      colNum: e.cols || 12,
      margin: [0, 0],
      rowHeight: e.rowHeight || 52,
      isDraggable: K(() => !e.disabled),
      isResizable: K(() => !e.disabled),
      responsive: !0,
      verticalCompact: !0,
      preventCollision: !1,
      useCssTransforms: !0,
      cols: {
        lg: e.cols || 12,
        md: e.cols || 12,
        sm: e.cols || 12,
        xs: 1,
        xxs: 1
      }
    });
    return (a, o) => (L(), re(O(RMe), He({
      layout: t.value,
      "onUpdate:layout": o[0] || (o[0] = (s) => t.value = s)
    }, i, {
      onLayoutReady: o[1] || (o[1] = () => r.value = !0)
    }), {
      default: ee(() => [
        (L(!0), W(Ke, null, _t(t.value, (s, l) => (L(), re(O(NC), {
          key: s.i,
          i: s.i,
          x: s.x,
          y: s.y,
          w: s.w,
          h: s.h
        }, {
          default: ee(() => [
            r.value ? ue(a.$slots, "item", {
              key: 0,
              index: l,
              i: s.i,
              x: s.x,
              y: s.y,
              w: s.w,
              h: s.h
            }, () => [
              G("pre", PMe, ke({ i: s.i, x: s.x, y: s.y, w: s.w, h: s.h }), 1)
            ], !0) : ge("", !0)
          ]),
          _: 2
        }, 1032, ["i", "x", "y", "w", "h"]))), 128))
      ]),
      _: 3
    }, 16, ["layout"]));
  }
}), YUe = /* @__PURE__ */ zt(jMe, [["__scopeId", "data-v-6dac9ad0"]]);
function t3(n) {
  return n.split("_").map((e) => e.charAt(0).toUpperCase() + e.slice(1)).join(" ");
}
function Xi(n, e = 0, t = !1) {
  if (isNaN(n)) return n.toString();
  let r = "en-US";
  return t ? new Intl.NumberFormat(r, {
    notation: "compact",
    maximumFractionDigits: e
  }).format(n) : (e = e || BMe(n), new Intl.NumberFormat(r, {
    minimumFractionDigits: e,
    maximumFractionDigits: e
  }).format(n));
}
function BMe(n) {
  if (!n || isNaN(n)) return 0;
  const e = n.toString(), t = e.indexOf(".");
  return t === -1 ? 0 : Math.min(e.length - t - 1, 2);
}
function $Me(n, e, t = "day") {
  return n ? (t && (e = {
    second: "MMMM D, YYYY h:mm:ss A",
    minute: "MMMM D, YYYY h:mm A",
    hour: "MMMM D, YYYY h:00 A",
    day: "MMMM D, YYYY",
    week: "MMM Do, YYYY",
    month: "MMMM, YYYY",
    year: "YYYY",
    quarter: "[Q]Q, YYYY"
  }[t]), e || (e = "MMM D, YY"), Cm(n).format(e)) : "";
}
function HS(n) {
  return n && typeof n == "object" && !Array.isArray(n);
}
function Eu(n, ...e) {
  if (!e.length) return n;
  const t = e.shift();
  if (!t || !HS(n) || !HS(t))
    return Eu(n, ...e);
  let r = Object.assign({}, n);
  return Object.keys(t).forEach((i) => {
    HS(t[i]) && i in r ? r[i] = Eu(r[i], t[i]) : r[i] = t[i];
  }), Eu(r, ...e);
}
const U9 = 0, zMe = 10, FMe = 30, VMe = 10, W9 = 20, q9 = 18, Y9 = 24;
function HMe(n) {
  var l;
  const e = n.title, t = n.subtitle, r = e ? 1 : 0, i = t ? 1 : 0;
  n.xAxis.title, n.yAxis.title, (l = n.y2Axis) != null && l.title;
  const a = n.series.length > 1 ? 1 : 0, o = GMe(n), s = UMe(n);
  return {
    animation: !0,
    animationDuration: 700,
    textStyle: { fontFamily: ["InterVar", "sans-serif"] },
    title: yD(e, t),
    color: n.colors,
    grid: {
      left: "1%",
      right: n.swapXY ? "2.5%" : "1.5%",
      top: U9 + W9 * r + q9 * i + Y9,
      bottom: zMe + FMe * a,
      containLabel: !0
    },
    xAxis: o,
    yAxis: s,
    series: [],
    tooltip: {
      show: !0,
      trigger: "axis",
      formatter: (u) => {
        if (Array.isArray(u) && (u = u.filter((c) => {
          var d;
          return ((d = c.value) == null ? void 0 : d[1]) !== 0;
        }).sort((c, d) => {
          var f, p;
          return ((f = d.value) == null ? void 0 : f[1]) - ((p = c.value) == null ? void 0 : p[1]);
        })), !Array.isArray(u)) {
          const c = u, d = n.swapXY ? c.value[0] : c.value[1], f = isNaN(d) ? d : Xi(d);
          return `
                <div class="flex items-center justify-between gap-5">
                  <div>${c.name}</div>
                  <div class="font-bold">${f}</div>
                </div>
              `;
        }
        if (Array.isArray(u))
          return u.map((d, f) => {
            const p = n.swapXY ? d.value[1] : d.value[0], h = n.swapXY ? d.value[0] : d.value[1], v = n.xAxis.type == "time" ? $Me(p, void 0, n.xAxis.timeGrain) : p, m = isNaN(h) ? h : Xi(h);
            return `
              <div class="flex flex-col">
                ${f == 0 ? `<div>${v}</div>` : ""}
                <div class="flex items-center justify-between gap-5">
                  <div class="flex gap-1 items-center">
                    ${d.marker}
                    <div>${t3(d.seriesName)}:</div>
                  </div>
                  <div class="font-bold">${m}</div>
                </div>
              </div>
            `;
          }).join("");
      },
      confine: !0,
      appendToBody: !1,
      axisPointer: {
        type: "shadow"
      }
    },
    legend: {
      show: a,
      type: "scroll",
      bottom: VMe,
      orient: "horizontal",
      itemGap: 12,
      padding: [0, 25],
      formatter: function(u) {
        return t3(u);
      },
      textStyle: {
        padding: [0, 0, 0, -5],
        color: "var(--ink-gray-8)"
      },
      icon: "circle",
      pageIcons: {
        horizontal: [
          "M 17 3 h 2 c 0.386 0 0.738 0.223 0.904 0.572 s 0.115 0.762 -0.13 1.062 L 11.292 15 l 8.482 10.367 c 0.245 0.299 0.295 0.712 0.13 1.062 S 19.386 27 19 27 h -2 c -0.3 0 -0.584 -0.135 -0.774 -0.367 l -9 -11 c -0.301 -0.369 -0.301 -0.898 0 -1.267 l 9 -11 C 16.416 3.135 16.7 3 17 3 Z",
          "M 12 27 h -2 c -0.386 0 -0.738 -0.223 -0.904 -0.572 s -0.115 -0.762 0.13 -1.062 L 17.708 15 L 9.226 4.633 c -0.245 -0.299 -0.295 -0.712 -0.13 -1.062 S 9.614 3 10 3 h 2 c 0.3 0 0.584 0.135 0.774 0.367 l 9 11 c 0.301 0.369 0.301 0.898 0 1.267 l -9 11 C 12.584 26.865 12.3 27 12 27 Z"
        ]
      },
      pageIconColor: "var(--ink-gray-6)",
      pageInactiveColor: "var(--ink-gray-4)",
      pageIconSize: 10,
      pageTextStyle: {
        color: "var(--ink-gray-6)"
      },
      animationDurationUpdate: 300
    }
  };
}
function yD(n, e) {
  return {
    top: "4px",
    left: "0.8%",
    text: n,
    subtext: e,
    padding: 0,
    itemGap: -3,
    textStyle: {
      fontSize: 14,
      fontWeight: 500,
      lineHeight: 24,
      color: "var(--ink-gray-8)"
    },
    subtextStyle: {
      fontSize: 13,
      fontWeight: 400,
      lineHeight: 20,
      color: "var(--ink-gray-6)"
    }
  };
}
function GMe(n) {
  const e = n.swapXY ? {
    show: !0,
    type: "value",
    z: 2,
    scale: !1,
    boundaryGap: !1,
    position: "top",
    name: `${n.yAxis.title} →`,
    nameGap: 6,
    nameLocation: "end",
    nameTextStyle: {
      align: "right",
      verticalAlign: "bottom",
      padding: [0, 0, 26, 0],
      backgroundColor: "var(--surface-white)",
      borderColor: "var(--surface-white)",
      color: "var(--ink-gray-8)",
      borderWidth: 4
    },
    splitLine: {
      show: !0,
      width: 1,
      lineStyle: {
        color: "var(--ink-gray-3)"
      }
    },
    axisLine: {
      show: !1,
      onZero: !1
    },
    axisTick: {
      show: !1,
      alignWithLabel: !0,
      formatter: function(t) {
        return Xi(t, 1, !0);
      }
    },
    axisLabel: {
      show: !0,
      hideOverlap: !0,
      margin: 8,
      formatter: function(t) {
        return Xi(t, 1, !0);
      }
    }
  } : {
    z: 2,
    type: n.xAxis.type,
    scale: !0,
    splitLine: {
      show: !1
    },
    axisLine: {
      show: !0
    },
    axisTick: {
      show: !1,
      alignWithLabel: !0
    },
    axisLabel: {
      show: !0,
      hideOverlap: !0,
      showMaxLabel: n.xAxis.type === "category" || n.xAxis.type === "value",
      margin: 8
    }
  };
  return Eu(e, n.swapXY ? n.yAxis.echartOptions : n.xAxis.echartOptions);
}
function UMe(n) {
  var r, i, a, o, s;
  let e = n.swapXY ? {
    show: !0,
    type: n.xAxis.type,
    z: 2,
    scale: !0,
    inverse: "true",
    splitLine: {
      show: !1
    },
    axisLine: {
      show: !0
    },
    axisTick: {
      show: !1,
      alignWithLabel: !0
    },
    axisLabel: {
      show: !0,
      hideOverlap: !0,
      margin: 6
    }
  } : {
    show: !0,
    type: "value",
    z: 2,
    scale: !1,
    boundaryGap: ["0%", "1%"],
    name: `↑ ${n.yAxis.title}`,
    nameGap: 6,
    nameLocation: "end",
    nameTextStyle: {
      align: "left",
      verticalAlign: "top",
      padding: [0, 0, 0, -2],
      backgroundColor: "var(--surface-white)",
      borderColor: "var(--surface-white)",
      color: "var(--ink-gray-8)",
      borderWidth: 4
    },
    splitLine: {
      show: !0,
      width: 1,
      lineStyle: {
        color: "var(--ink-gray-3)"
      }
    },
    axisLine: {
      show: !1,
      onZero: !1
    },
    axisTick: {
      show: !1,
      alignWithLabel: !0
    },
    axisLabel: {
      show: !0,
      hideOverlap: !0,
      margin: 8,
      formatter: function(l) {
        return Xi(l, 1, !0);
      }
    },
    min: n.yAxis.yMin,
    max: n.yAxis.yMax
  };
  e = Eu(
    e,
    n.swapXY ? n.xAxis.echartOptions : n.yAxis.echartOptions
  );
  let t = {
    show: !1,
    type: "value",
    z: 2,
    alignTicks: !0,
    scale: !1,
    boundaryGap: ["0%", "1%"],
    name: `${(r = n.y2Axis) == null ? void 0 : r.title} ↑`,
    nameLocation: "end",
    nameTextStyle: {
      align: "right",
      verticalAlign: "top",
      padding: [0, 5, 0, 0],
      backgroundColor: "var(--surface-white)",
      borderColor: "var(--surface-white)",
      color: "var(--ink-gray-8)"
    },
    nameGap: 6,
    splitLine: {
      show: !0,
      width: 1,
      lineStyle: {
        color: "var(--ink-gray-3)"
      }
    },
    axisLine: {
      show: !1,
      onZero: !1
    },
    axisTick: {
      show: !1,
      alignWithLabel: !0
    },
    axisLabel: {
      show: !0,
      hideOverlap: !0,
      margin: 8,
      formatter: function(l) {
        return Xi(l, 1, !0);
      }
      // color: '#000',
    },
    min: (i = n.y2Axis) == null ? void 0 : i.yMin,
    max: (a = n.y2Axis) == null ? void 0 : a.yMax
  };
  return t = Eu(
    t,
    n.swapXY ? (o = n.y2Axis) == null ? void 0 : o.echartOptions : (s = n.y2Axis) == null ? void 0 : s.echartOptions
  ), n.swapXY ? [e] : [e, t];
}
function WMe(n) {
  const e = n.data || [], t = HMe(n);
  if (n.xAxis.type === "time" && n.swapXY)
    throw new Error("Swap axes is not supported for time series data");
  if (n.series.find((o) => o.axis === "y2" || o.type !== "bar") && n.swapXY)
    throw new Error("Swap axes is not supported for non-bar series or y2 axis");
  const r = n.swapXY, i = n.series.slice().reverse().findIndex((o) => o.type === "bar");
  return n.series.some((o) => o.axis === "y2") && (t.yAxis[1].show = !0), t.series = n.series.map((o, s) => {
    let l = "top";
    o.type == "bar" && n.stacked && (l = s == i ? "top" : "inside"), o.type == "bar" && r && (l = "right");
    const u = {
      type: o.type,
      name: o.name,
      data: e.map((d) => {
        let f, p;
        return r ? (f = d[o.name], p = d[n.xAxis.key]) : (f = d[n.xAxis.key], p = d[o.name]), [f, p];
      }),
      yAxisIndex: o.axis === "y2" ? 1 : 0,
      label: {
        show: o.showDataLabels,
        position: l,
        formatter: (d) => {
          var p, h;
          const f = r ? (p = d.value) == null ? void 0 : p[0] : (h = d.value) == null ? void 0 : h[1];
          return Xi(f, 1, !0);
        },
        fontSize: 11
      },
      labelLayout: { hideOverlap: !0 },
      itemStyle: {
        color: o.color
      }
    };
    let c = {};
    return o.type === "bar" && (c = qMe(n, o)), o.type === "line" && (c = YMe(n, o)), o.type === "area" && (c = KMe(n, o)), Eu(u, c, o.echartOptions);
  }), Eu(t, n.echartOptions);
}
function qMe(n, e) {
  const t = n.swapXY ? [0, 2, 2, 0] : [2, 2, 0, 0], r = n.series.findIndex((o) => o.name === e.name), a = n.series.slice().reverse().findIndex((o) => o.type === "bar") === r;
  return {
    stack: n.stacked ? "stack" : void 0,
    barMaxWidth: 60,
    itemStyle: {
      borderRadius: n.stacked ? a ? t : 0 : t
    }
  };
}
function YMe(n, e) {
  return {
    connectNulls: !0,
    symbol: "circle",
    symbolSize: 7,
    showSymbol: e.showDataPoints || e.showDataLabels,
    emphasis: {},
    lineStyle: {
      width: e.lineWidth || 2,
      type: e.lineType
    }
  };
}
function KMe(n, e) {
  return {
    type: "line",
    showSymbol: e.showDataPoints,
    areaStyle: {
      color: e.color,
      opacity: e.fillOpacity || 0.5
    }
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var PC = function(n, e) {
  return PC = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
  }, PC(n, e);
};
function le(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  PC(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var XMe = /* @__PURE__ */ function() {
  function n() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return n;
}(), ZMe = /* @__PURE__ */ function() {
  function n() {
    this.browser = new XMe(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return n;
}(), Vt = new ZMe();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (Vt.wxa = !0, Vt.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? Vt.worker = !0 : !Vt.hasGlobalWindow || "Deno" in window ? (Vt.node = !0, Vt.svgSupported = !0) : JMe(navigator.userAgent, Vt);
function JMe(n, e) {
  var t = e.browser, r = n.match(/Firefox\/([\d.]+)/), i = n.match(/MSIE\s([\d.]+)/) || n.match(/Trident\/.+?rv:(([\d.]+))/), a = n.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(n);
  r && (t.firefox = !0, t.version = r[1]), i && (t.ie = !0, t.version = i[1]), a && (t.edge = !0, t.version = a[1], t.newEdge = +a[1].split(".")[0] > 18), o && (t.weChat = !0), e.svgSupported = typeof SVGRect < "u", e.touchEventsSupported = "ontouchstart" in window && !t.ie && !t.edge, e.pointerEventsSupported = "onpointerdown" in window && (t.edge || t.ie && +t.version >= 11), e.domSupported = typeof document < "u";
  var s = document.documentElement.style;
  e.transform3dSupported = (t.ie && "transition" in s || t.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in s) && !("OTransition" in s), e.transformSupported = e.transform3dSupported || t.ie && +t.version >= 9;
}
var bD = 12, K9 = "sans-serif", Iu = bD + "px " + K9, QMe = 20, eDe = 100, tDe = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function nDe(n) {
  var e = {};
  if (typeof JSON > "u")
    return e;
  for (var t = 0; t < n.length; t++) {
    var r = String.fromCharCode(t + 32), i = (n.charCodeAt(t) - QMe) / eDe;
    e[r] = i;
  }
  return e;
}
var rDe = nDe(tDe), Lu = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ function() {
    var n, e;
    return function(t, r) {
      if (!n) {
        var i = Lu.createCanvas();
        n = i && i.getContext("2d");
      }
      if (n)
        return e !== r && (e = n.font = r || Iu), n.measureText(t);
      t = t || "", r = r || Iu;
      var a = /((?:\d+)?\.?\d*)px/.exec(r), o = a && +a[1] || bD, s = 0;
      if (r.indexOf("mono") >= 0)
        s = o * t.length;
      else
        for (var l = 0; l < t.length; l++) {
          var u = rDe[t[l]];
          s += u == null ? o : u * o;
        }
      return { width: s };
    };
  }(),
  loadImage: function(n, e, t) {
    var r = new Image();
    return r.onload = e, r.onerror = t, r.src = n, r;
  }
}, X9 = xs([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(n, e) {
  return n["[object " + e + "]"] = !0, n;
}, {}), Z9 = xs([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(n, e) {
  return n["[object " + e + "Array]"] = !0, n;
}, {}), oh = Object.prototype.toString, Hx = Array.prototype, iDe = Hx.forEach, aDe = Hx.filter, _D = Hx.slice, oDe = Hx.map, n3 = (function() {
}).constructor, e0 = n3 ? n3.prototype : null, xD = "__proto__", sDe = 2311;
function J9() {
  return sDe++;
}
function _o() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  typeof console < "u" && console.error.apply(console, n);
}
function ht(n) {
  if (n == null || typeof n != "object")
    return n;
  var e = n, t = oh.call(n);
  if (t === "[object Array]") {
    if (!am(n)) {
      e = [];
      for (var r = 0, i = n.length; r < i; r++)
        e[r] = ht(n[r]);
    }
  } else if (Z9[t]) {
    if (!am(n)) {
      var a = n.constructor;
      if (a.from)
        e = a.from(n);
      else {
        e = new a(n.length);
        for (var r = 0, i = n.length; r < i; r++)
          e[r] = n[r];
      }
    }
  } else if (!X9[t] && !am(n) && !Md(n)) {
    e = {};
    for (var o in n)
      n.hasOwnProperty(o) && o !== xD && (e[o] = ht(n[o]));
  }
  return e;
}
function At(n, e, t) {
  if (!ut(e) || !ut(n))
    return t ? ht(e) : n;
  for (var r in e)
    if (e.hasOwnProperty(r) && r !== xD) {
      var i = n[r], a = e[r];
      ut(a) && ut(i) && !Me(a) && !Me(i) && !Md(a) && !Md(i) && !r3(a) && !r3(i) && !am(a) && !am(i) ? At(i, a, t) : (t || !(r in n)) && (n[r] = ht(e[r]));
    }
  return n;
}
function wD(n, e) {
  for (var t = n[0], r = 1, i = n.length; r < i; r++)
    t = At(t, n[r], e);
  return t;
}
function xe(n, e) {
  if (Object.assign)
    Object.assign(n, e);
  else
    for (var t in e)
      e.hasOwnProperty(t) && t !== xD && (n[t] = e[t]);
  return n;
}
function dt(n, e, t) {
  for (var r = Yt(e), i = 0, a = r.length; i < a; i++) {
    var o = r[i];
    (t ? e[o] != null : n[o] == null) && (n[o] = e[o]);
  }
  return n;
}
function Pt(n, e) {
  if (n) {
    if (n.indexOf)
      return n.indexOf(e);
    for (var t = 0, r = n.length; t < r; t++)
      if (n[t] === e)
        return t;
  }
  return -1;
}
function lDe(n, e) {
  var t = n.prototype;
  function r() {
  }
  r.prototype = e.prototype, n.prototype = new r();
  for (var i in t)
    t.hasOwnProperty(i) && (n.prototype[i] = t[i]);
  n.prototype.constructor = n, n.superClass = e;
}
function _r(n, e, t) {
  if (n = "prototype" in n ? n.prototype : n, e = "prototype" in e ? e.prototype : e, Object.getOwnPropertyNames)
    for (var r = Object.getOwnPropertyNames(e), i = 0; i < r.length; i++) {
      var a = r[i];
      a !== "constructor" && (t ? e[a] != null : n[a] == null) && (n[a] = e[a]);
    }
  else
    dt(n, e, t);
}
function hi(n) {
  return !n || typeof n == "string" ? !1 : typeof n.length == "number";
}
function $(n, e, t) {
  if (n && e)
    if (n.forEach && n.forEach === iDe)
      n.forEach(e, t);
    else if (n.length === +n.length)
      for (var r = 0, i = n.length; r < i; r++)
        e.call(t, n[r], r, n);
    else
      for (var a in n)
        n.hasOwnProperty(a) && e.call(t, n[a], a, n);
}
function De(n, e, t) {
  if (!n)
    return [];
  if (!e)
    return SD(n);
  if (n.map && n.map === oDe)
    return n.map(e, t);
  for (var r = [], i = 0, a = n.length; i < a; i++)
    r.push(e.call(t, n[i], i, n));
  return r;
}
function xs(n, e, t, r) {
  if (n && e) {
    for (var i = 0, a = n.length; i < a; i++)
      t = e.call(r, t, n[i], i, n);
    return t;
  }
}
function vn(n, e, t) {
  if (!n)
    return [];
  if (!e)
    return SD(n);
  if (n.filter && n.filter === aDe)
    return n.filter(e, t);
  for (var r = [], i = 0, a = n.length; i < a; i++)
    e.call(t, n[i], i, n) && r.push(n[i]);
  return r;
}
function uDe(n, e, t) {
  if (n && e) {
    for (var r = 0, i = n.length; r < i; r++)
      if (e.call(t, n[r], r, n))
        return n[r];
  }
}
function Yt(n) {
  if (!n)
    return [];
  if (Object.keys)
    return Object.keys(n);
  var e = [];
  for (var t in n)
    n.hasOwnProperty(t) && e.push(t);
  return e;
}
function cDe(n, e) {
  for (var t = [], r = 2; r < arguments.length; r++)
    t[r - 2] = arguments[r];
  return function() {
    return n.apply(e, t.concat(_D.call(arguments)));
  };
}
var Ze = e0 && at(e0.bind) ? e0.call.bind(e0.bind) : cDe;
function Tt(n) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return function() {
    return n.apply(this, e.concat(_D.call(arguments)));
  };
}
function Me(n) {
  return Array.isArray ? Array.isArray(n) : oh.call(n) === "[object Array]";
}
function at(n) {
  return typeof n == "function";
}
function We(n) {
  return typeof n == "string";
}
function Hb(n) {
  return oh.call(n) === "[object String]";
}
function sn(n) {
  return typeof n == "number";
}
function ut(n) {
  var e = typeof n;
  return e === "function" || !!n && e === "object";
}
function r3(n) {
  return !!X9[oh.call(n)];
}
function Bi(n) {
  return !!Z9[oh.call(n)];
}
function Md(n) {
  return typeof n == "object" && typeof n.nodeType == "number" && typeof n.ownerDocument == "object";
}
function Gx(n) {
  return n.colorStops != null;
}
function dDe(n) {
  return n.image != null;
}
function Q9(n) {
  return oh.call(n) === "[object RegExp]";
}
function Dd(n) {
  return n !== n;
}
function mr() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  for (var t = 0, r = n.length; t < r; t++)
    if (n[t] != null)
      return n[t];
}
function bt(n, e) {
  return n ?? e;
}
function Za(n, e, t) {
  return n ?? e ?? t;
}
function SD(n) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return _D.apply(n, e);
}
function ED(n) {
  if (typeof n == "number")
    return [n, n, n, n];
  var e = n.length;
  return e === 2 ? [n[0], n[1], n[0], n[1]] : e === 3 ? [n[0], n[1], n[2], n[1]] : n;
}
function ct(n, e) {
  if (!n)
    throw new Error(e);
}
function yo(n) {
  return n == null ? null : typeof n.trim == "function" ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var eG = "__ec_primitive__";
function Gb(n) {
  n[eG] = !0;
}
function am(n) {
  return n[eG];
}
var fDe = function() {
  function n() {
    this.data = {};
  }
  return n.prototype.delete = function(e) {
    var t = this.has(e);
    return t && delete this.data[e], t;
  }, n.prototype.has = function(e) {
    return this.data.hasOwnProperty(e);
  }, n.prototype.get = function(e) {
    return this.data[e];
  }, n.prototype.set = function(e, t) {
    return this.data[e] = t, this;
  }, n.prototype.keys = function() {
    return Yt(this.data);
  }, n.prototype.forEach = function(e) {
    var t = this.data;
    for (var r in t)
      t.hasOwnProperty(r) && e(t[r], r);
  }, n;
}(), tG = typeof Map == "function";
function pDe() {
  return tG ? /* @__PURE__ */ new Map() : new fDe();
}
var hDe = function() {
  function n(e) {
    var t = Me(e);
    this.data = pDe();
    var r = this;
    e instanceof n ? e.each(i) : e && $(e, i);
    function i(a, o) {
      t ? r.set(a, o) : r.set(o, a);
    }
  }
  return n.prototype.hasKey = function(e) {
    return this.data.has(e);
  }, n.prototype.get = function(e) {
    return this.data.get(e);
  }, n.prototype.set = function(e, t) {
    return this.data.set(e, t), t;
  }, n.prototype.each = function(e, t) {
    this.data.forEach(function(r, i) {
      e.call(t, r, i);
    });
  }, n.prototype.keys = function() {
    var e = this.data.keys();
    return tG ? Array.from(e) : e;
  }, n.prototype.removeKey = function(e) {
    this.data.delete(e);
  }, n;
}();
function tt(n) {
  return new hDe(n);
}
function Km(n, e) {
  for (var t = new n.constructor(n.length + e.length), r = 0; r < n.length; r++)
    t[r] = n[r];
  for (var i = n.length, r = 0; r < e.length; r++)
    t[r + i] = e[r];
  return t;
}
function Ux(n, e) {
  var t;
  if (Object.create)
    t = Object.create(n);
  else {
    var r = function() {
    };
    r.prototype = n, t = new r();
  }
  return e && xe(t, e), t;
}
function nG(n) {
  var e = n.style;
  e.webkitUserSelect = "none", e.userSelect = "none", e.webkitTapHighlightColor = "rgba(0,0,0,0)", e["-webkit-touch-callout"] = "none";
}
function Je(n, e) {
  return n.hasOwnProperty(e);
}
function dr() {
}
var g1 = 180 / Math.PI;
function Xd(n, e) {
  return n == null && (n = 0), e == null && (e = 0), [n, e];
}
function Si(n, e) {
  return n[0] = e[0], n[1] = e[1], n;
}
function ul(n) {
  return [n[0], n[1]];
}
function vDe(n, e, t) {
  return n[0] = e, n[1] = t, n;
}
function i3(n, e, t) {
  return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n;
}
function jC(n, e, t, r) {
  return n[0] = e[0] + t[0] * r, n[1] = e[1] + t[1] * r, n;
}
function Hc(n, e, t) {
  return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n;
}
function BC(n) {
  return Math.sqrt(mDe(n));
}
function mDe(n) {
  return n[0] * n[0] + n[1] * n[1];
}
function y1(n, e, t) {
  return n[0] = e[0] * t, n[1] = e[1] * t, n;
}
function sh(n, e) {
  var t = BC(e);
  return t === 0 ? (n[0] = 0, n[1] = 0) : (n[0] = e[0] / t, n[1] = e[1] / t), n;
}
function $C(n, e) {
  return Math.sqrt((n[0] - e[0]) * (n[0] - e[0]) + (n[1] - e[1]) * (n[1] - e[1]));
}
var du = $C;
function gDe(n, e) {
  return (n[0] - e[0]) * (n[0] - e[0]) + (n[1] - e[1]) * (n[1] - e[1]);
}
var cd = gDe;
function b1(n, e, t, r) {
  return n[0] = e[0] + r * (t[0] - e[0]), n[1] = e[1] + r * (t[1] - e[1]), n;
}
function Zr(n, e, t) {
  var r = e[0], i = e[1];
  return n[0] = t[0] * r + t[2] * i + t[4], n[1] = t[1] * r + t[3] * i + t[5], n;
}
function fu(n, e, t) {
  return n[0] = Math.min(e[0], t[0]), n[1] = Math.min(e[1], t[1]), n;
}
function pu(n, e, t) {
  return n[0] = Math.max(e[0], t[0]), n[1] = Math.max(e[1], t[1]), n;
}
var bf = /* @__PURE__ */ function() {
  function n(e, t) {
    this.target = e, this.topTarget = t && t.topTarget;
  }
  return n;
}(), yDe = function() {
  function n(e) {
    this.handler = e, e.on("mousedown", this._dragStart, this), e.on("mousemove", this._drag, this), e.on("mouseup", this._dragEnd, this);
  }
  return n.prototype._dragStart = function(e) {
    for (var t = e.target; t && !t.draggable; )
      t = t.parent || t.__hostTarget;
    t && (this._draggingTarget = t, t.dragging = !0, this._x = e.offsetX, this._y = e.offsetY, this.handler.dispatchToElement(new bf(t, e), "dragstart", e.event));
  }, n.prototype._drag = function(e) {
    var t = this._draggingTarget;
    if (t) {
      var r = e.offsetX, i = e.offsetY, a = r - this._x, o = i - this._y;
      this._x = r, this._y = i, t.drift(a, o, e), this.handler.dispatchToElement(new bf(t, e), "drag", e.event);
      var s = this.handler.findHover(r, i, t).target, l = this._dropTarget;
      this._dropTarget = s, t !== s && (l && s !== l && this.handler.dispatchToElement(new bf(l, e), "dragleave", e.event), s && s !== l && this.handler.dispatchToElement(new bf(s, e), "dragenter", e.event));
    }
  }, n.prototype._dragEnd = function(e) {
    var t = this._draggingTarget;
    t && (t.dragging = !1), this.handler.dispatchToElement(new bf(t, e), "dragend", e.event), this._dropTarget && this.handler.dispatchToElement(new bf(this._dropTarget, e), "drop", e.event), this._draggingTarget = null, this._dropTarget = null;
  }, n;
}(), io = function() {
  function n(e) {
    e && (this._$eventProcessor = e);
  }
  return n.prototype.on = function(e, t, r, i) {
    this._$handlers || (this._$handlers = {});
    var a = this._$handlers;
    if (typeof t == "function" && (i = r, r = t, t = null), !r || !e)
      return this;
    var o = this._$eventProcessor;
    t != null && o && o.normalizeQuery && (t = o.normalizeQuery(t)), a[e] || (a[e] = []);
    for (var s = 0; s < a[e].length; s++)
      if (a[e][s].h === r)
        return this;
    var l = {
      h: r,
      query: t,
      ctx: i || this,
      callAtLast: r.zrEventfulCallAtLast
    }, u = a[e].length - 1, c = a[e][u];
    return c && c.callAtLast ? a[e].splice(u, 0, l) : a[e].push(l), this;
  }, n.prototype.isSilent = function(e) {
    var t = this._$handlers;
    return !t || !t[e] || !t[e].length;
  }, n.prototype.off = function(e, t) {
    var r = this._$handlers;
    if (!r)
      return this;
    if (!e)
      return this._$handlers = {}, this;
    if (t) {
      if (r[e]) {
        for (var i = [], a = 0, o = r[e].length; a < o; a++)
          r[e][a].h !== t && i.push(r[e][a]);
        r[e] = i;
      }
      r[e] && r[e].length === 0 && delete r[e];
    } else
      delete r[e];
    return this;
  }, n.prototype.trigger = function(e) {
    for (var t = [], r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[e], a = this._$eventProcessor;
    if (i)
      for (var o = t.length, s = i.length, l = 0; l < s; l++) {
        var u = i[l];
        if (!(a && a.filter && u.query != null && !a.filter(e, u.query)))
          switch (o) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, t[0]);
              break;
            case 2:
              u.h.call(u.ctx, t[0], t[1]);
              break;
            default:
              u.h.apply(u.ctx, t);
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(e), this;
  }, n.prototype.triggerWithContext = function(e) {
    for (var t = [], r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[e], a = this._$eventProcessor;
    if (i)
      for (var o = t.length, s = t[o - 1], l = i.length, u = 0; u < l; u++) {
        var c = i[u];
        if (!(a && a.filter && c.query != null && !a.filter(e, c.query)))
          switch (o) {
            case 0:
              c.h.call(s);
              break;
            case 1:
              c.h.call(s, t[0]);
              break;
            case 2:
              c.h.call(s, t[0], t[1]);
              break;
            default:
              c.h.apply(s, t.slice(1, o - 1));
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(e), this;
  }, n;
}(), bDe = Math.log(2);
function zC(n, e, t, r, i, a) {
  var o = r + "-" + i, s = n.length;
  if (a.hasOwnProperty(o))
    return a[o];
  if (e === 1) {
    var l = Math.round(Math.log((1 << s) - 1 & ~i) / bDe);
    return n[t][l];
  }
  for (var u = r | 1 << t, c = t + 1; r & 1 << c; )
    c++;
  for (var d = 0, f = 0, p = 0; f < s; f++) {
    var h = 1 << f;
    h & i || (d += (p % 2 ? -1 : 1) * n[t][f] * zC(n, e - 1, c, u, i | h, a), p++);
  }
  return a[o] = d, d;
}
function a3(n, e) {
  var t = [
    [n[0], n[1], 1, 0, 0, 0, -e[0] * n[0], -e[0] * n[1]],
    [0, 0, 0, n[0], n[1], 1, -e[1] * n[0], -e[1] * n[1]],
    [n[2], n[3], 1, 0, 0, 0, -e[2] * n[2], -e[2] * n[3]],
    [0, 0, 0, n[2], n[3], 1, -e[3] * n[2], -e[3] * n[3]],
    [n[4], n[5], 1, 0, 0, 0, -e[4] * n[4], -e[4] * n[5]],
    [0, 0, 0, n[4], n[5], 1, -e[5] * n[4], -e[5] * n[5]],
    [n[6], n[7], 1, 0, 0, 0, -e[6] * n[6], -e[6] * n[7]],
    [0, 0, 0, n[6], n[7], 1, -e[7] * n[6], -e[7] * n[7]]
  ], r = {}, i = zC(t, 8, 0, 0, 0, r);
  if (i !== 0) {
    for (var a = [], o = 0; o < 8; o++)
      for (var s = 0; s < 8; s++)
        a[s] == null && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * zC(t, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, r) / i * e[o];
    return function(l, u, c) {
      var d = u * a[6] + c * a[7] + 1;
      l[0] = (u * a[0] + c * a[1] + a[2]) / d, l[1] = (u * a[3] + c * a[4] + a[5]) / d;
    };
  }
}
var o3 = "___zrEVENTSAVED", GS = [];
function _De(n, e, t, r, i) {
  return FC(GS, e, r, i, !0) && FC(n, t, GS[0], GS[1]);
}
function FC(n, e, t, r, i) {
  if (e.getBoundingClientRect && Vt.domSupported && !rG(e)) {
    var a = e[o3] || (e[o3] = {}), o = xDe(e, a), s = wDe(o, a, i);
    if (s)
      return s(n, t, r), !0;
  }
  return !1;
}
function xDe(n, e) {
  var t = e.markers;
  if (t)
    return t;
  t = e.markers = [];
  for (var r = ["left", "right"], i = ["top", "bottom"], a = 0; a < 4; a++) {
    var o = document.createElement("div"), s = o.style, l = a % 2, u = (a >> 1) % 2;
    s.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      r[l] + ":0",
      i[u] + ":0",
      r[1 - l] + ":auto",
      i[1 - u] + ":auto",
      ""
    ].join("!important;"), n.appendChild(o), t.push(o);
  }
  return t;
}
function wDe(n, e, t) {
  for (var r = t ? "invTrans" : "trans", i = e[r], a = e.srcCoords, o = [], s = [], l = !0, u = 0; u < 4; u++) {
    var c = n[u].getBoundingClientRect(), d = 2 * u, f = c.left, p = c.top;
    o.push(f, p), l = l && a && f === a[d] && p === a[d + 1], s.push(n[u].offsetLeft, n[u].offsetTop);
  }
  return l && i ? i : (e.srcCoords = o, e[r] = t ? a3(s, o) : a3(o, s));
}
function rG(n) {
  return n.nodeName.toUpperCase() === "CANVAS";
}
var SDe = /([&<>"'])/g, EDe = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function Ai(n) {
  return n == null ? "" : (n + "").replace(SDe, function(e, t) {
    return EDe[t];
  });
}
var TDe = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, US = [], CDe = Vt.browser.firefox && +Vt.browser.version.split(".")[0] < 39;
function VC(n, e, t, r) {
  return t = t || {}, r ? s3(n, e, t) : CDe && e.layerX != null && e.layerX !== e.offsetX ? (t.zrX = e.layerX, t.zrY = e.layerY) : e.offsetX != null ? (t.zrX = e.offsetX, t.zrY = e.offsetY) : s3(n, e, t), t;
}
function s3(n, e, t) {
  if (Vt.domSupported && n.getBoundingClientRect) {
    var r = e.clientX, i = e.clientY;
    if (rG(n)) {
      var a = n.getBoundingClientRect();
      t.zrX = r - a.left, t.zrY = i - a.top;
      return;
    } else if (FC(US, n, r, i)) {
      t.zrX = US[0], t.zrY = US[1];
      return;
    }
  }
  t.zrX = t.zrY = 0;
}
function TD(n) {
  return n || window.event;
}
function Pa(n, e, t) {
  if (e = TD(e), e.zrX != null)
    return e;
  var r = e.type, i = r && r.indexOf("touch") >= 0;
  if (i) {
    var o = r !== "touchend" ? e.targetTouches[0] : e.changedTouches[0];
    o && VC(n, o, e, t);
  } else {
    VC(n, e, e, t);
    var a = kDe(e);
    e.zrDelta = a ? a / 120 : -(e.detail || 0) / 3;
  }
  var s = e.button;
  return e.which == null && s !== void 0 && TDe.test(e.type) && (e.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), e;
}
function kDe(n) {
  var e = n.wheelDelta;
  if (e)
    return e;
  var t = n.deltaX, r = n.deltaY;
  if (t == null || r == null)
    return e;
  var i = Math.abs(r !== 0 ? r : t), a = r > 0 ? -1 : r < 0 ? 1 : t > 0 ? -1 : 1;
  return 3 * i * a;
}
function HC(n, e, t, r) {
  n.addEventListener(e, t, r);
}
function ADe(n, e, t, r) {
  n.removeEventListener(e, t, r);
}
var bl = function(n) {
  n.preventDefault(), n.stopPropagation(), n.cancelBubble = !0;
};
function l3(n) {
  return n.which === 2 || n.which === 3;
}
var MDe = function() {
  function n() {
    this._track = [];
  }
  return n.prototype.recognize = function(e, t, r) {
    return this._doTrack(e, t, r), this._recognize(e);
  }, n.prototype.clear = function() {
    return this._track.length = 0, this;
  }, n.prototype._doTrack = function(e, t, r) {
    var i = e.touches;
    if (i) {
      for (var a = {
        points: [],
        touches: [],
        target: t,
        event: e
      }, o = 0, s = i.length; o < s; o++) {
        var l = i[o], u = VC(r, l, {});
        a.points.push([u.zrX, u.zrY]), a.touches.push(l);
      }
      this._track.push(a);
    }
  }, n.prototype._recognize = function(e) {
    for (var t in WS)
      if (WS.hasOwnProperty(t)) {
        var r = WS[t](this._track, e);
        if (r)
          return r;
      }
  }, n;
}();
function u3(n) {
  var e = n[1][0] - n[0][0], t = n[1][1] - n[0][1];
  return Math.sqrt(e * e + t * t);
}
function DDe(n) {
  return [
    (n[0][0] + n[1][0]) / 2,
    (n[0][1] + n[1][1]) / 2
  ];
}
var WS = {
  pinch: function(n, e) {
    var t = n.length;
    if (t) {
      var r = (n[t - 1] || {}).points, i = (n[t - 2] || {}).points || r;
      if (i && i.length > 1 && r && r.length > 1) {
        var a = u3(r) / u3(i);
        !isFinite(a) && (a = 1), e.pinchScale = a;
        var o = DDe(r);
        return e.pinchX = o[0], e.pinchY = o[1], {
          type: "pinch",
          target: n[0].target,
          event: e
        };
      }
    }
  }
};
function ya() {
  return [1, 0, 0, 1, 0, 0];
}
function Wx(n) {
  return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 1, n[4] = 0, n[5] = 0, n;
}
function CD(n, e) {
  return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4], n[5] = e[5], n;
}
function cl(n, e, t) {
  var r = e[0] * t[0] + e[2] * t[1], i = e[1] * t[0] + e[3] * t[1], a = e[0] * t[2] + e[2] * t[3], o = e[1] * t[2] + e[3] * t[3], s = e[0] * t[4] + e[2] * t[5] + e[4], l = e[1] * t[4] + e[3] * t[5] + e[5];
  return n[0] = r, n[1] = i, n[2] = a, n[3] = o, n[4] = s, n[5] = l, n;
}
function ws(n, e, t) {
  return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4] + t[0], n[5] = e[5] + t[1], n;
}
function Zd(n, e, t, r) {
  r === void 0 && (r = [0, 0]);
  var i = e[0], a = e[2], o = e[4], s = e[1], l = e[3], u = e[5], c = Math.sin(t), d = Math.cos(t);
  return n[0] = i * d + s * c, n[1] = -i * c + s * d, n[2] = a * d + l * c, n[3] = -a * c + d * l, n[4] = d * (o - r[0]) + c * (u - r[1]) + r[0], n[5] = d * (u - r[1]) - c * (o - r[0]) + r[1], n;
}
function kD(n, e, t) {
  var r = t[0], i = t[1];
  return n[0] = e[0] * r, n[1] = e[1] * i, n[2] = e[2] * r, n[3] = e[3] * i, n[4] = e[4] * r, n[5] = e[5] * i, n;
}
function lh(n, e) {
  var t = e[0], r = e[2], i = e[4], a = e[1], o = e[3], s = e[5], l = t * o - a * r;
  return l ? (l = 1 / l, n[0] = o * l, n[1] = -a * l, n[2] = -r * l, n[3] = t * l, n[4] = (r * s - o * i) * l, n[5] = (a * i - t * s) * l, n) : null;
}
function ODe(n) {
  var e = ya();
  return CD(e, n), e;
}
var Mt = function() {
  function n(e, t) {
    this.x = e || 0, this.y = t || 0;
  }
  return n.prototype.copy = function(e) {
    return this.x = e.x, this.y = e.y, this;
  }, n.prototype.clone = function() {
    return new n(this.x, this.y);
  }, n.prototype.set = function(e, t) {
    return this.x = e, this.y = t, this;
  }, n.prototype.equal = function(e) {
    return e.x === this.x && e.y === this.y;
  }, n.prototype.add = function(e) {
    return this.x += e.x, this.y += e.y, this;
  }, n.prototype.scale = function(e) {
    this.x *= e, this.y *= e;
  }, n.prototype.scaleAndAdd = function(e, t) {
    this.x += e.x * t, this.y += e.y * t;
  }, n.prototype.sub = function(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }, n.prototype.dot = function(e) {
    return this.x * e.x + this.y * e.y;
  }, n.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, n.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, n.prototype.normalize = function() {
    var e = this.len();
    return this.x /= e, this.y /= e, this;
  }, n.prototype.distance = function(e) {
    var t = this.x - e.x, r = this.y - e.y;
    return Math.sqrt(t * t + r * r);
  }, n.prototype.distanceSquare = function(e) {
    var t = this.x - e.x, r = this.y - e.y;
    return t * t + r * r;
  }, n.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, n.prototype.transform = function(e) {
    if (e) {
      var t = this.x, r = this.y;
      return this.x = e[0] * t + e[2] * r + e[4], this.y = e[1] * t + e[3] * r + e[5], this;
    }
  }, n.prototype.toArray = function(e) {
    return e[0] = this.x, e[1] = this.y, e;
  }, n.prototype.fromArray = function(e) {
    this.x = e[0], this.y = e[1];
  }, n.set = function(e, t, r) {
    e.x = t, e.y = r;
  }, n.copy = function(e, t) {
    e.x = t.x, e.y = t.y;
  }, n.len = function(e) {
    return Math.sqrt(e.x * e.x + e.y * e.y);
  }, n.lenSquare = function(e) {
    return e.x * e.x + e.y * e.y;
  }, n.dot = function(e, t) {
    return e.x * t.x + e.y * t.y;
  }, n.add = function(e, t, r) {
    e.x = t.x + r.x, e.y = t.y + r.y;
  }, n.sub = function(e, t, r) {
    e.x = t.x - r.x, e.y = t.y - r.y;
  }, n.scale = function(e, t, r) {
    e.x = t.x * r, e.y = t.y * r;
  }, n.scaleAndAdd = function(e, t, r, i) {
    e.x = t.x + r.x * i, e.y = t.y + r.y * i;
  }, n.lerp = function(e, t, r, i) {
    var a = 1 - i;
    e.x = a * t.x + i * r.x, e.y = a * t.y + i * r.y;
  }, n;
}(), t0 = Math.min, n0 = Math.max, Qu = new Mt(), ec = new Mt(), tc = new Mt(), nc = new Mt(), Wh = new Mt(), qh = new Mt(), Ot = function() {
  function n(e, t, r, i) {
    r < 0 && (e = e + r, r = -r), i < 0 && (t = t + i, i = -i), this.x = e, this.y = t, this.width = r, this.height = i;
  }
  return n.prototype.union = function(e) {
    var t = t0(e.x, this.x), r = t0(e.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = n0(e.x + e.width, this.x + this.width) - t : this.width = e.width, isFinite(this.y) && isFinite(this.height) ? this.height = n0(e.y + e.height, this.y + this.height) - r : this.height = e.height, this.x = t, this.y = r;
  }, n.prototype.applyTransform = function(e) {
    n.applyTransform(this, this, e);
  }, n.prototype.calculateTransform = function(e) {
    var t = this, r = e.width / t.width, i = e.height / t.height, a = ya();
    return ws(a, a, [-t.x, -t.y]), kD(a, a, [r, i]), ws(a, a, [e.x, e.y]), a;
  }, n.prototype.intersect = function(e, t) {
    if (!e)
      return !1;
    e instanceof n || (e = n.create(e));
    var r = this, i = r.x, a = r.x + r.width, o = r.y, s = r.y + r.height, l = e.x, u = e.x + e.width, c = e.y, d = e.y + e.height, f = !(a < l || u < i || s < c || d < o);
    if (t) {
      var p = 1 / 0, h = 0, v = Math.abs(a - l), m = Math.abs(u - i), g = Math.abs(s - c), y = Math.abs(d - o), b = Math.min(v, m), _ = Math.min(g, y);
      a < l || u < i ? b > h && (h = b, v < m ? Mt.set(qh, -v, 0) : Mt.set(qh, m, 0)) : b < p && (p = b, v < m ? Mt.set(Wh, v, 0) : Mt.set(Wh, -m, 0)), s < c || d < o ? _ > h && (h = _, g < y ? Mt.set(qh, 0, -g) : Mt.set(qh, 0, y)) : b < p && (p = b, g < y ? Mt.set(Wh, 0, g) : Mt.set(Wh, 0, -y));
    }
    return t && Mt.copy(t, f ? Wh : qh), f;
  }, n.prototype.contain = function(e, t) {
    var r = this;
    return e >= r.x && e <= r.x + r.width && t >= r.y && t <= r.y + r.height;
  }, n.prototype.clone = function() {
    return new n(this.x, this.y, this.width, this.height);
  }, n.prototype.copy = function(e) {
    n.copy(this, e);
  }, n.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, n.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, n.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, n.create = function(e) {
    return new n(e.x, e.y, e.width, e.height);
  }, n.copy = function(e, t) {
    e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height;
  }, n.applyTransform = function(e, t, r) {
    if (!r) {
      e !== t && n.copy(e, t);
      return;
    }
    if (r[1] < 1e-5 && r[1] > -1e-5 && r[2] < 1e-5 && r[2] > -1e-5) {
      var i = r[0], a = r[3], o = r[4], s = r[5];
      e.x = t.x * i + o, e.y = t.y * a + s, e.width = t.width * i, e.height = t.height * a, e.width < 0 && (e.x += e.width, e.width = -e.width), e.height < 0 && (e.y += e.height, e.height = -e.height);
      return;
    }
    Qu.x = tc.x = t.x, Qu.y = nc.y = t.y, ec.x = nc.x = t.x + t.width, ec.y = tc.y = t.y + t.height, Qu.transform(r), nc.transform(r), ec.transform(r), tc.transform(r), e.x = t0(Qu.x, ec.x, tc.x, nc.x), e.y = t0(Qu.y, ec.y, tc.y, nc.y);
    var l = n0(Qu.x, ec.x, tc.x, nc.x), u = n0(Qu.y, ec.y, tc.y, nc.y);
    e.width = l - e.x, e.height = u - e.y;
  }, n;
}(), iG = "silent";
function IDe(n, e, t) {
  return {
    type: n,
    event: t,
    target: e.target,
    topTarget: e.topTarget,
    cancelBubble: !1,
    offsetX: t.zrX,
    offsetY: t.zrY,
    gestureEvent: t.gestureEvent,
    pinchX: t.pinchX,
    pinchY: t.pinchY,
    pinchScale: t.pinchScale,
    wheelDelta: t.zrDelta,
    zrByTouch: t.zrByTouch,
    which: t.which,
    stop: LDe
  };
}
function LDe() {
  bl(this.event);
}
var NDe = function(n) {
  le(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.handler = null, t;
  }
  return e.prototype.dispose = function() {
  }, e.prototype.setCursor = function() {
  }, e;
}(io), Yh = /* @__PURE__ */ function() {
  function n(e, t) {
    this.x = e, this.y = t;
  }
  return n;
}(), RDe = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], qS = new Ot(0, 0, 0, 0), aG = function(n) {
  le(e, n);
  function e(t, r, i, a, o) {
    var s = n.call(this) || this;
    return s._hovered = new Yh(0, 0), s.storage = t, s.painter = r, s.painterRoot = a, s._pointerSize = o, i = i || new NDe(), s.proxy = null, s.setHandlerProxy(i), s._draggingMgr = new yDe(s), s;
  }
  return e.prototype.setHandlerProxy = function(t) {
    this.proxy && this.proxy.dispose(), t && ($(RDe, function(r) {
      t.on && t.on(r, this[r], this);
    }, this), t.handler = this), this.proxy = t;
  }, e.prototype.mousemove = function(t) {
    var r = t.zrX, i = t.zrY, a = oG(this, r, i), o = this._hovered, s = o.target;
    s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target);
    var l = this._hovered = a ? new Yh(r, i) : this.findHover(r, i), u = l.target, c = this.proxy;
    c.setCursor && c.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(o, "mouseout", t), this.dispatchToElement(l, "mousemove", t), u && u !== s && this.dispatchToElement(l, "mouseover", t);
  }, e.prototype.mouseout = function(t) {
    var r = t.zrEventControl;
    r !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", t), r !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: t });
  }, e.prototype.resize = function() {
    this._hovered = new Yh(0, 0);
  }, e.prototype.dispatch = function(t, r) {
    var i = this[t];
    i && i.call(this, r);
  }, e.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, e.prototype.setCursorStyle = function(t) {
    var r = this.proxy;
    r.setCursor && r.setCursor(t);
  }, e.prototype.dispatchToElement = function(t, r, i) {
    t = t || {};
    var a = t.target;
    if (!(a && a.silent)) {
      for (var o = "on" + r, s = IDe(r, t, i); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(r, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble); )
        ;
      s.cancelBubble || (this.trigger(r, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[o] == "function" && l[o].call(l, s), l.trigger && l.trigger(r, s);
      }));
    }
  }, e.prototype.findHover = function(t, r, i) {
    var a = this.storage.getDisplayList(), o = new Yh(t, r);
    if (c3(a, o, t, r, i), this._pointerSize && !o.target) {
      for (var s = [], l = this._pointerSize, u = l / 2, c = new Ot(t - u, r - u, l, l), d = a.length - 1; d >= 0; d--) {
        var f = a[d];
        f !== i && !f.ignore && !f.ignoreCoarsePointer && (!f.parent || !f.parent.ignoreCoarsePointer) && (qS.copy(f.getBoundingRect()), f.transform && qS.applyTransform(f.transform), qS.intersect(c) && s.push(f));
      }
      if (s.length)
        for (var p = 4, h = Math.PI / 12, v = Math.PI * 2, m = 0; m < u; m += p)
          for (var g = 0; g < v; g += h) {
            var y = t + m * Math.cos(g), b = r + m * Math.sin(g);
            if (c3(s, o, y, b, i), o.target)
              return o;
          }
    }
    return o;
  }, e.prototype.processGesture = function(t, r) {
    this._gestureMgr || (this._gestureMgr = new MDe());
    var i = this._gestureMgr;
    r === "start" && i.clear();
    var a = i.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom);
    if (r === "end" && i.clear(), a) {
      var o = a.type;
      t.gestureEvent = o;
      var s = new Yh();
      s.target = a.target, this.dispatchToElement(s, o, a.event);
    }
  }, e;
}(io);
$(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(n) {
  aG.prototype[n] = function(e) {
    var t = e.zrX, r = e.zrY, i = oG(this, t, r), a, o;
    if ((n !== "mouseup" || !i) && (a = this.findHover(t, r), o = a.target), n === "mousedown")
      this._downEl = o, this._downPoint = [e.zrX, e.zrY], this._upEl = o;
    else if (n === "mouseup")
      this._upEl = o;
    else if (n === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || du(this._downPoint, [e.zrX, e.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(a, n, e);
  };
});
function PDe(n, e, t) {
  if (n[n.rectHover ? "rectContain" : "contain"](e, t)) {
    for (var r = n, i = void 0, a = !1; r; ) {
      if (r.ignoreClip && (a = !0), !a) {
        var o = r.getClipPath();
        if (o && !o.contain(e, t))
          return !1;
      }
      r.silent && (i = !0);
      var s = r.__hostTarget;
      r = s || r.parent;
    }
    return i ? iG : !0;
  }
  return !1;
}
function c3(n, e, t, r, i) {
  for (var a = n.length - 1; a >= 0; a--) {
    var o = n[a], s = void 0;
    if (o !== i && !o.ignore && (s = PDe(o, t, r)) && (!e.topTarget && (e.topTarget = o), s !== iG)) {
      e.target = o;
      break;
    }
  }
}
function oG(n, e, t) {
  var r = n.painter;
  return e < 0 || e > r.getWidth() || t < 0 || t > r.getHeight();
}
var sG = 32, Kh = 7;
function jDe(n) {
  for (var e = 0; n >= sG; )
    e |= n & 1, n >>= 1;
  return n + e;
}
function d3(n, e, t, r) {
  var i = e + 1;
  if (i === t)
    return 1;
  if (r(n[i++], n[e]) < 0) {
    for (; i < t && r(n[i], n[i - 1]) < 0; )
      i++;
    BDe(n, e, i);
  } else
    for (; i < t && r(n[i], n[i - 1]) >= 0; )
      i++;
  return i - e;
}
function BDe(n, e, t) {
  for (t--; e < t; ) {
    var r = n[e];
    n[e++] = n[t], n[t--] = r;
  }
}
function f3(n, e, t, r, i) {
  for (r === e && r++; r < t; r++) {
    for (var a = n[r], o = e, s = r, l; o < s; )
      l = o + s >>> 1, i(a, n[l]) < 0 ? s = l : o = l + 1;
    var u = r - o;
    switch (u) {
      case 3:
        n[o + 3] = n[o + 2];
      case 2:
        n[o + 2] = n[o + 1];
      case 1:
        n[o + 1] = n[o];
        break;
      default:
        for (; u > 0; )
          n[o + u] = n[o + u - 1], u--;
    }
    n[o] = a;
  }
}
function YS(n, e, t, r, i, a) {
  var o = 0, s = 0, l = 1;
  if (a(n, e[t + i]) > 0) {
    for (s = r - i; l < s && a(n, e[t + i + l]) > 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += i, l += i;
  } else {
    for (s = i + 1; l < s && a(n, e[t + i - l]) <= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = i - l, l = i - u;
  }
  for (o++; o < l; ) {
    var c = o + (l - o >>> 1);
    a(n, e[t + c]) > 0 ? o = c + 1 : l = c;
  }
  return l;
}
function KS(n, e, t, r, i, a) {
  var o = 0, s = 0, l = 1;
  if (a(n, e[t + i]) < 0) {
    for (s = i + 1; l < s && a(n, e[t + i - l]) < 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = i - l, l = i - u;
  } else {
    for (s = r - i; l < s && a(n, e[t + i + l]) >= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += i, l += i;
  }
  for (o++; o < l; ) {
    var c = o + (l - o >>> 1);
    a(n, e[t + c]) < 0 ? l = c : o = c + 1;
  }
  return l;
}
function $De(n, e) {
  var t = Kh, r, i, a = 0, o = [];
  r = [], i = [];
  function s(p, h) {
    r[a] = p, i[a] = h, a += 1;
  }
  function l() {
    for (; a > 1; ) {
      var p = a - 2;
      if (p >= 1 && i[p - 1] <= i[p] + i[p + 1] || p >= 2 && i[p - 2] <= i[p] + i[p - 1])
        i[p - 1] < i[p + 1] && p--;
      else if (i[p] > i[p + 1])
        break;
      c(p);
    }
  }
  function u() {
    for (; a > 1; ) {
      var p = a - 2;
      p > 0 && i[p - 1] < i[p + 1] && p--, c(p);
    }
  }
  function c(p) {
    var h = r[p], v = i[p], m = r[p + 1], g = i[p + 1];
    i[p] = v + g, p === a - 3 && (r[p + 1] = r[p + 2], i[p + 1] = i[p + 2]), a--;
    var y = KS(n[m], n, h, v, 0, e);
    h += y, v -= y, v !== 0 && (g = YS(n[h + v - 1], n, m, g, g - 1, e), g !== 0 && (v <= g ? d(h, v, m, g) : f(h, v, m, g)));
  }
  function d(p, h, v, m) {
    var g = 0;
    for (g = 0; g < h; g++)
      o[g] = n[p + g];
    var y = 0, b = v, _ = p;
    if (n[_++] = n[b++], --m === 0) {
      for (g = 0; g < h; g++)
        n[_ + g] = o[y + g];
      return;
    }
    if (h === 1) {
      for (g = 0; g < m; g++)
        n[_ + g] = n[b + g];
      n[_ + m] = o[y];
      return;
    }
    for (var x = t, w, S, C; ; ) {
      w = 0, S = 0, C = !1;
      do
        if (e(n[b], o[y]) < 0) {
          if (n[_++] = n[b++], S++, w = 0, --m === 0) {
            C = !0;
            break;
          }
        } else if (n[_++] = o[y++], w++, S = 0, --h === 1) {
          C = !0;
          break;
        }
      while ((w | S) < x);
      if (C)
        break;
      do {
        if (w = KS(n[b], o, y, h, 0, e), w !== 0) {
          for (g = 0; g < w; g++)
            n[_ + g] = o[y + g];
          if (_ += w, y += w, h -= w, h <= 1) {
            C = !0;
            break;
          }
        }
        if (n[_++] = n[b++], --m === 0) {
          C = !0;
          break;
        }
        if (S = YS(o[y], n, b, m, 0, e), S !== 0) {
          for (g = 0; g < S; g++)
            n[_ + g] = n[b + g];
          if (_ += S, b += S, m -= S, m === 0) {
            C = !0;
            break;
          }
        }
        if (n[_++] = o[y++], --h === 1) {
          C = !0;
          break;
        }
        x--;
      } while (w >= Kh || S >= Kh);
      if (C)
        break;
      x < 0 && (x = 0), x += 2;
    }
    if (t = x, t < 1 && (t = 1), h === 1) {
      for (g = 0; g < m; g++)
        n[_ + g] = n[b + g];
      n[_ + m] = o[y];
    } else {
      if (h === 0)
        throw new Error();
      for (g = 0; g < h; g++)
        n[_ + g] = o[y + g];
    }
  }
  function f(p, h, v, m) {
    var g = 0;
    for (g = 0; g < m; g++)
      o[g] = n[v + g];
    var y = p + h - 1, b = m - 1, _ = v + m - 1, x = 0, w = 0;
    if (n[_--] = n[y--], --h === 0) {
      for (x = _ - (m - 1), g = 0; g < m; g++)
        n[x + g] = o[g];
      return;
    }
    if (m === 1) {
      for (_ -= h, y -= h, w = _ + 1, x = y + 1, g = h - 1; g >= 0; g--)
        n[w + g] = n[x + g];
      n[_] = o[b];
      return;
    }
    for (var S = t; ; ) {
      var C = 0, k = 0, M = !1;
      do
        if (e(o[b], n[y]) < 0) {
          if (n[_--] = n[y--], C++, k = 0, --h === 0) {
            M = !0;
            break;
          }
        } else if (n[_--] = o[b--], k++, C = 0, --m === 1) {
          M = !0;
          break;
        }
      while ((C | k) < S);
      if (M)
        break;
      do {
        if (C = h - KS(o[b], n, p, h, h - 1, e), C !== 0) {
          for (_ -= C, y -= C, h -= C, w = _ + 1, x = y + 1, g = C - 1; g >= 0; g--)
            n[w + g] = n[x + g];
          if (h === 0) {
            M = !0;
            break;
          }
        }
        if (n[_--] = o[b--], --m === 1) {
          M = !0;
          break;
        }
        if (k = m - YS(n[y], o, 0, m, m - 1, e), k !== 0) {
          for (_ -= k, b -= k, m -= k, w = _ + 1, x = b + 1, g = 0; g < k; g++)
            n[w + g] = o[x + g];
          if (m <= 1) {
            M = !0;
            break;
          }
        }
        if (n[_--] = n[y--], --h === 0) {
          M = !0;
          break;
        }
        S--;
      } while (C >= Kh || k >= Kh);
      if (M)
        break;
      S < 0 && (S = 0), S += 2;
    }
    if (t = S, t < 1 && (t = 1), m === 1) {
      for (_ -= h, y -= h, w = _ + 1, x = y + 1, g = h - 1; g >= 0; g--)
        n[w + g] = n[x + g];
      n[_] = o[b];
    } else {
      if (m === 0)
        throw new Error();
      for (x = _ - (m - 1), g = 0; g < m; g++)
        n[x + g] = o[g];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: s
  };
}
function _1(n, e, t, r) {
  t || (t = 0), r || (r = n.length);
  var i = r - t;
  if (!(i < 2)) {
    var a = 0;
    if (i < sG) {
      a = d3(n, t, r, e), f3(n, t, r, t + a, e);
      return;
    }
    var o = $De(n, e), s = jDe(i);
    do {
      if (a = d3(n, t, r, e), a < s) {
        var l = i;
        l > s && (l = s), f3(n, t, t + l, t + a, e), a = l;
      }
      o.pushRun(t, a), o.mergeRuns(), i -= a, t += a;
    } while (i !== 0);
    o.forceMergeRuns();
  }
}
var pa = 1, Cv = 2, Jf = 4, p3 = !1;
function XS() {
  p3 || (p3 = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function h3(n, e) {
  return n.zlevel === e.zlevel ? n.z === e.z ? n.z2 - e.z2 : n.z - e.z : n.zlevel - e.zlevel;
}
var zDe = function() {
  function n() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = h3;
  }
  return n.prototype.traverse = function(e, t) {
    for (var r = 0; r < this._roots.length; r++)
      this._roots[r].traverse(e, t);
  }, n.prototype.getDisplayList = function(e, t) {
    t = t || !1;
    var r = this._displayList;
    return (e || !r.length) && this.updateDisplayList(t), r;
  }, n.prototype.updateDisplayList = function(e) {
    this._displayListLen = 0;
    for (var t = this._roots, r = this._displayList, i = 0, a = t.length; i < a; i++)
      this._updateAndAddDisplayable(t[i], null, e);
    r.length = this._displayListLen, _1(r, h3);
  }, n.prototype._updateAndAddDisplayable = function(e, t, r) {
    if (!(e.ignore && !r)) {
      e.beforeUpdate(), e.update(), e.afterUpdate();
      var i = e.getClipPath();
      if (e.ignoreClip)
        t = null;
      else if (i) {
        t ? t = t.slice() : t = [];
        for (var a = i, o = e; a; )
          a.parent = o, a.updateTransform(), t.push(a), o = a, a = a.getClipPath();
      }
      if (e.childrenRef) {
        for (var s = e.childrenRef(), l = 0; l < s.length; l++) {
          var u = s[l];
          e.__dirty && (u.__dirty |= pa), this._updateAndAddDisplayable(u, t, r);
        }
        e.__dirty = 0;
      } else {
        var c = e;
        t && t.length ? c.__clipPaths = t : c.__clipPaths && c.__clipPaths.length > 0 && (c.__clipPaths = []), isNaN(c.z) && (XS(), c.z = 0), isNaN(c.z2) && (XS(), c.z2 = 0), isNaN(c.zlevel) && (XS(), c.zlevel = 0), this._displayList[this._displayListLen++] = c;
      }
      var d = e.getDecalElement && e.getDecalElement();
      d && this._updateAndAddDisplayable(d, t, r);
      var f = e.getTextGuideLine();
      f && this._updateAndAddDisplayable(f, t, r);
      var p = e.getTextContent();
      p && this._updateAndAddDisplayable(p, t, r);
    }
  }, n.prototype.addRoot = function(e) {
    e.__zr && e.__zr.storage === this || this._roots.push(e);
  }, n.prototype.delRoot = function(e) {
    if (e instanceof Array) {
      for (var t = 0, r = e.length; t < r; t++)
        this.delRoot(e[t]);
      return;
    }
    var i = Pt(this._roots, e);
    i >= 0 && this._roots.splice(i, 1);
  }, n.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, n.prototype.getRoots = function() {
    return this._roots;
  }, n.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, n;
}(), Ub;
Ub = Vt.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(n) {
  return setTimeout(n, 16);
};
var om = {
  linear: function(n) {
    return n;
  },
  quadraticIn: function(n) {
    return n * n;
  },
  quadraticOut: function(n) {
    return n * (2 - n);
  },
  quadraticInOut: function(n) {
    return (n *= 2) < 1 ? 0.5 * n * n : -0.5 * (--n * (n - 2) - 1);
  },
  cubicIn: function(n) {
    return n * n * n;
  },
  cubicOut: function(n) {
    return --n * n * n + 1;
  },
  cubicInOut: function(n) {
    return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2);
  },
  quarticIn: function(n) {
    return n * n * n * n;
  },
  quarticOut: function(n) {
    return 1 - --n * n * n * n;
  },
  quarticInOut: function(n) {
    return (n *= 2) < 1 ? 0.5 * n * n * n * n : -0.5 * ((n -= 2) * n * n * n - 2);
  },
  quinticIn: function(n) {
    return n * n * n * n * n;
  },
  quinticOut: function(n) {
    return --n * n * n * n * n + 1;
  },
  quinticInOut: function(n) {
    return (n *= 2) < 1 ? 0.5 * n * n * n * n * n : 0.5 * ((n -= 2) * n * n * n * n + 2);
  },
  sinusoidalIn: function(n) {
    return 1 - Math.cos(n * Math.PI / 2);
  },
  sinusoidalOut: function(n) {
    return Math.sin(n * Math.PI / 2);
  },
  sinusoidalInOut: function(n) {
    return 0.5 * (1 - Math.cos(Math.PI * n));
  },
  exponentialIn: function(n) {
    return n === 0 ? 0 : Math.pow(1024, n - 1);
  },
  exponentialOut: function(n) {
    return n === 1 ? 1 : 1 - Math.pow(2, -10 * n);
  },
  exponentialInOut: function(n) {
    return n === 0 ? 0 : n === 1 ? 1 : (n *= 2) < 1 ? 0.5 * Math.pow(1024, n - 1) : 0.5 * (-Math.pow(2, -10 * (n - 1)) + 2);
  },
  circularIn: function(n) {
    return 1 - Math.sqrt(1 - n * n);
  },
  circularOut: function(n) {
    return Math.sqrt(1 - --n * n);
  },
  circularInOut: function(n) {
    return (n *= 2) < 1 ? -0.5 * (Math.sqrt(1 - n * n) - 1) : 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);
  },
  elasticIn: function(n) {
    var e, t = 0.1, r = 0.4;
    return n === 0 ? 0 : n === 1 ? 1 : (!t || t < 1 ? (t = 1, e = r / 4) : e = r * Math.asin(1 / t) / (2 * Math.PI), -(t * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - e) * (2 * Math.PI) / r)));
  },
  elasticOut: function(n) {
    var e, t = 0.1, r = 0.4;
    return n === 0 ? 0 : n === 1 ? 1 : (!t || t < 1 ? (t = 1, e = r / 4) : e = r * Math.asin(1 / t) / (2 * Math.PI), t * Math.pow(2, -10 * n) * Math.sin((n - e) * (2 * Math.PI) / r) + 1);
  },
  elasticInOut: function(n) {
    var e, t = 0.1, r = 0.4;
    return n === 0 ? 0 : n === 1 ? 1 : (!t || t < 1 ? (t = 1, e = r / 4) : e = r * Math.asin(1 / t) / (2 * Math.PI), (n *= 2) < 1 ? -0.5 * (t * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - e) * (2 * Math.PI) / r)) : t * Math.pow(2, -10 * (n -= 1)) * Math.sin((n - e) * (2 * Math.PI) / r) * 0.5 + 1);
  },
  backIn: function(n) {
    var e = 1.70158;
    return n * n * ((e + 1) * n - e);
  },
  backOut: function(n) {
    var e = 1.70158;
    return --n * n * ((e + 1) * n + e) + 1;
  },
  backInOut: function(n) {
    var e = 2.5949095;
    return (n *= 2) < 1 ? 0.5 * (n * n * ((e + 1) * n - e)) : 0.5 * ((n -= 2) * n * ((e + 1) * n + e) + 2);
  },
  bounceIn: function(n) {
    return 1 - om.bounceOut(1 - n);
  },
  bounceOut: function(n) {
    return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
  },
  bounceInOut: function(n) {
    return n < 0.5 ? om.bounceIn(n * 2) * 0.5 : om.bounceOut(n * 2 - 1) * 0.5 + 0.5;
  }
}, r0 = Math.pow, Tu = Math.sqrt, Wb = 1e-8, lG = 1e-4, v3 = Tu(3), i0 = 1 / 3, es = Xd(), Va = Xd(), yp = Xd();
function hu(n) {
  return n > -Wb && n < Wb;
}
function uG(n) {
  return n > Wb || n < -Wb;
}
function Ar(n, e, t, r, i) {
  var a = 1 - i;
  return a * a * (a * n + 3 * i * e) + i * i * (i * r + 3 * a * t);
}
function m3(n, e, t, r, i) {
  var a = 1 - i;
  return 3 * (((e - n) * a + 2 * (t - e) * i) * a + (r - t) * i * i);
}
function qb(n, e, t, r, i, a) {
  var o = r + 3 * (e - t) - n, s = 3 * (t - e * 2 + n), l = 3 * (e - n), u = n - i, c = s * s - 3 * o * l, d = s * l - 9 * o * u, f = l * l - 3 * s * u, p = 0;
  if (hu(c) && hu(d))
    if (hu(s))
      a[0] = 0;
    else {
      var h = -l / s;
      h >= 0 && h <= 1 && (a[p++] = h);
    }
  else {
    var v = d * d - 4 * c * f;
    if (hu(v)) {
      var m = d / c, h = -s / o + m, g = -m / 2;
      h >= 0 && h <= 1 && (a[p++] = h), g >= 0 && g <= 1 && (a[p++] = g);
    } else if (v > 0) {
      var y = Tu(v), b = c * s + 1.5 * o * (-d + y), _ = c * s + 1.5 * o * (-d - y);
      b < 0 ? b = -r0(-b, i0) : b = r0(b, i0), _ < 0 ? _ = -r0(-_, i0) : _ = r0(_, i0);
      var h = (-s - (b + _)) / (3 * o);
      h >= 0 && h <= 1 && (a[p++] = h);
    } else {
      var x = (2 * c * s - 3 * o * d) / (2 * Tu(c * c * c)), w = Math.acos(x) / 3, S = Tu(c), C = Math.cos(w), h = (-s - 2 * S * C) / (3 * o), g = (-s + S * (C + v3 * Math.sin(w))) / (3 * o), k = (-s + S * (C - v3 * Math.sin(w))) / (3 * o);
      h >= 0 && h <= 1 && (a[p++] = h), g >= 0 && g <= 1 && (a[p++] = g), k >= 0 && k <= 1 && (a[p++] = k);
    }
  }
  return p;
}
function cG(n, e, t, r, i) {
  var a = 6 * t - 12 * e + 6 * n, o = 9 * e + 3 * r - 3 * n - 9 * t, s = 3 * e - 3 * n, l = 0;
  if (hu(o)) {
    if (uG(a)) {
      var u = -s / a;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var c = a * a - 4 * o * s;
    if (hu(c))
      i[0] = -a / (2 * o);
    else if (c > 0) {
      var d = Tu(c), u = (-a + d) / (2 * o), f = (-a - d) / (2 * o);
      u >= 0 && u <= 1 && (i[l++] = u), f >= 0 && f <= 1 && (i[l++] = f);
    }
  }
  return l;
}
function Nu(n, e, t, r, i, a) {
  var o = (e - n) * i + n, s = (t - e) * i + e, l = (r - t) * i + t, u = (s - o) * i + o, c = (l - s) * i + s, d = (c - u) * i + u;
  a[0] = n, a[1] = o, a[2] = u, a[3] = d, a[4] = d, a[5] = c, a[6] = l, a[7] = r;
}
function dG(n, e, t, r, i, a, o, s, l, u, c) {
  var d, f = 5e-3, p = 1 / 0, h, v, m, g;
  es[0] = l, es[1] = u;
  for (var y = 0; y < 1; y += 0.05)
    Va[0] = Ar(n, t, i, o, y), Va[1] = Ar(e, r, a, s, y), m = cd(es, Va), m < p && (d = y, p = m);
  p = 1 / 0;
  for (var b = 0; b < 32 && !(f < lG); b++)
    h = d - f, v = d + f, Va[0] = Ar(n, t, i, o, h), Va[1] = Ar(e, r, a, s, h), m = cd(Va, es), h >= 0 && m < p ? (d = h, p = m) : (yp[0] = Ar(n, t, i, o, v), yp[1] = Ar(e, r, a, s, v), g = cd(yp, es), v <= 1 && g < p ? (d = v, p = g) : f *= 0.5);
  return c && (c[0] = Ar(n, t, i, o, d), c[1] = Ar(e, r, a, s, d)), Tu(p);
}
function FDe(n, e, t, r, i, a, o, s, l) {
  for (var u = n, c = e, d = 0, f = 1 / l, p = 1; p <= l; p++) {
    var h = p * f, v = Ar(n, t, i, o, h), m = Ar(e, r, a, s, h), g = v - u, y = m - c;
    d += Math.sqrt(g * g + y * y), u = v, c = m;
  }
  return d;
}
function Br(n, e, t, r) {
  var i = 1 - r;
  return i * (i * n + 2 * r * e) + r * r * t;
}
function GC(n, e, t, r) {
  return 2 * ((1 - r) * (e - n) + r * (t - e));
}
function VDe(n, e, t, r, i) {
  var a = n - 2 * e + t, o = 2 * (e - n), s = n - r, l = 0;
  if (hu(a)) {
    if (uG(o)) {
      var u = -s / o;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var c = o * o - 4 * a * s;
    if (hu(c)) {
      var u = -o / (2 * a);
      u >= 0 && u <= 1 && (i[l++] = u);
    } else if (c > 0) {
      var d = Tu(c), u = (-o + d) / (2 * a), f = (-o - d) / (2 * a);
      u >= 0 && u <= 1 && (i[l++] = u), f >= 0 && f <= 1 && (i[l++] = f);
    }
  }
  return l;
}
function fG(n, e, t) {
  var r = n + t - 2 * e;
  return r === 0 ? 0.5 : (n - e) / r;
}
function Xm(n, e, t, r, i) {
  var a = (e - n) * r + n, o = (t - e) * r + e, s = (o - a) * r + a;
  i[0] = n, i[1] = a, i[2] = s, i[3] = s, i[4] = o, i[5] = t;
}
function pG(n, e, t, r, i, a, o, s, l) {
  var u, c = 5e-3, d = 1 / 0;
  es[0] = o, es[1] = s;
  for (var f = 0; f < 1; f += 0.05) {
    Va[0] = Br(n, t, i, f), Va[1] = Br(e, r, a, f);
    var p = cd(es, Va);
    p < d && (u = f, d = p);
  }
  d = 1 / 0;
  for (var h = 0; h < 32 && !(c < lG); h++) {
    var v = u - c, m = u + c;
    Va[0] = Br(n, t, i, v), Va[1] = Br(e, r, a, v);
    var p = cd(Va, es);
    if (v >= 0 && p < d)
      u = v, d = p;
    else {
      yp[0] = Br(n, t, i, m), yp[1] = Br(e, r, a, m);
      var g = cd(yp, es);
      m <= 1 && g < d ? (u = m, d = g) : c *= 0.5;
    }
  }
  return l && (l[0] = Br(n, t, i, u), l[1] = Br(e, r, a, u)), Tu(d);
}
function HDe(n, e, t, r, i, a, o) {
  for (var s = n, l = e, u = 0, c = 1 / o, d = 1; d <= o; d++) {
    var f = d * c, p = Br(n, t, i, f), h = Br(e, r, a, f), v = p - s, m = h - l;
    u += Math.sqrt(v * v + m * m), s = p, l = h;
  }
  return u;
}
var GDe = /cubic-bezier\(([0-9,\.e ]+)\)/;
function AD(n) {
  var e = n && GDe.exec(n);
  if (e) {
    var t = e[1].split(","), r = +yo(t[0]), i = +yo(t[1]), a = +yo(t[2]), o = +yo(t[3]);
    if (isNaN(r + i + a + o))
      return;
    var s = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : qb(0, r, a, 1, l, s) && Ar(0, i, o, 1, s[0]);
    };
  }
}
var UDe = function() {
  function n(e) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = e.life || 1e3, this._delay = e.delay || 0, this.loop = e.loop || !1, this.onframe = e.onframe || dr, this.ondestroy = e.ondestroy || dr, this.onrestart = e.onrestart || dr, e.easing && this.setEasing(e.easing);
  }
  return n.prototype.step = function(e, t) {
    if (this._inited || (this._startTime = e + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += t;
      return;
    }
    var r = this._life, i = e - this._startTime - this._pausedTime, a = i / r;
    a < 0 && (a = 0), a = Math.min(a, 1);
    var o = this.easingFunc, s = o ? o(a) : a;
    if (this.onframe(s), a === 1)
      if (this.loop) {
        var l = i % r;
        this._startTime = e - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, n.prototype.pause = function() {
    this._paused = !0;
  }, n.prototype.resume = function() {
    this._paused = !1;
  }, n.prototype.setEasing = function(e) {
    this.easing = e, this.easingFunc = at(e) ? e : om[e] || AD(e);
  }, n;
}(), hG = /* @__PURE__ */ function() {
  function n(e) {
    this.value = e;
  }
  return n;
}(), WDe = function() {
  function n() {
    this._len = 0;
  }
  return n.prototype.insert = function(e) {
    var t = new hG(e);
    return this.insertEntry(t), t;
  }, n.prototype.insertEntry = function(e) {
    this.head ? (this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e) : this.head = this.tail = e, this._len++;
  }, n.prototype.remove = function(e) {
    var t = e.prev, r = e.next;
    t ? t.next = r : this.head = r, r ? r.prev = t : this.tail = t, e.next = e.prev = null, this._len--;
  }, n.prototype.len = function() {
    return this._len;
  }, n.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, n;
}(), $g = function() {
  function n(e) {
    this._list = new WDe(), this._maxSize = 10, this._map = {}, this._maxSize = e;
  }
  return n.prototype.put = function(e, t) {
    var r = this._list, i = this._map, a = null;
    if (i[e] == null) {
      var o = r.len(), s = this._lastRemovedEntry;
      if (o >= this._maxSize && o > 0) {
        var l = r.head;
        r.remove(l), delete i[l.key], a = l.value, this._lastRemovedEntry = l;
      }
      s ? s.value = t : s = new hG(t), s.key = e, r.insertEntry(s), i[e] = s;
    }
    return a;
  }, n.prototype.get = function(e) {
    var t = this._map[e], r = this._list;
    if (t != null)
      return t !== r.tail && (r.remove(t), r.insertEntry(t)), t.value;
  }, n.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, n.prototype.len = function() {
    return this._list.len();
  }, n;
}(), g3 = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function xo(n) {
  return n = Math.round(n), n < 0 ? 0 : n > 255 ? 255 : n;
}
function qDe(n) {
  return n = Math.round(n), n < 0 ? 0 : n > 360 ? 360 : n;
}
function Zm(n) {
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function ZS(n) {
  var e = n;
  return e.length && e.charAt(e.length - 1) === "%" ? xo(parseFloat(e) / 100 * 255) : xo(parseInt(e, 10));
}
function dd(n) {
  var e = n;
  return e.length && e.charAt(e.length - 1) === "%" ? Zm(parseFloat(e) / 100) : Zm(parseFloat(e));
}
function JS(n, e, t) {
  return t < 0 ? t += 1 : t > 1 && (t -= 1), t * 6 < 1 ? n + (e - n) * t * 6 : t * 2 < 1 ? e : t * 3 < 2 ? n + (e - n) * (2 / 3 - t) * 6 : n;
}
function vu(n, e, t) {
  return n + (e - n) * t;
}
function Na(n, e, t, r, i) {
  return n[0] = e, n[1] = t, n[2] = r, n[3] = i, n;
}
function UC(n, e) {
  return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n;
}
var vG = new $g(20), a0 = null;
function _f(n, e) {
  a0 && UC(a0, e), a0 = vG.put(n, a0 || e.slice());
}
function ba(n, e) {
  if (n) {
    e = e || [];
    var t = vG.get(n);
    if (t)
      return UC(e, t);
    n = n + "";
    var r = n.replace(/ /g, "").toLowerCase();
    if (r in g3)
      return UC(e, g3[r]), _f(n, e), e;
    var i = r.length;
    if (r.charAt(0) === "#") {
      if (i === 4 || i === 5) {
        var a = parseInt(r.slice(1, 4), 16);
        if (!(a >= 0 && a <= 4095)) {
          Na(e, 0, 0, 0, 1);
          return;
        }
        return Na(e, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, i === 5 ? parseInt(r.slice(4), 16) / 15 : 1), _f(n, e), e;
      } else if (i === 7 || i === 9) {
        var a = parseInt(r.slice(1, 7), 16);
        if (!(a >= 0 && a <= 16777215)) {
          Na(e, 0, 0, 0, 1);
          return;
        }
        return Na(e, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, i === 9 ? parseInt(r.slice(7), 16) / 255 : 1), _f(n, e), e;
      }
      return;
    }
    var o = r.indexOf("("), s = r.indexOf(")");
    if (o !== -1 && s + 1 === i) {
      var l = r.substr(0, o), u = r.substr(o + 1, s - (o + 1)).split(","), c = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? Na(e, +u[0], +u[1], +u[2], 1) : Na(e, 0, 0, 0, 1);
          c = dd(u.pop());
        case "rgb":
          if (u.length >= 3)
            return Na(e, ZS(u[0]), ZS(u[1]), ZS(u[2]), u.length === 3 ? c : dd(u[3])), _f(n, e), e;
          Na(e, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            Na(e, 0, 0, 0, 1);
            return;
          }
          return u[3] = dd(u[3]), WC(u, e), _f(n, e), e;
        case "hsl":
          if (u.length !== 3) {
            Na(e, 0, 0, 0, 1);
            return;
          }
          return WC(u, e), _f(n, e), e;
        default:
          return;
      }
    }
    Na(e, 0, 0, 0, 1);
  }
}
function WC(n, e) {
  var t = (parseFloat(n[0]) % 360 + 360) % 360 / 360, r = dd(n[1]), i = dd(n[2]), a = i <= 0.5 ? i * (r + 1) : i + r - i * r, o = i * 2 - a;
  return e = e || [], Na(e, xo(JS(o, a, t + 1 / 3) * 255), xo(JS(o, a, t) * 255), xo(JS(o, a, t - 1 / 3) * 255), 1), n.length === 4 && (e[3] = n[3]), e;
}
function YDe(n) {
  if (n) {
    var e = n[0] / 255, t = n[1] / 255, r = n[2] / 255, i = Math.min(e, t, r), a = Math.max(e, t, r), o = a - i, s = (a + i) / 2, l, u;
    if (o === 0)
      l = 0, u = 0;
    else {
      s < 0.5 ? u = o / (a + i) : u = o / (2 - a - i);
      var c = ((a - e) / 6 + o / 2) / o, d = ((a - t) / 6 + o / 2) / o, f = ((a - r) / 6 + o / 2) / o;
      e === a ? l = f - d : t === a ? l = 1 / 3 + c - f : r === a && (l = 2 / 3 + d - c), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var p = [l * 360, u, s];
    return n[3] != null && p.push(n[3]), p;
  }
}
function qC(n, e) {
  var t = ba(n);
  if (t) {
    for (var r = 0; r < 3; r++)
      e < 0 ? t[r] = t[r] * (1 - e) | 0 : t[r] = (255 - t[r]) * e + t[r] | 0, t[r] > 255 ? t[r] = 255 : t[r] < 0 && (t[r] = 0);
    return dl(t, t.length === 4 ? "rgba" : "rgb");
  }
}
function QS(n, e, t) {
  if (!(!(e && e.length) || !(n >= 0 && n <= 1))) {
    t = t || [];
    var r = n * (e.length - 1), i = Math.floor(r), a = Math.ceil(r), o = e[i], s = e[a], l = r - i;
    return t[0] = xo(vu(o[0], s[0], l)), t[1] = xo(vu(o[1], s[1], l)), t[2] = xo(vu(o[2], s[2], l)), t[3] = Zm(vu(o[3], s[3], l)), t;
  }
}
function KDe(n, e, t) {
  if (!(!(e && e.length) || !(n >= 0 && n <= 1))) {
    var r = n * (e.length - 1), i = Math.floor(r), a = Math.ceil(r), o = ba(e[i]), s = ba(e[a]), l = r - i, u = dl([
      xo(vu(o[0], s[0], l)),
      xo(vu(o[1], s[1], l)),
      xo(vu(o[2], s[2], l)),
      Zm(vu(o[3], s[3], l))
    ], "rgba");
    return t ? {
      color: u,
      leftIndex: i,
      rightIndex: a,
      value: r
    } : u;
  }
}
function sm(n, e, t, r) {
  var i = ba(n);
  if (n)
    return i = YDe(i), e != null && (i[0] = qDe(e)), t != null && (i[1] = dd(t)), r != null && (i[2] = dd(r)), dl(WC(i), "rgba");
}
function Yb(n, e) {
  var t = ba(n);
  if (t && e != null)
    return t[3] = Zm(e), dl(t, "rgba");
}
function dl(n, e) {
  if (!(!n || !n.length)) {
    var t = n[0] + "," + n[1] + "," + n[2];
    return (e === "rgba" || e === "hsva" || e === "hsla") && (t += "," + n[3]), e + "(" + t + ")";
  }
}
function Kb(n, e) {
  var t = ba(n);
  return t ? (0.299 * t[0] + 0.587 * t[1] + 0.114 * t[2]) * t[3] / 255 + (1 - t[3]) * e : 0;
}
var y3 = new $g(100);
function YC(n) {
  if (We(n)) {
    var e = y3.get(n);
    return e || (e = qC(n, -0.1), y3.put(n, e)), e;
  } else if (Gx(n)) {
    var t = xe({}, n);
    return t.colorStops = De(n.colorStops, function(r) {
      return {
        offset: r.offset,
        color: qC(r.color, -0.1)
      };
    }), t;
  }
  return n;
}
var Xb = Math.round;
function Jm(n) {
  var e;
  if (!n || n === "transparent")
    n = "none";
  else if (typeof n == "string" && n.indexOf("rgba") > -1) {
    var t = ba(n);
    t && (n = "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")", e = t[3]);
  }
  return {
    color: n,
    opacity: e ?? 1
  };
}
var b3 = 1e-4;
function mu(n) {
  return n < b3 && n > -b3;
}
function o0(n) {
  return Xb(n * 1e3) / 1e3;
}
function KC(n) {
  return Xb(n * 1e4) / 1e4;
}
function XDe(n) {
  return "matrix(" + o0(n[0]) + "," + o0(n[1]) + "," + o0(n[2]) + "," + o0(n[3]) + "," + KC(n[4]) + "," + KC(n[5]) + ")";
}
var ZDe = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function JDe(n, e, t) {
  return t === "top" ? n += e / 2 : t === "bottom" && (n -= e / 2), n;
}
function QDe(n) {
  return n && (n.shadowBlur || n.shadowOffsetX || n.shadowOffsetY);
}
function eOe(n) {
  var e = n.style, t = n.getGlobalScale();
  return [
    e.shadowColor,
    (e.shadowBlur || 0).toFixed(2),
    (e.shadowOffsetX || 0).toFixed(2),
    (e.shadowOffsetY || 0).toFixed(2),
    t[0],
    t[1]
  ].join(",");
}
function mG(n) {
  return n && !!n.image;
}
function tOe(n) {
  return n && !!n.svgElement;
}
function MD(n) {
  return mG(n) || tOe(n);
}
function gG(n) {
  return n.type === "linear";
}
function yG(n) {
  return n.type === "radial";
}
function bG(n) {
  return n && (n.type === "linear" || n.type === "radial");
}
function qx(n) {
  return "url(#" + n + ")";
}
function _G(n) {
  var e = n.getGlobalScale(), t = Math.max(e[0], e[1]);
  return Math.max(Math.ceil(Math.log(t) / Math.log(10)), 1);
}
function xG(n) {
  var e = n.x || 0, t = n.y || 0, r = (n.rotation || 0) * g1, i = bt(n.scaleX, 1), a = bt(n.scaleY, 1), o = n.skewX || 0, s = n.skewY || 0, l = [];
  return (e || t) && l.push("translate(" + e + "px," + t + "px)"), r && l.push("rotate(" + r + ")"), (i !== 1 || a !== 1) && l.push("scale(" + i + "," + a + ")"), (o || s) && l.push("skew(" + Xb(o * g1) + "deg, " + Xb(s * g1) + "deg)"), l.join(" ");
}
var nOe = function() {
  return Vt.hasGlobalWindow && at(window.btoa) ? function(n) {
    return window.btoa(unescape(encodeURIComponent(n)));
  } : typeof Buffer < "u" ? function(n) {
    return Buffer.from(n).toString("base64");
  } : function(n) {
    return process.env.NODE_ENV !== "production" && _o("Base64 isn't natively supported in the current environment."), null;
  };
}(), XC = Array.prototype.slice;
function qs(n, e, t) {
  return (e - n) * t + n;
}
function e2(n, e, t, r) {
  for (var i = e.length, a = 0; a < i; a++)
    n[a] = qs(e[a], t[a], r);
  return n;
}
function rOe(n, e, t, r) {
  for (var i = e.length, a = i && e[0].length, o = 0; o < i; o++) {
    n[o] || (n[o] = []);
    for (var s = 0; s < a; s++)
      n[o][s] = qs(e[o][s], t[o][s], r);
  }
  return n;
}
function s0(n, e, t, r) {
  for (var i = e.length, a = 0; a < i; a++)
    n[a] = e[a] + t[a] * r;
  return n;
}
function _3(n, e, t, r) {
  for (var i = e.length, a = i && e[0].length, o = 0; o < i; o++) {
    n[o] || (n[o] = []);
    for (var s = 0; s < a; s++)
      n[o][s] = e[o][s] + t[o][s] * r;
  }
  return n;
}
function iOe(n, e) {
  for (var t = n.length, r = e.length, i = t > r ? e : n, a = Math.min(t, r), o = i[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = a; s < Math.max(t, r); s++)
    i.push({
      offset: o.offset,
      color: o.color.slice()
    });
}
function aOe(n, e, t) {
  var r = n, i = e;
  if (!(!r.push || !i.push)) {
    var a = r.length, o = i.length;
    if (a !== o) {
      var s = a > o;
      if (s)
        r.length = o;
      else
        for (var l = a; l < o; l++)
          r.push(t === 1 ? i[l] : XC.call(i[l]));
    }
    for (var u = r[0] && r[0].length, l = 0; l < r.length; l++)
      if (t === 1)
        isNaN(r[l]) && (r[l] = i[l]);
      else
        for (var c = 0; c < u; c++)
          isNaN(r[l][c]) && (r[l][c] = i[l][c]);
  }
}
function lm(n) {
  if (hi(n)) {
    var e = n.length;
    if (hi(n[0])) {
      for (var t = [], r = 0; r < e; r++)
        t.push(XC.call(n[r]));
      return t;
    }
    return XC.call(n);
  }
  return n;
}
function x1(n) {
  return n[0] = Math.floor(n[0]) || 0, n[1] = Math.floor(n[1]) || 0, n[2] = Math.floor(n[2]) || 0, n[3] = n[3] == null ? 1 : n[3], "rgba(" + n.join(",") + ")";
}
function oOe(n) {
  return hi(n && n[0]) ? 2 : 1;
}
var l0 = 0, w1 = 1, wG = 2, kv = 3, ZC = 4, JC = 5, x3 = 6;
function w3(n) {
  return n === ZC || n === JC;
}
function u0(n) {
  return n === w1 || n === wG;
}
var Xh = [0, 0, 0, 0], sOe = function() {
  function n(e) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = e;
  }
  return n.prototype.isFinished = function() {
    return this._finished;
  }, n.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, n.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, n.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, n.prototype.addKeyframe = function(e, t, r) {
    this._needsSort = !0;
    var i = this.keyframes, a = i.length, o = !1, s = x3, l = t;
    if (hi(t)) {
      var u = oOe(t);
      s = u, (u === 1 && !sn(t[0]) || u === 2 && !sn(t[0][0])) && (o = !0);
    } else if (sn(t) && !Dd(t))
      s = l0;
    else if (We(t))
      if (!isNaN(+t))
        s = l0;
      else {
        var c = ba(t);
        c && (l = c, s = kv);
      }
    else if (Gx(t)) {
      var d = xe({}, l);
      d.colorStops = De(t.colorStops, function(p) {
        return {
          offset: p.offset,
          color: ba(p.color)
        };
      }), gG(t) ? s = ZC : yG(t) && (s = JC), l = d;
    }
    a === 0 ? this.valType = s : (s !== this.valType || s === x3) && (o = !0), this.discrete = this.discrete || o;
    var f = {
      time: e,
      value: l,
      rawValue: t,
      percent: 0
    };
    return r && (f.easing = r, f.easingFunc = at(r) ? r : om[r] || AD(r)), i.push(f), f;
  }, n.prototype.prepare = function(e, t) {
    var r = this.keyframes;
    this._needsSort && r.sort(function(v, m) {
      return v.time - m.time;
    });
    for (var i = this.valType, a = r.length, o = r[a - 1], s = this.discrete, l = u0(i), u = w3(i), c = 0; c < a; c++) {
      var d = r[c], f = d.value, p = o.value;
      d.percent = d.time / e, s || (l && c !== a - 1 ? aOe(f, p, i) : u && iOe(f.colorStops, p.colorStops));
    }
    if (!s && i !== JC && t && this.needsAnimate() && t.needsAnimate() && i === t.valType && !t._finished) {
      this._additiveTrack = t;
      for (var h = r[0].value, c = 0; c < a; c++)
        i === l0 ? r[c].additiveValue = r[c].value - h : i === kv ? r[c].additiveValue = s0([], r[c].value, h, -1) : u0(i) && (r[c].additiveValue = i === w1 ? s0([], r[c].value, h, -1) : _3([], r[c].value, h, -1));
    }
  }, n.prototype.step = function(e, t) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var r = this._additiveTrack != null, i = r ? "additiveValue" : "value", a = this.valType, o = this.keyframes, s = o.length, l = this.propName, u = a === kv, c, d = this._lastFr, f = Math.min, p, h;
      if (s === 1)
        p = h = o[0];
      else {
        if (t < 0)
          c = 0;
        else if (t < this._lastFrP) {
          var v = f(d + 1, s - 1);
          for (c = v; c >= 0 && !(o[c].percent <= t); c--)
            ;
          c = f(c, s - 2);
        } else {
          for (c = d; c < s && !(o[c].percent > t); c++)
            ;
          c = f(c - 1, s - 2);
        }
        h = o[c + 1], p = o[c];
      }
      if (p && h) {
        this._lastFr = c, this._lastFrP = t;
        var m = h.percent - p.percent, g = m === 0 ? 1 : f((t - p.percent) / m, 1);
        h.easingFunc && (g = h.easingFunc(g));
        var y = r ? this._additiveValue : u ? Xh : e[l];
        if ((u0(a) || u) && !y && (y = this._additiveValue = []), this.discrete)
          e[l] = g < 1 ? p.rawValue : h.rawValue;
        else if (u0(a))
          a === w1 ? e2(y, p[i], h[i], g) : rOe(y, p[i], h[i], g);
        else if (w3(a)) {
          var b = p[i], _ = h[i], x = a === ZC;
          e[l] = {
            type: x ? "linear" : "radial",
            x: qs(b.x, _.x, g),
            y: qs(b.y, _.y, g),
            colorStops: De(b.colorStops, function(S, C) {
              var k = _.colorStops[C];
              return {
                offset: qs(S.offset, k.offset, g),
                color: x1(e2([], S.color, k.color, g))
              };
            }),
            global: _.global
          }, x ? (e[l].x2 = qs(b.x2, _.x2, g), e[l].y2 = qs(b.y2, _.y2, g)) : e[l].r = qs(b.r, _.r, g);
        } else if (u)
          e2(y, p[i], h[i], g), r || (e[l] = x1(y));
        else {
          var w = qs(p[i], h[i], g);
          r ? this._additiveValue = w : e[l] = w;
        }
        r && this._addToTarget(e);
      }
    }
  }, n.prototype._addToTarget = function(e) {
    var t = this.valType, r = this.propName, i = this._additiveValue;
    t === l0 ? e[r] = e[r] + i : t === kv ? (ba(e[r], Xh), s0(Xh, Xh, i, 1), e[r] = x1(Xh)) : t === w1 ? s0(e[r], e[r], i, 1) : t === wG && _3(e[r], e[r], i, 1);
  }, n;
}(), DD = function() {
  function n(e, t, r, i) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = e, this._loop = t, t && i) {
      _o("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = i, this._allowDiscrete = r;
  }
  return n.prototype.getMaxTime = function() {
    return this._maxTime;
  }, n.prototype.getDelay = function() {
    return this._delay;
  }, n.prototype.getLoop = function() {
    return this._loop;
  }, n.prototype.getTarget = function() {
    return this._target;
  }, n.prototype.changeTarget = function(e) {
    this._target = e;
  }, n.prototype.when = function(e, t, r) {
    return this.whenWithKeys(e, t, Yt(t), r);
  }, n.prototype.whenWithKeys = function(e, t, r, i) {
    for (var a = this._tracks, o = 0; o < r.length; o++) {
      var s = r[o], l = a[s];
      if (!l) {
        l = a[s] = new sOe(s);
        var u = void 0, c = this._getAdditiveTrack(s);
        if (c) {
          var d = c.keyframes, f = d[d.length - 1];
          u = f && f.value, c.valType === kv && u && (u = x1(u));
        } else
          u = this._target[s];
        if (u == null)
          continue;
        e > 0 && l.addKeyframe(0, lm(u), i), this._trackKeys.push(s);
      }
      l.addKeyframe(e, lm(t[s]), i);
    }
    return this._maxTime = Math.max(this._maxTime, e), this;
  }, n.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, n.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, n.prototype.isPaused = function() {
    return !!this._paused;
  }, n.prototype.duration = function(e) {
    return this._maxTime = e, this._force = !0, this;
  }, n.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var e = this._doneCbs;
    if (e)
      for (var t = e.length, r = 0; r < t; r++)
        e[r].call(this);
  }, n.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var e = this.animation, t = this._abortedCbs;
    if (e && e.removeClip(this._clip), this._clip = null, t)
      for (var r = 0; r < t.length; r++)
        t[r].call(this);
  }, n.prototype._setTracksFinished = function() {
    for (var e = this._tracks, t = this._trackKeys, r = 0; r < t.length; r++)
      e[t[r]].setFinished();
  }, n.prototype._getAdditiveTrack = function(e) {
    var t, r = this._additiveAnimators;
    if (r)
      for (var i = 0; i < r.length; i++) {
        var a = r[i].getTrack(e);
        a && (t = a);
      }
    return t;
  }, n.prototype.start = function(e) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var t = this, r = [], i = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
        var o = this._trackKeys[a], s = this._tracks[o], l = this._getAdditiveTrack(o), u = s.keyframes, c = u.length;
        if (s.prepare(i, l), s.needsAnimate())
          if (!this._allowDiscrete && s.discrete) {
            var d = u[c - 1];
            d && (t._target[s.propName] = d.rawValue), s.setFinished();
          } else
            r.push(s);
      }
      if (r.length || this._force) {
        var f = new UDe({
          life: i,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(p) {
            t._started = 2;
            var h = t._additiveAnimators;
            if (h) {
              for (var v = !1, m = 0; m < h.length; m++)
                if (h[m]._clip) {
                  v = !0;
                  break;
                }
              v || (t._additiveAnimators = null);
            }
            for (var m = 0; m < r.length; m++)
              r[m].step(t._target, p);
            var g = t._onframeCbs;
            if (g)
              for (var m = 0; m < g.length; m++)
                g[m](t._target, p);
          },
          ondestroy: function() {
            t._doneCallback();
          }
        });
        this._clip = f, this.animation && this.animation.addClip(f), e && f.setEasing(e);
      } else
        this._doneCallback();
      return this;
    }
  }, n.prototype.stop = function(e) {
    if (this._clip) {
      var t = this._clip;
      e && t.onframe(1), this._abortedCallback();
    }
  }, n.prototype.delay = function(e) {
    return this._delay = e, this;
  }, n.prototype.during = function(e) {
    return e && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(e)), this;
  }, n.prototype.done = function(e) {
    return e && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(e)), this;
  }, n.prototype.aborted = function(e) {
    return e && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(e)), this;
  }, n.prototype.getClip = function() {
    return this._clip;
  }, n.prototype.getTrack = function(e) {
    return this._tracks[e];
  }, n.prototype.getTracks = function() {
    var e = this;
    return De(this._trackKeys, function(t) {
      return e._tracks[t];
    });
  }, n.prototype.stopTracks = function(e, t) {
    if (!e.length || !this._clip)
      return !0;
    for (var r = this._tracks, i = this._trackKeys, a = 0; a < e.length; a++) {
      var o = r[e[a]];
      o && !o.isFinished() && (t ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished());
    }
    for (var s = !0, a = 0; a < i.length; a++)
      if (!r[i[a]].isFinished()) {
        s = !1;
        break;
      }
    return s && this._abortedCallback(), s;
  }, n.prototype.saveTo = function(e, t, r) {
    if (e) {
      t = t || this._trackKeys;
      for (var i = 0; i < t.length; i++) {
        var a = t[i], o = this._tracks[a];
        if (!(!o || o.isFinished())) {
          var s = o.keyframes, l = s[r ? 0 : s.length - 1];
          l && (e[a] = lm(l.rawValue));
        }
      }
    }
  }, n.prototype.__changeFinalValue = function(e, t) {
    t = t || Yt(e);
    for (var r = 0; r < t.length; r++) {
      var i = t[r], a = this._tracks[i];
      if (a) {
        var o = a.keyframes;
        if (o.length > 1) {
          var s = o.pop();
          a.addKeyframe(s.time, e[i]), a.prepare(this._maxTime, a.getAdditiveTrack());
        }
      }
    }
  }, n;
}();
function lp() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var lOe = function(n) {
  le(e, n);
  function e(t) {
    var r = n.call(this) || this;
    return r._running = !1, r._time = 0, r._pausedTime = 0, r._pauseStart = 0, r._paused = !1, t = t || {}, r.stage = t.stage || {}, r;
  }
  return e.prototype.addClip = function(t) {
    t.animation && this.removeClip(t), this._head ? (this._tail.next = t, t.prev = this._tail, t.next = null, this._tail = t) : this._head = this._tail = t, t.animation = this;
  }, e.prototype.addAnimator = function(t) {
    t.animation = this;
    var r = t.getClip();
    r && this.addClip(r);
  }, e.prototype.removeClip = function(t) {
    if (t.animation) {
      var r = t.prev, i = t.next;
      r ? r.next = i : this._head = i, i ? i.prev = r : this._tail = r, t.next = t.prev = t.animation = null;
    }
  }, e.prototype.removeAnimator = function(t) {
    var r = t.getClip();
    r && this.removeClip(r), t.animation = null;
  }, e.prototype.update = function(t) {
    for (var r = lp() - this._pausedTime, i = r - this._time, a = this._head; a; ) {
      var o = a.next, s = a.step(r, i);
      s && (a.ondestroy(), this.removeClip(a)), a = o;
    }
    this._time = r, t || (this.trigger("frame", i), this.stage.update && this.stage.update());
  }, e.prototype._startLoop = function() {
    var t = this;
    this._running = !0;
    function r() {
      t._running && (Ub(r), !t._paused && t.update());
    }
    Ub(r);
  }, e.prototype.start = function() {
    this._running || (this._time = lp(), this._pausedTime = 0, this._startLoop());
  }, e.prototype.stop = function() {
    this._running = !1;
  }, e.prototype.pause = function() {
    this._paused || (this._pauseStart = lp(), this._paused = !0);
  }, e.prototype.resume = function() {
    this._paused && (this._pausedTime += lp() - this._pauseStart, this._paused = !1);
  }, e.prototype.clear = function() {
    for (var t = this._head; t; ) {
      var r = t.next;
      t.prev = t.next = t.animation = null, t = r;
    }
    this._head = this._tail = null;
  }, e.prototype.isFinished = function() {
    return this._head == null;
  }, e.prototype.animate = function(t, r) {
    r = r || {}, this.start();
    var i = new DD(t, r.loop);
    return this.addAnimator(i), i;
  }, e;
}(io), uOe = 300, t2 = Vt.domSupported, n2 = function() {
  var n = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], e = [
    "touchstart",
    "touchend",
    "touchmove"
  ], t = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, r = De(n, function(i) {
    var a = i.replace("mouse", "pointer");
    return t.hasOwnProperty(a) ? a : i;
  });
  return {
    mouse: n,
    touch: e,
    pointer: r
  };
}(), S3 = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, E3 = !1;
function QC(n) {
  var e = n.pointerType;
  return e === "pen" || e === "touch";
}
function cOe(n) {
  n.touching = !0, n.touchTimer != null && (clearTimeout(n.touchTimer), n.touchTimer = null), n.touchTimer = setTimeout(function() {
    n.touching = !1, n.touchTimer = null;
  }, 700);
}
function r2(n) {
  n && (n.zrByTouch = !0);
}
function dOe(n, e) {
  return Pa(n.dom, new fOe(n, e), !0);
}
function SG(n, e) {
  for (var t = e, r = !1; t && t.nodeType !== 9 && !(r = t.domBelongToZr || t !== e && t === n.painterRoot); )
    t = t.parentNode;
  return r;
}
var fOe = /* @__PURE__ */ function() {
  function n(e, t) {
    this.stopPropagation = dr, this.stopImmediatePropagation = dr, this.preventDefault = dr, this.type = t.type, this.target = this.currentTarget = e.dom, this.pointerType = t.pointerType, this.clientX = t.clientX, this.clientY = t.clientY;
  }
  return n;
}(), ho = {
  mousedown: function(n) {
    n = Pa(this.dom, n), this.__mayPointerCapture = [n.zrX, n.zrY], this.trigger("mousedown", n);
  },
  mousemove: function(n) {
    n = Pa(this.dom, n);
    var e = this.__mayPointerCapture;
    e && (n.zrX !== e[0] || n.zrY !== e[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", n);
  },
  mouseup: function(n) {
    n = Pa(this.dom, n), this.__togglePointerCapture(!1), this.trigger("mouseup", n);
  },
  mouseout: function(n) {
    n = Pa(this.dom, n);
    var e = n.toElement || n.relatedTarget;
    SG(this, e) || (this.__pointerCapturing && (n.zrEventControl = "no_globalout"), this.trigger("mouseout", n));
  },
  wheel: function(n) {
    E3 = !0, n = Pa(this.dom, n), this.trigger("mousewheel", n);
  },
  mousewheel: function(n) {
    E3 || (n = Pa(this.dom, n), this.trigger("mousewheel", n));
  },
  touchstart: function(n) {
    n = Pa(this.dom, n), r2(n), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(n, "start"), ho.mousemove.call(this, n), ho.mousedown.call(this, n);
  },
  touchmove: function(n) {
    n = Pa(this.dom, n), r2(n), this.handler.processGesture(n, "change"), ho.mousemove.call(this, n);
  },
  touchend: function(n) {
    n = Pa(this.dom, n), r2(n), this.handler.processGesture(n, "end"), ho.mouseup.call(this, n), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < uOe && ho.click.call(this, n);
  },
  pointerdown: function(n) {
    ho.mousedown.call(this, n);
  },
  pointermove: function(n) {
    QC(n) || ho.mousemove.call(this, n);
  },
  pointerup: function(n) {
    ho.mouseup.call(this, n);
  },
  pointerout: function(n) {
    QC(n) || ho.mouseout.call(this, n);
  }
};
$(["click", "dblclick", "contextmenu"], function(n) {
  ho[n] = function(e) {
    e = Pa(this.dom, e), this.trigger(n, e);
  };
});
var ek = {
  pointermove: function(n) {
    QC(n) || ek.mousemove.call(this, n);
  },
  pointerup: function(n) {
    ek.mouseup.call(this, n);
  },
  mousemove: function(n) {
    this.trigger("mousemove", n);
  },
  mouseup: function(n) {
    var e = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", n), e && (n.zrEventControl = "only_globalout", this.trigger("mouseout", n));
  }
};
function pOe(n, e) {
  var t = e.domHandlers;
  Vt.pointerEventsSupported ? $(n2.pointer, function(r) {
    S1(e, r, function(i) {
      t[r].call(n, i);
    });
  }) : (Vt.touchEventsSupported && $(n2.touch, function(r) {
    S1(e, r, function(i) {
      t[r].call(n, i), cOe(e);
    });
  }), $(n2.mouse, function(r) {
    S1(e, r, function(i) {
      i = TD(i), e.touching || t[r].call(n, i);
    });
  }));
}
function hOe(n, e) {
  Vt.pointerEventsSupported ? $(S3.pointer, t) : Vt.touchEventsSupported || $(S3.mouse, t);
  function t(r) {
    function i(a) {
      a = TD(a), SG(n, a.target) || (a = dOe(n, a), e.domHandlers[r].call(n, a));
    }
    S1(e, r, i, { capture: !0 });
  }
}
function S1(n, e, t, r) {
  n.mounted[e] = t, n.listenerOpts[e] = r, HC(n.domTarget, e, t, r);
}
function i2(n) {
  var e = n.mounted;
  for (var t in e)
    e.hasOwnProperty(t) && ADe(n.domTarget, t, e[t], n.listenerOpts[t]);
  n.mounted = {};
}
var T3 = /* @__PURE__ */ function() {
  function n(e, t) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = e, this.domHandlers = t;
  }
  return n;
}(), vOe = function(n) {
  le(e, n);
  function e(t, r) {
    var i = n.call(this) || this;
    return i.__pointerCapturing = !1, i.dom = t, i.painterRoot = r, i._localHandlerScope = new T3(t, ho), t2 && (i._globalHandlerScope = new T3(document, ek)), pOe(i, i._localHandlerScope), i;
  }
  return e.prototype.dispose = function() {
    i2(this._localHandlerScope), t2 && i2(this._globalHandlerScope);
  }, e.prototype.setCursor = function(t) {
    this.dom.style && (this.dom.style.cursor = t || "default");
  }, e.prototype.__togglePointerCapture = function(t) {
    if (this.__mayPointerCapture = null, t2 && +this.__pointerCapturing ^ +t) {
      this.__pointerCapturing = t;
      var r = this._globalHandlerScope;
      t ? hOe(this, r) : i2(r);
    }
  }, e;
}(io), EG = 1;
Vt.hasGlobalWindow && (EG = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var Zb = EG, tk = 0.4, nk = "#333", rk = "#ccc", mOe = "#eee", C3 = Wx, k3 = 5e-5;
function rc(n) {
  return n > k3 || n < -k3;
}
var ic = [], xf = [], a2 = ya(), o2 = Math.abs, rl = function() {
  function n() {
  }
  return n.prototype.getLocalTransform = function(e) {
    return n.getLocalTransform(this, e);
  }, n.prototype.setPosition = function(e) {
    this.x = e[0], this.y = e[1];
  }, n.prototype.setScale = function(e) {
    this.scaleX = e[0], this.scaleY = e[1];
  }, n.prototype.setSkew = function(e) {
    this.skewX = e[0], this.skewY = e[1];
  }, n.prototype.setOrigin = function(e) {
    this.originX = e[0], this.originY = e[1];
  }, n.prototype.needLocalTransform = function() {
    return rc(this.rotation) || rc(this.x) || rc(this.y) || rc(this.scaleX - 1) || rc(this.scaleY - 1) || rc(this.skewX) || rc(this.skewY);
  }, n.prototype.updateTransform = function() {
    var e = this.parent && this.parent.transform, t = this.needLocalTransform(), r = this.transform;
    if (!(t || e)) {
      r && (C3(r), this.invTransform = null);
      return;
    }
    r = r || ya(), t ? this.getLocalTransform(r) : C3(r), e && (t ? cl(r, e, r) : CD(r, e)), this.transform = r, this._resolveGlobalScaleRatio(r);
  }, n.prototype._resolveGlobalScaleRatio = function(e) {
    var t = this.globalScaleRatio;
    if (t != null && t !== 1) {
      this.getGlobalScale(ic);
      var r = ic[0] < 0 ? -1 : 1, i = ic[1] < 0 ? -1 : 1, a = ((ic[0] - r) * t + r) / ic[0] || 0, o = ((ic[1] - i) * t + i) / ic[1] || 0;
      e[0] *= a, e[1] *= a, e[2] *= o, e[3] *= o;
    }
    this.invTransform = this.invTransform || ya(), lh(this.invTransform, e);
  }, n.prototype.getComputedTransform = function() {
    for (var e = this, t = []; e; )
      t.push(e), e = e.parent;
    for (; e = t.pop(); )
      e.updateTransform();
    return this.transform;
  }, n.prototype.setLocalTransform = function(e) {
    if (e) {
      var t = e[0] * e[0] + e[1] * e[1], r = e[2] * e[2] + e[3] * e[3], i = Math.atan2(e[1], e[0]), a = Math.PI / 2 + i - Math.atan2(e[3], e[2]);
      r = Math.sqrt(r) * Math.cos(a), t = Math.sqrt(t), this.skewX = a, this.skewY = 0, this.rotation = -i, this.x = +e[4], this.y = +e[5], this.scaleX = t, this.scaleY = r, this.originX = 0, this.originY = 0;
    }
  }, n.prototype.decomposeTransform = function() {
    if (this.transform) {
      var e = this.parent, t = this.transform;
      e && e.transform && (e.invTransform = e.invTransform || ya(), cl(xf, e.invTransform, t), t = xf);
      var r = this.originX, i = this.originY;
      (r || i) && (a2[4] = r, a2[5] = i, cl(xf, t, a2), xf[4] -= r, xf[5] -= i, t = xf), this.setLocalTransform(t);
    }
  }, n.prototype.getGlobalScale = function(e) {
    var t = this.transform;
    return e = e || [], t ? (e[0] = Math.sqrt(t[0] * t[0] + t[1] * t[1]), e[1] = Math.sqrt(t[2] * t[2] + t[3] * t[3]), t[0] < 0 && (e[0] = -e[0]), t[3] < 0 && (e[1] = -e[1]), e) : (e[0] = 1, e[1] = 1, e);
  }, n.prototype.transformCoordToLocal = function(e, t) {
    var r = [e, t], i = this.invTransform;
    return i && Zr(r, r, i), r;
  }, n.prototype.transformCoordToGlobal = function(e, t) {
    var r = [e, t], i = this.transform;
    return i && Zr(r, r, i), r;
  }, n.prototype.getLineScale = function() {
    var e = this.transform;
    return e && o2(e[0] - 1) > 1e-10 && o2(e[3] - 1) > 1e-10 ? Math.sqrt(o2(e[0] * e[3] - e[2] * e[1])) : 1;
  }, n.prototype.copyTransform = function(e) {
    TG(this, e);
  }, n.getLocalTransform = function(e, t) {
    t = t || [];
    var r = e.originX || 0, i = e.originY || 0, a = e.scaleX, o = e.scaleY, s = e.anchorX, l = e.anchorY, u = e.rotation || 0, c = e.x, d = e.y, f = e.skewX ? Math.tan(e.skewX) : 0, p = e.skewY ? Math.tan(-e.skewY) : 0;
    if (r || i || s || l) {
      var h = r + s, v = i + l;
      t[4] = -h * a - f * v * o, t[5] = -v * o - p * h * a;
    } else
      t[4] = t[5] = 0;
    return t[0] = a, t[3] = o, t[1] = p * a, t[2] = f * o, u && Zd(t, t, u), t[4] += r + c, t[5] += i + d, t;
  }, n.initDefaultProps = function() {
    var e = n.prototype;
    e.scaleX = e.scaleY = e.globalScaleRatio = 1, e.x = e.y = e.originX = e.originY = e.skewX = e.skewY = e.rotation = e.anchorX = e.anchorY = 0;
  }(), n;
}(), Ss = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function TG(n, e) {
  for (var t = 0; t < Ss.length; t++) {
    var r = Ss[t];
    n[r] = e[r];
  }
}
var A3 = {};
function _a(n, e) {
  e = e || Iu;
  var t = A3[e];
  t || (t = A3[e] = new $g(500));
  var r = t.get(n);
  return r == null && (r = Lu.measureText(n, e).width, t.put(n, r)), r;
}
function M3(n, e, t, r) {
  var i = _a(n, e), a = Yx(e), o = Av(0, i, t), s = Qf(0, a, r), l = new Ot(o, s, i, a);
  return l;
}
function zg(n, e, t, r) {
  var i = ((n || "") + "").split(`
`), a = i.length;
  if (a === 1)
    return M3(i[0], e, t, r);
  for (var o = new Ot(0, 0, 0, 0), s = 0; s < i.length; s++) {
    var l = M3(i[s], e, t, r);
    s === 0 ? o.copy(l) : o.union(l);
  }
  return o;
}
function Av(n, e, t) {
  return t === "right" ? n -= e : t === "center" && (n -= e / 2), n;
}
function Qf(n, e, t) {
  return t === "middle" ? n -= e / 2 : t === "bottom" && (n -= e), n;
}
function Yx(n) {
  return _a("国", n);
}
function Mo(n, e) {
  return typeof n == "string" ? n.lastIndexOf("%") >= 0 ? parseFloat(n) / 100 * e : parseFloat(n) : n;
}
function Jb(n, e, t) {
  var r = e.position || "inside", i = e.distance != null ? e.distance : 5, a = t.height, o = t.width, s = a / 2, l = t.x, u = t.y, c = "left", d = "top";
  if (r instanceof Array)
    l += Mo(r[0], t.width), u += Mo(r[1], t.height), c = null, d = null;
  else
    switch (r) {
      case "left":
        l -= i, u += s, c = "right", d = "middle";
        break;
      case "right":
        l += i + o, u += s, d = "middle";
        break;
      case "top":
        l += o / 2, u -= i, c = "center", d = "bottom";
        break;
      case "bottom":
        l += o / 2, u += a + i, c = "center";
        break;
      case "inside":
        l += o / 2, u += s, c = "center", d = "middle";
        break;
      case "insideLeft":
        l += i, u += s, d = "middle";
        break;
      case "insideRight":
        l += o - i, u += s, c = "right", d = "middle";
        break;
      case "insideTop":
        l += o / 2, u += i, c = "center";
        break;
      case "insideBottom":
        l += o / 2, u += a - i, c = "center", d = "bottom";
        break;
      case "insideTopLeft":
        l += i, u += i;
        break;
      case "insideTopRight":
        l += o - i, u += i, c = "right";
        break;
      case "insideBottomLeft":
        l += i, u += a - i, d = "bottom";
        break;
      case "insideBottomRight":
        l += o - i, u += a - i, c = "right", d = "bottom";
        break;
    }
  return n = n || {}, n.x = l, n.y = u, n.align = c, n.verticalAlign = d, n;
}
var s2 = "__zr_normal__", l2 = Ss.concat(["ignore"]), gOe = xs(Ss, function(n, e) {
  return n[e] = !0, n;
}, { ignore: !1 }), wf = {}, yOe = new Ot(0, 0, 0, 0), Kx = function() {
  function n(e) {
    this.id = J9(), this.animators = [], this.currentStates = [], this.states = {}, this._init(e);
  }
  return n.prototype._init = function(e) {
    this.attr(e);
  }, n.prototype.drift = function(e, t, r) {
    switch (this.draggable) {
      case "horizontal":
        t = 0;
        break;
      case "vertical":
        e = 0;
        break;
    }
    var i = this.transform;
    i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += e, i[5] += t, this.decomposeTransform(), this.markRedraw();
  }, n.prototype.beforeUpdate = function() {
  }, n.prototype.afterUpdate = function() {
  }, n.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, n.prototype.updateInnerText = function(e) {
    var t = this._textContent;
    if (t && (!t.ignore || e)) {
      this.textConfig || (this.textConfig = {});
      var r = this.textConfig, i = r.local, a = t.innerTransformable, o = void 0, s = void 0, l = !1;
      a.parent = i ? this : null;
      var u = !1;
      if (a.copyTransform(t), r.position != null) {
        var c = yOe;
        r.layoutRect ? c.copy(r.layoutRect) : c.copy(this.getBoundingRect()), i || c.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(wf, r, c) : Jb(wf, r, c), a.x = wf.x, a.y = wf.y, o = wf.align, s = wf.verticalAlign;
        var d = r.origin;
        if (d && r.rotation != null) {
          var f = void 0, p = void 0;
          d === "center" ? (f = c.width * 0.5, p = c.height * 0.5) : (f = Mo(d[0], c.width), p = Mo(d[1], c.height)), u = !0, a.originX = -a.x + f + (i ? 0 : c.x), a.originY = -a.y + p + (i ? 0 : c.y);
        }
      }
      r.rotation != null && (a.rotation = r.rotation);
      var h = r.offset;
      h && (a.x += h[0], a.y += h[1], u || (a.originX = -h[0], a.originY = -h[1]));
      var v = r.inside == null ? typeof r.position == "string" && r.position.indexOf("inside") >= 0 : r.inside, m = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), g = void 0, y = void 0, b = void 0;
      v && this.canBeInsideText() ? (g = r.insideFill, y = r.insideStroke, (g == null || g === "auto") && (g = this.getInsideTextFill()), (y == null || y === "auto") && (y = this.getInsideTextStroke(g), b = !0)) : (g = r.outsideFill, y = r.outsideStroke, (g == null || g === "auto") && (g = this.getOutsideFill()), (y == null || y === "auto") && (y = this.getOutsideStroke(g), b = !0)), g = g || "#000", (g !== m.fill || y !== m.stroke || b !== m.autoStroke || o !== m.align || s !== m.verticalAlign) && (l = !0, m.fill = g, m.stroke = y, m.autoStroke = b, m.align = o, m.verticalAlign = s, t.setDefaultTextStyle(m)), t.__dirty |= pa, l && t.dirtyStyle(!0);
    }
  }, n.prototype.canBeInsideText = function() {
    return !0;
  }, n.prototype.getInsideTextFill = function() {
    return "#fff";
  }, n.prototype.getInsideTextStroke = function(e) {
    return "#000";
  }, n.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? rk : nk;
  }, n.prototype.getOutsideStroke = function(e) {
    var t = this.__zr && this.__zr.getBackgroundColor(), r = typeof t == "string" && ba(t);
    r || (r = [255, 255, 255, 1]);
    for (var i = r[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++)
      r[o] = r[o] * i + (a ? 0 : 255) * (1 - i);
    return r[3] = 1, dl(r, "rgba");
  }, n.prototype.traverse = function(e, t) {
  }, n.prototype.attrKV = function(e, t) {
    e === "textConfig" ? this.setTextConfig(t) : e === "textContent" ? this.setTextContent(t) : e === "clipPath" ? this.setClipPath(t) : e === "extra" ? (this.extra = this.extra || {}, xe(this.extra, t)) : this[e] = t;
  }, n.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, n.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, n.prototype.attr = function(e, t) {
    if (typeof e == "string")
      this.attrKV(e, t);
    else if (ut(e))
      for (var r = e, i = Yt(r), a = 0; a < i.length; a++) {
        var o = i[a];
        this.attrKV(o, e[o]);
      }
    return this.markRedraw(), this;
  }, n.prototype.saveCurrentToNormalState = function(e) {
    this._innerSaveToNormal(e);
    for (var t = this._normalState, r = 0; r < this.animators.length; r++) {
      var i = this.animators[r], a = i.__fromStateTransition;
      if (!(i.getLoop() || a && a !== s2)) {
        var o = i.targetName, s = o ? t[o] : t;
        i.saveTo(s);
      }
    }
  }, n.prototype._innerSaveToNormal = function(e) {
    var t = this._normalState;
    t || (t = this._normalState = {}), e.textConfig && !t.textConfig && (t.textConfig = this.textConfig), this._savePrimaryToNormal(e, t, l2);
  }, n.prototype._savePrimaryToNormal = function(e, t, r) {
    for (var i = 0; i < r.length; i++) {
      var a = r[i];
      e[a] != null && !(a in t) && (t[a] = this[a]);
    }
  }, n.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, n.prototype.getState = function(e) {
    return this.states[e];
  }, n.prototype.ensureState = function(e) {
    var t = this.states;
    return t[e] || (t[e] = {}), t[e];
  }, n.prototype.clearStates = function(e) {
    this.useState(s2, !1, e);
  }, n.prototype.useState = function(e, t, r, i) {
    var a = e === s2, o = this.hasState();
    if (!(!o && a)) {
      var s = this.currentStates, l = this.stateTransition;
      if (!(Pt(s, e) >= 0 && (t || s.length === 1))) {
        var u;
        if (this.stateProxy && !a && (u = this.stateProxy(e)), u || (u = this.states && this.states[e]), !u && !a) {
          _o("State " + e + " not exists.");
          return;
        }
        a || this.saveCurrentToNormalState(u);
        var c = !!(u && u.hoverLayer || i);
        c && this._toggleHoverLayerFlag(!0), this._applyStateObj(e, u, this._normalState, t, !r && !this.__inHover && l && l.duration > 0, l);
        var d = this._textContent, f = this._textGuide;
        return d && d.useState(e, t, r, c), f && f.useState(e, t, r, c), a ? (this.currentStates = [], this._normalState = {}) : t ? this.currentStates.push(e) : this.currentStates = [e], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~pa), u;
      }
    }
  }, n.prototype.useStates = function(e, t, r) {
    if (!e.length)
      this.clearStates();
    else {
      var i = [], a = this.currentStates, o = e.length, s = o === a.length;
      if (s) {
        for (var l = 0; l < o; l++)
          if (e[l] !== a[l]) {
            s = !1;
            break;
          }
      }
      if (s)
        return;
      for (var l = 0; l < o; l++) {
        var u = e[l], c = void 0;
        this.stateProxy && (c = this.stateProxy(u, e)), c || (c = this.states[u]), c && i.push(c);
      }
      var d = i[o - 1], f = !!(d && d.hoverLayer || r);
      f && this._toggleHoverLayerFlag(!0);
      var p = this._mergeStates(i), h = this.stateTransition;
      this.saveCurrentToNormalState(p), this._applyStateObj(e.join(","), p, this._normalState, !1, !t && !this.__inHover && h && h.duration > 0, h);
      var v = this._textContent, m = this._textGuide;
      v && v.useStates(e, t, f), m && m.useStates(e, t, f), this._updateAnimationTargets(), this.currentStates = e.slice(), this.markRedraw(), !f && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~pa);
    }
  }, n.prototype.isSilent = function() {
    for (var e = this.silent, t = this.parent; !e && t; ) {
      if (t.silent) {
        e = !0;
        break;
      }
      t = t.parent;
    }
    return e;
  }, n.prototype._updateAnimationTargets = function() {
    for (var e = 0; e < this.animators.length; e++) {
      var t = this.animators[e];
      t.targetName && t.changeTarget(this[t.targetName]);
    }
  }, n.prototype.removeState = function(e) {
    var t = Pt(this.currentStates, e);
    if (t >= 0) {
      var r = this.currentStates.slice();
      r.splice(t, 1), this.useStates(r);
    }
  }, n.prototype.replaceState = function(e, t, r) {
    var i = this.currentStates.slice(), a = Pt(i, e), o = Pt(i, t) >= 0;
    a >= 0 ? o ? i.splice(a, 1) : i[a] = t : r && !o && i.push(t), this.useStates(i);
  }, n.prototype.toggleState = function(e, t) {
    t ? this.useState(e, !0) : this.removeState(e);
  }, n.prototype._mergeStates = function(e) {
    for (var t = {}, r, i = 0; i < e.length; i++) {
      var a = e[i];
      xe(t, a), a.textConfig && (r = r || {}, xe(r, a.textConfig));
    }
    return r && (t.textConfig = r), t;
  }, n.prototype._applyStateObj = function(e, t, r, i, a, o) {
    var s = !(t && i);
    t && t.textConfig ? (this.textConfig = xe({}, i ? this.textConfig : r.textConfig), xe(this.textConfig, t.textConfig)) : s && r.textConfig && (this.textConfig = r.textConfig);
    for (var l = {}, u = !1, c = 0; c < l2.length; c++) {
      var d = l2[c], f = a && gOe[d];
      t && t[d] != null ? f ? (u = !0, l[d] = t[d]) : this[d] = t[d] : s && r[d] != null && (f ? (u = !0, l[d] = r[d]) : this[d] = r[d]);
    }
    if (!a)
      for (var c = 0; c < this.animators.length; c++) {
        var p = this.animators[c], h = p.targetName;
        p.getLoop() || p.__changeFinalValue(h ? (t || r)[h] : t || r);
      }
    u && this._transitionState(e, l, o);
  }, n.prototype._attachComponent = function(e) {
    if (e.__zr && !e.__hostTarget) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (e === this) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var t = this.__zr;
    t && e.addSelfToZr(t), e.__zr = t, e.__hostTarget = this;
  }, n.prototype._detachComponent = function(e) {
    e.__zr && e.removeSelfFromZr(e.__zr), e.__zr = null, e.__hostTarget = null;
  }, n.prototype.getClipPath = function() {
    return this._clipPath;
  }, n.prototype.setClipPath = function(e) {
    this._clipPath && this._clipPath !== e && this.removeClipPath(), this._attachComponent(e), this._clipPath = e, this.markRedraw();
  }, n.prototype.removeClipPath = function() {
    var e = this._clipPath;
    e && (this._detachComponent(e), this._clipPath = null, this.markRedraw());
  }, n.prototype.getTextContent = function() {
    return this._textContent;
  }, n.prototype.setTextContent = function(e) {
    var t = this._textContent;
    if (t !== e) {
      if (t && t !== e && this.removeTextContent(), process.env.NODE_ENV !== "production" && e.__zr && !e.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      e.innerTransformable = new rl(), this._attachComponent(e), this._textContent = e, this.markRedraw();
    }
  }, n.prototype.setTextConfig = function(e) {
    this.textConfig || (this.textConfig = {}), xe(this.textConfig, e), this.markRedraw();
  }, n.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, n.prototype.removeTextContent = function() {
    var e = this._textContent;
    e && (e.innerTransformable = null, this._detachComponent(e), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, n.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, n.prototype.setTextGuideLine = function(e) {
    this._textGuide && this._textGuide !== e && this.removeTextGuideLine(), this._attachComponent(e), this._textGuide = e, this.markRedraw();
  }, n.prototype.removeTextGuideLine = function() {
    var e = this._textGuide;
    e && (this._detachComponent(e), this._textGuide = null, this.markRedraw());
  }, n.prototype.markRedraw = function() {
    this.__dirty |= pa;
    var e = this.__zr;
    e && (this.__inHover ? e.refreshHover() : e.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, n.prototype.dirty = function() {
    this.markRedraw();
  }, n.prototype._toggleHoverLayerFlag = function(e) {
    this.__inHover = e;
    var t = this._textContent, r = this._textGuide;
    t && (t.__inHover = e), r && (r.__inHover = e);
  }, n.prototype.addSelfToZr = function(e) {
    if (this.__zr !== e) {
      this.__zr = e;
      var t = this.animators;
      if (t)
        for (var r = 0; r < t.length; r++)
          e.animation.addAnimator(t[r]);
      this._clipPath && this._clipPath.addSelfToZr(e), this._textContent && this._textContent.addSelfToZr(e), this._textGuide && this._textGuide.addSelfToZr(e);
    }
  }, n.prototype.removeSelfFromZr = function(e) {
    if (this.__zr) {
      this.__zr = null;
      var t = this.animators;
      if (t)
        for (var r = 0; r < t.length; r++)
          e.animation.removeAnimator(t[r]);
      this._clipPath && this._clipPath.removeSelfFromZr(e), this._textContent && this._textContent.removeSelfFromZr(e), this._textGuide && this._textGuide.removeSelfFromZr(e);
    }
  }, n.prototype.animate = function(e, t, r) {
    var i = e ? this[e] : this;
    if (process.env.NODE_ENV !== "production" && !i) {
      _o('Property "' + e + '" is not existed in element ' + this.id);
      return;
    }
    var a = new DD(i, t, r);
    return e && (a.targetName = e), this.addAnimator(a, e), a;
  }, n.prototype.addAnimator = function(e, t) {
    var r = this.__zr, i = this;
    e.during(function() {
      i.updateDuringAnimation(t);
    }).done(function() {
      var a = i.animators, o = Pt(a, e);
      o >= 0 && a.splice(o, 1);
    }), this.animators.push(e), r && r.animation.addAnimator(e), r && r.wakeUp();
  }, n.prototype.updateDuringAnimation = function(e) {
    this.markRedraw();
  }, n.prototype.stopAnimation = function(e, t) {
    for (var r = this.animators, i = r.length, a = [], o = 0; o < i; o++) {
      var s = r[o];
      !e || e === s.scope ? s.stop(t) : a.push(s);
    }
    return this.animators = a, this;
  }, n.prototype.animateTo = function(e, t, r) {
    u2(this, e, t, r);
  }, n.prototype.animateFrom = function(e, t, r) {
    u2(this, e, t, r, !0);
  }, n.prototype._transitionState = function(e, t, r, i) {
    for (var a = u2(this, t, r, i), o = 0; o < a.length; o++)
      a[o].__fromStateTransition = e;
  }, n.prototype.getBoundingRect = function() {
    return null;
  }, n.prototype.getPaintRect = function() {
    return null;
  }, n.initDefaultProps = function() {
    var e = n.prototype;
    e.type = "element", e.name = "", e.ignore = e.silent = e.isGroup = e.draggable = e.dragging = e.ignoreClip = e.__inHover = !1, e.__dirty = pa;
    var t = {};
    function r(a, o, s) {
      t[a + o + s] || (console.warn("DEPRECATED: '" + a + "' has been deprecated. use '" + o + "', '" + s + "' instead"), t[a + o + s] = !0);
    }
    function i(a, o, s, l) {
      Object.defineProperty(e, a, {
        get: function() {
          if (process.env.NODE_ENV !== "production" && r(a, s, l), !this[o]) {
            var c = this[o] = [];
            u(this, c);
          }
          return this[o];
        },
        set: function(c) {
          process.env.NODE_ENV !== "production" && r(a, s, l), this[s] = c[0], this[l] = c[1], this[o] = c, u(this, c);
        }
      });
      function u(c, d) {
        Object.defineProperty(d, 0, {
          get: function() {
            return c[s];
          },
          set: function(f) {
            c[s] = f;
          }
        }), Object.defineProperty(d, 1, {
          get: function() {
            return c[l];
          },
          set: function(f) {
            c[l] = f;
          }
        });
      }
    }
    Object.defineProperty && (i("position", "_legacyPos", "x", "y"), i("scale", "_legacyScale", "scaleX", "scaleY"), i("origin", "_legacyOrigin", "originX", "originY"));
  }(), n;
}();
_r(Kx, io);
_r(Kx, rl);
function u2(n, e, t, r, i) {
  t = t || {};
  var a = [];
  CG(n, "", n, e, t, r, a, i);
  var o = a.length, s = !1, l = t.done, u = t.aborted, c = function() {
    s = !0, o--, o <= 0 && (s ? l && l() : u && u());
  }, d = function() {
    o--, o <= 0 && (s ? l && l() : u && u());
  };
  o || l && l(), a.length > 0 && t.during && a[0].during(function(h, v) {
    t.during(v);
  });
  for (var f = 0; f < a.length; f++) {
    var p = a[f];
    c && p.done(c), d && p.aborted(d), t.force && p.duration(t.duration), p.start(t.easing);
  }
  return a;
}
function c2(n, e, t) {
  for (var r = 0; r < t; r++)
    n[r] = e[r];
}
function bOe(n) {
  return hi(n[0]);
}
function _Oe(n, e, t) {
  if (hi(e[t]))
    if (hi(n[t]) || (n[t] = []), Bi(e[t])) {
      var r = e[t].length;
      n[t].length !== r && (n[t] = new e[t].constructor(r), c2(n[t], e[t], r));
    } else {
      var i = e[t], a = n[t], o = i.length;
      if (bOe(i))
        for (var s = i[0].length, l = 0; l < o; l++)
          a[l] ? c2(a[l], i[l], s) : a[l] = Array.prototype.slice.call(i[l]);
      else
        c2(a, i, o);
      a.length = i.length;
    }
  else
    n[t] = e[t];
}
function xOe(n, e) {
  return n === e || hi(n) && hi(e) && wOe(n, e);
}
function wOe(n, e) {
  var t = n.length;
  if (t !== e.length)
    return !1;
  for (var r = 0; r < t; r++)
    if (n[r] !== e[r])
      return !1;
  return !0;
}
function CG(n, e, t, r, i, a, o, s) {
  for (var l = Yt(r), u = i.duration, c = i.delay, d = i.additive, f = i.setToFinal, p = !ut(a), h = n.animators, v = [], m = 0; m < l.length; m++) {
    var g = l[m], y = r[g];
    if (y != null && t[g] != null && (p || a[g]))
      if (ut(y) && !hi(y) && !Gx(y)) {
        if (e) {
          s || (t[g] = y, n.updateDuringAnimation(e));
          continue;
        }
        CG(n, g, t[g], y, i, a && a[g], o, s);
      } else
        v.push(g);
    else s || (t[g] = y, n.updateDuringAnimation(e), v.push(g));
  }
  var b = v.length;
  if (!d && b)
    for (var _ = 0; _ < h.length; _++) {
      var x = h[_];
      if (x.targetName === e) {
        var w = x.stopTracks(v);
        if (w) {
          var S = Pt(h, x);
          h.splice(S, 1);
        }
      }
    }
  if (i.force || (v = vn(v, function(D) {
    return !xOe(r[D], t[D]);
  }), b = v.length), b > 0 || i.force && !o.length) {
    var C = void 0, k = void 0, M = void 0;
    if (s) {
      k = {}, f && (C = {});
      for (var _ = 0; _ < b; _++) {
        var g = v[_];
        k[g] = t[g], f ? C[g] = r[g] : t[g] = r[g];
      }
    } else if (f) {
      M = {};
      for (var _ = 0; _ < b; _++) {
        var g = v[_];
        M[g] = lm(t[g]), _Oe(t, r, g);
      }
    }
    var x = new DD(t, !1, !1, d ? vn(h, function(N) {
      return N.targetName === e;
    }) : null);
    x.targetName = e, i.scope && (x.scope = i.scope), f && C && x.whenWithKeys(0, C, v), M && x.whenWithKeys(0, M, v), x.whenWithKeys(u ?? 500, s ? k : r, v).delay(c || 0), n.addAnimator(x, e), o.push(x);
  }
}
var mt = function(n) {
  le(e, n);
  function e(t) {
    var r = n.call(this) || this;
    return r.isGroup = !0, r._children = [], r.attr(t), r;
  }
  return e.prototype.childrenRef = function() {
    return this._children;
  }, e.prototype.children = function() {
    return this._children.slice();
  }, e.prototype.childAt = function(t) {
    return this._children[t];
  }, e.prototype.childOfName = function(t) {
    for (var r = this._children, i = 0; i < r.length; i++)
      if (r[i].name === t)
        return r[i];
  }, e.prototype.childCount = function() {
    return this._children.length;
  }, e.prototype.add = function(t) {
    if (t && (t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), process.env.NODE_ENV !== "production" && t.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, e.prototype.addBefore = function(t, r) {
    if (t && t !== this && t.parent !== this && r && r.parent === this) {
      var i = this._children, a = i.indexOf(r);
      a >= 0 && (i.splice(a, 0, t), this._doAdd(t));
    }
    return this;
  }, e.prototype.replace = function(t, r) {
    var i = Pt(this._children, t);
    return i >= 0 && this.replaceAt(r, i), this;
  }, e.prototype.replaceAt = function(t, r) {
    var i = this._children, a = i[r];
    if (t && t !== this && t.parent !== this && t !== a) {
      i[r] = t, a.parent = null;
      var o = this.__zr;
      o && a.removeSelfFromZr(o), this._doAdd(t);
    }
    return this;
  }, e.prototype._doAdd = function(t) {
    t.parent && t.parent.remove(t), t.parent = this;
    var r = this.__zr;
    r && r !== t.__zr && t.addSelfToZr(r), r && r.refresh();
  }, e.prototype.remove = function(t) {
    var r = this.__zr, i = this._children, a = Pt(i, t);
    return a < 0 ? this : (i.splice(a, 1), t.parent = null, r && t.removeSelfFromZr(r), r && r.refresh(), this);
  }, e.prototype.removeAll = function() {
    for (var t = this._children, r = this.__zr, i = 0; i < t.length; i++) {
      var a = t[i];
      r && a.removeSelfFromZr(r), a.parent = null;
    }
    return t.length = 0, this;
  }, e.prototype.eachChild = function(t, r) {
    for (var i = this._children, a = 0; a < i.length; a++) {
      var o = i[a];
      t.call(r, o, a);
    }
    return this;
  }, e.prototype.traverse = function(t, r) {
    for (var i = 0; i < this._children.length; i++) {
      var a = this._children[i], o = t.call(r, a);
      a.isGroup && !o && a.traverse(t, r);
    }
    return this;
  }, e.prototype.addSelfToZr = function(t) {
    n.prototype.addSelfToZr.call(this, t);
    for (var r = 0; r < this._children.length; r++) {
      var i = this._children[r];
      i.addSelfToZr(t);
    }
  }, e.prototype.removeSelfFromZr = function(t) {
    n.prototype.removeSelfFromZr.call(this, t);
    for (var r = 0; r < this._children.length; r++) {
      var i = this._children[r];
      i.removeSelfFromZr(t);
    }
  }, e.prototype.getBoundingRect = function(t) {
    for (var r = new Ot(0, 0, 0, 0), i = t || this._children, a = [], o = null, s = 0; s < i.length; s++) {
      var l = i[s];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), c = l.getLocalTransform(a);
        c ? (Ot.applyTransform(r, u, c), o = o || r.clone(), o.union(r)) : (o = o || u.clone(), o.union(u));
      }
    }
    return o || r;
  }, e;
}(Kx);
mt.prototype.type = "group";
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var Mv = {}, kG = {};
function SOe(n) {
  delete kG[n];
}
function EOe(n) {
  if (!n)
    return !1;
  if (typeof n == "string")
    return Kb(n, 1) < tk;
  if (n.colorStops) {
    for (var e = n.colorStops, t = 0, r = e.length, i = 0; i < r; i++)
      t += Kb(e[i].color, 1);
    return t /= r, t < tk;
  }
  return !1;
}
var TOe = function() {
  function n(e, t, r) {
    var i = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, r = r || {}, this.dom = t, this.id = e;
    var a = new zDe(), o = r.renderer || "canvas";
    if (Mv[o] || (o = Yt(Mv)[0]), process.env.NODE_ENV !== "production" && !Mv[o])
      throw new Error("Renderer '" + o + "' is not imported. Please import it first.");
    r.useDirtyRect = r.useDirtyRect == null ? !1 : r.useDirtyRect;
    var s = new Mv[o](t, a, r, e), l = r.ssr || s.ssrOnly;
    this.storage = a, this.painter = s;
    var u = !Vt.node && !Vt.worker && !l ? new vOe(s.getViewportRoot(), s.root) : null, c = r.useCoarsePointer, d = c == null || c === "auto" ? Vt.touchEventsSupported : !!c, f = 44, p;
    d && (p = bt(r.pointerSize, f)), this.handler = new aG(a, s, u, s.root, p), this.animation = new lOe({
      stage: {
        update: l ? null : function() {
          return i._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return n.prototype.add = function(e) {
    this._disposed || !e || (this.storage.addRoot(e), e.addSelfToZr(this), this.refresh());
  }, n.prototype.remove = function(e) {
    this._disposed || !e || (this.storage.delRoot(e), e.removeSelfFromZr(this), this.refresh());
  }, n.prototype.configLayer = function(e, t) {
    this._disposed || (this.painter.configLayer && this.painter.configLayer(e, t), this.refresh());
  }, n.prototype.setBackgroundColor = function(e) {
    this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(e), this.refresh(), this._backgroundColor = e, this._darkMode = EOe(e));
  }, n.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, n.prototype.setDarkMode = function(e) {
    this._darkMode = e;
  }, n.prototype.isDarkMode = function() {
    return this._darkMode;
  }, n.prototype.refreshImmediately = function(e) {
    this._disposed || (e || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
  }, n.prototype.refresh = function() {
    this._disposed || (this._needsRefresh = !0, this.animation.start());
  }, n.prototype.flush = function() {
    this._disposed || this._flush(!1);
  }, n.prototype._flush = function(e) {
    var t, r = lp();
    this._needsRefresh && (t = !0, this.refreshImmediately(e)), this._needsRefreshHover && (t = !0, this.refreshHoverImmediately());
    var i = lp();
    t ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: i - r
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, n.prototype.setSleepAfterStill = function(e) {
    this._sleepAfterStill = e;
  }, n.prototype.wakeUp = function() {
    this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
  }, n.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, n.prototype.refreshHoverImmediately = function() {
    this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
  }, n.prototype.resize = function(e) {
    this._disposed || (e = e || {}, this.painter.resize(e.width, e.height), this.handler.resize());
  }, n.prototype.clearAnimation = function() {
    this._disposed || this.animation.clear();
  }, n.prototype.getWidth = function() {
    if (!this._disposed)
      return this.painter.getWidth();
  }, n.prototype.getHeight = function() {
    if (!this._disposed)
      return this.painter.getHeight();
  }, n.prototype.setCursorStyle = function(e) {
    this._disposed || this.handler.setCursorStyle(e);
  }, n.prototype.findHover = function(e, t) {
    if (!this._disposed)
      return this.handler.findHover(e, t);
  }, n.prototype.on = function(e, t, r) {
    return this._disposed || this.handler.on(e, t, r), this;
  }, n.prototype.off = function(e, t) {
    this._disposed || this.handler.off(e, t);
  }, n.prototype.trigger = function(e, t) {
    this._disposed || this.handler.trigger(e, t);
  }, n.prototype.clear = function() {
    if (!this._disposed) {
      for (var e = this.storage.getRoots(), t = 0; t < e.length; t++)
        e[t] instanceof mt && e[t].removeSelfFromZr(this);
      this.storage.delAllRoots(), this.painter.clear();
    }
  }, n.prototype.dispose = function() {
    this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, SOe(this.id));
  }, n;
}();
function D3(n, e) {
  var t = new TOe(J9(), n, e);
  return kG[t.id] = t, t;
}
function COe(n, e) {
  Mv[n] = e;
}
var ik;
function kOe(n) {
  if (typeof ik == "function")
    return ik(n);
}
function AOe(n) {
  ik = n;
}
var O3 = 1e-4, AG = 20;
function MOe(n) {
  return n.replace(/^\s+|\s+$/g, "");
}
function mn(n, e, t, r) {
  var i = e[0], a = e[1], o = t[0], s = t[1], l = a - i, u = s - o;
  if (l === 0)
    return u === 0 ? o : (o + s) / 2;
  if (r)
    if (l > 0) {
      if (n <= i)
        return o;
      if (n >= a)
        return s;
    } else {
      if (n >= i)
        return o;
      if (n <= a)
        return s;
    }
  else {
    if (n === i)
      return o;
    if (n === a)
      return s;
  }
  return (n - i) / l * u + o;
}
function ze(n, e) {
  switch (n) {
    case "center":
    case "middle":
      n = "50%";
      break;
    case "left":
    case "top":
      n = "0%";
      break;
    case "right":
    case "bottom":
      n = "100%";
      break;
  }
  return We(n) ? MOe(n).match(/%$/) ? parseFloat(n) / 100 * e : parseFloat(n) : n == null ? NaN : +n;
}
function ir(n, e, t) {
  return e == null && (e = 10), e = Math.min(Math.max(0, e), AG), n = (+n).toFixed(e), t ? n : +n;
}
function Ya(n) {
  return n.sort(function(e, t) {
    return e - t;
  }), n;
}
function ss(n) {
  if (n = +n, isNaN(n))
    return 0;
  if (n > 1e-14) {
    for (var e = 1, t = 0; t < 15; t++, e *= 10)
      if (Math.round(n * e) / e === n)
        return t;
  }
  return ak(n);
}
function ak(n) {
  var e = n.toString().toLowerCase(), t = e.indexOf("e"), r = t > 0 ? +e.slice(t + 1) : 0, i = t > 0 ? t : e.length, a = e.indexOf("."), o = a < 0 ? 0 : i - 1 - a;
  return Math.max(0, o - r);
}
function MG(n, e) {
  var t = Math.log, r = Math.LN10, i = Math.floor(t(n[1] - n[0]) / r), a = Math.round(t(Math.abs(e[1] - e[0])) / r), o = Math.min(Math.max(-i + a, 0), 20);
  return isFinite(o) ? o : 20;
}
function DOe(n, e) {
  var t = xs(n, function(p, h) {
    return p + (isNaN(h) ? 0 : h);
  }, 0);
  if (t === 0)
    return [];
  for (var r = Math.pow(10, e), i = De(n, function(p) {
    return (isNaN(p) ? 0 : p) / t * r * 100;
  }), a = r * 100, o = De(i, function(p) {
    return Math.floor(p);
  }), s = xs(o, function(p, h) {
    return p + h;
  }, 0), l = De(i, function(p, h) {
    return p - o[h];
  }); s < a; ) {
    for (var u = Number.NEGATIVE_INFINITY, c = null, d = 0, f = l.length; d < f; ++d)
      l[d] > u && (u = l[d], c = d);
    ++o[c], l[c] = 0, ++s;
  }
  return De(o, function(p) {
    return p / r;
  });
}
function OOe(n, e) {
  var t = Math.max(ss(n), ss(e)), r = n + e;
  return t > AG ? r : ir(r, t);
}
var I3 = 9007199254740991;
function DG(n) {
  var e = Math.PI * 2;
  return (n % e + e) % e;
}
function Qm(n) {
  return n > -O3 && n < O3;
}
var IOe = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function Es(n) {
  if (n instanceof Date)
    return n;
  if (We(n)) {
    var e = IOe.exec(n);
    if (!e)
      return /* @__PURE__ */ new Date(NaN);
    if (e[8]) {
      var t = +e[4] || 0;
      return e[8].toUpperCase() !== "Z" && (t -= +e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, t, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0));
    } else
      return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0);
  } else if (n == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(n));
}
function LOe(n) {
  return Math.pow(10, Xx(n));
}
function Xx(n) {
  if (n === 0)
    return 0;
  var e = Math.floor(Math.log(n) / Math.LN10);
  return n / Math.pow(10, e) >= 10 && e++, e;
}
function OG(n, e) {
  var t = Xx(n), r = Math.pow(10, t), i = n / r, a;
  return i < 1.5 ? a = 1 : i < 2.5 ? a = 2 : i < 4 ? a = 3 : i < 7 ? a = 5 : a = 10, n = a * r, t >= -20 ? +n.toFixed(t < 0 ? -t : 0) : n;
}
function d2(n, e) {
  var t = (n.length - 1) * e + 1, r = Math.floor(t), i = +n[r - 1], a = t - r;
  return a ? i + a * (n[r] - i) : i;
}
function L3(n) {
  n.sort(function(l, u) {
    return s(l, u, 0) ? -1 : 1;
  });
  for (var e = -1 / 0, t = 1, r = 0; r < n.length; ) {
    for (var i = n[r].interval, a = n[r].close, o = 0; o < 2; o++)
      i[o] <= e && (i[o] = e, a[o] = o ? 1 : 1 - t), e = i[o], t = a[o];
    i[0] === i[1] && a[0] * a[1] !== 1 ? n.splice(r, 1) : r++;
  }
  return n;
  function s(l, u, c) {
    return l.interval[c] < u.interval[c] || l.interval[c] === u.interval[c] && (l.close[c] - u.close[c] === (c ? -1 : 1) || !c && s(l, u, 1));
  }
}
function _l(n) {
  var e = parseFloat(n);
  return e == n && (e !== 0 || !We(n) || n.indexOf("x") <= 0) ? e : NaN;
}
function OD(n) {
  return !isNaN(_l(n));
}
function IG() {
  return Math.round(Math.random() * 9);
}
function LG(n, e) {
  return e === 0 ? n : LG(e, n % e);
}
function N3(n, e) {
  return n == null ? e : e == null ? n : n * e / LG(n, e);
}
var NOe = "[ECharts] ", R3 = {}, ROe = typeof console < "u" && console.warn && console.log;
function Zx(n, e, t) {
  if (ROe) {
    if (t) {
      if (R3[e])
        return;
      R3[e] = !0;
    }
    console[n](NOe + e);
  }
}
function POe(n, e) {
  Zx("log", n, e);
}
function Jn(n, e) {
  Zx("warn", n, e);
}
function Jr(n, e) {
  Zx("error", n, e);
}
function Do(n) {
  process.env.NODE_ENV !== "production" && Zx("warn", "DEPRECATED: " + n, !0);
}
function vr(n, e, t) {
  process.env.NODE_ENV !== "production" && Do((t ? "[" + t + "]" : "") + (n + " is deprecated, use " + e + " instead."));
}
function $i() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  var t = "";
  if (process.env.NODE_ENV !== "production") {
    var r = function(i) {
      return i === void 0 ? "undefined" : i === 1 / 0 ? "Infinity" : i === -1 / 0 ? "-Infinity" : Dd(i) ? "NaN" : i instanceof Date ? "Date(" + i.toISOString() + ")" : at(i) ? "function () { ... }" : Q9(i) ? i + "" : null;
    };
    t = De(n, function(i) {
      if (We(i))
        return i;
      var a = r(i);
      if (a != null)
        return a;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(i, function(o, s) {
            var l = r(s);
            return l ?? s;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return t;
}
function hn(n) {
  throw new Error(n);
}
function P3(n, e, t) {
  return (e - n) * t + n;
}
var NG = "series\0", RG = "\0_ec_\0";
function wn(n) {
  return n instanceof Array ? n : n == null ? [] : [n];
}
function Od(n, e, t) {
  if (n) {
    n[e] = n[e] || {}, n.emphasis = n.emphasis || {}, n.emphasis[e] = n.emphasis[e] || {};
    for (var r = 0, i = t.length; r < i; r++) {
      var a = t[r];
      !n.emphasis[e].hasOwnProperty(a) && n[e].hasOwnProperty(a) && (n.emphasis[e][a] = n[e][a]);
    }
  }
}
var j3 = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function uh(n) {
  return ut(n) && !Me(n) && !(n instanceof Date) ? n.value : n;
}
function jOe(n) {
  return ut(n) && !(n instanceof Array);
}
function PG(n, e, t) {
  var r = t === "normalMerge", i = t === "replaceMerge", a = t === "replaceAll";
  n = n || [], e = (e || []).slice();
  var o = tt();
  $(e, function(l, u) {
    if (!ut(l)) {
      e[u] = null;
      return;
    }
    process.env.NODE_ENV !== "production" && (l.id != null && !$3(l.id) && B3(l.id), l.name != null && !$3(l.name) && B3(l.name));
  });
  var s = BOe(n, o, t);
  return (r || i) && $Oe(s, n, o, e), r && zOe(s, e), r || i ? FOe(s, e, i) : a && VOe(s, e), HOe(s), s;
}
function BOe(n, e, t) {
  var r = [];
  if (t === "replaceAll")
    return r;
  for (var i = 0; i < n.length; i++) {
    var a = n[i];
    a && a.id != null && e.set(a.id, i), r.push({
      existing: t === "replaceMerge" || $p(a) ? null : a,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return r;
}
function $Oe(n, e, t, r) {
  $(r, function(i, a) {
    if (!(!i || i.id == null)) {
      var o = um(i.id), s = t.get(o);
      if (s != null) {
        var l = n[s];
        ct(!l.newOption, 'Duplicated option on id "' + o + '".'), l.newOption = i, l.existing = e[s], r[a] = null;
      }
    }
  });
}
function zOe(n, e) {
  $(e, function(t, r) {
    if (!(!t || t.name == null))
      for (var i = 0; i < n.length; i++) {
        var a = n[i].existing;
        if (!n[i].newOption && a && (a.id == null || t.id == null) && !$p(t) && !$p(a) && jG("name", a, t)) {
          n[i].newOption = t, e[r] = null;
          return;
        }
      }
  });
}
function FOe(n, e, t) {
  $(e, function(r) {
    if (r) {
      for (
        var i, a = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (i = n[a]) && (i.newOption || $p(i.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        i.existing && r.id != null && !jG("id", r, i.existing));
      )
        a++;
      i ? (i.newOption = r, i.brandNew = t) : n.push({
        newOption: r,
        brandNew: t,
        existing: null,
        keyInfo: null
      }), a++;
    }
  });
}
function VOe(n, e) {
  $(e, function(t) {
    n.push({
      newOption: t,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function HOe(n) {
  var e = tt();
  $(n, function(t) {
    var r = t.existing;
    r && e.set(r.id, t);
  }), $(n, function(t) {
    var r = t.newOption;
    ct(!r || r.id == null || !e.get(r.id) || e.get(r.id) === t, "id duplicates: " + (r && r.id)), r && r.id != null && e.set(r.id, t), !t.keyInfo && (t.keyInfo = {});
  }), $(n, function(t, r) {
    var i = t.existing, a = t.newOption, o = t.keyInfo;
    if (ut(a)) {
      if (o.name = a.name != null ? um(a.name) : i ? i.name : NG + r, i)
        o.id = um(i.id);
      else if (a.id != null)
        o.id = um(a.id);
      else {
        var s = 0;
        do
          o.id = "\0" + o.name + "\0" + s++;
        while (e.get(o.id));
      }
      e.set(o.id, t);
    }
  });
}
function jG(n, e, t) {
  var r = wr(e[n], null), i = wr(t[n], null);
  return r != null && i != null && r === i;
}
function um(n) {
  if (process.env.NODE_ENV !== "production" && n == null)
    throw new Error();
  return wr(n, "");
}
function wr(n, e) {
  return n == null ? e : We(n) ? n : sn(n) || Hb(n) ? n + "" : e;
}
function B3(n) {
  process.env.NODE_ENV !== "production" && Jn("`" + n + "` is invalid id or name. Must be a string or number.");
}
function $3(n) {
  return Hb(n) || OD(n);
}
function ID(n) {
  var e = n.name;
  return !!(e && e.indexOf(NG));
}
function $p(n) {
  return n && n.id != null && um(n.id).indexOf(RG) === 0;
}
function GOe(n) {
  return RG + n;
}
function UOe(n, e, t) {
  $(n, function(r) {
    var i = r.newOption;
    ut(i) && (r.keyInfo.mainType = e, r.keyInfo.subType = WOe(e, i, r.existing, t));
  });
}
function WOe(n, e, t, r) {
  var i = e.type ? e.type : t ? t.subType : r.determineSubType(n, e);
  return i;
}
function qOe(n, e) {
  var t = {}, r = {};
  return i(n || [], t), i(e || [], r, t), [a(t), a(r)];
  function i(o, s, l) {
    for (var u = 0, c = o.length; u < c; u++) {
      var d = wr(o[u].seriesId, null);
      if (d == null)
        return;
      for (var f = wn(o[u].dataIndex), p = l && l[d], h = 0, v = f.length; h < v; h++) {
        var m = f[h];
        p && p[m] ? p[m] = null : (s[d] || (s[d] = {}))[m] = 1;
      }
    }
  }
  function a(o, s) {
    var l = [];
    for (var u in o)
      if (o.hasOwnProperty(u) && o[u] != null)
        if (s)
          l.push(+u);
        else {
          var c = a(o[u], !0);
          c.length && l.push({
            seriesId: u,
            dataIndex: c
          });
        }
    return l;
  }
}
function Id(n, e) {
  if (e.dataIndexInside != null)
    return e.dataIndexInside;
  if (e.dataIndex != null)
    return Me(e.dataIndex) ? De(e.dataIndex, function(t) {
      return n.indexOfRawIndex(t);
    }) : n.indexOfRawIndex(e.dataIndex);
  if (e.name != null)
    return Me(e.name) ? De(e.name, function(t) {
      return n.indexOfName(t);
    }) : n.indexOfName(e.name);
}
function en() {
  var n = "__ec_inner_" + YOe++;
  return function(e) {
    return e[n] || (e[n] = {});
  };
}
var YOe = IG();
function cm(n, e, t) {
  var r = LD(e, t), i = r.mainTypeSpecified, a = r.queryOptionMap, o = r.others, s = o, l = t ? t.defaultMainType : null;
  return !i && l && a.set(l, {}), a.each(function(u, c) {
    var d = Fg(n, c, u, {
      useDefault: l === c,
      enableAll: t && t.enableAll != null ? t.enableAll : !0,
      enableNone: t && t.enableNone != null ? t.enableNone : !0
    });
    s[c + "Models"] = d.models, s[c + "Model"] = d.models[0];
  }), s;
}
function LD(n, e) {
  var t;
  if (We(n)) {
    var r = {};
    r[n + "Index"] = 0, t = r;
  } else
    t = n;
  var i = tt(), a = {}, o = !1;
  return $(t, function(s, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      a[l] = s;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], d = (u[2] || "").toLowerCase();
    if (!(!c || !d || e && e.includeMainTypes && Pt(e.includeMainTypes, c) < 0)) {
      o = o || !!c;
      var f = i.get(c) || i.set(c, {});
      f[d] = s;
    }
  }), {
    mainTypeSpecified: o,
    queryOptionMap: i,
    others: a
  };
}
var gr = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
}, KOe = {
  useDefault: !1,
  enableAll: !0,
  enableNone: !0
};
function Fg(n, e, t, r) {
  r = r || gr;
  var i = t.index, a = t.id, o = t.name, s = {
    models: null,
    specified: i != null || a != null || o != null
  };
  if (!s.specified) {
    var l = void 0;
    return s.models = r.useDefault && (l = n.getComponent(e)) ? [l] : [], s;
  }
  return i === "none" || i === !1 ? (ct(r.enableNone, '`"none"` or `false` is not a valid value on index option.'), s.models = [], s) : (i === "all" && (ct(r.enableAll, '`"all"` is not a valid value on index option.'), i = a = o = null), s.models = n.queryComponents({
    mainType: e,
    index: i,
    id: a,
    name: o
  }), s);
}
function BG(n, e, t) {
  n.setAttribute ? n.setAttribute(e, t) : n[e] = t;
}
function XOe(n, e) {
  return n.getAttribute ? n.getAttribute(e) : n[e];
}
function ZOe(n) {
  return n === "auto" ? Vt.domSupported ? "html" : "richText" : n || "html";
}
function ok(n, e) {
  var t = tt(), r = [];
  return $(n, function(i) {
    var a = e(i);
    (t.get(a) || (r.push(a), t.set(a, []))).push(i);
  }), {
    keys: r,
    buckets: t
  };
}
function $G(n, e, t, r, i) {
  var a = e == null || e === "auto";
  if (r == null)
    return r;
  if (sn(r)) {
    var o = P3(t || 0, r, i);
    return ir(o, a ? Math.max(ss(t || 0), ss(r)) : e);
  } else {
    if (We(r))
      return i < 1 ? t : r;
    for (var s = [], l = t, u = r, c = Math.max(l ? l.length : 0, u.length), d = 0; d < c; ++d) {
      var f = n.getDimensionInfo(d);
      if (f && f.type === "ordinal")
        s[d] = (i < 1 && l ? l : u)[d];
      else {
        var p = l && l[d] ? l[d] : 0, h = u[d], o = P3(p, h, i);
        s[d] = ir(o, a ? Math.max(ss(p), ss(h)) : e);
      }
    }
    return s;
  }
}
var JOe = ".", ac = "___EC__COMPONENT__CONTAINER___", zG = "___EC__EXTENDED_CLASS___";
function ls(n) {
  var e = {
    main: "",
    sub: ""
  };
  if (n) {
    var t = n.split(JOe);
    e.main = t[0] || "", e.sub = t[1] || "";
  }
  return e;
}
function QOe(n) {
  ct(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(n), 'componentType "' + n + '" illegal');
}
function eIe(n) {
  return !!(n && n[zG]);
}
function ND(n, e) {
  n.$constructor = n, n.extend = function(t) {
    process.env.NODE_ENV !== "production" && $(e, function(a) {
      t[a] || console.warn("Method `" + a + "` should be implemented" + (t.type ? " in " + t.type : "") + ".");
    });
    var r = this, i;
    return tIe(r) ? i = /** @class */
    function(a) {
      le(o, a);
      function o() {
        return a.apply(this, arguments) || this;
      }
      return o;
    }(r) : (i = function() {
      (t.$constructor || r).apply(this, arguments);
    }, lDe(i, this)), xe(i.prototype, t), i[zG] = !0, i.extend = this.extend, i.superCall = iIe, i.superApply = aIe, i.superClass = r, i;
  };
}
function tIe(n) {
  return at(n) && /^class\s/.test(Function.prototype.toString.call(n));
}
function FG(n, e) {
  n.extend = e.extend;
}
var nIe = Math.round(Math.random() * 10);
function rIe(n) {
  var e = ["__\0is_clz", nIe++].join("_");
  n.prototype[e] = !0, process.env.NODE_ENV !== "production" && ct(!n.isInstance, 'The method "is" can not be defined.'), n.isInstance = function(t) {
    return !!(t && t[e]);
  };
}
function iIe(n, e) {
  for (var t = [], r = 2; r < arguments.length; r++)
    t[r - 2] = arguments[r];
  return this.superClass.prototype[e].apply(n, t);
}
function aIe(n, e, t) {
  return this.superClass.prototype[e].apply(n, t);
}
function Jx(n) {
  var e = {};
  n.registerClass = function(r) {
    var i = r.type || r.prototype.type;
    if (i) {
      QOe(i), r.prototype.type = i;
      var a = ls(i);
      if (!a.sub)
        process.env.NODE_ENV !== "production" && e[a.main] && console.warn(a.main + " exists."), e[a.main] = r;
      else if (a.sub !== ac) {
        var o = t(a);
        o[a.sub] = r;
      }
    }
    return r;
  }, n.getClass = function(r, i, a) {
    var o = e[r];
    if (o && o[ac] && (o = i ? o[i] : null), a && !o)
      throw new Error(i ? "Component " + r + "." + (i || "") + " is used but not imported." : r + ".type should be specified.");
    return o;
  }, n.getClassesByMainType = function(r) {
    var i = ls(r), a = [], o = e[i.main];
    return o && o[ac] ? $(o, function(s, l) {
      l !== ac && a.push(s);
    }) : a.push(o), a;
  }, n.hasClass = function(r) {
    var i = ls(r);
    return !!e[i.main];
  }, n.getAllClassMainTypes = function() {
    var r = [];
    return $(e, function(i, a) {
      r.push(a);
    }), r;
  }, n.hasSubTypes = function(r) {
    var i = ls(r), a = e[i.main];
    return a && a[ac];
  };
  function t(r) {
    var i = e[r.main];
    return (!i || !i[ac]) && (i = e[r.main] = {}, i[ac] = !0), i;
  }
}
function Ld(n, e) {
  for (var t = 0; t < n.length; t++)
    n[t][1] || (n[t][1] = n[t][0]);
  return e = e || !1, function(r, i, a) {
    for (var o = {}, s = 0; s < n.length; s++) {
      var l = n[s][1];
      if (!(i && Pt(i, l) >= 0 || a && Pt(a, l) < 0)) {
        var u = r.getShallow(l, e);
        u != null && (o[n[s][0]] = u);
      }
    }
    return o;
  };
}
var oIe = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], sIe = Ld(oIe), lIe = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getAreaStyle = function(e, t) {
      return sIe(this, e, t);
    }, n;
  }()
), sk = new $g(50);
function uIe(n) {
  if (typeof n == "string") {
    var e = sk.get(n);
    return e && e.image;
  } else
    return n;
}
function RD(n, e, t, r, i) {
  if (n)
    if (typeof n == "string") {
      if (e && e.__zrImageSrc === n || !t)
        return e;
      var a = sk.get(n), o = { hostEl: t, cb: r, cbPayload: i };
      return a ? (e = a.image, !Qx(e) && a.pending.push(o)) : (e = Lu.loadImage(n, z3, z3), e.__zrImageSrc = n, sk.put(n, e.__cachedImgObj = {
        image: e,
        pending: [o]
      })), e;
    } else
      return n;
  else return e;
}
function z3() {
  var n = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var e = 0; e < n.pending.length; e++) {
    var t = n.pending[e], r = t.cb;
    r && r(this, t.cbPayload), t.hostEl.dirty();
  }
  n.pending.length = 0;
}
function Qx(n) {
  return n && n.width && n.height;
}
var f2 = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function cIe(n, e, t, r, i, a) {
  if (!t) {
    n.text = "", n.isTruncated = !1;
    return;
  }
  var o = (e + "").split(`
`);
  a = VG(t, r, i, a);
  for (var s = !1, l = {}, u = 0, c = o.length; u < c; u++)
    HG(l, o[u], a), o[u] = l.textLine, s = s || l.isTruncated;
  n.text = o.join(`
`), n.isTruncated = s;
}
function VG(n, e, t, r) {
  r = r || {};
  var i = xe({}, r);
  i.font = e, t = bt(t, "..."), i.maxIterations = bt(r.maxIterations, 2);
  var a = i.minChar = bt(r.minChar, 0);
  i.cnCharWidth = _a("国", e);
  var o = i.ascCharWidth = _a("a", e);
  i.placeholder = bt(r.placeholder, "");
  for (var s = n = Math.max(0, n - 1), l = 0; l < a && s >= o; l++)
    s -= o;
  var u = _a(t, e);
  return u > s && (t = "", u = 0), s = n - u, i.ellipsis = t, i.ellipsisWidth = u, i.contentWidth = s, i.containerWidth = n, i;
}
function HG(n, e, t) {
  var r = t.containerWidth, i = t.font, a = t.contentWidth;
  if (!r) {
    n.textLine = "", n.isTruncated = !1;
    return;
  }
  var o = _a(e, i);
  if (o <= r) {
    n.textLine = e, n.isTruncated = !1;
    return;
  }
  for (var s = 0; ; s++) {
    if (o <= a || s >= t.maxIterations) {
      e += t.ellipsis;
      break;
    }
    var l = s === 0 ? dIe(e, a, t.ascCharWidth, t.cnCharWidth) : o > 0 ? Math.floor(e.length * a / o) : 0;
    e = e.substr(0, l), o = _a(e, i);
  }
  e === "" && (e = t.placeholder), n.textLine = e, n.isTruncated = !0;
}
function dIe(n, e, t, r) {
  for (var i = 0, a = 0, o = n.length; a < o && i < e; a++) {
    var s = n.charCodeAt(a);
    i += 0 <= s && s <= 127 ? t : r;
  }
  return a;
}
function fIe(n, e) {
  n != null && (n += "");
  var t = e.overflow, r = e.padding, i = e.font, a = t === "truncate", o = Yx(i), s = bt(e.lineHeight, o), l = !!e.backgroundColor, u = e.lineOverflow === "truncate", c = !1, d = e.width, f;
  d != null && (t === "break" || t === "breakAll") ? f = n ? GG(n, e.font, d, t === "breakAll", 0).lines : [] : f = n ? n.split(`
`) : [];
  var p = f.length * s, h = bt(e.height, p);
  if (p > h && u) {
    var v = Math.floor(h / s);
    c = c || f.length > v, f = f.slice(0, v);
  }
  if (n && a && d != null)
    for (var m = VG(d, i, e.ellipsis, {
      minChar: e.truncateMinChar,
      placeholder: e.placeholder
    }), g = {}, y = 0; y < f.length; y++)
      HG(g, f[y], m), f[y] = g.textLine, c = c || g.isTruncated;
  for (var b = h, _ = 0, y = 0; y < f.length; y++)
    _ = Math.max(_a(f[y], i), _);
  d == null && (d = _);
  var x = _;
  return r && (b += r[0] + r[2], x += r[1] + r[3], d += r[1] + r[3]), l && (x = d), {
    lines: f,
    height: h,
    outerWidth: x,
    outerHeight: b,
    lineHeight: s,
    calculatedLineHeight: o,
    contentWidth: _,
    contentHeight: p,
    width: d,
    isTruncated: c
  };
}
var pIe = /* @__PURE__ */ function() {
  function n() {
  }
  return n;
}(), F3 = /* @__PURE__ */ function() {
  function n(e) {
    this.tokens = [], e && (this.tokens = e);
  }
  return n;
}(), hIe = /* @__PURE__ */ function() {
  function n() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = !1;
  }
  return n;
}();
function vIe(n, e) {
  var t = new hIe();
  if (n != null && (n += ""), !n)
    return t;
  for (var r = e.width, i = e.height, a = e.overflow, o = (a === "break" || a === "breakAll") && r != null ? { width: r, accumWidth: 0, breakAll: a === "breakAll" } : null, s = f2.lastIndex = 0, l; (l = f2.exec(n)) != null; ) {
    var u = l.index;
    u > s && p2(t, n.substring(s, u), e, o), p2(t, l[2], e, o, l[1]), s = f2.lastIndex;
  }
  s < n.length && p2(t, n.substring(s, n.length), e, o);
  var c = [], d = 0, f = 0, p = e.padding, h = a === "truncate", v = e.lineOverflow === "truncate", m = {};
  function g(ne, J, X) {
    ne.width = J, ne.lineHeight = X, d += X, f = Math.max(f, J);
  }
  e: for (var y = 0; y < t.lines.length; y++) {
    for (var b = t.lines[y], _ = 0, x = 0, w = 0; w < b.tokens.length; w++) {
      var S = b.tokens[w], C = S.styleName && e.rich[S.styleName] || {}, k = S.textPadding = C.padding, M = k ? k[1] + k[3] : 0, D = S.font = C.font || e.font;
      S.contentHeight = Yx(D);
      var N = bt(C.height, S.contentHeight);
      if (S.innerHeight = N, k && (N += k[0] + k[2]), S.height = N, S.lineHeight = Za(C.lineHeight, e.lineHeight, N), S.align = C && C.align || e.align, S.verticalAlign = C && C.verticalAlign || "middle", v && i != null && d + S.lineHeight > i) {
        var R = t.lines.length;
        w > 0 ? (b.tokens = b.tokens.slice(0, w), g(b, x, _), t.lines = t.lines.slice(0, y + 1)) : t.lines = t.lines.slice(0, y), t.isTruncated = t.isTruncated || t.lines.length < R;
        break e;
      }
      var j = C.width, z = j == null || j === "auto";
      if (typeof j == "string" && j.charAt(j.length - 1) === "%")
        S.percentWidth = j, c.push(S), S.contentWidth = _a(S.text, D);
      else {
        if (z) {
          var F = C.backgroundColor, B = F && F.image;
          B && (B = uIe(B), Qx(B) && (S.width = Math.max(S.width, B.width * N / B.height)));
        }
        var H = h && r != null ? r - x : null;
        H != null && H < S.width ? !z || H < M ? (S.text = "", S.width = S.contentWidth = 0) : (cIe(m, S.text, H - M, D, e.ellipsis, { minChar: e.truncateMinChar }), S.text = m.text, t.isTruncated = t.isTruncated || m.isTruncated, S.width = S.contentWidth = _a(S.text, D)) : S.contentWidth = _a(S.text, D);
      }
      S.width += M, x += S.width, C && (_ = Math.max(_, S.lineHeight));
    }
    g(b, x, _);
  }
  t.outerWidth = t.width = bt(r, f), t.outerHeight = t.height = bt(i, d), t.contentHeight = d, t.contentWidth = f, p && (t.outerWidth += p[1] + p[3], t.outerHeight += p[0] + p[2]);
  for (var y = 0; y < c.length; y++) {
    var S = c[y], Y = S.percentWidth;
    S.width = parseInt(Y, 10) / 100 * t.width;
  }
  return t;
}
function p2(n, e, t, r, i) {
  var a = e === "", o = i && t.rich[i] || {}, s = n.lines, l = o.font || t.font, u = !1, c, d;
  if (r) {
    var f = o.padding, p = f ? f[1] + f[3] : 0;
    if (o.width != null && o.width !== "auto") {
      var h = Mo(o.width, r.width) + p;
      s.length > 0 && h + r.accumWidth > r.width && (c = e.split(`
`), u = !0), r.accumWidth = h;
    } else {
      var v = GG(e, l, r.width, r.breakAll, r.accumWidth);
      r.accumWidth = v.accumWidth + p, d = v.linesWidths, c = v.lines;
    }
  } else
    c = e.split(`
`);
  for (var m = 0; m < c.length; m++) {
    var g = c[m], y = new pIe();
    if (y.styleName = i, y.text = g, y.isLineHolder = !g && !a, typeof o.width == "number" ? y.width = o.width : y.width = d ? d[m] : _a(g, l), !m && !u) {
      var b = (s[s.length - 1] || (s[0] = new F3())).tokens, _ = b.length;
      _ === 1 && b[0].isLineHolder ? b[0] = y : (g || !_ || a) && b.push(y);
    } else
      s.push(new F3([y]));
  }
}
function mIe(n) {
  var e = n.charCodeAt(0);
  return e >= 32 && e <= 591 || e >= 880 && e <= 4351 || e >= 4608 && e <= 5119 || e >= 7680 && e <= 8303;
}
var gIe = xs(",&?/;] ".split(""), function(n, e) {
  return n[e] = !0, n;
}, {});
function yIe(n) {
  return mIe(n) ? !!gIe[n] : !0;
}
function GG(n, e, t, r, i) {
  for (var a = [], o = [], s = "", l = "", u = 0, c = 0, d = 0; d < n.length; d++) {
    var f = n.charAt(d);
    if (f === `
`) {
      l && (s += l, c += u), a.push(s), o.push(c), s = "", l = "", u = 0, c = 0;
      continue;
    }
    var p = _a(f, e), h = r ? !1 : !yIe(f);
    if (a.length ? c + p > t : i + c + p > t) {
      c ? (s || l) && (h ? (s || (s = l, l = "", u = 0, c = u), a.push(s), o.push(c - u), l += f, u += p, s = "", c = u) : (l && (s += l, l = "", u = 0), a.push(s), o.push(c), s = f, c = p)) : h ? (a.push(l), o.push(u), l = f, u = p) : (a.push(f), o.push(p));
      continue;
    }
    c += p, h ? (l += f, u += p) : (l && (s += l, l = "", u = 0), s += f);
  }
  return !a.length && !s && (s = n, l = "", u = 0), l && (s += l), s && (a.push(s), o.push(c)), a.length === 1 && (c += i), {
    accumWidth: c,
    lines: a,
    linesWidths: o
  };
}
var lk = "__zr_style_" + Math.round(Math.random() * 10), fd = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, ew = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
fd[lk] = !0;
var V3 = ["z", "z2", "invisible"], bIe = ["invisible"], no = function(n) {
  le(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype._init = function(t) {
    for (var r = Yt(t), i = 0; i < r.length; i++) {
      var a = r[i];
      a === "style" ? this.useStyle(t[a]) : n.prototype.attrKV.call(this, a, t[a]);
    }
    this.style || this.useStyle({});
  }, e.prototype.beforeBrush = function() {
  }, e.prototype.afterBrush = function() {
  }, e.prototype.innerBeforeBrush = function() {
  }, e.prototype.innerAfterBrush = function() {
  }, e.prototype.shouldBePainted = function(t, r, i, a) {
    var o = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && _Ie(this, t, r) || o && !o[0] && !o[3])
      return !1;
    if (i && this.__clipPaths) {
      for (var s = 0; s < this.__clipPaths.length; ++s)
        if (this.__clipPaths[s].isZeroArea())
          return !1;
    }
    if (a && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, e.prototype.contain = function(t, r) {
    return this.rectContain(t, r);
  }, e.prototype.traverse = function(t, r) {
    t.call(r, this);
  }, e.prototype.rectContain = function(t, r) {
    var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect();
    return a.contain(i[0], i[1]);
  }, e.prototype.getPaintRect = function() {
    var t = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var r = this.transform, i = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
      t = this._paintRect || (this._paintRect = new Ot(0, 0, 0, 0)), r ? Ot.applyTransform(t, i, r) : t.copy(i), (o || s || l) && (t.width += o * 2 + Math.abs(s), t.height += o * 2 + Math.abs(l), t.x = Math.min(t.x, t.x + s - o), t.y = Math.min(t.y, t.y + l - o));
      var u = this.dirtyRectTolerance;
      t.isZero() || (t.x = Math.floor(t.x - u), t.y = Math.floor(t.y - u), t.width = Math.ceil(t.width + 1 + u * 2), t.height = Math.ceil(t.height + 1 + u * 2));
    }
    return t;
  }, e.prototype.setPrevPaintRect = function(t) {
    t ? (this._prevPaintRect = this._prevPaintRect || new Ot(0, 0, 0, 0), this._prevPaintRect.copy(t)) : this._prevPaintRect = null;
  }, e.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, e.prototype.animateStyle = function(t) {
    return this.animate("style", t);
  }, e.prototype.updateDuringAnimation = function(t) {
    t === "style" ? this.dirtyStyle() : this.markRedraw();
  }, e.prototype.attrKV = function(t, r) {
    t !== "style" ? n.prototype.attrKV.call(this, t, r) : this.style ? this.setStyle(r) : this.useStyle(r);
  }, e.prototype.setStyle = function(t, r) {
    return typeof t == "string" ? this.style[t] = r : xe(this.style, t), this.dirtyStyle(), this;
  }, e.prototype.dirtyStyle = function(t) {
    t || this.markRedraw(), this.__dirty |= Cv, this._rect && (this._rect = null);
  }, e.prototype.dirty = function() {
    this.dirtyStyle();
  }, e.prototype.styleChanged = function() {
    return !!(this.__dirty & Cv);
  }, e.prototype.styleUpdated = function() {
    this.__dirty &= ~Cv;
  }, e.prototype.createStyle = function(t) {
    return Ux(fd, t);
  }, e.prototype.useStyle = function(t) {
    t[lk] || (t = this.createStyle(t)), this.__inHover ? this.__hoverStyle = t : this.style = t, this.dirtyStyle();
  }, e.prototype.isStyleObject = function(t) {
    return t[lk];
  }, e.prototype._innerSaveToNormal = function(t) {
    n.prototype._innerSaveToNormal.call(this, t);
    var r = this._normalState;
    t.style && !r.style && (r.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(t, r, V3);
  }, e.prototype._applyStateObj = function(t, r, i, a, o, s) {
    n.prototype._applyStateObj.call(this, t, r, i, a, o, s);
    var l = !(r && a), u;
    if (r && r.style ? o ? a ? u = r.style : (u = this._mergeStyle(this.createStyle(), i.style), this._mergeStyle(u, r.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : i.style), this._mergeStyle(u, r.style)) : l && (u = i.style), u)
      if (o) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l)
          for (var d = Yt(c), f = 0; f < d.length; f++) {
            var p = d[f];
            p in u && (u[p] = u[p], this.style[p] = c[p]);
          }
        for (var h = Yt(u), f = 0; f < h.length; f++) {
          var p = h[f];
          this.style[p] = this.style[p];
        }
        this._transitionState(t, {
          style: u
        }, s, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var v = this.__inHover ? bIe : V3, f = 0; f < v.length; f++) {
      var p = v[f];
      r && r[p] != null ? this[p] = r[p] : l && i[p] != null && (this[p] = i[p]);
    }
  }, e.prototype._mergeStates = function(t) {
    for (var r = n.prototype._mergeStates.call(this, t), i, a = 0; a < t.length; a++) {
      var o = t[a];
      o.style && (i = i || {}, this._mergeStyle(i, o.style));
    }
    return i && (r.style = i), r;
  }, e.prototype._mergeStyle = function(t, r) {
    return xe(t, r), t;
  }, e.prototype.getAnimationStyleProps = function() {
    return ew;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.type = "displayable", t.invisible = !1, t.z = 0, t.z2 = 0, t.zlevel = 0, t.culling = !1, t.cursor = "pointer", t.rectHover = !1, t.incremental = !1, t._rect = null, t.dirtyRectTolerance = 0, t.__dirty = pa | Cv;
  }(), e;
}(Kx), h2 = new Ot(0, 0, 0, 0), v2 = new Ot(0, 0, 0, 0);
function _Ie(n, e, t) {
  return h2.copy(n.getBoundingRect()), n.transform && h2.applyTransform(n.transform), v2.width = e, v2.height = t, !h2.intersect(v2);
}
var qi = Math.min, Yi = Math.max, m2 = Math.sin, g2 = Math.cos, oc = Math.PI * 2, c0 = Xd(), d0 = Xd(), f0 = Xd();
function tw(n, e, t) {
  if (n.length !== 0) {
    for (var r = n[0], i = r[0], a = r[0], o = r[1], s = r[1], l = 1; l < n.length; l++)
      r = n[l], i = qi(i, r[0]), a = Yi(a, r[0]), o = qi(o, r[1]), s = Yi(s, r[1]);
    e[0] = i, e[1] = o, t[0] = a, t[1] = s;
  }
}
function H3(n, e, t, r, i, a) {
  i[0] = qi(n, t), i[1] = qi(e, r), a[0] = Yi(n, t), a[1] = Yi(e, r);
}
var G3 = [], U3 = [];
function xIe(n, e, t, r, i, a, o, s, l, u) {
  var c = cG, d = Ar, f = c(n, t, i, o, G3);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var p = 0; p < f; p++) {
    var h = d(n, t, i, o, G3[p]);
    l[0] = qi(h, l[0]), u[0] = Yi(h, u[0]);
  }
  f = c(e, r, a, s, U3);
  for (var p = 0; p < f; p++) {
    var v = d(e, r, a, s, U3[p]);
    l[1] = qi(v, l[1]), u[1] = Yi(v, u[1]);
  }
  l[0] = qi(n, l[0]), u[0] = Yi(n, u[0]), l[0] = qi(o, l[0]), u[0] = Yi(o, u[0]), l[1] = qi(e, l[1]), u[1] = Yi(e, u[1]), l[1] = qi(s, l[1]), u[1] = Yi(s, u[1]);
}
function wIe(n, e, t, r, i, a, o, s) {
  var l = fG, u = Br, c = Yi(qi(l(n, t, i), 1), 0), d = Yi(qi(l(e, r, a), 1), 0), f = u(n, t, i, c), p = u(e, r, a, d);
  o[0] = qi(n, i, f), o[1] = qi(e, a, p), s[0] = Yi(n, i, f), s[1] = Yi(e, a, p);
}
function SIe(n, e, t, r, i, a, o, s, l) {
  var u = fu, c = pu, d = Math.abs(i - a);
  if (d % oc < 1e-4 && d > 1e-4) {
    s[0] = n - t, s[1] = e - r, l[0] = n + t, l[1] = e + r;
    return;
  }
  if (c0[0] = g2(i) * t + n, c0[1] = m2(i) * r + e, d0[0] = g2(a) * t + n, d0[1] = m2(a) * r + e, u(s, c0, d0), c(l, c0, d0), i = i % oc, i < 0 && (i = i + oc), a = a % oc, a < 0 && (a = a + oc), i > a && !o ? a += oc : i < a && o && (i += oc), o) {
    var f = a;
    a = i, i = f;
  }
  for (var p = 0; p < a; p += Math.PI / 2)
    p > i && (f0[0] = g2(p) * t + n, f0[1] = m2(p) * r + e, u(s, f0, s), c(l, f0, l));
}
var kn = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, sc = [], lc = [], $o = [], Bl = [], zo = [], Fo = [], y2 = Math.min, b2 = Math.max, uc = Math.cos, cc = Math.sin, Bs = Math.abs, uk = Math.PI, Kl = uk * 2, _2 = typeof Float32Array < "u", Zh = [];
function x2(n) {
  var e = Math.round(n / uk * 1e8) / 1e8;
  return e % 2 * uk;
}
function PD(n, e) {
  var t = x2(n[0]);
  t < 0 && (t += Kl);
  var r = t - n[0], i = n[1];
  i += r, !e && i - t >= Kl ? i = t + Kl : e && t - i >= Kl ? i = t - Kl : !e && t > i ? i = t + (Kl - x2(t - i)) : e && t < i && (i = t - (Kl - x2(i - t))), n[0] = t, n[1] = i;
}
var Ts = function() {
  function n(e) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, e && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return n.prototype.increaseVersion = function() {
    this._version++;
  }, n.prototype.getVersion = function() {
    return this._version;
  }, n.prototype.setScale = function(e, t, r) {
    r = r || 0, r > 0 && (this._ux = Bs(r / Zb / e) || 0, this._uy = Bs(r / Zb / t) || 0);
  }, n.prototype.setDPR = function(e) {
    this.dpr = e;
  }, n.prototype.setContext = function(e) {
    this._ctx = e;
  }, n.prototype.getContext = function() {
    return this._ctx;
  }, n.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, n.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, n.prototype.moveTo = function(e, t) {
    return this._drawPendingPt(), this.addData(kn.M, e, t), this._ctx && this._ctx.moveTo(e, t), this._x0 = e, this._y0 = t, this._xi = e, this._yi = t, this;
  }, n.prototype.lineTo = function(e, t) {
    var r = Bs(e - this._xi), i = Bs(t - this._yi), a = r > this._ux || i > this._uy;
    if (this.addData(kn.L, e, t), this._ctx && a && this._ctx.lineTo(e, t), a)
      this._xi = e, this._yi = t, this._pendingPtDist = 0;
    else {
      var o = r * r + i * i;
      o > this._pendingPtDist && (this._pendingPtX = e, this._pendingPtY = t, this._pendingPtDist = o);
    }
    return this;
  }, n.prototype.bezierCurveTo = function(e, t, r, i, a, o) {
    return this._drawPendingPt(), this.addData(kn.C, e, t, r, i, a, o), this._ctx && this._ctx.bezierCurveTo(e, t, r, i, a, o), this._xi = a, this._yi = o, this;
  }, n.prototype.quadraticCurveTo = function(e, t, r, i) {
    return this._drawPendingPt(), this.addData(kn.Q, e, t, r, i), this._ctx && this._ctx.quadraticCurveTo(e, t, r, i), this._xi = r, this._yi = i, this;
  }, n.prototype.arc = function(e, t, r, i, a, o) {
    this._drawPendingPt(), Zh[0] = i, Zh[1] = a, PD(Zh, o), i = Zh[0], a = Zh[1];
    var s = a - i;
    return this.addData(kn.A, e, t, r, r, i, s, 0, o ? 0 : 1), this._ctx && this._ctx.arc(e, t, r, i, a, o), this._xi = uc(a) * r + e, this._yi = cc(a) * r + t, this;
  }, n.prototype.arcTo = function(e, t, r, i, a) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(e, t, r, i, a), this;
  }, n.prototype.rect = function(e, t, r, i) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(e, t, r, i), this.addData(kn.R, e, t, r, i), this;
  }, n.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(kn.Z);
    var e = this._ctx, t = this._x0, r = this._y0;
    return e && e.closePath(), this._xi = t, this._yi = r, this;
  }, n.prototype.fill = function(e) {
    e && e.fill(), this.toStatic();
  }, n.prototype.stroke = function(e) {
    e && e.stroke(), this.toStatic();
  }, n.prototype.len = function() {
    return this._len;
  }, n.prototype.setData = function(e) {
    var t = e.length;
    !(this.data && this.data.length === t) && _2 && (this.data = new Float32Array(t));
    for (var r = 0; r < t; r++)
      this.data[r] = e[r];
    this._len = t;
  }, n.prototype.appendPath = function(e) {
    e instanceof Array || (e = [e]);
    for (var t = e.length, r = 0, i = this._len, a = 0; a < t; a++)
      r += e[a].len();
    _2 && this.data instanceof Float32Array && (this.data = new Float32Array(i + r));
    for (var a = 0; a < t; a++)
      for (var o = e[a].data, s = 0; s < o.length; s++)
        this.data[i++] = o[s];
    this._len = i;
  }, n.prototype.addData = function(e, t, r, i, a, o, s, l, u) {
    if (this._saveData) {
      var c = this.data;
      this._len + arguments.length > c.length && (this._expandData(), c = this.data);
      for (var d = 0; d < arguments.length; d++)
        c[this._len++] = arguments[d];
    }
  }, n.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, n.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var e = [], t = 0; t < this._len; t++)
        e[t] = this.data[t];
      this.data = e;
    }
  }, n.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var e = this.data;
      e instanceof Array && (e.length = this._len, _2 && this._len > 11 && (this.data = new Float32Array(e)));
    }
  }, n.prototype.getBoundingRect = function() {
    $o[0] = $o[1] = zo[0] = zo[1] = Number.MAX_VALUE, Bl[0] = Bl[1] = Fo[0] = Fo[1] = -Number.MAX_VALUE;
    var e = this.data, t = 0, r = 0, i = 0, a = 0, o;
    for (o = 0; o < this._len; ) {
      var s = e[o++], l = o === 1;
      switch (l && (t = e[o], r = e[o + 1], i = t, a = r), s) {
        case kn.M:
          t = i = e[o++], r = a = e[o++], zo[0] = i, zo[1] = a, Fo[0] = i, Fo[1] = a;
          break;
        case kn.L:
          H3(t, r, e[o], e[o + 1], zo, Fo), t = e[o++], r = e[o++];
          break;
        case kn.C:
          xIe(t, r, e[o++], e[o++], e[o++], e[o++], e[o], e[o + 1], zo, Fo), t = e[o++], r = e[o++];
          break;
        case kn.Q:
          wIe(t, r, e[o++], e[o++], e[o], e[o + 1], zo, Fo), t = e[o++], r = e[o++];
          break;
        case kn.A:
          var u = e[o++], c = e[o++], d = e[o++], f = e[o++], p = e[o++], h = e[o++] + p;
          o += 1;
          var v = !e[o++];
          l && (i = uc(p) * d + u, a = cc(p) * f + c), SIe(u, c, d, f, p, h, v, zo, Fo), t = uc(h) * d + u, r = cc(h) * f + c;
          break;
        case kn.R:
          i = t = e[o++], a = r = e[o++];
          var m = e[o++], g = e[o++];
          H3(i, a, i + m, a + g, zo, Fo);
          break;
        case kn.Z:
          t = i, r = a;
          break;
      }
      fu($o, $o, zo), pu(Bl, Bl, Fo);
    }
    return o === 0 && ($o[0] = $o[1] = Bl[0] = Bl[1] = 0), new Ot($o[0], $o[1], Bl[0] - $o[0], Bl[1] - $o[1]);
  }, n.prototype._calculateLength = function() {
    var e = this.data, t = this._len, r = this._ux, i = this._uy, a = 0, o = 0, s = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, c = 0, d = 0, f = 0; f < t; ) {
      var p = e[f++], h = f === 1;
      h && (a = e[f], o = e[f + 1], s = a, l = o);
      var v = -1;
      switch (p) {
        case kn.M:
          a = s = e[f++], o = l = e[f++];
          break;
        case kn.L: {
          var m = e[f++], g = e[f++], y = m - a, b = g - o;
          (Bs(y) > r || Bs(b) > i || f === t - 1) && (v = Math.sqrt(y * y + b * b), a = m, o = g);
          break;
        }
        case kn.C: {
          var _ = e[f++], x = e[f++], m = e[f++], g = e[f++], w = e[f++], S = e[f++];
          v = FDe(a, o, _, x, m, g, w, S, 10), a = w, o = S;
          break;
        }
        case kn.Q: {
          var _ = e[f++], x = e[f++], m = e[f++], g = e[f++];
          v = HDe(a, o, _, x, m, g, 10), a = m, o = g;
          break;
        }
        case kn.A:
          var C = e[f++], k = e[f++], M = e[f++], D = e[f++], N = e[f++], R = e[f++], j = R + N;
          f += 1, h && (s = uc(N) * M + C, l = cc(N) * D + k), v = b2(M, D) * y2(Kl, Math.abs(R)), a = uc(j) * M + C, o = cc(j) * D + k;
          break;
        case kn.R: {
          s = a = e[f++], l = o = e[f++];
          var z = e[f++], F = e[f++];
          v = z * 2 + F * 2;
          break;
        }
        case kn.Z: {
          var y = s - a, b = l - o;
          v = Math.sqrt(y * y + b * b), a = s, o = l;
          break;
        }
      }
      v >= 0 && (u[d++] = v, c += v);
    }
    return this._pathLen = c, c;
  }, n.prototype.rebuildPath = function(e, t) {
    var r = this.data, i = this._ux, a = this._uy, o = this._len, s, l, u, c, d, f, p = t < 1, h, v, m = 0, g = 0, y, b = 0, _, x;
    if (!(p && (this._pathSegLen || this._calculateLength(), h = this._pathSegLen, v = this._pathLen, y = t * v, !y)))
      e: for (var w = 0; w < o; ) {
        var S = r[w++], C = w === 1;
        switch (C && (u = r[w], c = r[w + 1], s = u, l = c), S !== kn.L && b > 0 && (e.lineTo(_, x), b = 0), S) {
          case kn.M:
            s = u = r[w++], l = c = r[w++], e.moveTo(u, c);
            break;
          case kn.L: {
            d = r[w++], f = r[w++];
            var k = Bs(d - u), M = Bs(f - c);
            if (k > i || M > a) {
              if (p) {
                var D = h[g++];
                if (m + D > y) {
                  var N = (y - m) / D;
                  e.lineTo(u * (1 - N) + d * N, c * (1 - N) + f * N);
                  break e;
                }
                m += D;
              }
              e.lineTo(d, f), u = d, c = f, b = 0;
            } else {
              var R = k * k + M * M;
              R > b && (_ = d, x = f, b = R);
            }
            break;
          }
          case kn.C: {
            var j = r[w++], z = r[w++], F = r[w++], B = r[w++], H = r[w++], Y = r[w++];
            if (p) {
              var D = h[g++];
              if (m + D > y) {
                var N = (y - m) / D;
                Nu(u, j, F, H, N, sc), Nu(c, z, B, Y, N, lc), e.bezierCurveTo(sc[1], lc[1], sc[2], lc[2], sc[3], lc[3]);
                break e;
              }
              m += D;
            }
            e.bezierCurveTo(j, z, F, B, H, Y), u = H, c = Y;
            break;
          }
          case kn.Q: {
            var j = r[w++], z = r[w++], F = r[w++], B = r[w++];
            if (p) {
              var D = h[g++];
              if (m + D > y) {
                var N = (y - m) / D;
                Xm(u, j, F, N, sc), Xm(c, z, B, N, lc), e.quadraticCurveTo(sc[1], lc[1], sc[2], lc[2]);
                break e;
              }
              m += D;
            }
            e.quadraticCurveTo(j, z, F, B), u = F, c = B;
            break;
          }
          case kn.A:
            var ne = r[w++], J = r[w++], X = r[w++], ie = r[w++], ye = r[w++], pe = r[w++], Be = r[w++], Ce = !r[w++], Ee = X > ie ? X : ie, ce = Bs(X - ie) > 1e-3, Pe = ye + pe, Ae = !1;
            if (p) {
              var D = h[g++];
              m + D > y && (Pe = ye + pe * (y - m) / D, Ae = !0), m += D;
            }
            if (ce && e.ellipse ? e.ellipse(ne, J, X, ie, Be, ye, Pe, Ce) : e.arc(ne, J, Ee, ye, Pe, Ce), Ae)
              break e;
            C && (s = uc(ye) * X + ne, l = cc(ye) * ie + J), u = uc(Pe) * X + ne, c = cc(Pe) * ie + J;
            break;
          case kn.R:
            s = u = r[w], l = c = r[w + 1], d = r[w++], f = r[w++];
            var fe = r[w++], oe = r[w++];
            if (p) {
              var D = h[g++];
              if (m + D > y) {
                var he = y - m;
                e.moveTo(d, f), e.lineTo(d + y2(he, fe), f), he -= fe, he > 0 && e.lineTo(d + fe, f + y2(he, oe)), he -= oe, he > 0 && e.lineTo(d + b2(fe - he, 0), f + oe), he -= fe, he > 0 && e.lineTo(d, f + b2(oe - he, 0));
                break e;
              }
              m += D;
            }
            e.rect(d, f, fe, oe);
            break;
          case kn.Z:
            if (p) {
              var D = h[g++];
              if (m + D > y) {
                var N = (y - m) / D;
                e.lineTo(u * (1 - N) + s * N, c * (1 - N) + l * N);
                break e;
              }
              m += D;
            }
            e.closePath(), u = s, c = l;
        }
      }
  }, n.prototype.clone = function() {
    var e = new n(), t = this.data;
    return e.data = t.slice ? t.slice() : Array.prototype.slice.call(t), e._len = this._len, e;
  }, n.CMD = kn, n.initDefaultProps = function() {
    var e = n.prototype;
    e._saveData = !0, e._ux = 0, e._uy = 0, e._pendingPtDist = 0, e._version = 0;
  }(), n;
}();
function eu(n, e, t, r, i, a, o) {
  if (i === 0)
    return !1;
  var s = i, l = 0, u = n;
  if (o > e + s && o > r + s || o < e - s && o < r - s || a > n + s && a > t + s || a < n - s && a < t - s)
    return !1;
  if (n !== t)
    l = (e - r) / (n - t), u = (n * r - t * e) / (n - t);
  else
    return Math.abs(a - n) <= s / 2;
  var c = l * a - o + u, d = c * c / (l * l + 1);
  return d <= s / 2 * s / 2;
}
function EIe(n, e, t, r, i, a, o, s, l, u, c) {
  if (l === 0)
    return !1;
  var d = l;
  if (c > e + d && c > r + d && c > a + d && c > s + d || c < e - d && c < r - d && c < a - d && c < s - d || u > n + d && u > t + d && u > i + d && u > o + d || u < n - d && u < t - d && u < i - d && u < o - d)
    return !1;
  var f = dG(n, e, t, r, i, a, o, s, u, c, null);
  return f <= d / 2;
}
function UG(n, e, t, r, i, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  if (l > e + u && l > r + u && l > a + u || l < e - u && l < r - u && l < a - u || s > n + u && s > t + u && s > i + u || s < n - u && s < t - u && s < i - u)
    return !1;
  var c = pG(n, e, t, r, i, a, s, l, null);
  return c <= u / 2;
}
var W3 = Math.PI * 2;
function va(n) {
  return n %= W3, n < 0 && (n += W3), n;
}
var Jh = Math.PI * 2;
function TIe(n, e, t, r, i, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  s -= n, l -= e;
  var c = Math.sqrt(s * s + l * l);
  if (c - u > t || c + u < t)
    return !1;
  if (Math.abs(r - i) % Jh < 1e-4)
    return !0;
  if (a) {
    var d = r;
    r = va(i), i = va(d);
  } else
    r = va(r), i = va(i);
  r > i && (i += Jh);
  var f = Math.atan2(l, s);
  return f < 0 && (f += Jh), f >= r && f <= i || f + Jh >= r && f + Jh <= i;
}
function Ys(n, e, t, r, i, a) {
  if (a > e && a > r || a < e && a < r || r === e)
    return 0;
  var o = (a - e) / (r - e), s = r < e ? 1 : -1;
  (o === 1 || o === 0) && (s = r < e ? 0.5 : -0.5);
  var l = o * (t - n) + n;
  return l === i ? 1 / 0 : l > i ? s : 0;
}
var $l = Ts.CMD, dc = Math.PI * 2, CIe = 1e-4;
function kIe(n, e) {
  return Math.abs(n - e) < CIe;
}
var Ti = [-1, -1, -1], Ba = [-1, -1];
function AIe() {
  var n = Ba[0];
  Ba[0] = Ba[1], Ba[1] = n;
}
function MIe(n, e, t, r, i, a, o, s, l, u) {
  if (u > e && u > r && u > a && u > s || u < e && u < r && u < a && u < s)
    return 0;
  var c = qb(e, r, a, s, u, Ti);
  if (c === 0)
    return 0;
  for (var d = 0, f = -1, p = void 0, h = void 0, v = 0; v < c; v++) {
    var m = Ti[v], g = m === 0 || m === 1 ? 0.5 : 1, y = Ar(n, t, i, o, m);
    y < l || (f < 0 && (f = cG(e, r, a, s, Ba), Ba[1] < Ba[0] && f > 1 && AIe(), p = Ar(e, r, a, s, Ba[0]), f > 1 && (h = Ar(e, r, a, s, Ba[1]))), f === 2 ? m < Ba[0] ? d += p < e ? g : -g : m < Ba[1] ? d += h < p ? g : -g : d += s < h ? g : -g : m < Ba[0] ? d += p < e ? g : -g : d += s < p ? g : -g);
  }
  return d;
}
function DIe(n, e, t, r, i, a, o, s) {
  if (s > e && s > r && s > a || s < e && s < r && s < a)
    return 0;
  var l = VDe(e, r, a, s, Ti);
  if (l === 0)
    return 0;
  var u = fG(e, r, a);
  if (u >= 0 && u <= 1) {
    for (var c = 0, d = Br(e, r, a, u), f = 0; f < l; f++) {
      var p = Ti[f] === 0 || Ti[f] === 1 ? 0.5 : 1, h = Br(n, t, i, Ti[f]);
      h < o || (Ti[f] < u ? c += d < e ? p : -p : c += a < d ? p : -p);
    }
    return c;
  } else {
    var p = Ti[0] === 0 || Ti[0] === 1 ? 0.5 : 1, h = Br(n, t, i, Ti[0]);
    return h < o ? 0 : a < e ? p : -p;
  }
}
function OIe(n, e, t, r, i, a, o, s) {
  if (s -= e, s > t || s < -t)
    return 0;
  var l = Math.sqrt(t * t - s * s);
  Ti[0] = -l, Ti[1] = l;
  var u = Math.abs(r - i);
  if (u < 1e-4)
    return 0;
  if (u >= dc - 1e-4) {
    r = 0, i = dc;
    var c = a ? 1 : -1;
    return o >= Ti[0] + n && o <= Ti[1] + n ? c : 0;
  }
  if (r > i) {
    var d = r;
    r = i, i = d;
  }
  r < 0 && (r += dc, i += dc);
  for (var f = 0, p = 0; p < 2; p++) {
    var h = Ti[p];
    if (h + n > o) {
      var v = Math.atan2(s, h), c = a ? 1 : -1;
      v < 0 && (v = dc + v), (v >= r && v <= i || v + dc >= r && v + dc <= i) && (v > Math.PI / 2 && v < Math.PI * 1.5 && (c = -c), f += c);
    }
  }
  return f;
}
function WG(n, e, t, r, i) {
  for (var a = n.data, o = n.len(), s = 0, l = 0, u = 0, c = 0, d = 0, f, p, h = 0; h < o; ) {
    var v = a[h++], m = h === 1;
    switch (v === $l.M && h > 1 && (t || (s += Ys(l, u, c, d, r, i))), m && (l = a[h], u = a[h + 1], c = l, d = u), v) {
      case $l.M:
        c = a[h++], d = a[h++], l = c, u = d;
        break;
      case $l.L:
        if (t) {
          if (eu(l, u, a[h], a[h + 1], e, r, i))
            return !0;
        } else
          s += Ys(l, u, a[h], a[h + 1], r, i) || 0;
        l = a[h++], u = a[h++];
        break;
      case $l.C:
        if (t) {
          if (EIe(l, u, a[h++], a[h++], a[h++], a[h++], a[h], a[h + 1], e, r, i))
            return !0;
        } else
          s += MIe(l, u, a[h++], a[h++], a[h++], a[h++], a[h], a[h + 1], r, i) || 0;
        l = a[h++], u = a[h++];
        break;
      case $l.Q:
        if (t) {
          if (UG(l, u, a[h++], a[h++], a[h], a[h + 1], e, r, i))
            return !0;
        } else
          s += DIe(l, u, a[h++], a[h++], a[h], a[h + 1], r, i) || 0;
        l = a[h++], u = a[h++];
        break;
      case $l.A:
        var g = a[h++], y = a[h++], b = a[h++], _ = a[h++], x = a[h++], w = a[h++];
        h += 1;
        var S = !!(1 - a[h++]);
        f = Math.cos(x) * b + g, p = Math.sin(x) * _ + y, m ? (c = f, d = p) : s += Ys(l, u, f, p, r, i);
        var C = (r - g) * _ / b + g;
        if (t) {
          if (TIe(g, y, _, x, x + w, S, e, C, i))
            return !0;
        } else
          s += OIe(g, y, _, x, x + w, S, C, i);
        l = Math.cos(x + w) * b + g, u = Math.sin(x + w) * _ + y;
        break;
      case $l.R:
        c = l = a[h++], d = u = a[h++];
        var k = a[h++], M = a[h++];
        if (f = c + k, p = d + M, t) {
          if (eu(c, d, f, d, e, r, i) || eu(f, d, f, p, e, r, i) || eu(f, p, c, p, e, r, i) || eu(c, p, c, d, e, r, i))
            return !0;
        } else
          s += Ys(f, d, f, p, r, i), s += Ys(c, p, c, d, r, i);
        break;
      case $l.Z:
        if (t) {
          if (eu(l, u, c, d, e, r, i))
            return !0;
        } else
          s += Ys(l, u, c, d, r, i);
        l = c, u = d;
        break;
    }
  }
  return !t && !kIe(u, d) && (s += Ys(l, u, c, d, r, i) || 0), s !== 0;
}
function IIe(n, e, t) {
  return WG(n, 0, !1, e, t);
}
function LIe(n, e, t, r) {
  return WG(n, e, !0, t, r);
}
var Qb = dt({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, fd), NIe = {
  style: dt({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, ew.style)
}, w2 = Ss.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), Ht = function(n) {
  le(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.update = function() {
    var t = this;
    n.prototype.update.call(this);
    var r = this.style;
    if (r.decal) {
      var i = this._decalEl = this._decalEl || new e();
      i.buildPath === e.prototype.buildPath && (i.buildPath = function(l) {
        t.buildPath(l, t.shape);
      }), i.silent = !0;
      var a = i.style;
      for (var o in r)
        a[o] !== r[o] && (a[o] = r[o]);
      a.fill = r.fill ? r.decal : null, a.decal = null, a.shadowColor = null, r.strokeFirst && (a.stroke = null);
      for (var s = 0; s < w2.length; ++s)
        i[w2[s]] = this[w2[s]];
      i.__dirty |= pa;
    } else this._decalEl && (this._decalEl = null);
  }, e.prototype.getDecalElement = function() {
    return this._decalEl;
  }, e.prototype._init = function(t) {
    var r = Yt(t);
    this.shape = this.getDefaultShape();
    var i = this.getDefaultStyle();
    i && this.useStyle(i);
    for (var a = 0; a < r.length; a++) {
      var o = r[a], s = t[o];
      o === "style" ? this.style ? xe(this.style, s) : this.useStyle(s) : o === "shape" ? xe(this.shape, s) : n.prototype.attrKV.call(this, o, s);
    }
    this.style || this.useStyle({});
  }, e.prototype.getDefaultStyle = function() {
    return null;
  }, e.prototype.getDefaultShape = function() {
    return {};
  }, e.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, e.prototype.getInsideTextFill = function() {
    var t = this.style.fill;
    if (t !== "none") {
      if (We(t)) {
        var r = Kb(t, 0);
        return r > 0.5 ? nk : r > 0.2 ? mOe : rk;
      } else if (t)
        return rk;
    }
    return nk;
  }, e.prototype.getInsideTextStroke = function(t) {
    var r = this.style.fill;
    if (We(r)) {
      var i = this.__zr, a = !!(i && i.isDarkMode()), o = Kb(t, 0) < tk;
      if (a === o)
        return r;
    }
  }, e.prototype.buildPath = function(t, r, i) {
  }, e.prototype.pathUpdated = function() {
    this.__dirty &= ~Jf;
  }, e.prototype.getUpdatedPathProxy = function(t) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, t), this.path;
  }, e.prototype.createPathProxy = function() {
    this.path = new Ts(!1);
  }, e.prototype.hasStroke = function() {
    var t = this.style, r = t.stroke;
    return !(r == null || r === "none" || !(t.lineWidth > 0));
  }, e.prototype.hasFill = function() {
    var t = this.style, r = t.fill;
    return r != null && r !== "none";
  }, e.prototype.getBoundingRect = function() {
    var t = this._rect, r = this.style, i = !t;
    if (i) {
      var a = !1;
      this.path || (a = !0, this.createPathProxy());
      var o = this.path;
      (a || this.__dirty & Jf) && (o.beginPath(), this.buildPath(o, this.shape, !1), this.pathUpdated()), t = o.getBoundingRect();
    }
    if (this._rect = t, this.hasStroke() && this.path && this.path.len() > 0) {
      var s = this._rectStroke || (this._rectStroke = t.clone());
      if (this.__dirty || i) {
        s.copy(t);
        var l = r.strokeNoScale ? this.getLineScale() : 1, u = r.lineWidth;
        if (!this.hasFill()) {
          var c = this.strokeContainThreshold;
          u = Math.max(u, c ?? 4);
        }
        l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
      }
      return s;
    }
    return t;
  }, e.prototype.contain = function(t, r) {
    var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect(), o = this.style;
    if (t = i[0], r = i[1], a.contain(t, r)) {
      var s = this.path;
      if (this.hasStroke()) {
        var l = o.lineWidth, u = o.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), LIe(s, l / u, t, r)))
          return !0;
      }
      if (this.hasFill())
        return IIe(s, t, r);
    }
    return !1;
  }, e.prototype.dirtyShape = function() {
    this.__dirty |= Jf, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, e.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, e.prototype.animateShape = function(t) {
    return this.animate("shape", t);
  }, e.prototype.updateDuringAnimation = function(t) {
    t === "style" ? this.dirtyStyle() : t === "shape" ? this.dirtyShape() : this.markRedraw();
  }, e.prototype.attrKV = function(t, r) {
    t === "shape" ? this.setShape(r) : n.prototype.attrKV.call(this, t, r);
  }, e.prototype.setShape = function(t, r) {
    var i = this.shape;
    return i || (i = this.shape = {}), typeof t == "string" ? i[t] = r : xe(i, t), this.dirtyShape(), this;
  }, e.prototype.shapeChanged = function() {
    return !!(this.__dirty & Jf);
  }, e.prototype.createStyle = function(t) {
    return Ux(Qb, t);
  }, e.prototype._innerSaveToNormal = function(t) {
    n.prototype._innerSaveToNormal.call(this, t);
    var r = this._normalState;
    t.shape && !r.shape && (r.shape = xe({}, this.shape));
  }, e.prototype._applyStateObj = function(t, r, i, a, o, s) {
    n.prototype._applyStateObj.call(this, t, r, i, a, o, s);
    var l = !(r && a), u;
    if (r && r.shape ? o ? a ? u = r.shape : (u = xe({}, i.shape), xe(u, r.shape)) : (u = xe({}, a ? this.shape : i.shape), xe(u, r.shape)) : l && (u = i.shape), u)
      if (o) {
        this.shape = xe({}, this.shape);
        for (var c = {}, d = Yt(u), f = 0; f < d.length; f++) {
          var p = d[f];
          typeof u[p] == "object" ? this.shape[p] = u[p] : c[p] = u[p];
        }
        this._transitionState(t, {
          shape: c
        }, s);
      } else
        this.shape = u, this.dirtyShape();
  }, e.prototype._mergeStates = function(t) {
    for (var r = n.prototype._mergeStates.call(this, t), i, a = 0; a < t.length; a++) {
      var o = t[a];
      o.shape && (i = i || {}, this._mergeStyle(i, o.shape));
    }
    return i && (r.shape = i), r;
  }, e.prototype.getAnimationStyleProps = function() {
    return NIe;
  }, e.prototype.isZeroArea = function() {
    return !1;
  }, e.extend = function(t) {
    var r = function(a) {
      le(o, a);
      function o(s) {
        var l = a.call(this, s) || this;
        return t.init && t.init.call(l, s), l;
      }
      return o.prototype.getDefaultStyle = function() {
        return ht(t.style);
      }, o.prototype.getDefaultShape = function() {
        return ht(t.shape);
      }, o;
    }(e);
    for (var i in t)
      typeof t[i] == "function" && (r.prototype[i] = t[i]);
    return r;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.type = "path", t.strokeContainThreshold = 5, t.segmentIgnoreThreshold = 0, t.subPixelOptimize = !1, t.autoBatch = !1, t.__dirty = pa | Cv | Jf;
  }(), e;
}(no), RIe = dt({
  strokeFirst: !0,
  font: Iu,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, Qb), zp = function(n) {
  le(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e.prototype.hasStroke = function() {
    var t = this.style, r = t.stroke;
    return r != null && r !== "none" && t.lineWidth > 0;
  }, e.prototype.hasFill = function() {
    var t = this.style, r = t.fill;
    return r != null && r !== "none";
  }, e.prototype.createStyle = function(t) {
    return Ux(RIe, t);
  }, e.prototype.setBoundingRect = function(t) {
    this._rect = t;
  }, e.prototype.getBoundingRect = function() {
    var t = this.style;
    if (!this._rect) {
      var r = t.text;
      r != null ? r += "" : r = "";
      var i = zg(r, t.font, t.textAlign, t.textBaseline);
      if (i.x += t.x || 0, i.y += t.y || 0, this.hasStroke()) {
        var a = t.lineWidth;
        i.x -= a / 2, i.y -= a / 2, i.width += a, i.height += a;
      }
      this._rect = i;
    }
    return this._rect;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.dirtyRectTolerance = 10;
  }(), e;
}(no);
zp.prototype.type = "tspan";
var PIe = dt({
  x: 0,
  y: 0
}, fd), jIe = {
  style: dt({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, ew.style)
};
function BIe(n) {
  return !!(n && typeof n != "string" && n.width && n.height);
}
var Ur = function(n) {
  le(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e.prototype.createStyle = function(t) {
    return Ux(PIe, t);
  }, e.prototype._getSize = function(t) {
    var r = this.style, i = r[t];
    if (i != null)
      return i;
    var a = BIe(r.image) ? r.image : this.__image;
    if (!a)
      return 0;
    var o = t === "width" ? "height" : "width", s = r[o];
    return s == null ? a[t] : a[t] / a[o] * s;
  }, e.prototype.getWidth = function() {
    return this._getSize("width");
  }, e.prototype.getHeight = function() {
    return this._getSize("height");
  }, e.prototype.getAnimationStyleProps = function() {
    return jIe;
  }, e.prototype.getBoundingRect = function() {
    var t = this.style;
    return this._rect || (this._rect = new Ot(t.x || 0, t.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, e;
}(no);
Ur.prototype.type = "image";
function $Ie(n, e) {
  var t = e.x, r = e.y, i = e.width, a = e.height, o = e.r, s, l, u, c;
  i < 0 && (t = t + i, i = -i), a < 0 && (r = r + a, a = -a), typeof o == "number" ? s = l = u = c = o : o instanceof Array ? o.length === 1 ? s = l = u = c = o[0] : o.length === 2 ? (s = u = o[0], l = c = o[1]) : o.length === 3 ? (s = o[0], l = c = o[1], u = o[2]) : (s = o[0], l = o[1], u = o[2], c = o[3]) : s = l = u = c = 0;
  var d;
  s + l > i && (d = s + l, s *= i / d, l *= i / d), u + c > i && (d = u + c, u *= i / d, c *= i / d), l + u > a && (d = l + u, l *= a / d, u *= a / d), s + c > a && (d = s + c, s *= a / d, c *= a / d), n.moveTo(t + s, r), n.lineTo(t + i - l, r), l !== 0 && n.arc(t + i - l, r + l, l, -Math.PI / 2, 0), n.lineTo(t + i, r + a - u), u !== 0 && n.arc(t + i - u, r + a - u, u, 0, Math.PI / 2), n.lineTo(t + c, r + a), c !== 0 && n.arc(t + c, r + a - c, c, Math.PI / 2, Math.PI), n.lineTo(t, r + s), s !== 0 && n.arc(t + s, r + s, s, Math.PI, Math.PI * 1.5);
}
var up = Math.round;
function qG(n, e, t) {
  if (e) {
    var r = e.x1, i = e.x2, a = e.y1, o = e.y2;
    n.x1 = r, n.x2 = i, n.y1 = a, n.y2 = o;
    var s = t && t.lineWidth;
    return s && (up(r * 2) === up(i * 2) && (n.x1 = n.x2 = Gc(r, s, !0)), up(a * 2) === up(o * 2) && (n.y1 = n.y2 = Gc(a, s, !0))), n;
  }
}
function YG(n, e, t) {
  if (e) {
    var r = e.x, i = e.y, a = e.width, o = e.height;
    n.x = r, n.y = i, n.width = a, n.height = o;
    var s = t && t.lineWidth;
    return s && (n.x = Gc(r, s, !0), n.y = Gc(i, s, !0), n.width = Math.max(Gc(r + a, s, !1) - n.x, a === 0 ? 0 : 1), n.height = Math.max(Gc(i + o, s, !1) - n.y, o === 0 ? 0 : 1)), n;
  }
}
function Gc(n, e, t) {
  if (!e)
    return n;
  var r = up(n * 2);
  return (r + up(e)) % 2 === 0 ? r / 2 : (r + (t ? 1 : -1)) / 2;
}
var zIe = /* @__PURE__ */ function() {
  function n() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return n;
}(), FIe = {}, Qt = function(n) {
  le(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new zIe();
  }, e.prototype.buildPath = function(t, r) {
    var i, a, o, s;
    if (this.subPixelOptimize) {
      var l = YG(FIe, r, this.style);
      i = l.x, a = l.y, o = l.width, s = l.height, l.r = r.r, r = l;
    } else
      i = r.x, a = r.y, o = r.width, s = r.height;
    r.r ? $Ie(t, r) : t.rect(i, a, o, s);
  }, e.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, e;
}(Ht);
Qt.prototype.type = "rect";
var q3 = {
  fill: "#000"
}, Y3 = 2, VIe = {
  style: dt({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, ew.style)
}, nn = function(n) {
  le(e, n);
  function e(t) {
    var r = n.call(this) || this;
    return r.type = "text", r._children = [], r._defaultStyle = q3, r.attr(t), r;
  }
  return e.prototype.childrenRef = function() {
    return this._children;
  }, e.prototype.update = function() {
    n.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var t = 0; t < this._children.length; t++) {
      var r = this._children[t];
      r.zlevel = this.zlevel, r.z = this.z, r.z2 = this.z2, r.culling = this.culling, r.cursor = this.cursor, r.invisible = this.invisible;
    }
  }, e.prototype.updateTransform = function() {
    var t = this.innerTransformable;
    t ? (t.updateTransform(), t.transform && (this.transform = t.transform)) : n.prototype.updateTransform.call(this);
  }, e.prototype.getLocalTransform = function(t) {
    var r = this.innerTransformable;
    return r ? r.getLocalTransform(t) : n.prototype.getLocalTransform.call(this, t);
  }, e.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), n.prototype.getComputedTransform.call(this);
  }, e.prototype._updateSubTexts = function() {
    this._childCursor = 0, UIe(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, e.prototype.addSelfToZr = function(t) {
    n.prototype.addSelfToZr.call(this, t);
    for (var r = 0; r < this._children.length; r++)
      this._children[r].__zr = t;
  }, e.prototype.removeSelfFromZr = function(t) {
    n.prototype.removeSelfFromZr.call(this, t);
    for (var r = 0; r < this._children.length; r++)
      this._children[r].__zr = null;
  }, e.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var t = new Ot(0, 0, 0, 0), r = this._children, i = [], a = null, o = 0; o < r.length; o++) {
        var s = r[o], l = s.getBoundingRect(), u = s.getLocalTransform(i);
        u ? (t.copy(l), t.applyTransform(u), a = a || t.clone(), a.union(t)) : (a = a || l.clone(), a.union(l));
      }
      this._rect = a || t;
    }
    return this._rect;
  }, e.prototype.setDefaultTextStyle = function(t) {
    this._defaultStyle = t || q3;
  }, e.prototype.setTextContent = function(t) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, e.prototype._mergeStyle = function(t, r) {
    if (!r)
      return t;
    var i = r.rich, a = t.rich || i && {};
    return xe(t, r), i && a ? (this._mergeRich(a, i), t.rich = a) : a && (t.rich = a), t;
  }, e.prototype._mergeRich = function(t, r) {
    for (var i = Yt(r), a = 0; a < i.length; a++) {
      var o = i[a];
      t[o] = t[o] || {}, xe(t[o], r[o]);
    }
  }, e.prototype.getAnimationStyleProps = function() {
    return VIe;
  }, e.prototype._getOrCreateChild = function(t) {
    var r = this._children[this._childCursor];
    return (!r || !(r instanceof t)) && (r = new t()), this._children[this._childCursor++] = r, r.__zr = this.__zr, r.parent = this, r;
  }, e.prototype._updatePlainTexts = function() {
    var t = this.style, r = t.font || Iu, i = t.padding, a = tj(t), o = fIe(a, t), s = S2(t), l = !!t.backgroundColor, u = o.outerHeight, c = o.outerWidth, d = o.contentWidth, f = o.lines, p = o.lineHeight, h = this._defaultStyle;
    this.isTruncated = !!o.isTruncated;
    var v = t.x || 0, m = t.y || 0, g = t.align || h.align || "left", y = t.verticalAlign || h.verticalAlign || "top", b = v, _ = Qf(m, o.contentHeight, y);
    if (s || i) {
      var x = Av(v, c, g), w = Qf(m, u, y);
      s && this._renderBackground(t, t, x, w, c, u);
    }
    _ += p / 2, i && (b = ej(v, g, i), y === "top" ? _ += i[0] : y === "bottom" && (_ -= i[2]));
    for (var S = 0, C = !1, k = Q3("fill" in t ? t.fill : (C = !0, h.fill)), M = J3("stroke" in t ? t.stroke : !l && (!h.autoStroke || C) ? (S = Y3, h.stroke) : null), D = t.textShadowBlur > 0, N = t.width != null && (t.overflow === "truncate" || t.overflow === "break" || t.overflow === "breakAll"), R = o.calculatedLineHeight, j = 0; j < f.length; j++) {
      var z = this._getOrCreateChild(zp), F = z.createStyle();
      z.useStyle(F), F.text = f[j], F.x = b, F.y = _, F.textAlign = g, F.textBaseline = "middle", F.opacity = t.opacity, F.strokeFirst = !0, D && (F.shadowBlur = t.textShadowBlur || 0, F.shadowColor = t.textShadowColor || "transparent", F.shadowOffsetX = t.textShadowOffsetX || 0, F.shadowOffsetY = t.textShadowOffsetY || 0), F.stroke = M, F.fill = k, M && (F.lineWidth = t.lineWidth || S, F.lineDash = t.lineDash, F.lineDashOffset = t.lineDashOffset || 0), F.font = r, X3(F, t), _ += p, N && z.setBoundingRect(new Ot(Av(F.x, d, F.textAlign), Qf(F.y, R, F.textBaseline), d, R));
    }
  }, e.prototype._updateRichTexts = function() {
    var t = this.style, r = tj(t), i = vIe(r, t), a = i.width, o = i.outerWidth, s = i.outerHeight, l = t.padding, u = t.x || 0, c = t.y || 0, d = this._defaultStyle, f = t.align || d.align, p = t.verticalAlign || d.verticalAlign;
    this.isTruncated = !!i.isTruncated;
    var h = Av(u, o, f), v = Qf(c, s, p), m = h, g = v;
    l && (m += l[3], g += l[0]);
    var y = m + a;
    S2(t) && this._renderBackground(t, t, h, v, o, s);
    for (var b = !!t.backgroundColor, _ = 0; _ < i.lines.length; _++) {
      for (var x = i.lines[_], w = x.tokens, S = w.length, C = x.lineHeight, k = x.width, M = 0, D = m, N = y, R = S - 1, j = void 0; M < S && (j = w[M], !j.align || j.align === "left"); )
        this._placeToken(j, t, C, g, D, "left", b), k -= j.width, D += j.width, M++;
      for (; R >= 0 && (j = w[R], j.align === "right"); )
        this._placeToken(j, t, C, g, N, "right", b), k -= j.width, N -= j.width, R--;
      for (D += (a - (D - m) - (y - N) - k) / 2; M <= R; )
        j = w[M], this._placeToken(j, t, C, g, D + j.width / 2, "center", b), D += j.width, M++;
      g += C;
    }
  }, e.prototype._placeToken = function(t, r, i, a, o, s, l) {
    var u = r.rich[t.styleName] || {};
    u.text = t.text;
    var c = t.verticalAlign, d = a + i / 2;
    c === "top" ? d = a + t.height / 2 : c === "bottom" && (d = a + i - t.height / 2);
    var f = !t.isLineHolder && S2(u);
    f && this._renderBackground(u, r, s === "right" ? o - t.width : s === "center" ? o - t.width / 2 : o, d - t.height / 2, t.width, t.height);
    var p = !!u.backgroundColor, h = t.textPadding;
    h && (o = ej(o, s, h), d -= t.height / 2 - h[0] - t.innerHeight / 2);
    var v = this._getOrCreateChild(zp), m = v.createStyle();
    v.useStyle(m);
    var g = this._defaultStyle, y = !1, b = 0, _ = Q3("fill" in u ? u.fill : "fill" in r ? r.fill : (y = !0, g.fill)), x = J3("stroke" in u ? u.stroke : "stroke" in r ? r.stroke : !p && !l && (!g.autoStroke || y) ? (b = Y3, g.stroke) : null), w = u.textShadowBlur > 0 || r.textShadowBlur > 0;
    m.text = t.text, m.x = o, m.y = d, w && (m.shadowBlur = u.textShadowBlur || r.textShadowBlur || 0, m.shadowColor = u.textShadowColor || r.textShadowColor || "transparent", m.shadowOffsetX = u.textShadowOffsetX || r.textShadowOffsetX || 0, m.shadowOffsetY = u.textShadowOffsetY || r.textShadowOffsetY || 0), m.textAlign = s, m.textBaseline = "middle", m.font = t.font || Iu, m.opacity = Za(u.opacity, r.opacity, 1), X3(m, u), x && (m.lineWidth = Za(u.lineWidth, r.lineWidth, b), m.lineDash = bt(u.lineDash, r.lineDash), m.lineDashOffset = r.lineDashOffset || 0, m.stroke = x), _ && (m.fill = _);
    var S = t.contentWidth, C = t.contentHeight;
    v.setBoundingRect(new Ot(Av(m.x, S, m.textAlign), Qf(m.y, C, m.textBaseline), S, C));
  }, e.prototype._renderBackground = function(t, r, i, a, o, s) {
    var l = t.backgroundColor, u = t.borderWidth, c = t.borderColor, d = l && l.image, f = l && !d, p = t.borderRadius, h = this, v, m;
    if (f || t.lineHeight || u && c) {
      v = this._getOrCreateChild(Qt), v.useStyle(v.createStyle()), v.style.fill = null;
      var g = v.shape;
      g.x = i, g.y = a, g.width = o, g.height = s, g.r = p, v.dirtyShape();
    }
    if (f) {
      var y = v.style;
      y.fill = l || null, y.fillOpacity = bt(t.fillOpacity, 1);
    } else if (d) {
      m = this._getOrCreateChild(Ur), m.onload = function() {
        h.dirtyStyle();
      };
      var b = m.style;
      b.image = l.image, b.x = i, b.y = a, b.width = o, b.height = s;
    }
    if (u && c) {
      var y = v.style;
      y.lineWidth = u, y.stroke = c, y.strokeOpacity = bt(t.strokeOpacity, 1), y.lineDash = t.borderDash, y.lineDashOffset = t.borderDashOffset || 0, v.strokeContainThreshold = 0, v.hasFill() && v.hasStroke() && (y.strokeFirst = !0, y.lineWidth *= 2);
    }
    var _ = (v || m).style;
    _.shadowBlur = t.shadowBlur || 0, _.shadowColor = t.shadowColor || "transparent", _.shadowOffsetX = t.shadowOffsetX || 0, _.shadowOffsetY = t.shadowOffsetY || 0, _.opacity = Za(t.opacity, r.opacity, 1);
  }, e.makeFont = function(t) {
    var r = "";
    return XG(t) && (r = [
      t.fontStyle,
      t.fontWeight,
      KG(t.fontSize),
      t.fontFamily || "sans-serif"
    ].join(" ")), r && yo(r) || t.textFont || t.font;
  }, e;
}(no), HIe = { left: !0, right: 1, center: 1 }, GIe = { top: 1, bottom: 1, middle: 1 }, K3 = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function KG(n) {
  return typeof n == "string" && (n.indexOf("px") !== -1 || n.indexOf("rem") !== -1 || n.indexOf("em") !== -1) ? n : isNaN(+n) ? bD + "px" : n + "px";
}
function X3(n, e) {
  for (var t = 0; t < K3.length; t++) {
    var r = K3[t], i = e[r];
    i != null && (n[r] = i);
  }
}
function XG(n) {
  return n.fontSize != null || n.fontFamily || n.fontWeight;
}
function UIe(n) {
  return Z3(n), $(n.rich, Z3), n;
}
function Z3(n) {
  if (n) {
    n.font = nn.makeFont(n);
    var e = n.align;
    e === "middle" && (e = "center"), n.align = e == null || HIe[e] ? e : "left";
    var t = n.verticalAlign;
    t === "center" && (t = "middle"), n.verticalAlign = t == null || GIe[t] ? t : "top";
    var r = n.padding;
    r && (n.padding = ED(n.padding));
  }
}
function J3(n, e) {
  return n == null || e <= 0 || n === "transparent" || n === "none" ? null : n.image || n.colorStops ? "#000" : n;
}
function Q3(n) {
  return n == null || n === "none" ? null : n.image || n.colorStops ? "#000" : n;
}
function ej(n, e, t) {
  return e === "right" ? n - t[1] : e === "center" ? n + t[3] / 2 - t[1] / 2 : n + t[3];
}
function tj(n) {
  var e = n.text;
  return e != null && (e += ""), e;
}
function S2(n) {
  return !!(n.backgroundColor || n.lineHeight || n.borderWidth && n.borderColor);
}
var yt = en(), ck = function(n, e, t, r) {
  if (r) {
    var i = yt(r);
    i.dataIndex = t, i.dataType = e, i.seriesIndex = n, i.ssrType = "chart", r.type === "group" && r.traverse(function(a) {
      var o = yt(a);
      o.seriesIndex = n, o.dataIndex = t, o.dataType = e, o.ssrType = "chart";
    });
  }
}, nj = 1, rj = {}, ZG = en(), jD = en(), BD = 0, Vg = 1, nw = 2, zi = ["emphasis", "blur", "select"], eg = ["normal", "emphasis", "blur", "select"], ch = 10, WIe = 9, pd = "highlight", E1 = "downplay", dm = "select", T1 = "unselect", fm = "toggleSelect";
function Sf(n) {
  return n != null && n !== "none";
}
function rw(n, e, t) {
  n.onHoverStateChange && (n.hoverState || 0) !== t && n.onHoverStateChange(e), n.hoverState = t;
}
function JG(n) {
  rw(n, "emphasis", nw);
}
function QG(n) {
  n.hoverState === nw && rw(n, "normal", BD);
}
function $D(n) {
  rw(n, "blur", Vg);
}
function eU(n) {
  n.hoverState === Vg && rw(n, "normal", BD);
}
function qIe(n) {
  n.selected = !0;
}
function YIe(n) {
  n.selected = !1;
}
function ij(n, e, t) {
  e(n, t);
}
function Al(n, e, t) {
  ij(n, e, t), n.isGroup && n.traverse(function(r) {
    ij(r, e, t);
  });
}
function e_(n, e) {
  switch (e) {
    case "emphasis":
      n.hoverState = nw;
      break;
    case "normal":
      n.hoverState = BD;
      break;
    case "blur":
      n.hoverState = Vg;
      break;
    case "select":
      n.selected = !0;
  }
}
function KIe(n, e, t, r) {
  for (var i = n.style, a = {}, o = 0; o < e.length; o++) {
    var s = e[o], l = i[s];
    a[s] = l ?? (r && r[s]);
  }
  for (var o = 0; o < n.animators.length; o++) {
    var u = n.animators[o];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(t) < 0 && u.targetName === "style" && u.saveTo(a, e);
  }
  return a;
}
function XIe(n, e, t, r) {
  var i = t && Pt(t, "select") >= 0, a = !1;
  if (n instanceof Ht) {
    var o = ZG(n), s = i && o.selectFill || o.normalFill, l = i && o.selectStroke || o.normalStroke;
    if (Sf(s) || Sf(l)) {
      r = r || {};
      var u = r.style || {};
      u.fill === "inherit" ? (a = !0, r = xe({}, r), u = xe({}, u), u.fill = s) : !Sf(u.fill) && Sf(s) ? (a = !0, r = xe({}, r), u = xe({}, u), u.fill = YC(s)) : !Sf(u.stroke) && Sf(l) && (a || (r = xe({}, r), u = xe({}, u)), u.stroke = YC(l)), r.style = u;
    }
  }
  if (r && r.z2 == null) {
    a || (r = xe({}, r));
    var c = n.z2EmphasisLift;
    r.z2 = n.z2 + (c ?? ch);
  }
  return r;
}
function ZIe(n, e, t) {
  if (t && t.z2 == null) {
    t = xe({}, t);
    var r = n.z2SelectLift;
    t.z2 = n.z2 + (r ?? WIe);
  }
  return t;
}
function JIe(n, e, t) {
  var r = Pt(n.currentStates, e) >= 0, i = n.style.opacity, a = r ? null : KIe(n, ["opacity"], e, {
    opacity: 1
  });
  t = t || {};
  var o = t.style || {};
  return o.opacity == null && (t = xe({}, t), o = xe({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: r ? i : a.opacity * 0.1
  }, o), t.style = o), t;
}
function E2(n, e) {
  var t = this.states[n];
  if (this.style) {
    if (n === "emphasis")
      return XIe(this, n, e, t);
    if (n === "blur")
      return JIe(this, n, t);
    if (n === "select")
      return ZIe(this, n, t);
  }
  return t;
}
function Nd(n) {
  n.stateProxy = E2;
  var e = n.getTextContent(), t = n.getTextGuideLine();
  e && (e.stateProxy = E2), t && (t.stateProxy = E2);
}
function aj(n, e) {
  !iU(n, e) && !n.__highByOuter && Al(n, JG);
}
function oj(n, e) {
  !iU(n, e) && !n.__highByOuter && Al(n, QG);
}
function xl(n, e) {
  n.__highByOuter |= 1 << (e || 0), Al(n, JG);
}
function wl(n, e) {
  !(n.__highByOuter &= ~(1 << (e || 0))) && Al(n, QG);
}
function tU(n) {
  Al(n, $D);
}
function zD(n) {
  Al(n, eU);
}
function nU(n) {
  Al(n, qIe);
}
function rU(n) {
  Al(n, YIe);
}
function iU(n, e) {
  return n.__highDownSilentOnTouch && e.zrByTouch;
}
function aU(n) {
  var e = n.getModel(), t = [], r = [];
  e.eachComponent(function(i, a) {
    var o = jD(a), s = i === "series", l = s ? n.getViewOfSeriesModel(a) : n.getViewOfComponentModel(a);
    !s && r.push(l), o.isBlured && (l.group.traverse(function(u) {
      eU(u);
    }), s && t.push(a)), o.isBlured = !1;
  }), $(r, function(i) {
    i && i.toggleBlurSeries && i.toggleBlurSeries(t, !1, e);
  });
}
function dk(n, e, t, r) {
  var i = r.getModel();
  t = t || "coordinateSystem";
  function a(u, c) {
    for (var d = 0; d < c.length; d++) {
      var f = u.getItemGraphicEl(c[d]);
      f && zD(f);
    }
  }
  if (n != null && !(!e || e === "none")) {
    var o = i.getSeriesByIndex(n), s = o.coordinateSystem;
    s && s.master && (s = s.master);
    var l = [];
    i.eachSeries(function(u) {
      var c = o === u, d = u.coordinateSystem;
      d && d.master && (d = d.master);
      var f = d && s ? d === s : c;
      if (!// Not blur other series if blurScope series
      (t === "series" && !c || t === "coordinateSystem" && !f || e === "series" && c)) {
        var p = r.getViewOfSeriesModel(u);
        if (p.group.traverse(function(m) {
          m.__highByOuter && c && e === "self" || $D(m);
        }), hi(e))
          a(u.getData(), e);
        else if (ut(e))
          for (var h = Yt(e), v = 0; v < h.length; v++)
            a(u.getData(h[v]), e[h[v]]);
        l.push(u), jD(u).isBlured = !0;
      }
    }), i.eachComponent(function(u, c) {
      if (u !== "series") {
        var d = r.getViewOfComponentModel(c);
        d && d.toggleBlurSeries && d.toggleBlurSeries(l, !0, i);
      }
    });
  }
}
function fk(n, e, t) {
  if (!(n == null || e == null)) {
    var r = t.getModel().getComponent(n, e);
    if (r) {
      jD(r).isBlured = !0;
      var i = t.getViewOfComponentModel(r);
      !i || !i.focusBlurEnabled || i.group.traverse(function(a) {
        $D(a);
      });
    }
  }
}
function QIe(n, e, t) {
  var r = n.seriesIndex, i = n.getData(e.dataType);
  if (!i) {
    process.env.NODE_ENV !== "production" && Jr("Unknown dataType " + e.dataType);
    return;
  }
  var a = Id(i, e);
  a = (Me(a) ? a[0] : a) || 0;
  var o = i.getItemGraphicEl(a);
  if (!o)
    for (var s = i.count(), l = 0; !o && l < s; )
      o = i.getItemGraphicEl(l++);
  if (o) {
    var u = yt(o);
    dk(r, u.focus, u.blurScope, t);
  } else {
    var c = n.get(["emphasis", "focus"]), d = n.get(["emphasis", "blurScope"]);
    c != null && dk(r, c, d, t);
  }
}
function FD(n, e, t, r) {
  var i = {
    focusSelf: !1,
    dispatchers: null
  };
  if (n == null || n === "series" || e == null || t == null)
    return i;
  var a = r.getModel().getComponent(n, e);
  if (!a)
    return i;
  var o = r.getViewOfComponentModel(a);
  if (!o || !o.findHighDownDispatchers)
    return i;
  for (var s = o.findHighDownDispatchers(t), l, u = 0; u < s.length; u++)
    if (process.env.NODE_ENV !== "production" && !Ru(s[u]) && Jr("param should be highDownDispatcher"), yt(s[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: s
  };
}
function eLe(n, e, t) {
  process.env.NODE_ENV !== "production" && !Ru(n) && Jr("param should be highDownDispatcher");
  var r = yt(n), i = FD(r.componentMainType, r.componentIndex, r.componentHighDownName, t), a = i.dispatchers, o = i.focusSelf;
  a ? (o && fk(r.componentMainType, r.componentIndex, t), $(a, function(s) {
    return aj(s, e);
  })) : (dk(r.seriesIndex, r.focus, r.blurScope, t), r.focus === "self" && fk(r.componentMainType, r.componentIndex, t), aj(n, e));
}
function tLe(n, e, t) {
  process.env.NODE_ENV !== "production" && !Ru(n) && Jr("param should be highDownDispatcher"), aU(t);
  var r = yt(n), i = FD(r.componentMainType, r.componentIndex, r.componentHighDownName, t).dispatchers;
  i ? $(i, function(a) {
    return oj(a, e);
  }) : oj(n, e);
}
function nLe(n, e, t) {
  if (hk(e)) {
    var r = e.dataType, i = n.getData(r), a = Id(i, e);
    Me(a) || (a = [a]), n[e.type === fm ? "toggleSelect" : e.type === dm ? "select" : "unselect"](a, r);
  }
}
function sj(n) {
  var e = n.getAllData();
  $(e, function(t) {
    var r = t.data, i = t.type;
    r.eachItemGraphicEl(function(a, o) {
      n.isSelected(o, i) ? nU(a) : rU(a);
    });
  });
}
function rLe(n) {
  var e = [];
  return n.eachSeries(function(t) {
    var r = t.getAllData();
    $(r, function(i) {
      i.data;
      var a = i.type, o = t.getSelectedDataIndices();
      if (o.length > 0) {
        var s = {
          dataIndex: o,
          seriesIndex: t.seriesIndex
        };
        a != null && (s.dataType = a), e.push(s);
      }
    });
  }), e;
}
function hd(n, e, t) {
  Uc(n, !0), Al(n, Nd), pk(n, e, t);
}
function iLe(n) {
  Uc(n, !1);
}
function er(n, e, t, r) {
  r ? iLe(n) : hd(n, e, t);
}
function pk(n, e, t) {
  var r = yt(n);
  e != null ? (r.focus = e, r.blurScope = t) : r.focus && (r.focus = null);
}
var lj = ["emphasis", "blur", "select"], aLe = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function Qr(n, e, t, r) {
  t = t || "itemStyle";
  for (var i = 0; i < lj.length; i++) {
    var a = lj[i], o = e.getModel([a, t]), s = n.ensureState(a);
    s.style = r ? r(o) : o[aLe[t]]();
  }
}
function Uc(n, e) {
  var t = e === !1, r = n;
  n.highDownSilentOnTouch && (r.__highDownSilentOnTouch = n.highDownSilentOnTouch), (!t || r.__highDownDispatcher) && (r.__highByOuter = r.__highByOuter || 0, r.__highDownDispatcher = !t);
}
function Ru(n) {
  return !!(n && n.__highDownDispatcher);
}
function oLe(n, e, t) {
  var r = yt(n);
  r.componentMainType = e.mainType, r.componentIndex = e.componentIndex, r.componentHighDownName = t;
}
function sLe(n) {
  var e = rj[n];
  return e == null && nj <= 32 && (e = rj[n] = nj++), e;
}
function hk(n) {
  var e = n.type;
  return e === dm || e === T1 || e === fm;
}
function uj(n) {
  var e = n.type;
  return e === pd || e === E1;
}
function lLe(n) {
  var e = ZG(n);
  e.normalFill = n.style.fill, e.normalStroke = n.style.stroke;
  var t = n.states.select || {};
  e.selectFill = t.style && t.style.fill || null, e.selectStroke = t.style && t.style.stroke || null;
}
var Ef = Ts.CMD, uLe = [[], [], []], cj = Math.sqrt, cLe = Math.atan2;
function oU(n, e) {
  if (e) {
    var t = n.data, r = n.len(), i, a, o, s, l, u, c = Ef.M, d = Ef.C, f = Ef.L, p = Ef.R, h = Ef.A, v = Ef.Q;
    for (o = 0, s = 0; o < r; ) {
      switch (i = t[o++], s = o, a = 0, i) {
        case c:
          a = 1;
          break;
        case f:
          a = 1;
          break;
        case d:
          a = 3;
          break;
        case v:
          a = 2;
          break;
        case h:
          var m = e[4], g = e[5], y = cj(e[0] * e[0] + e[1] * e[1]), b = cj(e[2] * e[2] + e[3] * e[3]), _ = cLe(-e[1] / b, e[0] / y);
          t[o] *= y, t[o++] += m, t[o] *= b, t[o++] += g, t[o++] *= y, t[o++] *= b, t[o++] += _, t[o++] += _, o += 2, s = o;
          break;
        case p:
          u[0] = t[o++], u[1] = t[o++], Zr(u, u, e), t[s++] = u[0], t[s++] = u[1], u[0] += t[o++], u[1] += t[o++], Zr(u, u, e), t[s++] = u[0], t[s++] = u[1];
      }
      for (l = 0; l < a; l++) {
        var x = uLe[l];
        x[0] = t[o++], x[1] = t[o++], Zr(x, x, e), t[s++] = x[0], t[s++] = x[1];
      }
    }
    n.increaseVersion();
  }
}
var T2 = Math.sqrt, p0 = Math.sin, h0 = Math.cos, Qh = Math.PI;
function dj(n) {
  return Math.sqrt(n[0] * n[0] + n[1] * n[1]);
}
function vk(n, e) {
  return (n[0] * e[0] + n[1] * e[1]) / (dj(n) * dj(e));
}
function fj(n, e) {
  return (n[0] * e[1] < n[1] * e[0] ? -1 : 1) * Math.acos(vk(n, e));
}
function pj(n, e, t, r, i, a, o, s, l, u, c) {
  var d = l * (Qh / 180), f = h0(d) * (n - t) / 2 + p0(d) * (e - r) / 2, p = -1 * p0(d) * (n - t) / 2 + h0(d) * (e - r) / 2, h = f * f / (o * o) + p * p / (s * s);
  h > 1 && (o *= T2(h), s *= T2(h));
  var v = (i === a ? -1 : 1) * T2((o * o * (s * s) - o * o * (p * p) - s * s * (f * f)) / (o * o * (p * p) + s * s * (f * f))) || 0, m = v * o * p / s, g = v * -s * f / o, y = (n + t) / 2 + h0(d) * m - p0(d) * g, b = (e + r) / 2 + p0(d) * m + h0(d) * g, _ = fj([1, 0], [(f - m) / o, (p - g) / s]), x = [(f - m) / o, (p - g) / s], w = [(-1 * f - m) / o, (-1 * p - g) / s], S = fj(x, w);
  if (vk(x, w) <= -1 && (S = Qh), vk(x, w) >= 1 && (S = 0), S < 0) {
    var C = Math.round(S / Qh * 1e6) / 1e6;
    S = Qh * 2 + C % 2 * Qh;
  }
  c.addData(u, y, b, o, s, _, S, d, a);
}
var dLe = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, fLe = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function pLe(n) {
  var e = new Ts();
  if (!n)
    return e;
  var t = 0, r = 0, i = t, a = r, o, s = Ts.CMD, l = n.match(dLe);
  if (!l)
    return e;
  for (var u = 0; u < l.length; u++) {
    for (var c = l[u], d = c.charAt(0), f = void 0, p = c.match(fLe) || [], h = p.length, v = 0; v < h; v++)
      p[v] = parseFloat(p[v]);
    for (var m = 0; m < h; ) {
      var g = void 0, y = void 0, b = void 0, _ = void 0, x = void 0, w = void 0, S = void 0, C = t, k = r, M = void 0, D = void 0;
      switch (d) {
        case "l":
          t += p[m++], r += p[m++], f = s.L, e.addData(f, t, r);
          break;
        case "L":
          t = p[m++], r = p[m++], f = s.L, e.addData(f, t, r);
          break;
        case "m":
          t += p[m++], r += p[m++], f = s.M, e.addData(f, t, r), i = t, a = r, d = "l";
          break;
        case "M":
          t = p[m++], r = p[m++], f = s.M, e.addData(f, t, r), i = t, a = r, d = "L";
          break;
        case "h":
          t += p[m++], f = s.L, e.addData(f, t, r);
          break;
        case "H":
          t = p[m++], f = s.L, e.addData(f, t, r);
          break;
        case "v":
          r += p[m++], f = s.L, e.addData(f, t, r);
          break;
        case "V":
          r = p[m++], f = s.L, e.addData(f, t, r);
          break;
        case "C":
          f = s.C, e.addData(f, p[m++], p[m++], p[m++], p[m++], p[m++], p[m++]), t = p[m - 2], r = p[m - 1];
          break;
        case "c":
          f = s.C, e.addData(f, p[m++] + t, p[m++] + r, p[m++] + t, p[m++] + r, p[m++] + t, p[m++] + r), t += p[m - 2], r += p[m - 1];
          break;
        case "S":
          g = t, y = r, M = e.len(), D = e.data, o === s.C && (g += t - D[M - 4], y += r - D[M - 3]), f = s.C, C = p[m++], k = p[m++], t = p[m++], r = p[m++], e.addData(f, g, y, C, k, t, r);
          break;
        case "s":
          g = t, y = r, M = e.len(), D = e.data, o === s.C && (g += t - D[M - 4], y += r - D[M - 3]), f = s.C, C = t + p[m++], k = r + p[m++], t += p[m++], r += p[m++], e.addData(f, g, y, C, k, t, r);
          break;
        case "Q":
          C = p[m++], k = p[m++], t = p[m++], r = p[m++], f = s.Q, e.addData(f, C, k, t, r);
          break;
        case "q":
          C = p[m++] + t, k = p[m++] + r, t += p[m++], r += p[m++], f = s.Q, e.addData(f, C, k, t, r);
          break;
        case "T":
          g = t, y = r, M = e.len(), D = e.data, o === s.Q && (g += t - D[M - 4], y += r - D[M - 3]), t = p[m++], r = p[m++], f = s.Q, e.addData(f, g, y, t, r);
          break;
        case "t":
          g = t, y = r, M = e.len(), D = e.data, o === s.Q && (g += t - D[M - 4], y += r - D[M - 3]), t += p[m++], r += p[m++], f = s.Q, e.addData(f, g, y, t, r);
          break;
        case "A":
          b = p[m++], _ = p[m++], x = p[m++], w = p[m++], S = p[m++], C = t, k = r, t = p[m++], r = p[m++], f = s.A, pj(C, k, t, r, w, S, b, _, x, f, e);
          break;
        case "a":
          b = p[m++], _ = p[m++], x = p[m++], w = p[m++], S = p[m++], C = t, k = r, t += p[m++], r += p[m++], f = s.A, pj(C, k, t, r, w, S, b, _, x, f, e);
          break;
      }
    }
    (d === "z" || d === "Z") && (f = s.Z, e.addData(f), t = i, r = a), o = f;
  }
  return e.toStatic(), e;
}
var sU = function(n) {
  le(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e.prototype.applyTransform = function(t) {
  }, e;
}(Ht);
function lU(n) {
  return n.setData != null;
}
function uU(n, e) {
  var t = pLe(n), r = xe({}, e);
  return r.buildPath = function(i) {
    if (lU(i)) {
      i.setData(t.data);
      var a = i.getContext();
      a && i.rebuildPath(a, 1);
    } else {
      var a = i;
      t.rebuildPath(a, 1);
    }
  }, r.applyTransform = function(i) {
    oU(t, i), this.dirtyShape();
  }, r;
}
function cU(n, e) {
  return new sU(uU(n, e));
}
function hLe(n, e) {
  var t = uU(n, e), r = function(i) {
    le(a, i);
    function a(o) {
      var s = i.call(this, o) || this;
      return s.applyTransform = t.applyTransform, s.buildPath = t.buildPath, s;
    }
    return a;
  }(sU);
  return r;
}
function vLe(n, e) {
  for (var t = [], r = n.length, i = 0; i < r; i++) {
    var a = n[i];
    t.push(a.getUpdatedPathProxy(!0));
  }
  var o = new Ht(e);
  return o.createPathProxy(), o.buildPath = function(s) {
    if (lU(s)) {
      s.appendPath(t);
      var l = s.getContext();
      l && s.rebuildPath(l, 1);
    }
  }, o;
}
function VD(n, e) {
  e = e || {};
  var t = new Ht();
  return n.shape && t.setShape(n.shape), t.setStyle(n.style), e.bakeTransform ? oU(t.path, n.getComputedTransform()) : e.toLocal ? t.setLocalTransform(n.getComputedTransform()) : t.copyTransform(n), t.buildPath = n.buildPath, t.applyTransform = t.applyTransform, t.z = n.z, t.z2 = n.z2, t.zlevel = n.zlevel, t;
}
var mLe = /* @__PURE__ */ function() {
  function n() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return n;
}(), Ml = function(n) {
  le(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new mLe();
  }, e.prototype.buildPath = function(t, r) {
    t.moveTo(r.cx + r.r, r.cy), t.arc(r.cx, r.cy, r.r, 0, Math.PI * 2);
  }, e;
}(Ht);
Ml.prototype.type = "circle";
var gLe = /* @__PURE__ */ function() {
  function n() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return n;
}(), iw = function(n) {
  le(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new gLe();
  }, e.prototype.buildPath = function(t, r) {
    var i = 0.5522848, a = r.cx, o = r.cy, s = r.rx, l = r.ry, u = s * i, c = l * i;
    t.moveTo(a - s, o), t.bezierCurveTo(a - s, o - c, a - u, o - l, a, o - l), t.bezierCurveTo(a + u, o - l, a + s, o - c, a + s, o), t.bezierCurveTo(a + s, o + c, a + u, o + l, a, o + l), t.bezierCurveTo(a - u, o + l, a - s, o + c, a - s, o), t.closePath();
  }, e;
}(Ht);
iw.prototype.type = "ellipse";
var dU = Math.PI, C2 = dU * 2, fc = Math.sin, Tf = Math.cos, yLe = Math.acos, ii = Math.atan2, hj = Math.abs, pm = Math.sqrt, Dv = Math.max, Vo = Math.min, fo = 1e-4;
function bLe(n, e, t, r, i, a, o, s) {
  var l = t - n, u = r - e, c = o - i, d = s - a, f = d * l - c * u;
  if (!(f * f < fo))
    return f = (c * (e - a) - d * (n - i)) / f, [n + f * l, e + f * u];
}
function v0(n, e, t, r, i, a, o) {
  var s = n - t, l = e - r, u = (o ? a : -a) / pm(s * s + l * l), c = u * l, d = -u * s, f = n + c, p = e + d, h = t + c, v = r + d, m = (f + h) / 2, g = (p + v) / 2, y = h - f, b = v - p, _ = y * y + b * b, x = i - a, w = f * v - h * p, S = (b < 0 ? -1 : 1) * pm(Dv(0, x * x * _ - w * w)), C = (w * b - y * S) / _, k = (-w * y - b * S) / _, M = (w * b + y * S) / _, D = (-w * y + b * S) / _, N = C - m, R = k - g, j = M - m, z = D - g;
  return N * N + R * R > j * j + z * z && (C = M, k = D), {
    cx: C,
    cy: k,
    x0: -c,
    y0: -d,
    x1: C * (i / x - 1),
    y1: k * (i / x - 1)
  };
}
function _Le(n) {
  var e;
  if (Me(n)) {
    var t = n.length;
    if (!t)
      return n;
    t === 1 ? e = [n[0], n[0], 0, 0] : t === 2 ? e = [n[0], n[0], n[1], n[1]] : t === 3 ? e = n.concat(n[2]) : e = n;
  } else
    e = [n, n, n, n];
  return e;
}
function xLe(n, e) {
  var t, r = Dv(e.r, 0), i = Dv(e.r0 || 0, 0), a = r > 0, o = i > 0;
  if (!(!a && !o)) {
    if (a || (r = i, i = 0), i > r) {
      var s = r;
      r = i, i = s;
    }
    var l = e.startAngle, u = e.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var c = e.cx, d = e.cy, f = !!e.clockwise, p = hj(u - l), h = p > C2 && p % C2;
      if (h > fo && (p = h), !(r > fo))
        n.moveTo(c, d);
      else if (p > C2 - fo)
        n.moveTo(c + r * Tf(l), d + r * fc(l)), n.arc(c, d, r, l, u, !f), i > fo && (n.moveTo(c + i * Tf(u), d + i * fc(u)), n.arc(c, d, i, u, l, f));
      else {
        var v = void 0, m = void 0, g = void 0, y = void 0, b = void 0, _ = void 0, x = void 0, w = void 0, S = void 0, C = void 0, k = void 0, M = void 0, D = void 0, N = void 0, R = void 0, j = void 0, z = r * Tf(l), F = r * fc(l), B = i * Tf(u), H = i * fc(u), Y = p > fo;
        if (Y) {
          var ne = e.cornerRadius;
          ne && (t = _Le(ne), v = t[0], m = t[1], g = t[2], y = t[3]);
          var J = hj(r - i) / 2;
          if (b = Vo(J, g), _ = Vo(J, y), x = Vo(J, v), w = Vo(J, m), k = S = Dv(b, _), M = C = Dv(x, w), (S > fo || C > fo) && (D = r * Tf(u), N = r * fc(u), R = i * Tf(l), j = i * fc(l), p < dU)) {
            var X = bLe(z, F, R, j, D, N, B, H);
            if (X) {
              var ie = z - X[0], ye = F - X[1], pe = D - X[0], Be = N - X[1], Ce = 1 / fc(yLe((ie * pe + ye * Be) / (pm(ie * ie + ye * ye) * pm(pe * pe + Be * Be))) / 2), Ee = pm(X[0] * X[0] + X[1] * X[1]);
              k = Vo(S, (r - Ee) / (Ce + 1)), M = Vo(C, (i - Ee) / (Ce - 1));
            }
          }
        }
        if (!Y)
          n.moveTo(c + z, d + F);
        else if (k > fo) {
          var ce = Vo(g, k), Pe = Vo(y, k), Ae = v0(R, j, z, F, r, ce, f), fe = v0(D, N, B, H, r, Pe, f);
          n.moveTo(c + Ae.cx + Ae.x0, d + Ae.cy + Ae.y0), k < S && ce === Pe ? n.arc(c + Ae.cx, d + Ae.cy, k, ii(Ae.y0, Ae.x0), ii(fe.y0, fe.x0), !f) : (ce > 0 && n.arc(c + Ae.cx, d + Ae.cy, ce, ii(Ae.y0, Ae.x0), ii(Ae.y1, Ae.x1), !f), n.arc(c, d, r, ii(Ae.cy + Ae.y1, Ae.cx + Ae.x1), ii(fe.cy + fe.y1, fe.cx + fe.x1), !f), Pe > 0 && n.arc(c + fe.cx, d + fe.cy, Pe, ii(fe.y1, fe.x1), ii(fe.y0, fe.x0), !f));
        } else
          n.moveTo(c + z, d + F), n.arc(c, d, r, l, u, !f);
        if (!(i > fo) || !Y)
          n.lineTo(c + B, d + H);
        else if (M > fo) {
          var ce = Vo(v, M), Pe = Vo(m, M), Ae = v0(B, H, D, N, i, -Pe, f), fe = v0(z, F, R, j, i, -ce, f);
          n.lineTo(c + Ae.cx + Ae.x0, d + Ae.cy + Ae.y0), M < C && ce === Pe ? n.arc(c + Ae.cx, d + Ae.cy, M, ii(Ae.y0, Ae.x0), ii(fe.y0, fe.x0), !f) : (Pe > 0 && n.arc(c + Ae.cx, d + Ae.cy, Pe, ii(Ae.y0, Ae.x0), ii(Ae.y1, Ae.x1), !f), n.arc(c, d, i, ii(Ae.cy + Ae.y1, Ae.cx + Ae.x1), ii(fe.cy + fe.y1, fe.cx + fe.x1), f), ce > 0 && n.arc(c + fe.cx, d + fe.cy, ce, ii(fe.y1, fe.x1), ii(fe.y0, fe.x0), !f));
        } else
          n.lineTo(c + B, d + H), n.arc(c, d, i, u, l, f);
      }
      n.closePath();
    }
  }
}
var wLe = /* @__PURE__ */ function() {
  function n() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return n;
}(), Fi = function(n) {
  le(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new wLe();
  }, e.prototype.buildPath = function(t, r) {
    xLe(t, r);
  }, e.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, e;
}(Ht);
Fi.prototype.type = "sector";
var SLe = /* @__PURE__ */ function() {
  function n() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return n;
}(), Hg = function(n) {
  le(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new SLe();
  }, e.prototype.buildPath = function(t, r) {
    var i = r.cx, a = r.cy, o = Math.PI * 2;
    t.moveTo(i + r.r, a), t.arc(i, a, r.r, 0, o, !1), t.moveTo(i + r.r0, a), t.arc(i, a, r.r0, 0, o, !0);
  }, e;
}(Ht);
Hg.prototype.type = "ring";
function ELe(n, e, t, r) {
  var i = [], a = [], o = [], s = [], l, u, c, d;
  if (r) {
    c = [1 / 0, 1 / 0], d = [-1 / 0, -1 / 0];
    for (var f = 0, p = n.length; f < p; f++)
      fu(c, c, n[f]), pu(d, d, n[f]);
    fu(c, c, r[0]), pu(d, d, r[1]);
  }
  for (var f = 0, p = n.length; f < p; f++) {
    var h = n[f];
    if (t)
      l = n[f ? f - 1 : p - 1], u = n[(f + 1) % p];
    else if (f === 0 || f === p - 1) {
      i.push(ul(n[f]));
      continue;
    } else
      l = n[f - 1], u = n[f + 1];
    Hc(a, u, l), y1(a, a, e);
    var v = $C(h, l), m = $C(h, u), g = v + m;
    g !== 0 && (v /= g, m /= g), y1(o, a, -v), y1(s, a, m);
    var y = i3([], h, o), b = i3([], h, s);
    r && (pu(y, y, c), fu(y, y, d), pu(b, b, c), fu(b, b, d)), i.push(y), i.push(b);
  }
  return t && i.push(i.shift()), i;
}
function fU(n, e, t) {
  var r = e.smooth, i = e.points;
  if (i && i.length >= 2) {
    if (r) {
      var a = ELe(i, r, t, e.smoothConstraint);
      n.moveTo(i[0][0], i[0][1]);
      for (var o = i.length, s = 0; s < (t ? o : o - 1); s++) {
        var l = a[s * 2], u = a[s * 2 + 1], c = i[(s + 1) % o];
        n.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
      }
    } else {
      n.moveTo(i[0][0], i[0][1]);
      for (var s = 1, d = i.length; s < d; s++)
        n.lineTo(i[s][0], i[s][1]);
    }
    t && n.closePath();
  }
}
var TLe = /* @__PURE__ */ function() {
  function n() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return n;
}(), Vi = function(n) {
  le(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new TLe();
  }, e.prototype.buildPath = function(t, r) {
    fU(t, r, !0);
  }, e;
}(Ht);
Vi.prototype.type = "polygon";
var CLe = /* @__PURE__ */ function() {
  function n() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return n;
}(), Hi = function(n) {
  le(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new CLe();
  }, e.prototype.buildPath = function(t, r) {
    fU(t, r, !1);
  }, e;
}(Ht);
Hi.prototype.type = "polyline";
var kLe = {}, ALe = /* @__PURE__ */ function() {
  function n() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return n;
}(), Dr = function(n) {
  le(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new ALe();
  }, e.prototype.buildPath = function(t, r) {
    var i, a, o, s;
    if (this.subPixelOptimize) {
      var l = qG(kLe, r, this.style);
      i = l.x1, a = l.y1, o = l.x2, s = l.y2;
    } else
      i = r.x1, a = r.y1, o = r.x2, s = r.y2;
    var u = r.percent;
    u !== 0 && (t.moveTo(i, a), u < 1 && (o = i * (1 - u) + o * u, s = a * (1 - u) + s * u), t.lineTo(o, s));
  }, e.prototype.pointAt = function(t) {
    var r = this.shape;
    return [
      r.x1 * (1 - t) + r.x2 * t,
      r.y1 * (1 - t) + r.y2 * t
    ];
  }, e;
}(Ht);
Dr.prototype.type = "line";
var Gi = [], MLe = /* @__PURE__ */ function() {
  function n() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return n;
}();
function vj(n, e, t) {
  var r = n.cpx2, i = n.cpy2;
  return r != null || i != null ? [
    (t ? m3 : Ar)(n.x1, n.cpx1, n.cpx2, n.x2, e),
    (t ? m3 : Ar)(n.y1, n.cpy1, n.cpy2, n.y2, e)
  ] : [
    (t ? GC : Br)(n.x1, n.cpx1, n.x2, e),
    (t ? GC : Br)(n.y1, n.cpy1, n.y2, e)
  ];
}
var Gg = function(n) {
  le(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new MLe();
  }, e.prototype.buildPath = function(t, r) {
    var i = r.x1, a = r.y1, o = r.x2, s = r.y2, l = r.cpx1, u = r.cpy1, c = r.cpx2, d = r.cpy2, f = r.percent;
    f !== 0 && (t.moveTo(i, a), c == null || d == null ? (f < 1 && (Xm(i, l, o, f, Gi), l = Gi[1], o = Gi[2], Xm(a, u, s, f, Gi), u = Gi[1], s = Gi[2]), t.quadraticCurveTo(l, u, o, s)) : (f < 1 && (Nu(i, l, c, o, f, Gi), l = Gi[1], c = Gi[2], o = Gi[3], Nu(a, u, d, s, f, Gi), u = Gi[1], d = Gi[2], s = Gi[3]), t.bezierCurveTo(l, u, c, d, o, s)));
  }, e.prototype.pointAt = function(t) {
    return vj(this.shape, t, !1);
  }, e.prototype.tangentAt = function(t) {
    var r = vj(this.shape, t, !0);
    return sh(r, r);
  }, e;
}(Ht);
Gg.prototype.type = "bezier-curve";
var DLe = /* @__PURE__ */ function() {
  function n() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return n;
}(), aw = function(n) {
  le(e, n);
  function e(t) {
    return n.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new DLe();
  }, e.prototype.buildPath = function(t, r) {
    var i = r.cx, a = r.cy, o = Math.max(r.r, 0), s = r.startAngle, l = r.endAngle, u = r.clockwise, c = Math.cos(s), d = Math.sin(s);
    t.moveTo(c * o + i, d * o + a), t.arc(i, a, o, s, l, !u);
  }, e;
}(Ht);
aw.prototype.type = "arc";
var HD = function(n) {
  le(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.type = "compound", t;
  }
  return e.prototype._updatePathDirty = function() {
    for (var t = this.shape.paths, r = this.shapeChanged(), i = 0; i < t.length; i++)
      r = r || t[i].shapeChanged();
    r && this.dirtyShape();
  }, e.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var t = this.shape.paths || [], r = this.getGlobalScale(), i = 0; i < t.length; i++)
      t[i].path || t[i].createPathProxy(), t[i].path.setScale(r[0], r[1], t[i].segmentIgnoreThreshold);
  }, e.prototype.buildPath = function(t, r) {
    for (var i = r.paths || [], a = 0; a < i.length; a++)
      i[a].buildPath(t, i[a].shape, !0);
  }, e.prototype.afterBrush = function() {
    for (var t = this.shape.paths || [], r = 0; r < t.length; r++)
      t[r].pathUpdated();
  }, e.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), Ht.prototype.getBoundingRect.call(this);
  }, e;
}(Ht), pU = function() {
  function n(e) {
    this.colorStops = e || [];
  }
  return n.prototype.addColorStop = function(e, t) {
    this.colorStops.push({
      offset: e,
      color: t
    });
  }, n;
}(), Ug = function(n) {
  le(e, n);
  function e(t, r, i, a, o, s) {
    var l = n.call(this, o) || this;
    return l.x = t ?? 0, l.y = r ?? 0, l.x2 = i ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = s || !1, l;
  }
  return e;
}(pU), hU = function(n) {
  le(e, n);
  function e(t, r, i, a, o) {
    var s = n.call(this, a) || this;
    return s.x = t ?? 0.5, s.y = r ?? 0.5, s.r = i ?? 0.5, s.type = "radial", s.global = o || !1, s;
  }
  return e;
}(pU), pc = [0, 0], hc = [0, 0], m0 = new Mt(), g0 = new Mt(), t_ = function() {
  function n(e, t) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var r = 0; r < 4; r++)
      this._corners[r] = new Mt();
    for (var r = 0; r < 2; r++)
      this._axes[r] = new Mt();
    e && this.fromBoundingRect(e, t);
  }
  return n.prototype.fromBoundingRect = function(e, t) {
    var r = this._corners, i = this._axes, a = e.x, o = e.y, s = a + e.width, l = o + e.height;
    if (r[0].set(a, o), r[1].set(s, o), r[2].set(s, l), r[3].set(a, l), t)
      for (var u = 0; u < 4; u++)
        r[u].transform(t);
    Mt.sub(i[0], r[1], r[0]), Mt.sub(i[1], r[3], r[0]), i[0].normalize(), i[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = i[u].dot(r[0]);
  }, n.prototype.intersect = function(e, t) {
    var r = !0, i = !t;
    return m0.set(1 / 0, 1 / 0), g0.set(0, 0), !this._intersectCheckOneSide(this, e, m0, g0, i, 1) && (r = !1, i) || !this._intersectCheckOneSide(e, this, m0, g0, i, -1) && (r = !1, i) || i || Mt.copy(t, r ? m0 : g0), r;
  }, n.prototype._intersectCheckOneSide = function(e, t, r, i, a, o) {
    for (var s = !0, l = 0; l < 2; l++) {
      var u = this._axes[l];
      if (this._getProjMinMaxOnAxis(l, e._corners, pc), this._getProjMinMaxOnAxis(l, t._corners, hc), pc[1] < hc[0] || pc[0] > hc[1]) {
        if (s = !1, a)
          return s;
        var c = Math.abs(hc[0] - pc[1]), d = Math.abs(pc[0] - hc[1]);
        Math.min(c, d) > i.len() && (c < d ? Mt.scale(i, u, -c * o) : Mt.scale(i, u, d * o));
      } else if (r) {
        var c = Math.abs(hc[0] - pc[1]), d = Math.abs(pc[0] - hc[1]);
        Math.min(c, d) < r.len() && (c < d ? Mt.scale(r, u, c * o) : Mt.scale(r, u, -d * o));
      }
    }
    return s;
  }, n.prototype._getProjMinMaxOnAxis = function(e, t, r) {
    for (var i = this._axes[e], a = this._origin, o = t[0].dot(i) + a[e], s = o, l = o, u = 1; u < t.length; u++) {
      var c = t[u].dot(i) + a[e];
      s = Math.min(c, s), l = Math.max(c, l);
    }
    r[0] = s, r[1] = l;
  }, n;
}(), OLe = [], ILe = function(n) {
  le(e, n);
  function e() {
    var t = n !== null && n.apply(this, arguments) || this;
    return t.notClear = !0, t.incremental = !0, t._displayables = [], t._temporaryDisplayables = [], t._cursor = 0, t;
  }
  return e.prototype.traverse = function(t, r) {
    t.call(r, this);
  }, e.prototype.useStyle = function() {
    this.style = {};
  }, e.prototype.getCursor = function() {
    return this._cursor;
  }, e.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, e.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, e.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, e.prototype.addDisplayable = function(t, r) {
    r ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.markRedraw();
  }, e.prototype.addDisplayables = function(t, r) {
    r = r || !1;
    for (var i = 0; i < t.length; i++)
      this.addDisplayable(t[i], r);
  }, e.prototype.getDisplayables = function() {
    return this._displayables;
  }, e.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, e.prototype.eachPendingDisplayable = function(t) {
    for (var r = this._cursor; r < this._displayables.length; r++)
      t && t(this._displayables[r]);
    for (var r = 0; r < this._temporaryDisplayables.length; r++)
      t && t(this._temporaryDisplayables[r]);
  }, e.prototype.update = function() {
    this.updateTransform();
    for (var t = this._cursor; t < this._displayables.length; t++) {
      var r = this._displayables[t];
      r.parent = this, r.update(), r.parent = null;
    }
    for (var t = 0; t < this._temporaryDisplayables.length; t++) {
      var r = this._temporaryDisplayables[t];
      r.parent = this, r.update(), r.parent = null;
    }
  }, e.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var t = new Ot(1 / 0, 1 / 0, -1 / 0, -1 / 0), r = 0; r < this._displayables.length; r++) {
        var i = this._displayables[r], a = i.getBoundingRect().clone();
        i.needLocalTransform() && a.applyTransform(i.getLocalTransform(OLe)), t.union(a);
      }
      this._rect = t;
    }
    return this._rect;
  }, e.prototype.contain = function(t, r) {
    var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect();
    if (a.contain(i[0], i[1]))
      for (var o = 0; o < this._displayables.length; o++) {
        var s = this._displayables[o];
        if (s.contain(t, r))
          return !0;
      }
    return !1;
  }, e;
}(no), vU = en();
function dh(n, e, t, r, i) {
  var a;
  if (e && e.ecModel) {
    var o = e.ecModel.getUpdatePayload();
    a = o && o.animation;
  }
  var s = e && e.isAnimationEnabled(), l = n === "update";
  if (s) {
    var u = void 0, c = void 0, d = void 0;
    r ? (u = bt(r.duration, 200), c = bt(r.easing, "cubicOut"), d = 0) : (u = e.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = e.getShallow(l ? "animationEasingUpdate" : "animationEasing"), d = e.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (c = a.easing), a.delay != null && (d = a.delay)), at(d) && (d = d(t, i)), at(u) && (u = u(t));
    var f = {
      duration: u || 0,
      delay: d,
      easing: c
    };
    return f;
  } else
    return null;
}
function GD(n, e, t, r, i, a, o) {
  var s = !1, l;
  at(i) ? (o = a, a = i, i = null) : ut(i) && (a = i.cb, o = i.during, s = i.isFrom, l = i.removeOpt, i = i.dataIndex);
  var u = n === "leave";
  u || e.stopAnimation("leave");
  var c = dh(n, r, i, u ? l || {} : null, r && r.getAnimationDelayParams ? r.getAnimationDelayParams(e, i) : null);
  if (c && c.duration > 0) {
    var d = c.duration, f = c.delay, p = c.easing, h = {
      duration: d,
      delay: f || 0,
      easing: p,
      done: a,
      force: !!a || !!o,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: n,
      during: o
    };
    s ? e.animateFrom(t, h) : e.animateTo(t, h);
  } else
    e.stopAnimation(), !s && e.attr(t), o && o(1), a && a();
}
function ln(n, e, t, r, i, a) {
  GD("update", n, e, t, r, i, a);
}
function Gn(n, e, t, r, i, a) {
  GD("enter", n, e, t, r, i, a);
}
function bp(n) {
  if (!n.__zr)
    return !0;
  for (var e = 0; e < n.animators.length; e++) {
    var t = n.animators[e];
    if (t.scope === "leave")
      return !0;
  }
  return !1;
}
function Pu(n, e, t, r, i, a) {
  bp(n) || GD("leave", n, e, t, r, i, a);
}
function mj(n, e, t, r) {
  n.removeTextContent(), n.removeTextGuideLine(), Pu(n, {
    style: {
      opacity: 0
    }
  }, e, t, r);
}
function tg(n, e, t) {
  function r() {
    n.parent && n.parent.remove(n);
  }
  n.isGroup ? n.traverse(function(i) {
    i.isGroup || mj(i, e, t, r);
  }) : mj(n, e, t, r);
}
function Oo(n) {
  vU(n).oldStyle = n.style;
}
function LLe(n) {
  return vU(n).oldStyle;
}
var n_ = Math.max, r_ = Math.min, mk = {};
function NLe(n) {
  return Ht.extend(n);
}
var RLe = hLe;
function PLe(n, e) {
  return RLe(n, e);
}
function Ro(n, e) {
  mk[n] = e;
}
function UD(n) {
  if (mk.hasOwnProperty(n))
    return mk[n];
}
function ow(n, e, t, r) {
  var i = cU(n, e);
  return t && (r === "center" && (t = gU(t, i.getBoundingRect())), yU(i, t)), i;
}
function mU(n, e, t) {
  var r = new Ur({
    style: {
      image: n,
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    },
    onload: function(i) {
      if (t === "center") {
        var a = {
          width: i.width,
          height: i.height
        };
        r.setStyle(gU(e, a));
      }
    }
  });
  return r;
}
function gU(n, e) {
  var t = e.width / e.height, r = n.height * t, i;
  r <= n.width ? i = n.height : (r = n.width, i = r / t);
  var a = n.x + n.width / 2, o = n.y + n.height / 2;
  return {
    x: a - r / 2,
    y: o - i / 2,
    width: r,
    height: i
  };
}
var Wa = vLe;
function yU(n, e) {
  if (n.applyTransform) {
    var t = n.getBoundingRect(), r = t.calculateTransform(e);
    n.applyTransform(r);
  }
}
function Fp(n, e) {
  return qG(n, n, {
    lineWidth: e
  }), n;
}
function jLe(n) {
  return YG(n.shape, n.shape, n.style), n;
}
var C1 = Gc;
function vd(n, e) {
  for (var t = Wx([]); n && n !== e; )
    cl(t, n.getLocalTransform(), t), n = n.parent;
  return t;
}
function wo(n, e, t) {
  return e && !hi(e) && (e = rl.getLocalTransform(e)), t && (e = lh([], e)), Zr([], n, e);
}
function sw(n, e, t) {
  var r = e[4] === 0 || e[5] === 0 || e[0] === 0 ? 1 : Math.abs(2 * e[4] / e[0]), i = e[4] === 0 || e[5] === 0 || e[2] === 0 ? 1 : Math.abs(2 * e[4] / e[2]), a = [n === "left" ? -r : n === "right" ? r : 0, n === "top" ? -i : n === "bottom" ? i : 0];
  return a = wo(a, e, t), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
}
function gj(n) {
  return !n.isGroup;
}
function BLe(n) {
  return n.shape != null;
}
function Wg(n, e, t) {
  if (!n || !e)
    return;
  function r(o) {
    var s = {};
    return o.traverse(function(l) {
      gj(l) && l.anid && (s[l.anid] = l);
    }), s;
  }
  function i(o) {
    var s = {
      x: o.x,
      y: o.y,
      rotation: o.rotation
    };
    return BLe(o) && (s.shape = xe({}, o.shape)), s;
  }
  var a = r(n);
  e.traverse(function(o) {
    if (gj(o) && o.anid) {
      var s = a[o.anid];
      if (s) {
        var l = i(o);
        o.attr(i(s)), ln(o, l, t, yt(o).dataIndex);
      }
    }
  });
}
function bU(n, e) {
  return De(n, function(t) {
    var r = t[0];
    r = n_(r, e.x), r = r_(r, e.x + e.width);
    var i = t[1];
    return i = n_(i, e.y), i = r_(i, e.y + e.height), [r, i];
  });
}
function $Le(n, e) {
  var t = n_(n.x, e.x), r = r_(n.x + n.width, e.x + e.width), i = n_(n.y, e.y), a = r_(n.y + n.height, e.y + e.height);
  if (r >= t && a >= i)
    return {
      x: t,
      y: i,
      width: r - t,
      height: a - i
    };
}
function qg(n, e, t) {
  var r = xe({
    rectHover: !0
  }, e), i = r.style = {
    strokeNoScale: !0
  };
  if (t = t || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, n)
    return n.indexOf("image://") === 0 ? (i.image = n.slice(8), dt(i, t), new Ur(r)) : ow(n.replace("path://", ""), r, t, "center");
}
function Ov(n, e, t, r, i) {
  for (var a = 0, o = i[i.length - 1]; a < i.length; a++) {
    var s = i[a];
    if (_U(n, e, t, r, s[0], s[1], o[0], o[1]))
      return !0;
    o = s;
  }
}
function _U(n, e, t, r, i, a, o, s) {
  var l = t - n, u = r - e, c = o - i, d = s - a, f = k2(c, d, l, u);
  if (zLe(f))
    return !1;
  var p = n - i, h = e - a, v = k2(p, h, l, u) / f;
  if (v < 0 || v > 1)
    return !1;
  var m = k2(p, h, c, d) / f;
  return !(m < 0 || m > 1);
}
function k2(n, e, t, r) {
  return n * r - t * e;
}
function zLe(n) {
  return n <= 1e-6 && n >= -1e-6;
}
function Jd(n) {
  var e = n.itemTooltipOption, t = n.componentModel, r = n.itemName, i = We(e) ? {
    formatter: e
  } : e, a = t.mainType, o = t.componentIndex, s = {
    componentType: a,
    name: r,
    $vars: ["name"]
  };
  s[a + "Index"] = o;
  var l = n.formatterParamsExtra;
  l && $(Yt(l), function(c) {
    Je(s, c) || (s[c] = l[c], s.$vars.push(c));
  });
  var u = yt(n.el);
  u.componentMainType = a, u.componentIndex = o, u.tooltipConfig = {
    name: r,
    option: dt({
      content: r,
      encodeHTMLContent: !0,
      formatterParams: s
    }, i)
  };
}
function yj(n, e) {
  var t;
  n.isGroup && (t = e(n)), t || n.traverse(e);
}
function Yu(n, e) {
  if (n)
    if (Me(n))
      for (var t = 0; t < n.length; t++)
        yj(n[t], e);
    else
      yj(n, e);
}
Ro("circle", Ml);
Ro("ellipse", iw);
Ro("sector", Fi);
Ro("ring", Hg);
Ro("polygon", Vi);
Ro("polyline", Hi);
Ro("rect", Qt);
Ro("line", Dr);
Ro("bezierCurve", Gg);
Ro("arc", aw);
const Qd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: aw,
  BezierCurve: Gg,
  BoundingRect: Ot,
  Circle: Ml,
  CompoundPath: HD,
  Ellipse: iw,
  Group: mt,
  Image: Ur,
  IncrementalDisplayable: ILe,
  Line: Dr,
  LinearGradient: Ug,
  OrientedBoundingRect: t_,
  Path: Ht,
  Point: Mt,
  Polygon: Vi,
  Polyline: Hi,
  RadialGradient: hU,
  Rect: Qt,
  Ring: Hg,
  Sector: Fi,
  Text: nn,
  applyTransform: wo,
  clipPointsByRect: bU,
  clipRectByRect: $Le,
  createIcon: qg,
  extendPath: PLe,
  extendShape: NLe,
  getShapeClass: UD,
  getTransform: vd,
  groupTransition: Wg,
  initProps: Gn,
  isElementRemoved: bp,
  lineLineIntersect: _U,
  linePolygonIntersect: Ov,
  makeImage: mU,
  makePath: ow,
  mergePath: Wa,
  registerShape: Ro,
  removeElement: Pu,
  removeElementWithFadeOut: tg,
  resizePath: yU,
  setTooltipConfig: Jd,
  subPixelOptimize: C1,
  subPixelOptimizeLine: Fp,
  subPixelOptimizeRect: jLe,
  transformDirection: sw,
  traverseElements: Yu,
  updateProps: ln
}, Symbol.toStringTag, { value: "Module" }));
var lw = {};
function xU(n, e) {
  for (var t = 0; t < zi.length; t++) {
    var r = zi[t], i = e[r], a = n.ensureState(r);
    a.style = a.style || {}, a.style.text = i;
  }
  var o = n.currentStates.slice();
  n.clearStates(!0), n.setStyle({
    text: e.normal
  }), n.useStates(o, !0);
}
function gk(n, e, t) {
  var r = n.labelFetcher, i = n.labelDataIndex, a = n.labelDimIndex, o = e.normal, s;
  r && (s = r.getFormattedLabel(i, "normal", null, a, o && o.get("formatter"), t != null ? {
    interpolatedValue: t
  } : null)), s == null && (s = at(n.defaultText) ? n.defaultText(i, n, t) : n.defaultText);
  for (var l = {
    normal: s
  }, u = 0; u < zi.length; u++) {
    var c = zi[u], d = e[c];
    l[c] = bt(r ? r.getFormattedLabel(i, c, null, a, d && d.get("formatter")) : null, s);
  }
  return l;
}
function ei(n, e, t, r) {
  t = t || lw;
  for (var i = n instanceof nn, a = !1, o = 0; o < eg.length; o++) {
    var s = e[eg[o]];
    if (s && s.getShallow("show")) {
      a = !0;
      break;
    }
  }
  var l = i ? n : n.getTextContent();
  if (a) {
    i || (l || (l = new nn(), n.setTextContent(l)), n.stateProxy && (l.stateProxy = n.stateProxy));
    var u = gk(t, e), c = e.normal, d = !!c.getShallow("show"), f = Ln(c, r && r.normal, t, !1, !i);
    f.text = u.normal, i || n.setTextConfig(i_(c, t, !1));
    for (var o = 0; o < zi.length; o++) {
      var p = zi[o], s = e[p];
      if (s) {
        var h = l.ensureState(p), v = !!bt(s.getShallow("show"), d);
        if (v !== d && (h.ignore = !v), h.style = Ln(s, r && r[p], t, !0, !i), h.style.text = u[p], !i) {
          var m = n.ensureState(p);
          m.textConfig = i_(s, t, !0);
        }
      }
    }
    l.silent = !!c.getShallow("silent"), l.style.x != null && (f.x = l.style.x), l.style.y != null && (f.y = l.style.y), l.ignore = !d, l.useStyle(f), l.dirty(), t.enableTextSetter && (fh(l).setLabelText = function(g) {
      var y = gk(t, e, g);
      xU(l, y);
    });
  } else l && (l.ignore = !0);
  n.dirty();
}
function Nr(n, e) {
  e = e || "label";
  for (var t = {
    normal: n.getModel(e)
  }, r = 0; r < zi.length; r++) {
    var i = zi[r];
    t[i] = n.getModel([i, e]);
  }
  return t;
}
function Ln(n, e, t, r, i) {
  var a = {};
  return FLe(a, n, t, r, i), e && xe(a, e), a;
}
function i_(n, e, t) {
  e = e || {};
  var r = {}, i, a = n.getShallow("rotate"), o = bt(n.getShallow("distance"), t ? null : 5), s = n.getShallow("offset");
  return i = n.getShallow("position") || (t ? null : "inside"), i === "outside" && (i = e.defaultOutsidePosition || "top"), i != null && (r.position = i), s != null && (r.offset = s), a != null && (a *= Math.PI / 180, r.rotation = a), o != null && (r.distance = o), r.outsideFill = n.get("color") === "inherit" ? e.inheritColor || null : "auto", r;
}
function FLe(n, e, t, r, i) {
  t = t || lw;
  var a = e.ecModel, o = a && a.option.textStyle, s = VLe(e), l;
  if (s) {
    l = {};
    for (var u in s)
      if (s.hasOwnProperty(u)) {
        var c = e.getModel(["rich", u]);
        wj(l[u] = {}, c, o, t, r, i, !1, !0);
      }
  }
  l && (n.rich = l);
  var d = e.get("overflow");
  d && (n.overflow = d);
  var f = e.get("minMargin");
  f != null && (n.margin = f), wj(n, e, o, t, r, i, !0, !1);
}
function VLe(n) {
  for (var e; n && n !== n.ecModel; ) {
    var t = (n.option || lw).rich;
    if (t) {
      e = e || {};
      for (var r = Yt(t), i = 0; i < r.length; i++) {
        var a = r[i];
        e[a] = 1;
      }
    }
    n = n.parentModel;
  }
  return e;
}
var bj = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], _j = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], xj = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function wj(n, e, t, r, i, a, o, s) {
  t = !i && t || lw;
  var l = r && r.inheritColor, u = e.getShallow("color"), c = e.getShallow("textBorderColor"), d = bt(e.getShallow("opacity"), t.opacity);
  (u === "inherit" || u === "auto") && (process.env.NODE_ENV !== "production" && u === "auto" && vr("color: 'auto'", "color: 'inherit'"), l ? u = l : u = null), (c === "inherit" || c === "auto") && (process.env.NODE_ENV !== "production" && c === "auto" && vr("color: 'auto'", "color: 'inherit'"), l ? c = l : c = null), a || (u = u || t.color, c = c || t.textBorderColor), u != null && (n.fill = u), c != null && (n.stroke = c);
  var f = bt(e.getShallow("textBorderWidth"), t.textBorderWidth);
  f != null && (n.lineWidth = f);
  var p = bt(e.getShallow("textBorderType"), t.textBorderType);
  p != null && (n.lineDash = p);
  var h = bt(e.getShallow("textBorderDashOffset"), t.textBorderDashOffset);
  h != null && (n.lineDashOffset = h), !i && d == null && !s && (d = r && r.defaultOpacity), d != null && (n.opacity = d), !i && !a && n.fill == null && r.inheritColor && (n.fill = r.inheritColor);
  for (var v = 0; v < bj.length; v++) {
    var m = bj[v], g = bt(e.getShallow(m), t[m]);
    g != null && (n[m] = g);
  }
  for (var v = 0; v < _j.length; v++) {
    var m = _j[v], g = e.getShallow(m);
    g != null && (n[m] = g);
  }
  if (n.verticalAlign == null) {
    var y = e.getShallow("baseline");
    y != null && (n.verticalAlign = y);
  }
  if (!o || !r.disableBox) {
    for (var v = 0; v < xj.length; v++) {
      var m = xj[v], g = e.getShallow(m);
      g != null && (n[m] = g);
    }
    var b = e.getShallow("borderType");
    b != null && (n.borderDash = b), (n.backgroundColor === "auto" || n.backgroundColor === "inherit") && l && (process.env.NODE_ENV !== "production" && n.backgroundColor === "auto" && vr("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), n.backgroundColor = l), (n.borderColor === "auto" || n.borderColor === "inherit") && l && (process.env.NODE_ENV !== "production" && n.borderColor === "auto" && vr("borderColor: 'auto'", "borderColor: 'inherit'"), n.borderColor = l);
  }
}
function WD(n, e) {
  var t = e && e.getModel("textStyle");
  return yo([
    // FIXME in node-canvas fontWeight is before fontStyle
    n.fontStyle || t && t.getShallow("fontStyle") || "",
    n.fontWeight || t && t.getShallow("fontWeight") || "",
    (n.fontSize || t && t.getShallow("fontSize") || 12) + "px",
    n.fontFamily || t && t.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var fh = en();
function wU(n, e, t, r) {
  if (n) {
    var i = fh(n);
    i.prevValue = i.value, i.value = t;
    var a = e.normal;
    i.valueAnimation = a.get("valueAnimation"), i.valueAnimation && (i.precision = a.get("precision"), i.defaultInterpolatedText = r, i.statesModels = e);
  }
}
function SU(n, e, t, r, i) {
  var a = fh(n);
  if (!a.valueAnimation || a.prevValue === a.value)
    return;
  var o = a.defaultInterpolatedText, s = bt(a.interpolatedValue, a.prevValue), l = a.value;
  function u(c) {
    var d = $G(t, a.precision, s, l, c);
    a.interpolatedValue = c === 1 ? null : d;
    var f = gk({
      labelDataIndex: e,
      labelFetcher: i,
      defaultText: o ? o(d) : d + ""
    }, a.statesModels, d);
    xU(n, f);
  }
  n.percent = 0, (a.prevValue == null ? Gn : ln)(n, {
    // percent is used to prevent animation from being aborted #15916
    percent: 1
  }, r, e, null, u);
}
var HLe = ["textStyle", "color"], A2 = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], M2 = new nn(), GLe = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getTextColor = function(e) {
      var t = this.ecModel;
      return this.getShallow("color") || (!e && t ? t.get(HLe) : null);
    }, n.prototype.getFont = function() {
      return WD({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, n.prototype.getTextRect = function(e) {
      for (var t = {
        text: e,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, r = 0; r < A2.length; r++)
        t[A2[r]] = this.getShallow(A2[r]);
      return M2.useStyle(t), M2.update(), M2.getBoundingRect();
    }, n;
  }()
), EU = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], ULe = Ld(EU), WLe = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getLineStyle = function(e) {
      return ULe(this, e);
    }, n;
  }()
), TU = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], qLe = Ld(TU), YLe = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getItemStyle = function(e, t) {
      return qLe(this, e, t);
    }, n;
  }()
), yn = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.parentModel = t, this.ecModel = r, this.option = e;
    }
    return n.prototype.init = function(e, t, r) {
    }, n.prototype.mergeOption = function(e, t) {
      At(this.option, e, !0);
    }, n.prototype.get = function(e, t) {
      return e == null ? this.option : this._doGet(this.parsePath(e), !t && this.parentModel);
    }, n.prototype.getShallow = function(e, t) {
      var r = this.option, i = r == null ? r : r[e];
      if (i == null && !t) {
        var a = this.parentModel;
        a && (i = a.getShallow(e));
      }
      return i;
    }, n.prototype.getModel = function(e, t) {
      var r = e != null, i = r ? this.parsePath(e) : null, a = r ? this._doGet(i) : this.option;
      return t = t || this.parentModel && this.parentModel.getModel(this.resolveParentPath(i)), new n(a, t, this.ecModel);
    }, n.prototype.isEmpty = function() {
      return this.option == null;
    }, n.prototype.restoreData = function() {
    }, n.prototype.clone = function() {
      var e = this.constructor;
      return new e(ht(this.option));
    }, n.prototype.parsePath = function(e) {
      return typeof e == "string" ? e.split(".") : e;
    }, n.prototype.resolveParentPath = function(e) {
      return e;
    }, n.prototype.isAnimationEnabled = function() {
      if (!Vt.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, n.prototype._doGet = function(e, t) {
      var r = this.option;
      if (!e)
        return r;
      for (var i = 0; i < e.length && !(e[i] && (r = r && typeof r == "object" ? r[e[i]] : null, r == null)); i++)
        ;
      return r == null && t && (r = t._doGet(this.resolveParentPath(e), t.parentModel)), r;
    }, n;
  }()
);
ND(yn);
rIe(yn);
_r(yn, WLe);
_r(yn, YLe);
_r(yn, lIe);
_r(yn, GLe);
var KLe = Math.round(Math.random() * 10);
function ph(n) {
  return [n || "", KLe++].join("_");
}
function XLe(n) {
  var e = {};
  n.registerSubTypeDefaulter = function(t, r) {
    var i = ls(t);
    e[i.main] = r;
  }, n.determineSubType = function(t, r) {
    var i = r.type;
    if (!i) {
      var a = ls(t).main;
      n.hasSubTypes(t) && e[a] && (i = e[a](r));
    }
    return i;
  };
}
function ZLe(n, e) {
  n.topologicalTravel = function(a, o, s, l) {
    if (!a.length)
      return;
    var u = t(o), c = u.graph, d = u.noEntryList, f = {};
    for ($(a, function(y) {
      f[y] = !0;
    }); d.length; ) {
      var p = d.pop(), h = c[p], v = !!f[p];
      v && (s.call(l, p, h.originalDeps.slice()), delete f[p]), $(h.successor, v ? g : m);
    }
    $(f, function() {
      var y = "";
      throw process.env.NODE_ENV !== "production" && (y = $i("Circular dependency may exists: ", f, a, o)), new Error(y);
    });
    function m(y) {
      c[y].entryCount--, c[y].entryCount === 0 && d.push(y);
    }
    function g(y) {
      f[y] = !0, m(y);
    }
  };
  function t(a) {
    var o = {}, s = [];
    return $(a, function(l) {
      var u = r(o, l), c = u.originalDeps = e(l), d = i(c, a);
      u.entryCount = d.length, u.entryCount === 0 && s.push(l), $(d, function(f) {
        Pt(u.predecessor, f) < 0 && u.predecessor.push(f);
        var p = r(o, f);
        Pt(p.successor, f) < 0 && p.successor.push(l);
      });
    }), {
      graph: o,
      noEntryList: s
    };
  }
  function r(a, o) {
    return a[o] || (a[o] = {
      predecessor: [],
      successor: []
    }), a[o];
  }
  function i(a, o) {
    var s = [];
    return $(a, function(l) {
      Pt(o, l) >= 0 && s.push(l);
    }), s;
  }
}
function Ku(n, e) {
  return At(At({}, n, !0), e, !0);
}
const JLe = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, QLe = {
  time: {
    month: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
    monthAbbr: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
    dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
    dayOfWeekAbbr: ["日", "一", "二", "三", "四", "五", "六"]
  },
  legend: {
    selector: {
      all: "全选",
      inverse: "反选"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "矩形选择",
        polygon: "圈选",
        lineX: "横向选择",
        lineY: "纵向选择",
        keep: "保持选择",
        clear: "清除选择"
      }
    },
    dataView: {
      title: "数据视图",
      lang: ["数据视图", "关闭", "刷新"]
    },
    dataZoom: {
      title: {
        zoom: "区域缩放",
        back: "区域缩放还原"
      }
    },
    magicType: {
      title: {
        line: "切换为折线图",
        bar: "切换为柱状图",
        stack: "切换为堆叠",
        tiled: "切换为平铺"
      }
    },
    restore: {
      title: "还原"
    },
    saveAsImage: {
      title: "保存为图片",
      lang: ["右键另存为图片"]
    }
  },
  series: {
    typeNames: {
      pie: "饼图",
      bar: "柱状图",
      line: "折线图",
      scatter: "散点图",
      effectScatter: "涟漪散点图",
      radar: "雷达图",
      tree: "树图",
      treemap: "矩形树图",
      boxplot: "箱型图",
      candlestick: "K线图",
      k: "K线图",
      heatmap: "热力图",
      map: "地图",
      parallel: "平行坐标图",
      lines: "线图",
      graph: "关系图",
      sankey: "桑基图",
      funnel: "漏斗图",
      gauge: "仪表盘图",
      pictorialBar: "象形柱图",
      themeRiver: "主题河流图",
      sunburst: "旭日图",
      custom: "自定义图表",
      chart: "图表"
    }
  },
  aria: {
    general: {
      withTitle: "这是一个关于“{title}”的图表。",
      withoutTitle: "这是一个图表，"
    },
    series: {
      single: {
        prefix: "",
        withName: "图表类型是{seriesType}，表示{seriesName}。",
        withoutName: "图表类型是{seriesType}。"
      },
      multiple: {
        prefix: "它由{seriesCount}个图表系列组成。",
        withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
        withoutName: "第{seriesId}个系列是一个{seriesType}，",
        separator: {
          middle: "；",
          end: "。"
        }
      }
    },
    data: {
      allData: "其数据是——",
      partialData: "其中，前{displayCnt}项是——",
      withName: "{name}的数据是{value}",
      withoutName: "{value}",
      separator: {
        middle: "，",
        end: ""
      }
    }
  }
};
var a_ = "ZH", qD = "EN", _p = qD, k1 = {}, YD = {}, CU = Vt.domSupported ? function() {
  var n = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage || _p).toUpperCase()
  );
  return n.indexOf(a_) > -1 ? a_ : _p;
}() : _p;
function kU(n, e) {
  n = n.toUpperCase(), YD[n] = new yn(e), k1[n] = e;
}
function eNe(n) {
  if (We(n)) {
    var e = k1[n.toUpperCase()] || {};
    return n === a_ || n === qD ? ht(e) : At(ht(e), ht(k1[_p]), !1);
  } else
    return At(ht(n), ht(k1[_p]), !1);
}
function yk(n) {
  return YD[n];
}
function tNe() {
  return YD[_p];
}
kU(qD, JLe);
kU(a_, QLe);
var KD = 1e3, XD = KD * 60, hm = XD * 60, qa = hm * 24, Sj = qa * 365, Iv = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
}, y0 = "{yyyy}-{MM}-{dd}", Ej = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: y0,
  hour: y0 + " " + Iv.hour,
  minute: y0 + " " + Iv.minute,
  second: y0 + " " + Iv.second,
  millisecond: Iv.none
}, D2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"], AU = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function zl(n, e) {
  return n += "", "0000".substr(0, e - n.length) + n;
}
function xp(n) {
  switch (n) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return n;
  }
}
function nNe(n) {
  return n === xp(n);
}
function rNe(n) {
  switch (n) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function uw(n, e, t, r) {
  var i = Es(n), a = i[ZD(t)](), o = i[wp(t)]() + 1, s = Math.floor((o - 1) / 3) + 1, l = i[cw(t)](), u = i["get" + (t ? "UTC" : "") + "Day"](), c = i[ng(t)](), d = (c - 1) % 12 + 1, f = i[dw(t)](), p = i[fw(t)](), h = i[pw(t)](), v = c >= 12 ? "pm" : "am", m = v.toUpperCase(), g = r instanceof yn ? r : yk(r || CU) || tNe(), y = g.getModel("time"), b = y.get("month"), _ = y.get("monthAbbr"), x = y.get("dayOfWeek"), w = y.get("dayOfWeekAbbr");
  return (e || "").replace(/{a}/g, v + "").replace(/{A}/g, m + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, zl(a % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, b[o - 1]).replace(/{MMM}/g, _[o - 1]).replace(/{MM}/g, zl(o, 2)).replace(/{M}/g, o + "").replace(/{dd}/g, zl(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, x[u]).replace(/{ee}/g, w[u]).replace(/{e}/g, u + "").replace(/{HH}/g, zl(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, zl(d + "", 2)).replace(/{h}/g, d + "").replace(/{mm}/g, zl(f, 2)).replace(/{m}/g, f + "").replace(/{ss}/g, zl(p, 2)).replace(/{s}/g, p + "").replace(/{SSS}/g, zl(h, 3)).replace(/{S}/g, h + "");
}
function iNe(n, e, t, r, i) {
  var a = null;
  if (We(t))
    a = t;
  else if (at(t))
    a = t(n.value, e, {
      level: n.level
    });
  else {
    var o = xe({}, Iv);
    if (n.level > 0)
      for (var s = 0; s < D2.length; ++s)
        o[D2[s]] = "{primary|" + o[D2[s]] + "}";
    var l = t ? t.inherit === !1 ? t : dt(t, o) : o, u = MU(n.value, i);
    if (l[u])
      a = l[u];
    else if (l.inherit) {
      for (var c = AU.indexOf(u), s = c - 1; s >= 0; --s)
        if (l[u]) {
          a = l[u];
          break;
        }
      a = a || o.none;
    }
    if (Me(a)) {
      var d = n.level == null ? 0 : n.level >= 0 ? n.level : a.length + n.level;
      d = Math.min(d, a.length - 1), a = a[d];
    }
  }
  return uw(new Date(n.value), a, i, r);
}
function MU(n, e) {
  var t = Es(n), r = t[wp(e)]() + 1, i = t[cw(e)](), a = t[ng(e)](), o = t[dw(e)](), s = t[fw(e)](), l = t[pw(e)](), u = l === 0, c = u && s === 0, d = c && o === 0, f = d && a === 0, p = f && i === 1, h = p && r === 1;
  return h ? "year" : p ? "month" : f ? "day" : d ? "hour" : c ? "minute" : u ? "second" : "millisecond";
}
function Tj(n, e, t) {
  var r = sn(n) ? Es(n) : n;
  switch (e = e || MU(n, t), e) {
    case "year":
      return r[ZD(t)]();
    case "half-year":
      return r[wp(t)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((r[wp(t)]() + 1) / 4);
    case "month":
      return r[wp(t)]();
    case "day":
      return r[cw(t)]();
    case "half-day":
      return r[ng(t)]() / 24;
    case "hour":
      return r[ng(t)]();
    case "minute":
      return r[dw(t)]();
    case "second":
      return r[fw(t)]();
    case "millisecond":
      return r[pw(t)]();
  }
}
function ZD(n) {
  return n ? "getUTCFullYear" : "getFullYear";
}
function wp(n) {
  return n ? "getUTCMonth" : "getMonth";
}
function cw(n) {
  return n ? "getUTCDate" : "getDate";
}
function ng(n) {
  return n ? "getUTCHours" : "getHours";
}
function dw(n) {
  return n ? "getUTCMinutes" : "getMinutes";
}
function fw(n) {
  return n ? "getUTCSeconds" : "getSeconds";
}
function pw(n) {
  return n ? "getUTCMilliseconds" : "getMilliseconds";
}
function aNe(n) {
  return n ? "setUTCFullYear" : "setFullYear";
}
function DU(n) {
  return n ? "setUTCMonth" : "setMonth";
}
function OU(n) {
  return n ? "setUTCDate" : "setDate";
}
function IU(n) {
  return n ? "setUTCHours" : "setHours";
}
function LU(n) {
  return n ? "setUTCMinutes" : "setMinutes";
}
function NU(n) {
  return n ? "setUTCSeconds" : "setSeconds";
}
function RU(n) {
  return n ? "setUTCMilliseconds" : "setMilliseconds";
}
function PU(n) {
  if (!OD(n))
    return We(n) ? n : "-";
  var e = (n + "").split(".");
  return e[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (e.length > 1 ? "." + e[1] : "");
}
function jU(n, e) {
  return n = (n || "").toLowerCase().replace(/-(.)/g, function(t, r) {
    return r.toUpperCase();
  }), e && n && (n = n.charAt(0).toUpperCase() + n.slice(1)), n;
}
var hh = ED;
function bk(n, e, t) {
  var r = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function i(c) {
    return c && yo(c) ? c : "-";
  }
  function a(c) {
    return !!(c != null && !isNaN(c) && isFinite(c));
  }
  var o = e === "time", s = n instanceof Date;
  if (o || s) {
    var l = o ? Es(n) : n;
    if (isNaN(+l)) {
      if (s)
        return "-";
    } else return uw(l, r, t);
  }
  if (e === "ordinal")
    return Hb(n) ? i(n) : sn(n) && a(n) ? n + "" : "-";
  var u = _l(n);
  return a(u) ? PU(u) : Hb(n) ? i(n) : typeof n == "boolean" ? n + "" : "-";
}
var Cj = ["a", "b", "c", "d", "e", "f", "g"], O2 = function(n, e) {
  return "{" + n + (e ?? "") + "}";
};
function BU(n, e, t) {
  Me(e) || (e = [e]);
  var r = e.length;
  if (!r)
    return "";
  for (var i = e[0].$vars || [], a = 0; a < i.length; a++) {
    var o = Cj[a];
    n = n.replace(O2(o), O2(o, 0));
  }
  for (var s = 0; s < r; s++)
    for (var l = 0; l < i.length; l++) {
      var u = e[s][i[l]];
      n = n.replace(O2(Cj[l], s), t ? Ai(u) : u);
    }
  return n;
}
function oNe(n, e, t) {
  return $(e, function(r, i) {
    n = n.replace("{" + i + "}", r);
  }), n;
}
function sNe(n, e) {
  var t = We(n) ? {
    color: n,
    extraCssText: e
  } : n || {}, r = t.color, i = t.type;
  e = t.extraCssText;
  var a = t.renderMode || "html";
  if (!r)
    return "";
  if (a === "html")
    return i === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Ai(r) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Ai(r) + ";" + (e || "") + '"></span>';
  var o = t.markerId || "markerX";
  return {
    renderMode: a,
    content: "{" + o + "|}  ",
    style: i === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: r
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: r
    }
  };
}
function Rd(n, e) {
  return e = e || "transparent", We(n) ? n : ut(n) && n.colorStops && (n.colorStops[0] || {}).color || e;
}
function o_(n, e) {
  if (e === "_blank" || e === "blank") {
    var t = window.open();
    t.opener = null, t.location.href = n;
  } else
    window.open(n, e);
}
var A1 = $, $U = ["left", "right", "top", "bottom", "width", "height"], Wc = [["width", "left", "right"], ["height", "top", "bottom"]];
function JD(n, e, t, r, i) {
  var a = 0, o = 0;
  r == null && (r = 1 / 0), i == null && (i = 1 / 0);
  var s = 0;
  e.eachChild(function(l, u) {
    var c = l.getBoundingRect(), d = e.childAt(u + 1), f = d && d.getBoundingRect(), p, h;
    if (n === "horizontal") {
      var v = c.width + (f ? -f.x + c.x : 0);
      p = a + v, p > r || l.newline ? (a = 0, p = v, o += s + t, s = c.height) : s = Math.max(s, c.height);
    } else {
      var m = c.height + (f ? -f.y + c.y : 0);
      h = o + m, h > i || l.newline ? (a += s + t, o = 0, h = m, s = c.width) : s = Math.max(s, c.width);
    }
    l.newline || (l.x = a, l.y = o, l.markRedraw(), n === "horizontal" ? a = p + t : o = h + t);
  });
}
var md = JD;
Tt(JD, "vertical");
Tt(JD, "horizontal");
function lNe(n, e, t) {
  var r = e.width, i = e.height, a = ze(n.left, r), o = ze(n.top, i), s = ze(n.right, r), l = ze(n.bottom, i);
  return (isNaN(a) || isNaN(parseFloat(n.left))) && (a = 0), (isNaN(s) || isNaN(parseFloat(n.right))) && (s = r), (isNaN(o) || isNaN(parseFloat(n.top))) && (o = 0), (isNaN(l) || isNaN(parseFloat(n.bottom))) && (l = i), t = hh(t || 0), {
    width: Math.max(s - a - t[1] - t[3], 0),
    height: Math.max(l - o - t[0] - t[2], 0)
  };
}
function Er(n, e, t) {
  t = hh(t || 0);
  var r = e.width, i = e.height, a = ze(n.left, r), o = ze(n.top, i), s = ze(n.right, r), l = ze(n.bottom, i), u = ze(n.width, r), c = ze(n.height, i), d = t[2] + t[0], f = t[1] + t[3], p = n.aspect;
  switch (isNaN(u) && (u = r - s - f - a), isNaN(c) && (c = i - l - d - o), p != null && (isNaN(u) && isNaN(c) && (p > r / i ? u = r * 0.8 : c = i * 0.8), isNaN(u) && (u = p * c), isNaN(c) && (c = u / p)), isNaN(a) && (a = r - s - u - f), isNaN(o) && (o = i - l - c - d), n.left || n.right) {
    case "center":
      a = r / 2 - u / 2 - t[3];
      break;
    case "right":
      a = r - u - f;
      break;
  }
  switch (n.top || n.bottom) {
    case "middle":
    case "center":
      o = i / 2 - c / 2 - t[0];
      break;
    case "bottom":
      o = i - c - d;
      break;
  }
  a = a || 0, o = o || 0, isNaN(u) && (u = r - f - a - (s || 0)), isNaN(c) && (c = i - d - o - (l || 0));
  var h = new Ot(a + t[3], o + t[0], u, c);
  return h.margin = t, h;
}
function hw(n, e, t, r, i, a) {
  var o = !i || !i.hv || i.hv[0], s = !i || !i.hv || i.hv[1], l = i && i.boundingMode || "all";
  if (a = a || n, a.x = n.x, a.y = n.y, !o && !s)
    return !1;
  var u;
  if (l === "raw")
    u = n.type === "group" ? new Ot(0, 0, +e.width || 0, +e.height || 0) : n.getBoundingRect();
  else if (u = n.getBoundingRect(), n.needLocalTransform()) {
    var c = n.getLocalTransform();
    u = u.clone(), u.applyTransform(c);
  }
  var d = Er(dt({
    width: u.width,
    height: u.height
  }, e), t, r), f = o ? d.x - u.x : 0, p = s ? d.y - u.y : 0;
  return l === "raw" ? (a.x = f, a.y = p) : (a.x += f, a.y += p), a === n && n.markRedraw(), !0;
}
function uNe(n, e) {
  return n[Wc[e][0]] != null || n[Wc[e][1]] != null && n[Wc[e][2]] != null;
}
function rg(n) {
  var e = n.layoutMode || n.constructor.layoutMode;
  return ut(e) ? e : e ? {
    type: e
  } : null;
}
function ju(n, e, t) {
  var r = t && t.ignoreSize;
  !Me(r) && (r = [r, r]);
  var i = o(Wc[0], 0), a = o(Wc[1], 1);
  u(Wc[0], n, i), u(Wc[1], n, a);
  function o(c, d) {
    var f = {}, p = 0, h = {}, v = 0, m = 2;
    if (A1(c, function(b) {
      h[b] = n[b];
    }), A1(c, function(b) {
      s(e, b) && (f[b] = h[b] = e[b]), l(f, b) && p++, l(h, b) && v++;
    }), r[d])
      return l(e, c[1]) ? h[c[2]] = null : l(e, c[2]) && (h[c[1]] = null), h;
    if (v === m || !p)
      return h;
    if (p >= m)
      return f;
    for (var g = 0; g < c.length; g++) {
      var y = c[g];
      if (!s(f, y) && s(n, y)) {
        f[y] = n[y];
        break;
      }
    }
    return f;
  }
  function s(c, d) {
    return c.hasOwnProperty(d);
  }
  function l(c, d) {
    return c[d] != null && c[d] !== "auto";
  }
  function u(c, d, f) {
    A1(c, function(p) {
      d[p] = f[p];
    });
  }
}
function vh(n) {
  return zU({}, n);
}
function zU(n, e) {
  return e && n && A1($U, function(t) {
    e.hasOwnProperty(t) && (n[t] = e[t]);
  }), n;
}
var cNe = en(), Ut = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i) {
      var a = n.call(this, t, r, i) || this;
      return a.uid = ph("ec_cpt_model"), a;
    }
    return e.prototype.init = function(t, r, i) {
      this.mergeDefaultAndTheme(t, i);
    }, e.prototype.mergeDefaultAndTheme = function(t, r) {
      var i = rg(this), a = i ? vh(t) : {}, o = r.getTheme();
      At(t, o.get(this.mainType)), At(t, this.getDefaultOption()), i && ju(t, a, i);
    }, e.prototype.mergeOption = function(t, r) {
      At(this.option, t, !0);
      var i = rg(this);
      i && ju(this.option, t, i);
    }, e.prototype.optionUpdated = function(t, r) {
    }, e.prototype.getDefaultOption = function() {
      var t = this.constructor;
      if (!eIe(t))
        return t.defaultOption;
      var r = cNe(this);
      if (!r.defaultOption) {
        for (var i = [], a = t; a; ) {
          var o = a.prototype.defaultOption;
          o && i.push(o), a = a.superClass;
        }
        for (var s = {}, l = i.length - 1; l >= 0; l--)
          s = At(s, i[l], !0);
        r.defaultOption = s;
      }
      return r.defaultOption;
    }, e.prototype.getReferringComponents = function(t, r) {
      var i = t + "Index", a = t + "Id";
      return Fg(this.ecModel, t, {
        index: this.get(i, !0),
        id: this.get(a, !0)
      }, r);
    }, e.prototype.getBoxLayoutParams = function() {
      var t = this;
      return {
        left: t.get("left"),
        top: t.get("top"),
        right: t.get("right"),
        bottom: t.get("bottom"),
        width: t.get("width"),
        height: t.get("height")
      };
    }, e.prototype.getZLevelKey = function() {
      return "";
    }, e.prototype.setZLevel = function(t) {
      this.option.zlevel = t;
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "component", t.id = "", t.name = "", t.mainType = "", t.subType = "", t.componentIndex = 0;
    }(), e;
  }(yn)
);
FG(Ut, yn);
Jx(Ut);
XLe(Ut);
ZLe(Ut, dNe);
function dNe(n) {
  var e = [];
  return $(Ut.getClassesByMainType(n), function(t) {
    e = e.concat(t.dependencies || t.prototype.dependencies || []);
  }), e = De(e, function(t) {
    return ls(t).main;
  }), n !== "dataset" && Pt(e, "dataset") <= 0 && e.unshift("dataset"), e;
}
var FU = "";
typeof navigator < "u" && (FU = navigator.platform || "");
var Cf = "rgba(0, 0, 0, 0.2)";
const fNe = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: Cf,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: Cf,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: Cf,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: Cf,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: Cf,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: Cf,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: FU.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var _k = tt(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), ao = "original", vi = "arrayRows", oo = "objectRows", Ms = "keyedColumns", fl = "typedArray", VU = "unknown", ps = "column", mh = "row", qr = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, HU = en();
function pNe(n) {
  HU(n).datasetMap = tt();
}
function GU(n, e, t) {
  var r = {}, i = eO(e);
  if (!i || !n)
    return r;
  var a = [], o = [], s = e.ecModel, l = HU(s).datasetMap, u = i.uid + "_" + t.seriesLayoutBy, c, d;
  n = n.slice(), $(n, function(v, m) {
    var g = ut(v) ? v : n[m] = {
      name: v
    };
    g.type === "ordinal" && c == null && (c = m, d = h(g)), r[g.name] = [];
  });
  var f = l.get(u) || l.set(u, {
    categoryWayDim: d,
    valueWayDim: 0
  });
  $(n, function(v, m) {
    var g = v.name, y = h(v);
    if (c == null) {
      var b = f.valueWayDim;
      p(r[g], b, y), p(o, b, y), f.valueWayDim += y;
    } else if (c === m)
      p(r[g], 0, y), p(a, 0, y);
    else {
      var b = f.categoryWayDim;
      p(r[g], b, y), p(o, b, y), f.categoryWayDim += y;
    }
  });
  function p(v, m, g) {
    for (var y = 0; y < g; y++)
      v.push(m + y);
  }
  function h(v) {
    var m = v.dimsDef;
    return m ? m.length : 1;
  }
  return a.length && (r.itemName = a), o.length && (r.seriesName = o), r;
}
function QD(n, e, t) {
  var r = {}, i = eO(n);
  if (!i)
    return r;
  var a = e.sourceFormat, o = e.dimensionsDefine, s;
  (a === oo || a === Ms) && $(o, function(c, d) {
    (ut(c) ? c.name : c) === "name" && (s = d);
  });
  var l = function() {
    for (var c = {}, d = {}, f = [], p = 0, h = Math.min(5, t); p < h; p++) {
      var v = WU(e.data, a, e.seriesLayoutBy, o, e.startIndex, p);
      f.push(v);
      var m = v === qr.Not;
      if (m && c.v == null && p !== s && (c.v = p), (c.n == null || c.n === c.v || !m && f[c.n] === qr.Not) && (c.n = p), g(c) && f[c.n] !== qr.Not)
        return c;
      m || (v === qr.Might && d.v == null && p !== s && (d.v = p), (d.n == null || d.n === d.v) && (d.n = p));
    }
    function g(y) {
      return y.v != null && y.n != null;
    }
    return g(c) ? c : g(d) ? d : null;
  }();
  if (l) {
    r.value = [l.v];
    var u = s ?? l.n;
    r.itemName = [u], r.seriesName = [u];
  }
  return r;
}
function eO(n) {
  var e = n.get("data", !0);
  if (!e)
    return Fg(n.ecModel, "dataset", {
      index: n.get("datasetIndex", !0),
      id: n.get("datasetId", !0)
    }, gr).models[0];
}
function hNe(n) {
  return !n.get("transform", !0) && !n.get("fromTransformResult", !0) ? [] : Fg(n.ecModel, "dataset", {
    index: n.get("fromDatasetIndex", !0),
    id: n.get("fromDatasetId", !0)
  }, gr).models;
}
function UU(n, e) {
  return WU(n.data, n.sourceFormat, n.seriesLayoutBy, n.dimensionsDefine, n.startIndex, e);
}
function WU(n, e, t, r, i, a) {
  var o, s = 5;
  if (Bi(n))
    return qr.Not;
  var l, u;
  if (r) {
    var c = r[a];
    ut(c) ? (l = c.name, u = c.type) : We(c) && (l = c);
  }
  if (u != null)
    return u === "ordinal" ? qr.Must : qr.Not;
  if (e === vi) {
    var d = n;
    if (t === mh) {
      for (var f = d[a], p = 0; p < (f || []).length && p < s; p++)
        if ((o = _(f[i + p])) != null)
          return o;
    } else
      for (var p = 0; p < d.length && p < s; p++) {
        var h = d[i + p];
        if (h && (o = _(h[a])) != null)
          return o;
      }
  } else if (e === oo) {
    var v = n;
    if (!l)
      return qr.Not;
    for (var p = 0; p < v.length && p < s; p++) {
      var m = v[p];
      if (m && (o = _(m[l])) != null)
        return o;
    }
  } else if (e === Ms) {
    var g = n;
    if (!l)
      return qr.Not;
    var f = g[l];
    if (!f || Bi(f))
      return qr.Not;
    for (var p = 0; p < f.length && p < s; p++)
      if ((o = _(f[p])) != null)
        return o;
  } else if (e === ao)
    for (var y = n, p = 0; p < y.length && p < s; p++) {
      var m = y[p], b = uh(m);
      if (!Me(b))
        return qr.Not;
      if ((o = _(b[a])) != null)
        return o;
    }
  function _(x) {
    var w = We(x);
    if (x != null && Number.isFinite(Number(x)) && x !== "")
      return w ? qr.Might : qr.Not;
    if (w && x !== "-")
      return qr.Must;
  }
  return qr.Not;
}
var xk = tt();
function vNe(n, e) {
  ct(xk.get(n) == null && e), xk.set(n, e);
}
function mNe(n, e, t) {
  var r = xk.get(e);
  if (!r)
    return t;
  var i = r(n);
  if (!i)
    return t;
  if (process.env.NODE_ENV !== "production")
    for (var a = 0; a < i.length; a++)
      ct($p(i[a]));
  return t.concat(i);
}
var kj = en(), gNe = en(), tO = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getColorFromPalette = function(e, t, r) {
      var i = wn(this.get("color", !0)), a = this.get("colorLayer", !0);
      return qU(this, kj, i, a, e, t, r);
    }, n.prototype.clearColorPalette = function() {
      bNe(this, kj);
    }, n;
  }()
);
function wk(n, e, t, r) {
  var i = wn(n.get(["aria", "decal", "decals"]));
  return qU(n, gNe, i, null, e, t, r);
}
function yNe(n, e) {
  for (var t = n.length, r = 0; r < t; r++)
    if (n[r].length > e)
      return n[r];
  return n[t - 1];
}
function qU(n, e, t, r, i, a, o) {
  a = a || n;
  var s = e(a), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
  if (u.hasOwnProperty(i))
    return u[i];
  var c = o == null || !r ? t : yNe(r, o);
  if (c = c || t, !(!c || !c.length)) {
    var d = c[l];
    return i && (u[i] = d), s.paletteIdx = (l + 1) % c.length, d;
  }
}
function bNe(n, e) {
  e(n).paletteIdx = 0, e(n).paletteNameMap = {};
}
var b0, ev, Aj, I2 = "\0_ec_inner", Mj = 1, _Ne = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, xNe = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, s_ = {};
function wNe(n) {
  $(n, function(e, t) {
    if (!Ut.hasClass(t)) {
      var r = _Ne[t];
      r && !s_[r] && (Jr("Component " + t + ` is used but not imported.
import { ` + r + ` } from 'echarts/components';
echarts.use([` + r + "]);"), s_[r] = !0);
    }
  });
}
var nO = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t, r, i, a, o, s) {
      a = a || {}, this.option = null, this._theme = new yn(a), this._locale = new yn(o), this._optionManager = s;
    }, e.prototype.setOption = function(t, r, i) {
      process.env.NODE_ENV !== "production" && (ct(t != null, "option is null/undefined"), ct(t[I2] !== Mj, "please use chart.getOption()"));
      var a = Ij(r);
      this._optionManager.setOption(t, i, a), this._resetOption(null, a);
    }, e.prototype.resetOption = function(t, r) {
      return this._resetOption(t, Ij(r));
    }, e.prototype._resetOption = function(t, r) {
      var i = !1, a = this._optionManager;
      if (!t || t === "recreate") {
        var o = a.mountOption(t === "recreate");
        process.env.NODE_ENV !== "production" && wNe(o), !this.option || t === "recreate" ? Aj(this, o) : (this.restoreData(), this._mergeOption(o, r)), i = !0;
      }
      if ((t === "timeline" || t === "media") && this.restoreData(), !t || t === "recreate" || t === "timeline") {
        var s = a.getTimelineOption(this);
        s && (i = !0, this._mergeOption(s, r));
      }
      if (!t || t === "recreate" || t === "media") {
        var l = a.getMediaOption(this);
        l.length && $(l, function(u) {
          i = !0, this._mergeOption(u, r);
        }, this);
      }
      return i;
    }, e.prototype.mergeOption = function(t) {
      this._mergeOption(t, null);
    }, e.prototype._mergeOption = function(t, r) {
      var i = this.option, a = this._componentsMap, o = this._componentsCount, s = [], l = tt(), u = r && r.replaceMergeMainTypeMap;
      pNe(this), $(t, function(d, f) {
        d != null && (Ut.hasClass(f) ? f && (s.push(f), l.set(f, !0)) : i[f] = i[f] == null ? ht(d) : At(i[f], d, !0));
      }), u && u.each(function(d, f) {
        Ut.hasClass(f) && !l.get(f) && (s.push(f), l.set(f, !0));
      }), Ut.topologicalTravel(s, Ut.getAllClassMainTypes(), c, this);
      function c(d) {
        var f = mNe(this, d, wn(t[d])), p = a.get(d), h = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          p ? u && u.get(d) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), v = PG(p, f, h);
        UOe(v, d, Ut), i[d] = null, a.set(d, null), o.set(d, 0);
        var m = [], g = [], y = 0, b, _;
        $(v, function(x, w) {
          var S = x.existing, C = x.newOption;
          if (!C)
            S && (S.mergeOption({}, this), S.optionUpdated({}, !1));
          else {
            var k = d === "series", M = Ut.getClass(
              d,
              x.keyInfo.subType,
              !k
              // Give a more detailed warn later if series don't exists
            );
            if (!M) {
              if (process.env.NODE_ENV !== "production") {
                var D = x.keyInfo.subType, N = xNe[D];
                s_[D] || (s_[D] = !0, Jr(N ? "Series " + D + ` is used but not imported.
import { ` + N + ` } from 'echarts/charts';
echarts.use([` + N + "]);" : "Unknown series " + D));
              }
              return;
            }
            if (d === "tooltip") {
              if (b) {
                process.env.NODE_ENV !== "production" && (_ || (Jn("Currently only one tooltip component is allowed."), _ = !0));
                return;
              }
              b = !0;
            }
            if (S && S.constructor === M)
              S.name = x.keyInfo.name, S.mergeOption(C, this), S.optionUpdated(C, !1);
            else {
              var R = xe({
                componentIndex: w
              }, x.keyInfo);
              S = new M(C, this, this, R), xe(S, R), x.brandNew && (S.__requireNewView = !0), S.init(C, this, this), S.optionUpdated(null, !0);
            }
          }
          S ? (m.push(S.option), g.push(S), y++) : (m.push(void 0), g.push(void 0));
        }, this), i[d] = m, a.set(d, g), o.set(d, y), d === "series" && b0(this);
      }
      this._seriesIndices || b0(this);
    }, e.prototype.getOption = function() {
      var t = ht(this.option);
      return $(t, function(r, i) {
        if (Ut.hasClass(i)) {
          for (var a = wn(r), o = a.length, s = !1, l = o - 1; l >= 0; l--)
            a[l] && !$p(a[l]) ? s = !0 : (a[l] = null, !s && o--);
          a.length = o, t[i] = a;
        }
      }), delete t[I2], t;
    }, e.prototype.getTheme = function() {
      return this._theme;
    }, e.prototype.getLocaleModel = function() {
      return this._locale;
    }, e.prototype.setUpdatePayload = function(t) {
      this._payload = t;
    }, e.prototype.getUpdatePayload = function() {
      return this._payload;
    }, e.prototype.getComponent = function(t, r) {
      var i = this._componentsMap.get(t);
      if (i) {
        var a = i[r || 0];
        if (a)
          return a;
        if (r == null) {
          for (var o = 0; o < i.length; o++)
            if (i[o])
              return i[o];
        }
      }
    }, e.prototype.queryComponents = function(t) {
      var r = t.mainType;
      if (!r)
        return [];
      var i = t.index, a = t.id, o = t.name, s = this._componentsMap.get(r);
      if (!s || !s.length)
        return [];
      var l;
      return i != null ? (l = [], $(wn(i), function(u) {
        s[u] && l.push(s[u]);
      })) : a != null ? l = Dj("id", a, s) : o != null ? l = Dj("name", o, s) : l = vn(s, function(u) {
        return !!u;
      }), Oj(l, t);
    }, e.prototype.findComponents = function(t) {
      var r = t.query, i = t.mainType, a = s(r), o = a ? this.queryComponents(a) : vn(this._componentsMap.get(i), function(u) {
        return !!u;
      });
      return l(Oj(o, t));
      function s(u) {
        var c = i + "Index", d = i + "Id", f = i + "Name";
        return u && (u[c] != null || u[d] != null || u[f] != null) ? {
          mainType: i,
          // subType will be filtered finally.
          index: u[c],
          id: u[d],
          name: u[f]
        } : null;
      }
      function l(u) {
        return t.filter ? vn(u, t.filter) : u;
      }
    }, e.prototype.eachComponent = function(t, r, i) {
      var a = this._componentsMap;
      if (at(t)) {
        var o = r, s = t;
        a.each(function(d, f) {
          for (var p = 0; d && p < d.length; p++) {
            var h = d[p];
            h && s.call(o, f, h, h.componentIndex);
          }
        });
      } else
        for (var l = We(t) ? a.get(t) : ut(t) ? this.findComponents(t) : null, u = 0; l && u < l.length; u++) {
          var c = l[u];
          c && r.call(i, c, c.componentIndex);
        }
    }, e.prototype.getSeriesByName = function(t) {
      var r = wr(t, null);
      return vn(this._componentsMap.get("series"), function(i) {
        return !!i && r != null && i.name === r;
      });
    }, e.prototype.getSeriesByIndex = function(t) {
      return this._componentsMap.get("series")[t];
    }, e.prototype.getSeriesByType = function(t) {
      return vn(this._componentsMap.get("series"), function(r) {
        return !!r && r.subType === t;
      });
    }, e.prototype.getSeries = function() {
      return vn(this._componentsMap.get("series"), function(t) {
        return !!t;
      });
    }, e.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, e.prototype.eachSeries = function(t, r) {
      ev(this), $(this._seriesIndices, function(i) {
        var a = this._componentsMap.get("series")[i];
        t.call(r, a, i);
      }, this);
    }, e.prototype.eachRawSeries = function(t, r) {
      $(this._componentsMap.get("series"), function(i) {
        i && t.call(r, i, i.componentIndex);
      });
    }, e.prototype.eachSeriesByType = function(t, r, i) {
      ev(this), $(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        o.subType === t && r.call(i, o, a);
      }, this);
    }, e.prototype.eachRawSeriesByType = function(t, r, i) {
      return $(this.getSeriesByType(t), r, i);
    }, e.prototype.isSeriesFiltered = function(t) {
      return ev(this), this._seriesIndicesMap.get(t.componentIndex) == null;
    }, e.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, e.prototype.filterSeries = function(t, r) {
      ev(this);
      var i = [];
      $(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        t.call(r, o, a) && i.push(a);
      }, this), this._seriesIndices = i, this._seriesIndicesMap = tt(i);
    }, e.prototype.restoreData = function(t) {
      b0(this);
      var r = this._componentsMap, i = [];
      r.each(function(a, o) {
        Ut.hasClass(o) && i.push(o);
      }), Ut.topologicalTravel(i, Ut.getAllClassMainTypes(), function(a) {
        $(r.get(a), function(o) {
          o && (a !== "series" || !SNe(o, t)) && o.restoreData();
        });
      });
    }, e.internalField = function() {
      b0 = function(t) {
        var r = t._seriesIndices = [];
        $(t._componentsMap.get("series"), function(i) {
          i && r.push(i.componentIndex);
        }), t._seriesIndicesMap = tt(r);
      }, ev = function(t) {
        if (process.env.NODE_ENV !== "production" && !t._seriesIndices)
          throw new Error("Option should contains series.");
      }, Aj = function(t, r) {
        t.option = {}, t.option[I2] = Mj, t._componentsMap = tt({
          series: []
        }), t._componentsCount = tt();
        var i = r.aria;
        ut(i) && i.enabled == null && (i.enabled = !0), ENe(r, t._theme.option), At(r, fNe, !1), t._mergeOption(r, null);
      };
    }(), e;
  }(yn)
);
function SNe(n, e) {
  if (e) {
    var t = e.seriesIndex, r = e.seriesId, i = e.seriesName;
    return t != null && n.componentIndex !== t || r != null && n.id !== r || i != null && n.name !== i;
  }
}
function ENe(n, e) {
  var t = n.color && !n.colorLayer;
  $(e, function(r, i) {
    i === "colorLayer" && t || Ut.hasClass(i) || (typeof r == "object" ? n[i] = n[i] ? At(n[i], r, !1) : ht(r) : n[i] == null && (n[i] = r));
  });
}
function Dj(n, e, t) {
  if (Me(e)) {
    var r = tt();
    return $(e, function(a) {
      if (a != null) {
        var o = wr(a, null);
        o != null && r.set(a, !0);
      }
    }), vn(t, function(a) {
      return a && r.get(a[n]);
    });
  } else {
    var i = wr(e, null);
    return vn(t, function(a) {
      return a && i != null && a[n] === i;
    });
  }
}
function Oj(n, e) {
  return e.hasOwnProperty("subType") ? vn(n, function(t) {
    return t && t.subType === e.subType;
  }) : n;
}
function Ij(n) {
  var e = tt();
  return n && $(wn(n.replaceMerge), function(t) {
    process.env.NODE_ENV !== "production" && ct(Ut.hasClass(t), '"' + t + '" is not valid component main type in "replaceMerge"'), e.set(t, !0);
  }), {
    replaceMergeMainTypeMap: e
  };
}
_r(nO, tO);
var TNe = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], YU = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e) {
      $(TNe, function(t) {
        this[t] = Ze(e[t], e);
      }, this);
    }
    return n;
  }()
), L2 = {}, gh = (
  /** @class */
  function() {
    function n() {
      this._coordinateSystems = [];
    }
    return n.prototype.create = function(e, t) {
      var r = [];
      $(L2, function(i, a) {
        var o = i.create(e, t);
        r = r.concat(o || []);
      }), this._coordinateSystems = r;
    }, n.prototype.update = function(e, t) {
      $(this._coordinateSystems, function(r) {
        r.update && r.update(e, t);
      });
    }, n.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    }, n.register = function(e, t) {
      L2[e] = t;
    }, n.get = function(e) {
      return L2[e];
    }, n;
  }()
), CNe = /^(min|max)?(.+)$/, kNe = (
  /** @class */
  function() {
    function n(e) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = e;
    }
    return n.prototype.setOption = function(e, t, r) {
      e && ($(wn(e.series), function(o) {
        o && o.data && Bi(o.data) && Gb(o.data);
      }), $(wn(e.dataset), function(o) {
        o && o.source && Bi(o.source) && Gb(o.source);
      })), e = ht(e);
      var i = this._optionBackup, a = ANe(e, t, !i);
      this._newBaseOption = a.baseOption, i ? (a.timelineOptions.length && (i.timelineOptions = a.timelineOptions), a.mediaList.length && (i.mediaList = a.mediaList), a.mediaDefault && (i.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, n.prototype.mountOption = function(e) {
      var t = this._optionBackup;
      return this._timelineOptions = t.timelineOptions, this._mediaList = t.mediaList, this._mediaDefault = t.mediaDefault, this._currentMediaIndices = [], ht(e ? t.baseOption : this._newBaseOption);
    }, n.prototype.getTimelineOption = function(e) {
      var t, r = this._timelineOptions;
      if (r.length) {
        var i = e.getComponent("timeline");
        i && (t = ht(
          // FIXME:TS as TimelineModel or quivlant interface
          r[i.getCurrentIndex()]
        ));
      }
      return t;
    }, n.prototype.getMediaOption = function(e) {
      var t = this._api.getWidth(), r = this._api.getHeight(), i = this._mediaList, a = this._mediaDefault, o = [], s = [];
      if (!i.length && !a)
        return s;
      for (var l = 0, u = i.length; l < u; l++)
        MNe(i[l].query, t, r) && o.push(l);
      return !o.length && a && (o = [-1]), o.length && !ONe(o, this._currentMediaIndices) && (s = De(o, function(c) {
        return ht(c === -1 ? a.option : i[c].option);
      })), this._currentMediaIndices = o, s;
    }, n;
  }()
);
function ANe(n, e, t) {
  var r = [], i, a, o = n.baseOption, s = n.timeline, l = n.options, u = n.media, c = !!n.media, d = !!(l || s || o && o.timeline);
  o ? (a = o, a.timeline || (a.timeline = s)) : ((d || c) && (n.options = n.media = null), a = n), c && (Me(u) ? $(u, function(p) {
    process.env.NODE_ENV !== "production" && p && !p.option && ut(p.query) && ut(p.query.option) && Jr("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), p && p.option && (p.query ? r.push(p) : i || (i = p));
  }) : process.env.NODE_ENV !== "production" && Jr("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), f(a), $(l, function(p) {
    return f(p);
  }), $(r, function(p) {
    return f(p.option);
  });
  function f(p) {
    $(e, function(h) {
      h(p, t);
    });
  }
  return {
    baseOption: a,
    timelineOptions: l || [],
    mediaDefault: i,
    mediaList: r
  };
}
function MNe(n, e, t) {
  var r = {
    width: e,
    height: t,
    aspectratio: e / t
    // lower case for convenience.
  }, i = !0;
  return $(n, function(a, o) {
    var s = o.match(CNe);
    if (!(!s || !s[1] || !s[2])) {
      var l = s[1], u = s[2].toLowerCase();
      DNe(r[u], a, l) || (i = !1);
    }
  }), i;
}
function DNe(n, e, t) {
  return t === "min" ? n >= e : t === "max" ? n <= e : n === e;
}
function ONe(n, e) {
  return n.join(",") === e.join(",");
}
var Ma = $, ig = ut, Lj = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function N2(n) {
  var e = n && n.itemStyle;
  if (e)
    for (var t = 0, r = Lj.length; t < r; t++) {
      var i = Lj[t], a = e.normal, o = e.emphasis;
      a && a[i] && (process.env.NODE_ENV !== "production" && vr("itemStyle.normal." + i, i), n[i] = n[i] || {}, n[i].normal ? At(n[i].normal, a[i]) : n[i].normal = a[i], a[i] = null), o && o[i] && (process.env.NODE_ENV !== "production" && vr("itemStyle.emphasis." + i, "emphasis." + i), n[i] = n[i] || {}, n[i].emphasis ? At(n[i].emphasis, o[i]) : n[i].emphasis = o[i], o[i] = null);
    }
}
function ui(n, e, t) {
  if (n && n[e] && (n[e].normal || n[e].emphasis)) {
    var r = n[e].normal, i = n[e].emphasis;
    r && (process.env.NODE_ENV !== "production" && Do("'normal' hierarchy in " + e + " has been removed since 4.0. All style properties are configured in " + e + " directly now."), t ? (n[e].normal = n[e].emphasis = null, dt(n[e], r)) : n[e] = r), i && (process.env.NODE_ENV !== "production" && Do(e + ".emphasis has been changed to emphasis." + e + " since 4.0"), n.emphasis = n.emphasis || {}, n.emphasis[e] = i, i.focus && (n.emphasis.focus = i.focus), i.blurScope && (n.emphasis.blurScope = i.blurScope));
  }
}
function Lv(n) {
  ui(n, "itemStyle"), ui(n, "lineStyle"), ui(n, "areaStyle"), ui(n, "label"), ui(n, "labelLine"), ui(n, "upperLabel"), ui(n, "edgeLabel");
}
function hr(n, e) {
  var t = ig(n) && n[e], r = ig(t) && t.textStyle;
  if (r) {
    process.env.NODE_ENV !== "production" && Do("textStyle hierarchy in " + e + " has been removed since 4.0. All textStyle properties are configured in " + e + " directly now.");
    for (var i = 0, a = j3.length; i < a; i++) {
      var o = j3[i];
      r.hasOwnProperty(o) && (t[o] = r[o]);
    }
  }
}
function ja(n) {
  n && (Lv(n), hr(n, "label"), n.emphasis && hr(n.emphasis, "label"));
}
function INe(n) {
  if (ig(n)) {
    N2(n), Lv(n), hr(n, "label"), hr(n, "upperLabel"), hr(n, "edgeLabel"), n.emphasis && (hr(n.emphasis, "label"), hr(n.emphasis, "upperLabel"), hr(n.emphasis, "edgeLabel"));
    var e = n.markPoint;
    e && (N2(e), ja(e));
    var t = n.markLine;
    t && (N2(t), ja(t));
    var r = n.markArea;
    r && ja(r);
    var i = n.data;
    if (n.type === "graph") {
      i = i || n.nodes;
      var a = n.links || n.edges;
      if (a && !Bi(a))
        for (var o = 0; o < a.length; o++)
          ja(a[o]);
      $(n.categories, function(u) {
        Lv(u);
      });
    }
    if (i && !Bi(i))
      for (var o = 0; o < i.length; o++)
        ja(i[o]);
    if (e = n.markPoint, e && e.data)
      for (var s = e.data, o = 0; o < s.length; o++)
        ja(s[o]);
    if (t = n.markLine, t && t.data)
      for (var l = t.data, o = 0; o < l.length; o++)
        Me(l[o]) ? (ja(l[o][0]), ja(l[o][1])) : ja(l[o]);
    n.type === "gauge" ? (hr(n, "axisLabel"), hr(n, "title"), hr(n, "detail")) : n.type === "treemap" ? (ui(n.breadcrumb, "itemStyle"), $(n.levels, function(u) {
      Lv(u);
    })) : n.type === "tree" && Lv(n.leaves);
  }
}
function $s(n) {
  return Me(n) ? n : n ? [n] : [];
}
function Nj(n) {
  return (Me(n) ? n[0] : n) || {};
}
function LNe(n, e) {
  Ma($s(n.series), function(r) {
    ig(r) && INe(r);
  });
  var t = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  e && t.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), Ma(t, function(r) {
    Ma($s(n[r]), function(i) {
      i && (hr(i, "axisLabel"), hr(i.axisPointer, "label"));
    });
  }), Ma($s(n.parallel), function(r) {
    var i = r && r.parallelAxisDefault;
    hr(i, "axisLabel"), hr(i && i.axisPointer, "label");
  }), Ma($s(n.calendar), function(r) {
    ui(r, "itemStyle"), hr(r, "dayLabel"), hr(r, "monthLabel"), hr(r, "yearLabel");
  }), Ma($s(n.radar), function(r) {
    hr(r, "name"), r.name && r.axisName == null && (r.axisName = r.name, delete r.name, process.env.NODE_ENV !== "production" && Do("name property in radar component has been changed to axisName")), r.nameGap != null && r.axisNameGap == null && (r.axisNameGap = r.nameGap, delete r.nameGap, process.env.NODE_ENV !== "production" && Do("nameGap property in radar component has been changed to axisNameGap")), process.env.NODE_ENV !== "production" && Ma(r.indicator, function(i) {
      i.text && vr("text", "name", "radar.indicator");
    });
  }), Ma($s(n.geo), function(r) {
    ig(r) && (ja(r), Ma($s(r.regions), function(i) {
      ja(i);
    }));
  }), Ma($s(n.timeline), function(r) {
    ja(r), ui(r, "label"), ui(r, "itemStyle"), ui(r, "controlStyle", !0);
    var i = r.data;
    Me(i) && $(i, function(a) {
      ut(a) && (ui(a, "label"), ui(a, "itemStyle"));
    });
  }), Ma($s(n.toolbox), function(r) {
    ui(r, "iconStyle"), Ma(r.feature, function(i) {
      ui(i, "iconStyle");
    });
  }), hr(Nj(n.axisPointer), "label"), hr(Nj(n.tooltip).axisPointer, "label");
}
function NNe(n, e) {
  for (var t = e.split(","), r = n, i = 0; i < t.length && (r = r && r[t[i]], r != null); i++)
    ;
  return r;
}
function RNe(n, e, t, r) {
  for (var i = e.split(","), a = n, o, s = 0; s < i.length - 1; s++)
    o = i[s], a[o] == null && (a[o] = {}), a = a[o];
  a[i[s]] == null && (a[i[s]] = t);
}
function Rj(n) {
  n && $(PNe, function(e) {
    e[0] in n && !(e[1] in n) && (n[e[1]] = n[e[0]]);
  });
}
var PNe = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], jNe = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], R2 = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function tv(n) {
  var e = n && n.itemStyle;
  if (e)
    for (var t = 0; t < R2.length; t++) {
      var r = R2[t][1], i = R2[t][0];
      e[r] != null && (e[i] = e[r], process.env.NODE_ENV !== "production" && vr(r, i));
    }
}
function Pj(n) {
  n && n.alignTo === "edge" && n.margin != null && n.edgeDistance == null && (process.env.NODE_ENV !== "production" && vr("label.margin", "label.edgeDistance", "pie"), n.edgeDistance = n.margin);
}
function jj(n) {
  n && n.downplay && !n.blur && (n.blur = n.downplay, process.env.NODE_ENV !== "production" && vr("downplay", "blur", "sunburst"));
}
function BNe(n) {
  n && n.focusNodeAdjacency != null && (n.emphasis = n.emphasis || {}, n.emphasis.focus == null && (process.env.NODE_ENV !== "production" && vr("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), n.emphasis.focus = "adjacency"));
}
function KU(n, e) {
  if (n)
    for (var t = 0; t < n.length; t++)
      e(n[t]), n[t] && KU(n[t].children, e);
}
function XU(n, e) {
  LNe(n, e), n.series = wn(n.series), $(n.series, function(t) {
    if (ut(t)) {
      var r = t.type;
      if (r === "line")
        t.clipOverflow != null && (t.clip = t.clipOverflow, process.env.NODE_ENV !== "production" && vr("clipOverflow", "clip", "line"));
      else if (r === "pie" || r === "gauge") {
        t.clockWise != null && (t.clockwise = t.clockWise, process.env.NODE_ENV !== "production" && vr("clockWise", "clockwise")), Pj(t.label);
        var i = t.data;
        if (i && !Bi(i))
          for (var a = 0; a < i.length; a++)
            Pj(i[a]);
        t.hoverOffset != null && (t.emphasis = t.emphasis || {}, (t.emphasis.scaleSize = null) && (process.env.NODE_ENV !== "production" && vr("hoverOffset", "emphasis.scaleSize"), t.emphasis.scaleSize = t.hoverOffset));
      } else if (r === "gauge") {
        var o = NNe(t, "pointer.color");
        o != null && RNe(t, "itemStyle.color", o);
      } else if (r === "bar") {
        tv(t), tv(t.backgroundStyle), tv(t.emphasis);
        var i = t.data;
        if (i && !Bi(i))
          for (var a = 0; a < i.length; a++)
            typeof i[a] == "object" && (tv(i[a]), tv(i[a] && i[a].emphasis));
      } else if (r === "sunburst") {
        var s = t.highlightPolicy;
        s && (t.emphasis = t.emphasis || {}, t.emphasis.focus || (t.emphasis.focus = s, process.env.NODE_ENV !== "production" && vr("highlightPolicy", "emphasis.focus", "sunburst"))), jj(t), KU(t.data, jj);
      } else r === "graph" || r === "sankey" ? BNe(t) : r === "map" && (t.mapType && !t.map && (process.env.NODE_ENV !== "production" && vr("mapType", "map", "map"), t.map = t.mapType), t.mapLocation && (process.env.NODE_ENV !== "production" && Do("`mapLocation` is not used anymore."), dt(t, t.mapLocation)));
      t.hoverAnimation != null && (t.emphasis = t.emphasis || {}, t.emphasis && t.emphasis.scale == null && (process.env.NODE_ENV !== "production" && vr("hoverAnimation", "emphasis.scale"), t.emphasis.scale = t.hoverAnimation)), Rj(t);
    }
  }), n.dataRange && (n.visualMap = n.dataRange), $(jNe, function(t) {
    var r = n[t];
    r && (Me(r) || (r = [r]), $(r, function(i) {
      Rj(i);
    }));
  });
}
function $Ne(n) {
  var e = tt();
  n.eachSeries(function(t) {
    var r = t.get("stack");
    if (r) {
      var i = e.get(r) || e.set(r, []), a = t.getData(), o = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: a.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
        stackedDimension: a.getCalculationInfo("stackedDimension"),
        stackedByDimension: a.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
        data: a,
        seriesModel: t
      };
      if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension))
        return;
      i.length && a.setCalculationInfo("stackedOnSeries", i[i.length - 1].seriesModel), i.push(o);
    }
  }), e.each(zNe);
}
function zNe(n) {
  $(n, function(e, t) {
    var r = [], i = [NaN, NaN], a = [e.stackResultDimension, e.stackedOverDimension], o = e.data, s = e.isStackedByIndex, l = e.seriesModel.get("stackStrategy") || "samesign";
    o.modify(a, function(u, c, d) {
      var f = o.get(e.stackedDimension, d);
      if (isNaN(f))
        return i;
      var p, h;
      s ? h = o.getRawIndex(d) : p = o.get(e.stackedByDimension, d);
      for (var v = NaN, m = t - 1; m >= 0; m--) {
        var g = n[m];
        if (s || (h = g.data.rawIndexOf(g.stackedByDimension, p)), h >= 0) {
          var y = g.data.getByRawIndex(g.stackResultDimension, h);
          if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && f >= 0 && y > 0 || l === "samesign" && f <= 0 && y < 0) {
            f = OOe(f, y), v = y;
            break;
          }
        }
      }
      return r[0] = f, r[1] = v, r;
    });
  });
}
var vw = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e) {
      this.data = e.data || (e.sourceFormat === Ms ? {} : []), this.sourceFormat = e.sourceFormat || VU, this.seriesLayoutBy = e.seriesLayoutBy || ps, this.startIndex = e.startIndex || 0, this.dimensionsDetectedCount = e.dimensionsDetectedCount, this.metaRawOption = e.metaRawOption;
      var t = this.dimensionsDefine = e.dimensionsDefine;
      if (t)
        for (var r = 0; r < t.length; r++) {
          var i = t[r];
          i.type == null && UU(this, r) === qr.Must && (i.type = "ordinal");
        }
    }
    return n;
  }()
);
function rO(n) {
  return n instanceof vw;
}
function Sk(n, e, t) {
  t = t || ZU(n);
  var r = e.seriesLayoutBy, i = VNe(n, t, r, e.sourceHeader, e.dimensions), a = new vw({
    data: n,
    sourceFormat: t,
    seriesLayoutBy: r,
    dimensionsDefine: i.dimensionsDefine,
    startIndex: i.startIndex,
    dimensionsDetectedCount: i.dimensionsDetectedCount,
    metaRawOption: ht(e)
  });
  return a;
}
function iO(n) {
  return new vw({
    data: n,
    sourceFormat: Bi(n) ? fl : ao
  });
}
function FNe(n) {
  return new vw({
    data: n.data,
    sourceFormat: n.sourceFormat,
    seriesLayoutBy: n.seriesLayoutBy,
    dimensionsDefine: ht(n.dimensionsDefine),
    startIndex: n.startIndex,
    dimensionsDetectedCount: n.dimensionsDetectedCount
  });
}
function ZU(n) {
  var e = VU;
  if (Bi(n))
    e = fl;
  else if (Me(n)) {
    n.length === 0 && (e = vi);
    for (var t = 0, r = n.length; t < r; t++) {
      var i = n[t];
      if (i != null) {
        if (Me(i) || Bi(i)) {
          e = vi;
          break;
        } else if (ut(i)) {
          e = oo;
          break;
        }
      }
    }
  } else if (ut(n)) {
    for (var a in n)
      if (Je(n, a) && hi(n[a])) {
        e = Ms;
        break;
      }
  }
  return e;
}
function VNe(n, e, t, r, i) {
  var a, o;
  if (!n)
    return {
      dimensionsDefine: Bj(i),
      startIndex: o,
      dimensionsDetectedCount: a
    };
  if (e === vi) {
    var s = n;
    r === "auto" || r == null ? $j(function(u) {
      u != null && u !== "-" && (We(u) ? o == null && (o = 1) : o = 0);
    }, t, s, 10) : o = sn(r) ? r : r ? 1 : 0, !i && o === 1 && (i = [], $j(function(u, c) {
      i[c] = u != null ? u + "" : "";
    }, t, s, 1 / 0)), a = i ? i.length : t === mh ? s.length : s[0] ? s[0].length : null;
  } else if (e === oo)
    i || (i = HNe(n));
  else if (e === Ms)
    i || (i = [], $(n, function(u, c) {
      i.push(c);
    }));
  else if (e === ao) {
    var l = uh(n[0]);
    a = Me(l) && l.length || 1;
  } else e === fl && process.env.NODE_ENV !== "production" && ct(!!i, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: o,
    dimensionsDefine: Bj(i),
    dimensionsDetectedCount: a
  };
}
function HNe(n) {
  for (var e = 0, t; e < n.length && !(t = n[e++]); )
    ;
  if (t)
    return Yt(t);
}
function Bj(n) {
  if (n) {
    var e = tt();
    return De(n, function(t, r) {
      t = ut(t) ? t : {
        name: t
      };
      var i = {
        name: t.name,
        displayName: t.displayName,
        type: t.type
      };
      if (i.name == null)
        return i;
      i.name += "", i.displayName == null && (i.displayName = i.name);
      var a = e.get(i.name);
      return a ? i.name += "-" + a.count++ : e.set(i.name, {
        count: 1
      }), i;
    });
  }
}
function $j(n, e, t, r) {
  if (e === mh)
    for (var i = 0; i < t.length && i < r; i++)
      n(t[i] ? t[i][0] : null, i);
  else
    for (var a = t[0] || [], i = 0; i < a.length && i < r; i++)
      n(a[i], i);
}
function JU(n) {
  var e = n.sourceFormat;
  return e === oo || e === Ms;
}
var vc, mc, gc, zj, Fj, QU = (
  /** @class */
  function() {
    function n(e, t) {
      var r = rO(e) ? e : iO(e);
      this._source = r;
      var i = this._data = r.data;
      if (r.sourceFormat === fl) {
        if (process.env.NODE_ENV !== "production" && t == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = t, this._data = i;
      }
      Fj(this, i, r);
    }
    return n.prototype.getSource = function() {
      return this._source;
    }, n.prototype.count = function() {
      return 0;
    }, n.prototype.getItem = function(e, t) {
    }, n.prototype.appendData = function(e) {
    }, n.prototype.clean = function() {
    }, n.protoInitialize = function() {
      var e = n.prototype;
      e.pure = !1, e.persistent = !0;
    }(), n.internalField = function() {
      var e;
      Fj = function(o, s, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, d = l.startIndex, f = l.dimensionsDefine, p = zj[aO(u, c)];
        if (process.env.NODE_ENV !== "production" && ct(p, "Invalide sourceFormat: " + u), xe(o, p), u === fl)
          o.getItem = t, o.count = i, o.fillStorage = r;
        else {
          var h = eW(u, c);
          o.getItem = Ze(h, null, s, d, f);
          var v = tW(u, c);
          o.count = Ze(v, null, s, d, f);
        }
      };
      var t = function(o, s) {
        o = o - this._offset, s = s || [];
        for (var l = this._data, u = this._dimSize, c = u * o, d = 0; d < u; d++)
          s[d] = l[c + d];
        return s;
      }, r = function(o, s, l, u) {
        for (var c = this._data, d = this._dimSize, f = 0; f < d; f++) {
          for (var p = u[f], h = p[0] == null ? 1 / 0 : p[0], v = p[1] == null ? -1 / 0 : p[1], m = s - o, g = l[f], y = 0; y < m; y++) {
            var b = c[y * d + f];
            g[o + y] = b, b < h && (h = b), b > v && (v = b);
          }
          p[0] = h, p[1] = v;
        }
      }, i = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      zj = (e = {}, e[vi + "_" + ps] = {
        pure: !0,
        appendData: a
      }, e[vi + "_" + mh] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, e[oo] = {
        pure: !0,
        appendData: a
      }, e[Ms] = {
        pure: !0,
        appendData: function(o) {
          var s = this._data;
          $(o, function(l, u) {
            for (var c = s[u] || (s[u] = []), d = 0; d < (l || []).length; d++)
              c.push(l[d]);
          });
        }
      }, e[ao] = {
        appendData: a
      }, e[fl] = {
        persistent: !1,
        pure: !0,
        appendData: function(o) {
          process.env.NODE_ENV !== "production" && ct(Bi(o), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = o;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, e);
      function a(o) {
        for (var s = 0; s < o.length; s++)
          this._data.push(o[s]);
      }
    }(), n;
  }()
), Vj = function(n, e, t, r) {
  return n[r];
}, GNe = (vc = {}, vc[vi + "_" + ps] = function(n, e, t, r) {
  return n[r + e];
}, vc[vi + "_" + mh] = function(n, e, t, r, i) {
  r += e;
  for (var a = i || [], o = n, s = 0; s < o.length; s++) {
    var l = o[s];
    a[s] = l ? l[r] : null;
  }
  return a;
}, vc[oo] = Vj, vc[Ms] = function(n, e, t, r, i) {
  for (var a = i || [], o = 0; o < t.length; o++) {
    var s = t[o].name;
    if (process.env.NODE_ENV !== "production" && s == null)
      throw new Error();
    var l = n[s];
    a[o] = l ? l[r] : null;
  }
  return a;
}, vc[ao] = Vj, vc);
function eW(n, e) {
  var t = GNe[aO(n, e)];
  return process.env.NODE_ENV !== "production" && ct(t, 'Do not support get item on "' + n + '", "' + e + '".'), t;
}
var Hj = function(n, e, t) {
  return n.length;
}, UNe = (mc = {}, mc[vi + "_" + ps] = function(n, e, t) {
  return Math.max(0, n.length - e);
}, mc[vi + "_" + mh] = function(n, e, t) {
  var r = n[0];
  return r ? Math.max(0, r.length - e) : 0;
}, mc[oo] = Hj, mc[Ms] = function(n, e, t) {
  var r = t[0].name;
  if (process.env.NODE_ENV !== "production" && r == null)
    throw new Error();
  var i = n[r];
  return i ? i.length : 0;
}, mc[ao] = Hj, mc);
function tW(n, e) {
  var t = UNe[aO(n, e)];
  return process.env.NODE_ENV !== "production" && ct(t, 'Do not support count on "' + n + '", "' + e + '".'), t;
}
var P2 = function(n, e, t) {
  return n[e];
}, WNe = (gc = {}, gc[vi] = P2, gc[oo] = function(n, e, t) {
  return n[t];
}, gc[Ms] = P2, gc[ao] = function(n, e, t) {
  var r = uh(n);
  return r instanceof Array ? r[e] : r;
}, gc[fl] = P2, gc);
function nW(n) {
  var e = WNe[n];
  return process.env.NODE_ENV !== "production" && ct(e, 'Do not support get value on "' + n + '".'), e;
}
function aO(n, e) {
  return n === vi ? n + "_" + e : n;
}
function Vp(n, e, t) {
  if (n) {
    var r = n.getRawDataItem(e);
    if (r != null) {
      var i = n.getStore(), a = i.getSource().sourceFormat;
      if (t != null) {
        var o = n.getDimensionIndex(t), s = i.getDimensionProperty(o);
        return nW(a)(r, o, s);
      } else {
        var l = r;
        return a === ao && (l = uh(r)), l;
      }
    }
  }
}
var qNe = /\{@(.+?)\}/g, mw = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getDataParams = function(e, t) {
      var r = this.getData(t), i = this.getRawValue(e, t), a = r.getRawIndex(e), o = r.getName(e), s = r.getRawDataItem(e), l = r.getItemVisual(e, "style"), u = l && l[r.getItemVisual(e, "drawType") || "fill"], c = l && l.stroke, d = this.mainType, f = d === "series", p = r.userOutput && r.userOutput.get();
      return {
        componentType: d,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: f ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: f ? this.id : null,
        seriesName: f ? this.name : null,
        name: o,
        dataIndex: a,
        data: s,
        dataType: t,
        value: i,
        color: u,
        borderColor: c,
        dimensionNames: p ? p.fullDimensions : null,
        encode: p ? p.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, n.prototype.getFormattedLabel = function(e, t, r, i, a, o) {
      t = t || "normal";
      var s = this.getData(r), l = this.getDataParams(e, r);
      if (o && (l.value = o.interpolatedValue), i != null && Me(l.value) && (l.value = l.value[i]), !a) {
        var u = s.getItemModel(e);
        a = u.get(t === "normal" ? ["label", "formatter"] : [t, "label", "formatter"]);
      }
      if (at(a))
        return l.status = t, l.dimensionIndex = i, a(l);
      if (We(a)) {
        var c = BU(a, l);
        return c.replace(qNe, function(d, f) {
          var p = f.length, h = f;
          h.charAt(0) === "[" && h.charAt(p - 1) === "]" && (h = +h.slice(1, p - 1), process.env.NODE_ENV !== "production" && isNaN(h) && Jr("Invalide label formatter: @" + f + ", only support @[0], @[1], @[2], ..."));
          var v = Vp(s, e, h);
          if (o && Me(o.interpolatedValue)) {
            var m = s.getDimensionIndex(h);
            m >= 0 && (v = o.interpolatedValue[m]);
          }
          return v != null ? v + "" : "";
        });
      }
    }, n.prototype.getRawValue = function(e, t) {
      return Vp(this.getData(t), e);
    }, n.prototype.formatTooltip = function(e, t, r) {
    }, n;
  }()
);
function Gj(n) {
  var e, t;
  return ut(n) ? n.type ? t = n : process.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + $i(n)) : e = n, {
    text: e,
    // markers: markers || markersExisting,
    frag: t
  };
}
function vm(n) {
  return new YNe(n);
}
var YNe = (
  /** @class */
  function() {
    function n(e) {
      e = e || {}, this._reset = e.reset, this._plan = e.plan, this._count = e.count, this._onDirty = e.onDirty, this._dirty = !0;
    }
    return n.prototype.perform = function(e) {
      var t = this._upstream, r = e && e.skip;
      if (this._dirty && t) {
        var i = this.context;
        i.data = i.outputData = t.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !r && (a = this._plan(this.context));
      var o = c(this._modBy), s = this._modDataCount || 0, l = c(e && e.modBy), u = e && e.modDataCount || 0;
      (o !== l || s !== u) && (a = "reset");
      function c(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var d;
      (this._dirty || a === "reset") && (this._dirty = !1, d = this._doReset(r)), this._modBy = l, this._modDataCount = u;
      var f = e && e.step;
      if (t ? (process.env.NODE_ENV !== "production" && ct(t._outputDueEnd != null), this._dueEnd = t._outputDueEnd) : (process.env.NODE_ENV !== "production" && ct(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var p = this._dueIndex, h = Math.min(f != null ? this._dueIndex + f : 1 / 0, this._dueEnd);
        if (!r && (d || p < h)) {
          var v = this._progress;
          if (Me(v))
            for (var m = 0; m < v.length; m++)
              this._doProgress(v[m], p, h, l, u);
          else
            this._doProgress(v, p, h, l, u);
        }
        this._dueIndex = h;
        var g = this._settedOutputEnd != null ? this._settedOutputEnd : h;
        process.env.NODE_ENV !== "production" && ct(g >= this._outputDueEnd), this._outputDueEnd = g;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, n.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, n.prototype._doProgress = function(e, t, r, i, a) {
      Uj.reset(t, r, i, a), this._callingProgress = e, this._callingProgress({
        start: t,
        end: r,
        count: r - t,
        next: Uj.next
      }, this.context);
    }, n.prototype._doReset = function(e) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var t, r;
      !e && this._reset && (t = this._reset(this.context), t && t.progress && (r = t.forceFirstProgress, t = t.progress), Me(t) && !t.length && (t = null)), this._progress = t, this._modBy = this._modDataCount = null;
      var i = this._downstream;
      return i && i.dirty(), r;
    }, n.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, n.prototype.pipe = function(e) {
      process.env.NODE_ENV !== "production" && ct(e && !e._disposed && e !== this), (this._downstream !== e || this._dirty) && (this._downstream = e, e._upstream = this, e.dirty());
    }, n.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, n.prototype.getUpstream = function() {
      return this._upstream;
    }, n.prototype.getDownstream = function() {
      return this._downstream;
    }, n.prototype.setOutputEnd = function(e) {
      this._outputDueEnd = this._settedOutputEnd = e;
    }, n;
  }()
), Uj = /* @__PURE__ */ function() {
  var n, e, t, r, i, a = {
    reset: function(l, u, c, d) {
      e = l, n = u, t = c, r = d, i = Math.ceil(r / t), a.next = t > 1 && r > 0 ? s : o;
    }
  };
  return a;
  function o() {
    return e < n ? e++ : null;
  }
  function s() {
    var l = e % i * t + Math.ceil(e / i), u = e >= n ? null : l < r ? l : e;
    return e++, u;
  }
}();
function Cu(n, e) {
  var t = e && e.type;
  return t === "ordinal" ? n : (t === "time" && !sn(n) && n != null && n !== "-" && (n = +Es(n)), n == null || n === "" ? NaN : Number(n));
}
var KNe = tt({
  number: function(n) {
    return parseFloat(n);
  },
  time: function(n) {
    return +Es(n);
  },
  trim: function(n) {
    return We(n) ? yo(n) : n;
  }
});
function rW(n) {
  return KNe.get(n);
}
var iW = {
  lt: function(n, e) {
    return n < e;
  },
  lte: function(n, e) {
    return n <= e;
  },
  gt: function(n, e) {
    return n > e;
  },
  gte: function(n, e) {
    return n >= e;
  }
}, XNe = (
  /** @class */
  function() {
    function n(e, t) {
      if (!sn(t)) {
        var r = "";
        process.env.NODE_ENV !== "production" && (r = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.'), hn(r);
      }
      this._opFn = iW[e], this._rvalFloat = _l(t);
    }
    return n.prototype.evaluate = function(e) {
      return sn(e) ? this._opFn(e, this._rvalFloat) : this._opFn(_l(e), this._rvalFloat);
    }, n;
  }()
), aW = (
  /** @class */
  function() {
    function n(e, t) {
      var r = e === "desc";
      this._resultLT = r ? 1 : -1, t == null && (t = r ? "min" : "max"), this._incomparable = t === "min" ? -1 / 0 : 1 / 0;
    }
    return n.prototype.evaluate = function(e, t) {
      var r = sn(e) ? e : _l(e), i = sn(t) ? t : _l(t), a = isNaN(r), o = isNaN(i);
      if (a && (r = this._incomparable), o && (i = this._incomparable), a && o) {
        var s = We(e), l = We(t);
        s && (r = l ? e : 0), l && (i = s ? t : 0);
      }
      return r < i ? this._resultLT : r > i ? -this._resultLT : 0;
    }, n;
  }()
), ZNe = (
  /** @class */
  function() {
    function n(e, t) {
      this._rval = t, this._isEQ = e, this._rvalTypeof = typeof t, this._rvalFloat = _l(t);
    }
    return n.prototype.evaluate = function(e) {
      var t = e === this._rval;
      if (!t) {
        var r = typeof e;
        r !== this._rvalTypeof && (r === "number" || this._rvalTypeof === "number") && (t = _l(e) === this._rvalFloat);
      }
      return this._isEQ ? t : !t;
    }, n;
  }()
);
function JNe(n, e) {
  return n === "eq" || n === "ne" ? new ZNe(n === "eq", e) : Je(iW, n) ? new XNe(n, e) : null;
}
var QNe = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getRawData = function() {
      throw new Error("not supported");
    }, n.prototype.getRawDataItem = function(e) {
      throw new Error("not supported");
    }, n.prototype.cloneRawData = function() {
    }, n.prototype.getDimensionInfo = function(e) {
    }, n.prototype.cloneAllDimensionInfo = function() {
    }, n.prototype.count = function() {
    }, n.prototype.retrieveValue = function(e, t) {
    }, n.prototype.retrieveValueFromItem = function(e, t) {
    }, n.prototype.convertValue = function(e, t) {
      return Cu(e, t);
    }, n;
  }()
);
function eRe(n, e) {
  var t = new QNe(), r = n.data, i = t.sourceFormat = n.sourceFormat, a = n.startIndex, o = "";
  n.seriesLayoutBy !== ps && (process.env.NODE_ENV !== "production" && (o = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), hn(o));
  var s = [], l = {}, u = n.dimensionsDefine;
  if (u)
    $(u, function(v, m) {
      var g = v.name, y = {
        index: m,
        name: g,
        displayName: v.displayName
      };
      if (s.push(y), g != null) {
        var b = "";
        Je(l, g) && (process.env.NODE_ENV !== "production" && (b = 'dimension name "' + g + '" duplicated.'), hn(b)), l[g] = y;
      }
    });
  else
    for (var c = 0; c < n.dimensionsDetectedCount; c++)
      s.push({
        index: c
      });
  var d = eW(i, ps);
  e.__isBuiltIn && (t.getRawDataItem = function(v) {
    return d(r, a, s, v);
  }, t.getRawData = Ze(tRe, null, n)), t.cloneRawData = Ze(nRe, null, n);
  var f = tW(i, ps);
  t.count = Ze(f, null, r, a, s);
  var p = nW(i);
  t.retrieveValue = function(v, m) {
    var g = d(r, a, s, v);
    return h(g, m);
  };
  var h = t.retrieveValueFromItem = function(v, m) {
    if (v != null) {
      var g = s[m];
      if (g)
        return p(v, m, g.name);
    }
  };
  return t.getDimensionInfo = Ze(rRe, null, s, l), t.cloneAllDimensionInfo = Ze(iRe, null, s), t;
}
function tRe(n) {
  var e = n.sourceFormat;
  if (!oO(e)) {
    var t = "";
    process.env.NODE_ENV !== "production" && (t = "`getRawData` is not supported in source format " + e), hn(t);
  }
  return n.data;
}
function nRe(n) {
  var e = n.sourceFormat, t = n.data;
  if (!oO(e)) {
    var r = "";
    process.env.NODE_ENV !== "production" && (r = "`cloneRawData` is not supported in source format " + e), hn(r);
  }
  if (e === vi) {
    for (var i = [], a = 0, o = t.length; a < o; a++)
      i.push(t[a].slice());
    return i;
  } else if (e === oo) {
    for (var i = [], a = 0, o = t.length; a < o; a++)
      i.push(xe({}, t[a]));
    return i;
  }
}
function rRe(n, e, t) {
  if (t != null) {
    if (sn(t) || !isNaN(t) && !Je(e, t))
      return n[t];
    if (Je(e, t))
      return e[t];
  }
}
function iRe(n) {
  return ht(n);
}
var oW = tt();
function aRe(n) {
  n = ht(n);
  var e = n.type, t = "";
  e || (process.env.NODE_ENV !== "production" && (t = "Must have a `type` when `registerTransform`."), hn(t));
  var r = e.split(":");
  r.length !== 2 && (process.env.NODE_ENV !== "production" && (t = 'Name must include namespace like "ns:regression".'), hn(t));
  var i = !1;
  r[0] === "echarts" && (e = r[1], i = !0), n.__isBuiltIn = i, oW.set(e, n);
}
function oRe(n, e, t) {
  var r = wn(n), i = r.length, a = "";
  i || (process.env.NODE_ENV !== "production" && (a = "If `transform` declared, it should at least contain one transform."), hn(a));
  for (var o = 0, s = i; o < s; o++) {
    var l = r[o];
    e = sRe(l, e, t, i === 1 ? null : o), o !== s - 1 && (e.length = Math.max(e.length, 1));
  }
  return e;
}
function sRe(n, e, t, r) {
  var i = "";
  e.length || (process.env.NODE_ENV !== "production" && (i = "Must have at least one upstream dataset."), hn(i)), ut(n) || (process.env.NODE_ENV !== "production" && (i = "transform declaration must be an object rather than " + typeof n + "."), hn(i));
  var a = n.type, o = oW.get(a);
  o || (process.env.NODE_ENV !== "production" && (i = 'Can not find transform on type "' + a + '".'), hn(i));
  var s = De(e, function(c) {
    return eRe(c, o);
  }), l = wn(o.transform({
    upstream: s[0],
    upstreamList: s,
    config: ht(n.config)
  }));
  if (process.env.NODE_ENV !== "production" && n.print) {
    var u = De(l, function(c) {
      var d = r != null ? " === pipe index: " + r : "";
      return ["=== dataset index: " + t.datasetIndex + d + " ===", "- transform result data:", $i(c.data), "- transform result dimensions:", $i(c.dimensions)].join(`
`);
    }).join(`
`);
    POe(u);
  }
  return De(l, function(c, d) {
    var f = "";
    ut(c) || (process.env.NODE_ENV !== "production" && (f = "A transform should not return some empty results."), hn(f)), c.data || (process.env.NODE_ENV !== "production" && (f = "Transform result data should be not be null or undefined"), hn(f));
    var p = ZU(c.data);
    oO(p) || (process.env.NODE_ENV !== "production" && (f = "Transform result data should be array rows or object rows."), hn(f));
    var h, v = e[0];
    if (v && d === 0 && !c.dimensions) {
      var m = v.startIndex;
      m && (c.data = v.data.slice(0, m).concat(c.data)), h = {
        seriesLayoutBy: ps,
        sourceHeader: m,
        dimensions: v.metaRawOption.dimensions
      };
    } else
      h = {
        seriesLayoutBy: ps,
        sourceHeader: 0,
        dimensions: c.dimensions
      };
    return Sk(c.data, h, null);
  });
}
function oO(n) {
  return n === vi || n === oo;
}
var gw = "undefined", lRe = typeof Uint32Array === gw ? Array : Uint32Array, uRe = typeof Uint16Array === gw ? Array : Uint16Array, sW = typeof Int32Array === gw ? Array : Int32Array, Wj = typeof Float64Array === gw ? Array : Float64Array, lW = {
  float: Wj,
  int: sW,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: Wj
}, j2;
function kf(n) {
  return n > 65535 ? lRe : uRe;
}
function Af() {
  return [1 / 0, -1 / 0];
}
function cRe(n) {
  var e = n.constructor;
  return e === Array ? n.slice() : new e(n);
}
function qj(n, e, t, r, i) {
  var a = lW[t || "float"];
  if (i) {
    var o = n[e], s = o && o.length;
    if (s !== r) {
      for (var l = new a(r), u = 0; u < s; u++)
        l[u] = o[u];
      n[e] = l;
    }
  } else
    n[e] = new a(r);
}
var Ek = (
  /** @class */
  function() {
    function n() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = tt();
    }
    return n.prototype.initData = function(e, t, r) {
      process.env.NODE_ENV !== "production" && ct(at(e.getItem) && at(e.count), "Invalid data provider."), this._provider = e, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var i = e.getSource(), a = this.defaultDimValueGetter = j2[i.sourceFormat];
      this._dimValueGetter = r || a, this._rawExtent = [];
      var o = JU(i);
      this._dimensions = De(t, function(s) {
        return process.env.NODE_ENV !== "production" && o && ct(s.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: s.type,
          property: s.property
        };
      }), this._initDataFromProvider(0, e.count());
    }, n.prototype.getProvider = function() {
      return this._provider;
    }, n.prototype.getSource = function() {
      return this._provider.getSource();
    }, n.prototype.ensureCalculationDimension = function(e, t) {
      var r = this._calcDimNameToIdx, i = this._dimensions, a = r.get(e);
      if (a != null) {
        if (i[a].type === t)
          return a;
      } else
        a = i.length;
      return i[a] = {
        type: t
      }, r.set(e, a), this._chunks[a] = new lW[t || "float"](this._rawCount), this._rawExtent[a] = Af(), a;
    }, n.prototype.collectOrdinalMeta = function(e, t) {
      var r = this._chunks[e], i = this._dimensions[e], a = this._rawExtent, o = i.ordinalOffset || 0, s = r.length;
      o === 0 && (a[e] = Af());
      for (var l = a[e], u = o; u < s; u++) {
        var c = r[u] = t.parseAndCollect(r[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      i.ordinalMeta = t, i.ordinalOffset = s, i.type = "ordinal";
    }, n.prototype.getOrdinalMeta = function(e) {
      var t = this._dimensions[e], r = t.ordinalMeta;
      return r;
    }, n.prototype.getDimensionProperty = function(e) {
      var t = this._dimensions[e];
      return t && t.property;
    }, n.prototype.appendData = function(e) {
      process.env.NODE_ENV !== "production" && ct(!this._indices, "appendData can only be called on raw data.");
      var t = this._provider, r = this.count();
      t.appendData(e);
      var i = t.count();
      return t.persistent || (i += r), r < i && this._initDataFromProvider(r, i, !0), [r, i];
    }, n.prototype.appendValues = function(e, t) {
      for (var r = this._chunks, i = this._dimensions, a = i.length, o = this._rawExtent, s = this.count(), l = s + Math.max(e.length, t || 0), u = 0; u < a; u++) {
        var c = i[u];
        qj(r, u, c.type, l, !0);
      }
      for (var d = [], f = s; f < l; f++)
        for (var p = f - s, h = 0; h < a; h++) {
          var c = i[h], v = j2.arrayRows.call(this, e[p] || d, c.property, p, h);
          r[h][f] = v;
          var m = o[h];
          v < m[0] && (m[0] = v), v > m[1] && (m[1] = v);
        }
      return this._rawCount = this._count = l, {
        start: s,
        end: l
      };
    }, n.prototype._initDataFromProvider = function(e, t, r) {
      for (var i = this._provider, a = this._chunks, o = this._dimensions, s = o.length, l = this._rawExtent, u = De(o, function(y) {
        return y.property;
      }), c = 0; c < s; c++) {
        var d = o[c];
        l[c] || (l[c] = Af()), qj(a, c, d.type, t, r);
      }
      if (i.fillStorage)
        i.fillStorage(e, t, a, l);
      else
        for (var f = [], p = e; p < t; p++) {
          f = i.getItem(p, f);
          for (var h = 0; h < s; h++) {
            var v = a[h], m = this._dimValueGetter(f, u[h], p, h);
            v[p] = m;
            var g = l[h];
            m < g[0] && (g[0] = m), m > g[1] && (g[1] = m);
          }
        }
      !i.persistent && i.clean && i.clean(), this._rawCount = this._count = t, this._extent = [];
    }, n.prototype.count = function() {
      return this._count;
    }, n.prototype.get = function(e, t) {
      if (!(t >= 0 && t < this._count))
        return NaN;
      var r = this._chunks[e];
      return r ? r[this.getRawIndex(t)] : NaN;
    }, n.prototype.getValues = function(e, t) {
      var r = [], i = [];
      if (t == null) {
        t = e, e = [];
        for (var a = 0; a < this._dimensions.length; a++)
          i.push(a);
      } else
        i = e;
      for (var a = 0, o = i.length; a < o; a++)
        r.push(this.get(i[a], t));
      return r;
    }, n.prototype.getByRawIndex = function(e, t) {
      if (!(t >= 0 && t < this._rawCount))
        return NaN;
      var r = this._chunks[e];
      return r ? r[t] : NaN;
    }, n.prototype.getSum = function(e) {
      var t = this._chunks[e], r = 0;
      if (t)
        for (var i = 0, a = this.count(); i < a; i++) {
          var o = this.get(e, i);
          isNaN(o) || (r += o);
        }
      return r;
    }, n.prototype.getMedian = function(e) {
      var t = [];
      this.each([e], function(a) {
        isNaN(a) || t.push(a);
      });
      var r = t.sort(function(a, o) {
        return a - o;
      }), i = this.count();
      return i === 0 ? 0 : i % 2 === 1 ? r[(i - 1) / 2] : (r[i / 2] + r[i / 2 - 1]) / 2;
    }, n.prototype.indexOfRawIndex = function(e) {
      if (e >= this._rawCount || e < 0)
        return -1;
      if (!this._indices)
        return e;
      var t = this._indices, r = t[e];
      if (r != null && r < this._count && r === e)
        return e;
      for (var i = 0, a = this._count - 1; i <= a; ) {
        var o = (i + a) / 2 | 0;
        if (t[o] < e)
          i = o + 1;
        else if (t[o] > e)
          a = o - 1;
        else
          return o;
      }
      return -1;
    }, n.prototype.indicesOfNearest = function(e, t, r) {
      var i = this._chunks, a = i[e], o = [];
      if (!a)
        return o;
      r == null && (r = 1 / 0);
      for (var s = 1 / 0, l = -1, u = 0, c = 0, d = this.count(); c < d; c++) {
        var f = this.getRawIndex(c), p = t - a[f], h = Math.abs(p);
        h <= r && ((h < s || h === s && p >= 0 && l < 0) && (s = h, l = p, u = 0), p === l && (o[u++] = c));
      }
      return o.length = u, o;
    }, n.prototype.getIndices = function() {
      var e, t = this._indices;
      if (t) {
        var r = t.constructor, i = this._count;
        if (r === Array) {
          e = new r(i);
          for (var a = 0; a < i; a++)
            e[a] = t[a];
        } else
          e = new r(t.buffer, 0, i);
      } else {
        var r = kf(this._rawCount);
        e = new r(this.count());
        for (var a = 0; a < e.length; a++)
          e[a] = a;
      }
      return e;
    }, n.prototype.filter = function(e, t) {
      if (!this._count)
        return this;
      for (var r = this.clone(), i = r.count(), a = kf(r._rawCount), o = new a(i), s = [], l = e.length, u = 0, c = e[0], d = r._chunks, f = 0; f < i; f++) {
        var p = void 0, h = r.getRawIndex(f);
        if (l === 0)
          p = t(f);
        else if (l === 1) {
          var v = d[c][h];
          p = t(v, f);
        } else {
          for (var m = 0; m < l; m++)
            s[m] = d[e[m]][h];
          s[m] = f, p = t.apply(null, s);
        }
        p && (o[u++] = h);
      }
      return u < i && (r._indices = o), r._count = u, r._extent = [], r._updateGetRawIdx(), r;
    }, n.prototype.selectRange = function(e) {
      var t = this.clone(), r = t._count;
      if (!r)
        return this;
      var i = Yt(e), a = i.length;
      if (!a)
        return this;
      var o = t.count(), s = kf(t._rawCount), l = new s(o), u = 0, c = i[0], d = e[c][0], f = e[c][1], p = t._chunks, h = !1;
      if (!t._indices) {
        var v = 0;
        if (a === 1) {
          for (var m = p[i[0]], g = 0; g < r; g++) {
            var y = m[g];
            (y >= d && y <= f || isNaN(y)) && (l[u++] = v), v++;
          }
          h = !0;
        } else if (a === 2) {
          for (var m = p[i[0]], b = p[i[1]], _ = e[i[1]][0], x = e[i[1]][1], g = 0; g < r; g++) {
            var y = m[g], w = b[g];
            (y >= d && y <= f || isNaN(y)) && (w >= _ && w <= x || isNaN(w)) && (l[u++] = v), v++;
          }
          h = !0;
        }
      }
      if (!h)
        if (a === 1)
          for (var g = 0; g < o; g++) {
            var S = t.getRawIndex(g), y = p[i[0]][S];
            (y >= d && y <= f || isNaN(y)) && (l[u++] = S);
          }
        else
          for (var g = 0; g < o; g++) {
            for (var C = !0, S = t.getRawIndex(g), k = 0; k < a; k++) {
              var M = i[k], y = p[M][S];
              (y < e[M][0] || y > e[M][1]) && (C = !1);
            }
            C && (l[u++] = t.getRawIndex(g));
          }
      return u < o && (t._indices = l), t._count = u, t._extent = [], t._updateGetRawIdx(), t;
    }, n.prototype.map = function(e, t) {
      var r = this.clone(e);
      return this._updateDims(r, e, t), r;
    }, n.prototype.modify = function(e, t) {
      this._updateDims(this, e, t);
    }, n.prototype._updateDims = function(e, t, r) {
      for (var i = e._chunks, a = [], o = t.length, s = e.count(), l = [], u = e._rawExtent, c = 0; c < t.length; c++)
        u[t[c]] = Af();
      for (var d = 0; d < s; d++) {
        for (var f = e.getRawIndex(d), p = 0; p < o; p++)
          l[p] = i[t[p]][f];
        l[o] = d;
        var h = r && r.apply(null, l);
        if (h != null) {
          typeof h != "object" && (a[0] = h, h = a);
          for (var c = 0; c < h.length; c++) {
            var v = t[c], m = h[c], g = u[v], y = i[v];
            y && (y[f] = m), m < g[0] && (g[0] = m), m > g[1] && (g[1] = m);
          }
        }
      }
    }, n.prototype.lttbDownSample = function(e, t) {
      var r = this.clone([e], !0), i = r._chunks, a = i[e], o = this.count(), s = 0, l = Math.floor(1 / t), u = this.getRawIndex(0), c, d, f, p = new (kf(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o));
      p[s++] = u;
      for (var h = 1; h < o - 1; h += l) {
        for (var v = Math.min(h + l, o - 1), m = Math.min(h + l * 2, o), g = (m + v) / 2, y = 0, b = v; b < m; b++) {
          var _ = this.getRawIndex(b), x = a[_];
          isNaN(x) || (y += x);
        }
        y /= m - v;
        var w = h, S = Math.min(h + l, o), C = h - 1, k = a[u];
        c = -1, f = w;
        for (var M = -1, D = 0, b = w; b < S; b++) {
          var _ = this.getRawIndex(b), x = a[_];
          if (isNaN(x)) {
            D++, M < 0 && (M = _);
            continue;
          }
          d = Math.abs((C - g) * (x - k) - (C - b) * (y - k)), d > c && (c = d, f = _);
        }
        D > 0 && D < S - w && (p[s++] = Math.min(M, f), f = Math.max(M, f)), p[s++] = f, u = f;
      }
      return p[s++] = this.getRawIndex(o - 1), r._count = s, r._indices = p, r.getRawIndex = this._getRawIdx, r;
    }, n.prototype.minmaxDownSample = function(e, t) {
      for (var r = this.clone([e], !0), i = r._chunks, a = Math.floor(1 / t), o = i[e], s = this.count(), l = new (kf(this._rawCount))(Math.ceil(s / a) * 2), u = 0, c = 0; c < s; c += a) {
        var d = c, f = o[this.getRawIndex(d)], p = c, h = o[this.getRawIndex(p)], v = a;
        c + a > s && (v = s - c);
        for (var m = 0; m < v; m++) {
          var g = this.getRawIndex(c + m), y = o[g];
          y < f && (f = y, d = c + m), y > h && (h = y, p = c + m);
        }
        var b = this.getRawIndex(d), _ = this.getRawIndex(p);
        d < p ? (l[u++] = b, l[u++] = _) : (l[u++] = _, l[u++] = b);
      }
      return r._count = u, r._indices = l, r._updateGetRawIdx(), r;
    }, n.prototype.downSample = function(e, t, r, i) {
      for (var a = this.clone([e], !0), o = a._chunks, s = [], l = Math.floor(1 / t), u = o[e], c = this.count(), d = a._rawExtent[e] = Af(), f = new (kf(this._rawCount))(Math.ceil(c / l)), p = 0, h = 0; h < c; h += l) {
        l > c - h && (l = c - h, s.length = l);
        for (var v = 0; v < l; v++) {
          var m = this.getRawIndex(h + v);
          s[v] = u[m];
        }
        var g = r(s), y = this.getRawIndex(Math.min(h + i(s, g) || 0, c - 1));
        u[y] = g, g < d[0] && (d[0] = g), g > d[1] && (d[1] = g), f[p++] = y;
      }
      return a._count = p, a._indices = f, a._updateGetRawIdx(), a;
    }, n.prototype.each = function(e, t) {
      if (this._count)
        for (var r = e.length, i = this._chunks, a = 0, o = this.count(); a < o; a++) {
          var s = this.getRawIndex(a);
          switch (r) {
            case 0:
              t(a);
              break;
            case 1:
              t(i[e[0]][s], a);
              break;
            case 2:
              t(i[e[0]][s], i[e[1]][s], a);
              break;
            default:
              for (var l = 0, u = []; l < r; l++)
                u[l] = i[e[l]][s];
              u[l] = a, t.apply(null, u);
          }
        }
    }, n.prototype.getDataExtent = function(e) {
      var t = this._chunks[e], r = Af();
      if (!t)
        return r;
      var i = this.count(), a = !this._indices, o;
      if (a)
        return this._rawExtent[e].slice();
      if (o = this._extent[e], o)
        return o.slice();
      o = r;
      for (var s = o[0], l = o[1], u = 0; u < i; u++) {
        var c = this.getRawIndex(u), d = t[c];
        d < s && (s = d), d > l && (l = d);
      }
      return o = [s, l], this._extent[e] = o, o;
    }, n.prototype.getRawDataItem = function(e) {
      var t = this.getRawIndex(e);
      if (this._provider.persistent)
        return this._provider.getItem(t);
      for (var r = [], i = this._chunks, a = 0; a < i.length; a++)
        r.push(i[a][t]);
      return r;
    }, n.prototype.clone = function(e, t) {
      var r = new n(), i = this._chunks, a = e && xs(e, function(s, l) {
        return s[l] = !0, s;
      }, {});
      if (a)
        for (var o = 0; o < i.length; o++)
          r._chunks[o] = a[o] ? cRe(i[o]) : i[o];
      else
        r._chunks = i;
      return this._copyCommonProps(r), t || (r._indices = this._cloneIndices()), r._updateGetRawIdx(), r;
    }, n.prototype._copyCommonProps = function(e) {
      e._count = this._count, e._rawCount = this._rawCount, e._provider = this._provider, e._dimensions = this._dimensions, e._extent = ht(this._extent), e._rawExtent = ht(this._rawExtent);
    }, n.prototype._cloneIndices = function() {
      if (this._indices) {
        var e = this._indices.constructor, t = void 0;
        if (e === Array) {
          var r = this._indices.length;
          t = new e(r);
          for (var i = 0; i < r; i++)
            t[i] = this._indices[i];
        } else
          t = new e(this._indices);
        return t;
      }
      return null;
    }, n.prototype._getRawIdxIdentity = function(e) {
      return e;
    }, n.prototype._getRawIdx = function(e) {
      return e < this._count && e >= 0 ? this._indices[e] : -1;
    }, n.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, n.internalField = function() {
      function e(t, r, i, a) {
        return Cu(t[a], this._dimensions[a]);
      }
      j2 = {
        arrayRows: e,
        objectRows: function(t, r, i, a) {
          return Cu(t[r], this._dimensions[a]);
        },
        keyedColumns: e,
        original: function(t, r, i, a) {
          var o = t && (t.value == null ? t : t.value);
          return Cu(o instanceof Array ? o[a] : o, this._dimensions[a]);
        },
        typedArray: function(t, r, i, a) {
          return t[a];
        }
      };
    }(), n;
  }()
), uW = (
  /** @class */
  function() {
    function n(e) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = e;
    }
    return n.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, n.prototype._setLocalSource = function(e, t) {
      this._sourceList = e, this._upstreamSignList = t, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, n.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, n.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, n.prototype._createSource = function() {
      this._setLocalSource([], []);
      var e = this._sourceHost, t = this._getUpstreamSourceManagers(), r = !!t.length, i, a;
      if (nv(e)) {
        var o = e, s = void 0, l = void 0, u = void 0;
        if (r) {
          var c = t[0];
          c.prepareSource(), u = c.getSource(), s = u.data, l = u.sourceFormat, a = [c._getVersionSign()];
        } else
          s = o.get("data", !0), l = Bi(s) ? fl : ao, a = [];
        var d = this._getSourceMetaRawOption() || {}, f = u && u.metaRawOption || {}, p = bt(d.seriesLayoutBy, f.seriesLayoutBy) || null, h = bt(d.sourceHeader, f.sourceHeader), v = bt(d.dimensions, f.dimensions), m = p !== f.seriesLayoutBy || !!h != !!f.sourceHeader || v;
        i = m ? [Sk(s, {
          seriesLayoutBy: p,
          sourceHeader: h,
          dimensions: v
        }, l)] : [];
      } else {
        var g = e;
        if (r) {
          var y = this._applyTransform(t);
          i = y.sourceList, a = y.upstreamSignList;
        } else {
          var b = g.get("source", !0);
          i = [Sk(b, this._getSourceMetaRawOption(), null)], a = [];
        }
      }
      process.env.NODE_ENV !== "production" && ct(i && a), this._setLocalSource(i, a);
    }, n.prototype._applyTransform = function(e) {
      var t = this._sourceHost, r = t.get("transform", !0), i = t.get("fromTransformResult", !0);
      if (process.env.NODE_ENV !== "production" && ct(i != null || r != null), i != null) {
        var a = "";
        e.length !== 1 && (process.env.NODE_ENV !== "production" && (a = "When using `fromTransformResult`, there should be only one upstream dataset"), Kj(a));
      }
      var o, s = [], l = [];
      return $(e, function(u) {
        u.prepareSource();
        var c = u.getSource(i || 0), d = "";
        i != null && !c && (process.env.NODE_ENV !== "production" && (d = "Can not retrieve result by `fromTransformResult`: " + i), Kj(d)), s.push(c), l.push(u._getVersionSign());
      }), r ? o = oRe(r, s, {
        datasetIndex: t.componentIndex
      }) : i != null && (o = [FNe(s[0])]), {
        sourceList: o,
        upstreamSignList: l
      };
    }, n.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var e = this._getUpstreamSourceManagers(), t = 0; t < e.length; t++) {
        var r = e[t];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          r._isDirty() || this._upstreamSignList[t] !== r._getVersionSign()
        )
          return !0;
      }
    }, n.prototype.getSource = function(e) {
      e = e || 0;
      var t = this._sourceList[e];
      if (!t) {
        var r = this._getUpstreamSourceManagers();
        return r[0] && r[0].getSource(e);
      }
      return t;
    }, n.prototype.getSharedDataStore = function(e) {
      process.env.NODE_ENV !== "production" && ct(nv(this._sourceHost), "Can only call getDataStore on series source manager.");
      var t = e.makeStoreSchema();
      return this._innerGetDataStore(t.dimensions, e.source, t.hash);
    }, n.prototype._innerGetDataStore = function(e, t, r) {
      var i = 0, a = this._storeList, o = a[i];
      o || (o = a[i] = {});
      var s = o[r];
      if (!s) {
        var l = this._getUpstreamSourceManagers()[0];
        nv(this._sourceHost) && l ? s = l._innerGetDataStore(e, t, r) : (s = new Ek(), s.initData(new QU(t, e.length), e)), o[r] = s;
      }
      return s;
    }, n.prototype._getUpstreamSourceManagers = function() {
      var e = this._sourceHost;
      if (nv(e)) {
        var t = eO(e);
        return t ? [t.getSourceManager()] : [];
      } else
        return De(hNe(e), function(r) {
          return r.getSourceManager();
        });
    }, n.prototype._getSourceMetaRawOption = function() {
      var e = this._sourceHost, t, r, i;
      if (nv(e))
        t = e.get("seriesLayoutBy", !0), r = e.get("sourceHeader", !0), i = e.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = e;
        t = a.get("seriesLayoutBy", !0), r = a.get("sourceHeader", !0), i = a.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: t,
        sourceHeader: r,
        dimensions: i
      };
    }, n;
  }()
);
function Yj(n) {
  var e = n.option.transform;
  e && Gb(n.option.transform);
}
function nv(n) {
  return n.mainType === "series";
}
function Kj(n) {
  throw new Error(n);
}
var dRe = "line-height:1";
function cW(n) {
  var e = n.lineHeight;
  return e == null ? dRe : "line-height:" + Ai(e + "") + "px";
}
function dW(n, e) {
  var t = n.color || "#6e7079", r = n.fontSize || 12, i = n.fontWeight || "400", a = n.color || "#464646", o = n.fontSize || 14, s = n.fontWeight || "900";
  return e === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + Ai(r + "") + "px;color:" + Ai(t) + ";font-weight:" + Ai(i + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + Ai(o + "") + "px;color:" + Ai(a) + ";font-weight:" + Ai(s + "")
  } : {
    nameStyle: {
      fontSize: r,
      fill: t,
      fontWeight: i
    },
    valueStyle: {
      fontSize: o,
      fill: a,
      fontWeight: s
    }
  };
}
var fRe = [0, 10, 20, 30], pRe = ["", `
`, `

`, `


`];
function Rr(n, e) {
  return e.type = n, e;
}
function Tk(n) {
  return n.type === "section";
}
function fW(n) {
  return Tk(n) ? hRe : vRe;
}
function pW(n) {
  if (Tk(n)) {
    var e = 0, t = n.blocks.length, r = t > 1 || t > 0 && !n.noHeader;
    return $(n.blocks, function(i) {
      var a = pW(i);
      a >= e && (e = a + +(r && // 0 always can not be readable gap level.
      (!a || Tk(i) && !i.noHeader)));
    }), e;
  }
  return 0;
}
function hRe(n, e, t, r) {
  var i = e.noHeader, a = mRe(pW(e)), o = [], s = e.blocks || [];
  ct(!s || Me(s)), s = s || [];
  var l = n.orderMode;
  if (e.sortBlocks && l) {
    s = s.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (Je(u, l)) {
      var c = new aW(u[l], null);
      s.sort(function(v, m) {
        return c.evaluate(v.sortParam, m.sortParam);
      });
    } else l === "seriesDesc" && s.reverse();
  }
  $(s, function(v, m) {
    var g = e.valueFormatter, y = fW(v)(
      // Inherit valueFormatter
      g ? xe(xe({}, n), {
        valueFormatter: g
      }) : n,
      v,
      m > 0 ? a.html : 0,
      r
    );
    y != null && o.push(y);
  });
  var d = n.renderMode === "richText" ? o.join(a.richText) : Ck(r, o.join(""), i ? t : a.html);
  if (i)
    return d;
  var f = bk(e.header, "ordinal", n.useUTC), p = dW(r, n.renderMode).nameStyle, h = cW(r);
  return n.renderMode === "richText" ? hW(n, f, p) + a.richText + d : Ck(r, '<div style="' + p + ";" + h + ';">' + Ai(f) + "</div>" + d, t);
}
function vRe(n, e, t, r) {
  var i = n.renderMode, a = e.noName, o = e.noValue, s = !e.markerType, l = e.name, u = n.useUTC, c = e.valueFormatter || n.valueFormatter || function(_) {
    return _ = Me(_) ? _ : [_], De(_, function(x, w) {
      return bk(x, Me(p) ? p[w] : p, u);
    });
  };
  if (!(a && o)) {
    var d = s ? "" : n.markupStyleCreator.makeTooltipMarker(e.markerType, e.markerColor || "#333", i), f = a ? "" : bk(l, "ordinal", u), p = e.valueType, h = o ? [] : c(e.value, e.dataIndex), v = !s || !a, m = !s && a, g = dW(r, i), y = g.nameStyle, b = g.valueStyle;
    return i === "richText" ? (s ? "" : d) + (a ? "" : hW(n, f, y)) + (o ? "" : bRe(n, h, v, m, b)) : Ck(r, (s ? "" : d) + (a ? "" : gRe(f, !s, y)) + (o ? "" : yRe(h, v, m, b)), t);
  }
}
function Xj(n, e, t, r, i, a) {
  if (n) {
    var o = fW(n), s = {
      useUTC: i,
      renderMode: t,
      orderMode: r,
      markupStyleCreator: e,
      valueFormatter: n.valueFormatter
    };
    return o(s, n, 0, a);
  }
}
function mRe(n) {
  return {
    html: fRe[n],
    richText: pRe[n]
  };
}
function Ck(n, e, t) {
  var r = '<div style="clear:both"></div>', i = "margin: " + t + "px 0 0", a = cW(n);
  return '<div style="' + i + ";" + a + ';">' + e + r + "</div>";
}
function gRe(n, e, t) {
  var r = e ? "margin-left:2px" : "";
  return '<span style="' + t + ";" + r + '">' + Ai(n) + "</span>";
}
function yRe(n, e, t, r) {
  var i = t ? "10px" : "20px", a = e ? "float:right;margin-left:" + i : "";
  return n = Me(n) ? n : [n], '<span style="' + a + ";" + r + '">' + De(n, function(o) {
    return Ai(o);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function hW(n, e, t) {
  return n.markupStyleCreator.wrapRichTextStyle(e, t);
}
function bRe(n, e, t, r, i) {
  var a = [i], o = r ? 10 : 20;
  return t && a.push({
    padding: [0, 0, 0, o],
    align: "right"
  }), n.markupStyleCreator.wrapRichTextStyle(Me(e) ? e.join("  ") : e, a);
}
function vW(n, e) {
  var t = n.getData().getItemVisual(e, "style"), r = t[n.visualDrawType];
  return Rd(r);
}
function mW(n, e) {
  var t = n.get("padding");
  return t ?? (e === "richText" ? [8, 10] : 10);
}
var B2 = (
  /** @class */
  function() {
    function n() {
      this.richTextStyles = {}, this._nextStyleNameId = IG();
    }
    return n.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, n.prototype.makeTooltipMarker = function(e, t, r) {
      var i = r === "richText" ? this._generateStyleName() : null, a = sNe({
        color: t,
        type: e,
        renderMode: r,
        markerId: i
      });
      return We(a) ? a : (process.env.NODE_ENV !== "production" && ct(i), this.richTextStyles[i] = a.style, a.content);
    }, n.prototype.wrapRichTextStyle = function(e, t) {
      var r = {};
      Me(t) ? $(t, function(a) {
        return xe(r, a);
      }) : xe(r, t);
      var i = this._generateStyleName();
      return this.richTextStyles[i] = r, "{" + i + "|" + e + "}";
    }, n;
  }()
);
function gW(n) {
  var e = n.series, t = n.dataIndex, r = n.multipleSeries, i = e.getData(), a = i.mapDimensionsAll("defaultedTooltip"), o = a.length, s = e.getRawValue(t), l = Me(s), u = vW(e, t), c, d, f, p;
  if (o > 1 || l && !o) {
    var h = _Re(s, e, t, a, u);
    c = h.inlineValues, d = h.inlineValueTypes, f = h.blocks, p = h.inlineValues[0];
  } else if (o) {
    var v = i.getDimensionInfo(a[0]);
    p = c = Vp(i, t, a[0]), d = v.type;
  } else
    p = c = l ? s[0] : s;
  var m = ID(e), g = m && e.name || "", y = i.getName(t), b = r ? g : y;
  return Rr("section", {
    header: g,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: r || !m,
    sortParam: p,
    blocks: [Rr("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: b,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !yo(b),
      value: c,
      valueType: d,
      dataIndex: t
    })].concat(f || [])
  });
}
function _Re(n, e, t, r, i) {
  var a = e.getData(), o = xs(n, function(d, f, p) {
    var h = a.getDimensionInfo(p);
    return d = d || h && h.tooltip !== !1 && h.displayName != null;
  }, !1), s = [], l = [], u = [];
  r.length ? $(r, function(d) {
    c(Vp(a, t, d), d);
  }) : $(n, c);
  function c(d, f) {
    var p = a.getDimensionInfo(f);
    !p || p.otherDims.tooltip === !1 || (o ? u.push(Rr("nameValue", {
      markerType: "subItem",
      markerColor: i,
      name: p.displayName,
      value: d,
      valueType: p.type
    })) : (s.push(d), l.push(p.type)));
  }
  return {
    inlineValues: s,
    inlineValueTypes: l,
    blocks: u
  };
}
var Fl = en();
function _0(n, e) {
  return n.getName(e) || n.getId(e);
}
var M1 = "__universalTransitionEnabled", Rn = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t._selectedDataIndicesMap = {}, t;
    }
    return e.prototype.init = function(t, r, i) {
      this.seriesIndex = this.componentIndex, this.dataTask = vm({
        count: wRe,
        reset: SRe
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(t, i);
      var a = Fl(this).sourceManager = new uW(this);
      a.prepareSource();
      var o = this.getInitialData(t, i);
      Jj(o, this), this.dataTask.context.data = o, process.env.NODE_ENV !== "production" && ct(o, "getInitialData returned invalid data."), Fl(this).dataBeforeProcessed = o, Zj(this), this._initSelectedMapFromData(o);
    }, e.prototype.mergeDefaultAndTheme = function(t, r) {
      var i = rg(this), a = i ? vh(t) : {}, o = this.subType;
      Ut.hasClass(o) && (o += "Series"), At(t, r.getTheme().get(this.subType)), At(t, this.getDefaultOption()), Od(t, "label", ["show"]), this.fillDataTextStyle(t.data), i && ju(t, a, i);
    }, e.prototype.mergeOption = function(t, r) {
      t = At(this.option, t, !0), this.fillDataTextStyle(t.data);
      var i = rg(this);
      i && ju(this.option, t, i);
      var a = Fl(this).sourceManager;
      a.dirty(), a.prepareSource();
      var o = this.getInitialData(t, r);
      Jj(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, Fl(this).dataBeforeProcessed = o, Zj(this), this._initSelectedMapFromData(o);
    }, e.prototype.fillDataTextStyle = function(t) {
      if (t && !Bi(t))
        for (var r = ["show"], i = 0; i < t.length; i++)
          t[i] && t[i].label && Od(t[i], "label", r);
    }, e.prototype.getInitialData = function(t, r) {
    }, e.prototype.appendData = function(t) {
      var r = this.getRawData();
      r.appendData(t.data);
    }, e.prototype.getData = function(t) {
      var r = kk(this);
      if (r) {
        var i = r.context.data;
        return t == null || !i.getLinkedData ? i : i.getLinkedData(t);
      } else
        return Fl(this).data;
    }, e.prototype.getAllData = function() {
      var t = this.getData();
      return t && t.getLinkedDataAll ? t.getLinkedDataAll() : [{
        data: t
      }];
    }, e.prototype.setData = function(t) {
      var r = kk(this);
      if (r) {
        var i = r.context;
        i.outputData = t, r !== this.dataTask && (i.data = t);
      }
      Fl(this).data = t;
    }, e.prototype.getEncode = function() {
      var t = this.get("encode", !0);
      if (t)
        return tt(t);
    }, e.prototype.getSourceManager = function() {
      return Fl(this).sourceManager;
    }, e.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, e.prototype.getRawData = function() {
      return Fl(this).dataBeforeProcessed;
    }, e.prototype.getColorBy = function() {
      var t = this.get("colorBy");
      return t || "series";
    }, e.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, e.prototype.getBaseAxis = function() {
      var t = this.coordinateSystem;
      return t && t.getBaseAxis && t.getBaseAxis();
    }, e.prototype.formatTooltip = function(t, r, i) {
      return gW({
        series: this,
        dataIndex: t,
        multipleSeries: r
      });
    }, e.prototype.isAnimationEnabled = function() {
      var t = this.ecModel;
      if (Vt.node && !(t && t.ssr))
        return !1;
      var r = this.getShallow("animation");
      return r && this.getData().count() > this.getShallow("animationThreshold") && (r = !1), !!r;
    }, e.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, e.prototype.getColorFromPalette = function(t, r, i) {
      var a = this.ecModel, o = tO.prototype.getColorFromPalette.call(this, t, r, i);
      return o || (o = a.getColorFromPalette(t, r, i)), o;
    }, e.prototype.coordDimToDataDim = function(t) {
      return this.getRawData().mapDimensionsAll(t);
    }, e.prototype.getProgressive = function() {
      return this.get("progressive");
    }, e.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, e.prototype.select = function(t, r) {
      this._innerSelect(this.getData(r), t);
    }, e.prototype.unselect = function(t, r) {
      var i = this.option.selectedMap;
      if (i) {
        var a = this.option.selectedMode, o = this.getData(r);
        if (a === "series" || i === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var s = 0; s < t.length; s++) {
          var l = t[s], u = _0(o, l);
          i[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, e.prototype.toggleSelect = function(t, r) {
      for (var i = [], a = 0; a < t.length; a++)
        i[0] = t[a], this.isSelected(t[a], r) ? this.unselect(i, r) : this.select(i, r);
    }, e.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var t = this._selectedDataIndicesMap, r = Yt(t), i = [], a = 0; a < r.length; a++) {
        var o = t[r[a]];
        o >= 0 && i.push(o);
      }
      return i;
    }, e.prototype.isSelected = function(t, r) {
      var i = this.option.selectedMap;
      if (!i)
        return !1;
      var a = this.getData(r);
      return (i === "all" || i[_0(a, t)]) && !a.getItemModel(t).get(["select", "disabled"]);
    }, e.prototype.isUniversalTransitionEnabled = function() {
      if (this[M1])
        return !0;
      var t = this.option.universalTransition;
      return t ? t === !0 ? !0 : t && t.enabled : !1;
    }, e.prototype._innerSelect = function(t, r) {
      var i, a, o = this.option, s = o.selectedMode, l = r.length;
      if (!(!s || !l)) {
        if (s === "series")
          o.selectedMap = "all";
        else if (s === "multiple") {
          ut(o.selectedMap) || (o.selectedMap = {});
          for (var u = o.selectedMap, c = 0; c < l; c++) {
            var d = r[c], f = _0(t, d);
            u[f] = !0, this._selectedDataIndicesMap[f] = t.getRawIndex(d);
          }
        } else if (s === "single" || s === !0) {
          var p = r[l - 1], f = _0(t, p);
          o.selectedMap = (i = {}, i[f] = !0, i), this._selectedDataIndicesMap = (a = {}, a[f] = t.getRawIndex(p), a);
        }
      }
    }, e.prototype._initSelectedMapFromData = function(t) {
      if (!this.option.selectedMap) {
        var r = [];
        t.hasItemOption && t.each(function(i) {
          var a = t.getRawDataItem(i);
          a && a.selected && r.push(i);
        }), r.length > 0 && this._innerSelect(t, r);
      }
    }, e.registerClass = function(t) {
      return Ut.registerClass(t);
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "series.__base__", t.seriesIndex = 0, t.ignoreStyleOnData = !1, t.hasSymbolVisual = !1, t.defaultSymbol = "circle", t.visualStyleAccessPath = "itemStyle", t.visualDrawType = "fill";
    }(), e;
  }(Ut)
);
_r(Rn, mw);
_r(Rn, tO);
FG(Rn, Ut);
function Zj(n) {
  var e = n.name;
  ID(n) || (n.name = xRe(n) || e);
}
function xRe(n) {
  var e = n.getRawData(), t = e.mapDimensionsAll("seriesName"), r = [];
  return $(t, function(i) {
    var a = e.getDimensionInfo(i);
    a.displayName && r.push(a.displayName);
  }), r.join(" ");
}
function wRe(n) {
  return n.model.getRawData().count();
}
function SRe(n) {
  var e = n.model;
  return e.setData(e.getRawData().cloneShallow()), ERe;
}
function ERe(n, e) {
  e.outputData && n.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData);
}
function Jj(n, e) {
  $(Km(n.CHANGABLE_METHODS, n.DOWNSAMPLE_METHODS), function(t) {
    n.wrapMethod(t, Tt(TRe, e));
  });
}
function TRe(n, e) {
  var t = kk(n);
  return t && t.setOutputEnd((e || this).count()), e;
}
function kk(n) {
  var e = (n.ecModel || {}).scheduler, t = e && e.getPipeline(n.uid);
  if (t) {
    var r = t.currentTask;
    if (r) {
      var i = r.agentStubMap;
      i && (r = i.get(n.uid));
    }
    return r;
  }
}
var Yn = (
  /** @class */
  function() {
    function n() {
      this.group = new mt(), this.uid = ph("viewComponent");
    }
    return n.prototype.init = function(e, t) {
    }, n.prototype.render = function(e, t, r, i) {
    }, n.prototype.dispose = function(e, t) {
    }, n.prototype.updateView = function(e, t, r, i) {
    }, n.prototype.updateLayout = function(e, t, r, i) {
    }, n.prototype.updateVisual = function(e, t, r, i) {
    }, n.prototype.toggleBlurSeries = function(e, t, r) {
    }, n.prototype.eachRendered = function(e) {
      var t = this.group;
      t && t.traverse(e);
    }, n;
  }()
);
ND(Yn);
Jx(Yn);
function yh() {
  var n = en();
  return function(e) {
    var t = n(e), r = e.pipelineContext, i = !!t.large, a = !!t.progressiveRender, o = t.large = !!(r && r.large), s = t.progressiveRender = !!(r && r.progressiveRender);
    return (i !== o || a !== s) && "reset";
  };
}
var yW = en(), CRe = yh(), Tn = (
  /** @class */
  function() {
    function n() {
      this.group = new mt(), this.uid = ph("viewChart"), this.renderTask = vm({
        plan: kRe,
        reset: ARe
      }), this.renderTask.context = {
        view: this
      };
    }
    return n.prototype.init = function(e, t) {
    }, n.prototype.render = function(e, t, r, i) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, n.prototype.highlight = function(e, t, r, i) {
      var a = e.getData(i && i.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && Jr("Unknown dataType " + i.dataType);
        return;
      }
      e5(a, i, "emphasis");
    }, n.prototype.downplay = function(e, t, r, i) {
      var a = e.getData(i && i.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && Jr("Unknown dataType " + i.dataType);
        return;
      }
      e5(a, i, "normal");
    }, n.prototype.remove = function(e, t) {
      this.group.removeAll();
    }, n.prototype.dispose = function(e, t) {
    }, n.prototype.updateView = function(e, t, r, i) {
      this.render(e, t, r, i);
    }, n.prototype.updateLayout = function(e, t, r, i) {
      this.render(e, t, r, i);
    }, n.prototype.updateVisual = function(e, t, r, i) {
      this.render(e, t, r, i);
    }, n.prototype.eachRendered = function(e) {
      Yu(this.group, e);
    }, n.markUpdateMethod = function(e, t) {
      yW(e).updateMethod = t;
    }, n.protoInitialize = function() {
      var e = n.prototype;
      e.type = "chart";
    }(), n;
  }()
);
function Qj(n, e, t) {
  n && Ru(n) && (e === "emphasis" ? xl : wl)(n, t);
}
function e5(n, e, t) {
  var r = Id(n, e), i = e && e.highlightKey != null ? sLe(e.highlightKey) : null;
  r != null ? $(wn(r), function(a) {
    Qj(n.getItemGraphicEl(a), t, i);
  }) : n.eachItemGraphicEl(function(a) {
    Qj(a, t, i);
  });
}
ND(Tn, ["dispose"]);
Jx(Tn);
function kRe(n) {
  return CRe(n.model);
}
function ARe(n) {
  var e = n.model, t = n.ecModel, r = n.api, i = n.payload, a = e.pipelineContext.progressiveRender, o = n.view, s = i && yW(i).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render";
  return l !== "render" && o[l](e, t, r, i), MRe[l];
}
var MRe = {
  incrementalPrepareRender: {
    progress: function(n, e) {
      e.view.incrementalRender(n, e.model, e.ecModel, e.api, e.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(n, e) {
      e.view.render(e.model, e.ecModel, e.api, e.payload);
    }
  }
}, l_ = "\0__throttleOriginMethod", t5 = "\0__throttleRate", n5 = "\0__throttleType";
function sO(n, e, t) {
  var r, i = 0, a = 0, o = null, s, l, u, c;
  e = e || 0;
  function d() {
    a = (/* @__PURE__ */ new Date()).getTime(), o = null, n.apply(l, u || []);
  }
  var f = function() {
    for (var p = [], h = 0; h < arguments.length; h++)
      p[h] = arguments[h];
    r = (/* @__PURE__ */ new Date()).getTime(), l = this, u = p;
    var v = c || e, m = c || t;
    c = null, s = r - (m ? i : a) - v, clearTimeout(o), m ? o = setTimeout(d, v) : s >= 0 ? d() : o = setTimeout(d, -s), i = r;
  };
  return f.clear = function() {
    o && (clearTimeout(o), o = null);
  }, f.debounceNextCall = function(p) {
    c = p;
  }, f;
}
function bh(n, e, t, r) {
  var i = n[e];
  if (i) {
    var a = i[l_] || i, o = i[n5], s = i[t5];
    if (s !== t || o !== r) {
      if (t == null || !r)
        return n[e] = a;
      i = n[e] = sO(a, t, r === "debounce"), i[l_] = a, i[n5] = r, i[t5] = t;
    }
    return i;
  }
}
function ag(n, e) {
  var t = n[e];
  t && t[l_] && (t.clear && t.clear(), n[e] = t[l_]);
}
var r5 = en(), i5 = {
  itemStyle: Ld(TU, !0),
  lineStyle: Ld(EU, !0)
}, DRe = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function bW(n, e) {
  var t = n.visualStyleMapper || i5[e];
  return t || (console.warn("Unknown style type '" + e + "'."), i5.itemStyle);
}
function _W(n, e) {
  var t = n.visualDrawType || DRe[e];
  return t || (console.warn("Unknown style type '" + e + "'."), "fill");
}
var ORe = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(n, e) {
    var t = n.getData(), r = n.visualStyleAccessPath || "itemStyle", i = n.getModel(r), a = bW(n, r), o = a(i), s = i.getShallow("decal");
    s && (t.setVisual("decal", s), s.dirty = !0);
    var l = _W(n, r), u = o[l], c = at(u) ? u : null, d = o.fill === "auto" || o.stroke === "auto";
    if (!o[l] || c || d) {
      var f = n.getColorFromPalette(
        // TODO series count changed.
        n.name,
        null,
        e.getSeriesCount()
      );
      o[l] || (o[l] = f, t.setVisual("colorFromPalette", !0)), o.fill = o.fill === "auto" || at(o.fill) ? f : o.fill, o.stroke = o.stroke === "auto" || at(o.stroke) ? f : o.stroke;
    }
    if (t.setVisual("style", o), t.setVisual("drawType", l), !e.isSeriesFiltered(n) && c)
      return t.setVisual("colorFromPalette", !1), {
        dataEach: function(p, h) {
          var v = n.getDataParams(h), m = xe({}, o);
          m[l] = c(v), p.setItemVisual(h, "style", m);
        }
      };
  }
}, rv = new yn(), IRe = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(n, e) {
    if (!(n.ignoreStyleOnData || e.isSeriesFiltered(n))) {
      var t = n.getData(), r = n.visualStyleAccessPath || "itemStyle", i = bW(n, r), a = t.getVisual("drawType");
      return {
        dataEach: t.hasItemOption ? function(o, s) {
          var l = o.getRawDataItem(s);
          if (l && l[r]) {
            rv.option = l[r];
            var u = i(rv), c = o.ensureUniqueItemVisual(s, "style");
            xe(c, u), rv.option.decal && (o.setItemVisual(s, "decal", rv.option.decal), rv.option.decal.dirty = !0), a in u && o.setItemVisual(s, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, LRe = {
  performRawSeries: !0,
  overallReset: function(n) {
    var e = tt();
    n.eachSeries(function(t) {
      var r = t.getColorBy();
      if (!t.isColorBySeries()) {
        var i = t.type + "-" + r, a = e.get(i);
        a || (a = {}, e.set(i, a)), r5(t).scope = a;
      }
    }), n.eachSeries(function(t) {
      if (!(t.isColorBySeries() || n.isSeriesFiltered(t))) {
        var r = t.getRawData(), i = {}, a = t.getData(), o = r5(t).scope, s = t.visualStyleAccessPath || "itemStyle", l = _W(t, s);
        a.each(function(u) {
          var c = a.getRawIndex(u);
          i[c] = u;
        }), r.each(function(u) {
          var c = i[u], d = a.getItemVisual(c, "colorFromPalette");
          if (d) {
            var f = a.ensureUniqueItemVisual(c, "style"), p = r.getName(u) || u + "", h = r.count();
            f[l] = t.getColorFromPalette(p, o, h);
          }
        });
      }
    });
  }
}, x0 = Math.PI;
function NRe(n, e) {
  e = e || {}, dt(e, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: !0,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var t = new mt(), r = new Qt({
    style: {
      fill: e.maskColor
    },
    zlevel: e.zlevel,
    z: 1e4
  });
  t.add(r);
  var i = new nn({
    style: {
      text: e.text,
      fill: e.textColor,
      fontSize: e.fontSize,
      fontWeight: e.fontWeight,
      fontStyle: e.fontStyle,
      fontFamily: e.fontFamily
    },
    zlevel: e.zlevel,
    z: 10001
  }), a = new Qt({
    style: {
      fill: "none"
    },
    textContent: i,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: e.zlevel,
    z: 10001
  });
  t.add(a);
  var o;
  return e.showSpinner && (o = new aw({
    shape: {
      startAngle: -x0 / 2,
      endAngle: -x0 / 2 + 0.1,
      r: e.spinnerRadius
    },
    style: {
      stroke: e.color,
      lineCap: "round",
      lineWidth: e.lineWidth
    },
    zlevel: e.zlevel,
    z: 10001
  }), o.animateShape(!0).when(1e3, {
    endAngle: x0 * 3 / 2
  }).start("circularInOut"), o.animateShape(!0).when(1e3, {
    startAngle: x0 * 3 / 2
  }).delay(300).start("circularInOut"), t.add(o)), t.resize = function() {
    var s = i.getBoundingRect().width, l = e.showSpinner ? e.spinnerRadius : 0, u = (n.getWidth() - l * 2 - (e.showSpinner && s ? 10 : 0) - s) / 2 - (e.showSpinner && s ? 0 : 5 + s / 2) + (e.showSpinner ? 0 : s / 2) + (s ? 0 : l), c = n.getHeight() / 2;
    e.showSpinner && o.setShape({
      cx: u,
      cy: c
    }), a.setShape({
      x: u - l,
      y: c - l,
      width: l * 2,
      height: l * 2
    }), r.setShape({
      x: 0,
      y: 0,
      width: n.getWidth(),
      height: n.getHeight()
    });
  }, t.resize(), t;
}
var xW = (
  /** @class */
  function() {
    function n(e, t, r, i) {
      this._stageTaskMap = tt(), this.ecInstance = e, this.api = t, r = this._dataProcessorHandlers = r.slice(), i = this._visualHandlers = i.slice(), this._allHandlers = r.concat(i);
    }
    return n.prototype.restoreData = function(e, t) {
      e.restoreData(t), this._stageTaskMap.each(function(r) {
        var i = r.overallTask;
        i && i.dirty();
      });
    }, n.prototype.getPerformArgs = function(e, t) {
      if (e.__pipeline) {
        var r = this._pipelineMap.get(e.__pipeline.id), i = r.context, a = !t && r.progressiveEnabled && (!i || i.progressiveRender) && e.__idxInPipeline > r.blockIndex, o = a ? r.step : null, s = i && i.modDataCount, l = s != null ? Math.ceil(s / o) : null;
        return {
          step: o,
          modBy: l,
          modDataCount: s
        };
      }
    }, n.prototype.getPipeline = function(e) {
      return this._pipelineMap.get(e);
    }, n.prototype.updateStreamModes = function(e, t) {
      var r = this._pipelineMap.get(e.uid), i = e.getData(), a = i.count(), o = r.progressiveEnabled && t.incrementalPrepareRender && a >= r.threshold, s = e.get("large") && a >= e.get("largeThreshold"), l = e.get("progressiveChunkMode") === "mod" ? a : null;
      e.pipelineContext = r.context = {
        progressiveRender: o,
        modDataCount: l,
        large: s
      };
    }, n.prototype.restorePipelines = function(e) {
      var t = this, r = t._pipelineMap = tt();
      e.eachSeries(function(i) {
        var a = i.getProgressive(), o = i.uid;
        r.set(o, {
          id: o,
          head: null,
          tail: null,
          threshold: i.getProgressiveThreshold(),
          progressiveEnabled: a && !(i.preventIncremental && i.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), t._pipe(i, i.dataTask);
      });
    }, n.prototype.prepareStageTasks = function() {
      var e = this._stageTaskMap, t = this.api.getModel(), r = this.api;
      $(this._allHandlers, function(i) {
        var a = e.get(i.uid) || e.set(i.uid, {}), o = "";
        process.env.NODE_ENV !== "production" && (o = '"reset" and "overallReset" must not be both specified.'), ct(!(i.reset && i.overallReset), o), i.reset && this._createSeriesStageTask(i, a, t, r), i.overallReset && this._createOverallStageTask(i, a, t, r);
      }, this);
    }, n.prototype.prepareView = function(e, t, r, i) {
      var a = e.renderTask, o = a.context;
      o.model = t, o.ecModel = r, o.api = i, a.__block = !e.incrementalPrepareRender, this._pipe(t, a);
    }, n.prototype.performDataProcessorTasks = function(e, t) {
      this._performStageTasks(this._dataProcessorHandlers, e, t, {
        block: !0
      });
    }, n.prototype.performVisualTasks = function(e, t, r) {
      this._performStageTasks(this._visualHandlers, e, t, r);
    }, n.prototype._performStageTasks = function(e, t, r, i) {
      i = i || {};
      var a = !1, o = this;
      $(e, function(l, u) {
        if (!(i.visualType && i.visualType !== l.visualType)) {
          var c = o._stageTaskMap.get(l.uid), d = c.seriesTaskMap, f = c.overallTask;
          if (f) {
            var p, h = f.agentStubMap;
            h.each(function(m) {
              s(i, m) && (m.dirty(), p = !0);
            }), p && f.dirty(), o.updatePayload(f, r);
            var v = o.getPerformArgs(f, i.block);
            h.each(function(m) {
              m.perform(v);
            }), f.perform(v) && (a = !0);
          } else d && d.each(function(m, g) {
            s(i, m) && m.dirty();
            var y = o.getPerformArgs(m, i.block);
            y.skip = !l.performRawSeries && t.isSeriesFiltered(m.context.model), o.updatePayload(m, r), m.perform(y) && (a = !0);
          });
        }
      });
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, n.prototype.performSeriesTasks = function(e) {
      var t;
      e.eachSeries(function(r) {
        t = r.dataTask.perform() || t;
      }), this.unfinished = t || this.unfinished;
    }, n.prototype.plan = function() {
      this._pipelineMap.each(function(e) {
        var t = e.tail;
        do {
          if (t.__block) {
            e.blockIndex = t.__idxInPipeline;
            break;
          }
          t = t.getUpstream();
        } while (t);
      });
    }, n.prototype.updatePayload = function(e, t) {
      t !== "remain" && (e.context.payload = t);
    }, n.prototype._createSeriesStageTask = function(e, t, r, i) {
      var a = this, o = t.seriesTaskMap, s = t.seriesTaskMap = tt(), l = e.seriesType, u = e.getTargetSeries;
      e.createOnAllSeries ? r.eachRawSeries(c) : l ? r.eachRawSeriesByType(l, c) : u && u(r, i).each(c);
      function c(d) {
        var f = d.uid, p = s.set(f, o && o.get(f) || vm({
          plan: $Re,
          reset: zRe,
          count: VRe
        }));
        p.context = {
          model: d,
          ecModel: r,
          api: i,
          // PENDING: `useClearVisual` not used?
          useClearVisual: e.isVisual && !e.isLayout,
          plan: e.plan,
          reset: e.reset,
          scheduler: a
        }, a._pipe(d, p);
      }
    }, n.prototype._createOverallStageTask = function(e, t, r, i) {
      var a = this, o = t.overallTask = t.overallTask || vm({
        reset: RRe
      });
      o.context = {
        ecModel: r,
        api: i,
        overallReset: e.overallReset,
        scheduler: a
      };
      var s = o.agentStubMap, l = o.agentStubMap = tt(), u = e.seriesType, c = e.getTargetSeries, d = !0, f = !1, p = "";
      process.env.NODE_ENV !== "production" && (p = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), ct(!e.createOnAllSeries, p), u ? r.eachRawSeriesByType(u, h) : c ? c(r, i).each(h) : (d = !1, $(r.getSeries(), h));
      function h(v) {
        var m = v.uid, g = l.set(m, s && s.get(m) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (f = !0, vm({
          reset: PRe,
          onDirty: BRe
        })));
        g.context = {
          model: v,
          overallProgress: d
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, g.agent = o, g.__block = d, a._pipe(v, g);
      }
      f && o.dirty();
    }, n.prototype._pipe = function(e, t) {
      var r = e.uid, i = this._pipelineMap.get(r);
      !i.head && (i.head = t), i.tail && i.tail.pipe(t), i.tail = t, t.__idxInPipeline = i.count++, t.__pipeline = i;
    }, n.wrapStageHandler = function(e, t) {
      return at(e) && (e = {
        overallReset: e,
        seriesType: HRe(e)
      }), e.uid = ph("stageHandler"), t && (e.visualType = t), e;
    }, n;
  }()
);
function RRe(n) {
  n.overallReset(n.ecModel, n.api, n.payload);
}
function PRe(n) {
  return n.overallProgress && jRe;
}
function jRe() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function BRe() {
  this.agent && this.agent.dirty();
}
function $Re(n) {
  return n.plan ? n.plan(n.model, n.ecModel, n.api, n.payload) : null;
}
function zRe(n) {
  n.useClearVisual && n.data.clearAllVisual();
  var e = n.resetDefines = wn(n.reset(n.model, n.ecModel, n.api, n.payload));
  return e.length > 1 ? De(e, function(t, r) {
    return wW(r);
  }) : FRe;
}
var FRe = wW(0);
function wW(n) {
  return function(e, t) {
    var r = t.data, i = t.resetDefines[n];
    if (i && i.dataEach)
      for (var a = e.start; a < e.end; a++)
        i.dataEach(r, a);
    else i && i.progress && i.progress(e, r);
  };
}
function VRe(n) {
  return n.data.count();
}
function HRe(n) {
  u_ = null;
  try {
    n(og, SW);
  } catch {
  }
  return u_;
}
var og = {}, SW = {}, u_;
EW(og, nO);
EW(SW, YU);
og.eachSeriesByType = og.eachRawSeriesByType = function(n) {
  u_ = n;
};
og.eachComponent = function(n) {
  n.mainType === "series" && n.subType && (u_ = n.subType);
};
function EW(n, e) {
  for (var t in e.prototype)
    n[t] = dr;
}
var a5 = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
const GRe = {
  color: a5,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], a5]
};
var oi = "#B9B8CE", o5 = "#100C2A", w0 = function() {
  return {
    axisLine: {
      lineStyle: {
        color: oi
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
}, s5 = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"], TW = {
  darkMode: !0,
  color: s5,
  backgroundColor: o5,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      // TODO Contrast of label backgorundColor
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: oi
    },
    pageTextStyle: {
      color: oi
    }
  },
  textStyle: {
    color: oi
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: oi
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: oi
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: oi
    }
  },
  timeline: {
    lineStyle: {
      color: oi
    },
    label: {
      color: oi
    },
    controlStyle: {
      color: oi,
      borderColor: oi
    }
  },
  calendar: {
    itemStyle: {
      color: o5
    },
    dayLabel: {
      color: oi
    },
    monthLabel: {
      color: oi
    },
    yearLabel: {
      color: oi
    }
  },
  timeAxis: w0(),
  logAxis: w0(),
  valueAxis: w0(),
  categoryAxis: w0(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: s5
  },
  gauge: {
    title: {
      color: oi
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: oi
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  }
};
TW.categoryAxis.splitLine.show = !1;
var URe = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.normalizeQuery = function(e) {
      var t = {}, r = {}, i = {};
      if (We(e)) {
        var a = ls(e);
        t.mainType = a.main || null, t.subType = a.sub || null;
      } else {
        var o = ["Index", "Name", "Id"], s = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        $(e, function(l, u) {
          for (var c = !1, d = 0; d < o.length; d++) {
            var f = o[d], p = u.lastIndexOf(f);
            if (p > 0 && p === u.length - f.length) {
              var h = u.slice(0, p);
              h !== "data" && (t.mainType = h, t[f.toLowerCase()] = l, c = !0);
            }
          }
          s.hasOwnProperty(u) && (r[u] = l, c = !0), c || (i[u] = l);
        });
      }
      return {
        cptQuery: t,
        dataQuery: r,
        otherQuery: i
      };
    }, n.prototype.filter = function(e, t) {
      var r = this.eventInfo;
      if (!r)
        return !0;
      var i = r.targetEl, a = r.packedEvent, o = r.model, s = r.view;
      if (!o || !s)
        return !0;
      var l = t.cptQuery, u = t.dataQuery;
      return c(l, o, "mainType") && c(l, o, "subType") && c(l, o, "index", "componentIndex") && c(l, o, "name") && c(l, o, "id") && c(u, a, "name") && c(u, a, "dataIndex") && c(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(e, t.otherQuery, i, a));
      function c(d, f, p, h) {
        return d[p] == null || f[h || p] === d[p];
      }
    }, n.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, n;
  }()
), Ak = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], l5 = Ak.concat(["symbolKeepAspect"]), WRe = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(n, e) {
    var t = n.getData();
    if (n.legendIcon && t.setVisual("legendIcon", n.legendIcon), !n.hasSymbolVisual)
      return;
    for (var r = {}, i = {}, a = !1, o = 0; o < Ak.length; o++) {
      var s = Ak[o], l = n.get(s);
      at(l) ? (a = !0, i[s] = l) : r[s] = l;
    }
    if (r.symbol = r.symbol || n.defaultSymbol, t.setVisual(xe({
      legendIcon: n.legendIcon || r.symbol,
      symbolKeepAspect: n.get("symbolKeepAspect")
    }, r)), e.isSeriesFiltered(n))
      return;
    var u = Yt(i);
    function c(d, f) {
      for (var p = n.getRawValue(f), h = n.getDataParams(f), v = 0; v < u.length; v++) {
        var m = u[v];
        d.setItemVisual(f, m, i[m](p, h));
      }
    }
    return {
      dataEach: a ? c : null
    };
  }
}, qRe = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(n, e) {
    if (!n.hasSymbolVisual || e.isSeriesFiltered(n))
      return;
    var t = n.getData();
    function r(i, a) {
      for (var o = i.getItemModel(a), s = 0; s < l5.length; s++) {
        var l = l5[s], u = o.getShallow(l, !0);
        u != null && i.setItemVisual(a, l, u);
      }
    }
    return {
      dataEach: t.hasItemOption ? r : null
    };
  }
};
function lO(n, e, t) {
  switch (t) {
    case "color":
      var r = n.getItemVisual(e, "style");
      return r[n.getVisual("drawType")];
    case "opacity":
      return n.getItemVisual(e, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return n.getItemVisual(e, t);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function Yg(n, e) {
  switch (e) {
    case "color":
      var t = n.getVisual("style");
      return t[n.getVisual("drawType")];
    case "opacity":
      return n.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return n.getVisual(e);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + e);
  }
}
function CW(n, e, t, r) {
  switch (t) {
    case "color":
      var i = n.ensureUniqueItemVisual(e, "style");
      i[n.getVisual("drawType")] = r, n.setItemVisual(e, "colorFromPalette", !1);
      break;
    case "opacity":
      n.ensureUniqueItemVisual(e, "style").opacity = r;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      n.setItemVisual(e, t, r);
      break;
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function kW(n, e) {
  function t(r, i) {
    var a = [];
    return r.eachComponent({
      mainType: "series",
      subType: n,
      query: i
    }, function(o) {
      a.push(o.seriesIndex);
    }), a;
  }
  $([[n + "ToggleSelect", "toggleSelect"], [n + "Select", "select"], [n + "UnSelect", "unselect"]], function(r) {
    e(r[0], function(i, a, o) {
      i = xe({}, i), process.env.NODE_ENV !== "production" && vr(i.type, r[1]), o.dispatchAction(xe(i, {
        type: r[1],
        seriesIndex: t(a, i)
      }));
    });
  });
}
function Mf(n, e, t, r, i) {
  var a = n + e;
  t.isSilent(a) || (process.env.NODE_ENV !== "production" && Do("event " + a + " is deprecated."), r.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(o) {
    for (var s = o.seriesIndex, l = o.option.selectedMap, u = i.selected, c = 0; c < u.length; c++)
      if (u[c].seriesIndex === s) {
        var d = o.getData(), f = Id(d, i.fromActionPayload);
        t.trigger(a, {
          type: a,
          seriesId: o.id,
          name: Me(f) ? d.getName(f[0]) : d.getName(f),
          selected: We(l) ? l : xe({}, l)
        });
      }
  }));
}
function YRe(n, e, t) {
  n.on("selectchanged", function(r) {
    var i = t.getModel();
    r.isFromClick ? (Mf("map", "selectchanged", e, i, r), Mf("pie", "selectchanged", e, i, r)) : r.fromAction === "select" ? (Mf("map", "selected", e, i, r), Mf("pie", "selected", e, i, r)) : r.fromAction === "unselect" && (Mf("map", "unselected", e, i, r), Mf("pie", "unselected", e, i, r));
  });
}
function qc(n, e, t) {
  for (var r; n && !(e(n) && (r = n, t)); )
    n = n.__hostTarget || n.parent;
  return r;
}
var KRe = Math.round(Math.random() * 9), XRe = typeof Object.defineProperty == "function", ZRe = function() {
  function n() {
    this._id = "__ec_inner_" + KRe++;
  }
  return n.prototype.get = function(e) {
    return this._guard(e)[this._id];
  }, n.prototype.set = function(e, t) {
    var r = this._guard(e);
    return XRe ? Object.defineProperty(r, this._id, {
      value: t,
      enumerable: !1,
      configurable: !0
    }) : r[this._id] = t, this;
  }, n.prototype.delete = function(e) {
    return this.has(e) ? (delete this._guard(e)[this._id], !0) : !1;
  }, n.prototype.has = function(e) {
    return !!this._guard(e)[this._id];
  }, n.prototype._guard = function(e) {
    if (e !== Object(e))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return e;
  }, n;
}(), JRe = Ht.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(n, e) {
    var t = e.cx, r = e.cy, i = e.width / 2, a = e.height / 2;
    n.moveTo(t, r - a), n.lineTo(t + i, r + a), n.lineTo(t - i, r + a), n.closePath();
  }
}), QRe = Ht.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(n, e) {
    var t = e.cx, r = e.cy, i = e.width / 2, a = e.height / 2;
    n.moveTo(t, r - a), n.lineTo(t + i, r), n.lineTo(t, r + a), n.lineTo(t - i, r), n.closePath();
  }
}), ePe = Ht.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(n, e) {
    var t = e.x, r = e.y, i = e.width / 5 * 3, a = Math.max(i, e.height), o = i / 2, s = o * o / (a - o), l = r - a + o + s, u = Math.asin(s / o), c = Math.cos(u) * o, d = Math.sin(u), f = Math.cos(u), p = o * 0.6, h = o * 0.7;
    n.moveTo(t - c, l + s), n.arc(t, l, o, Math.PI - u, Math.PI * 2 + u), n.bezierCurveTo(t + c - d * p, l + s + f * p, t, r - h, t, r), n.bezierCurveTo(t, r - h, t - c + d * p, l + s + f * p, t - c, l + s), n.closePath();
  }
}), tPe = Ht.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(n, e) {
    var t = e.height, r = e.width, i = e.x, a = e.y, o = r / 3 * 2;
    n.moveTo(i, a), n.lineTo(i + o, a + t), n.lineTo(i, a + t / 4 * 3), n.lineTo(i - o, a + t), n.lineTo(i, a), n.closePath();
  }
}), nPe = {
  line: Dr,
  rect: Qt,
  roundRect: Qt,
  square: Qt,
  circle: Ml,
  diamond: QRe,
  pin: ePe,
  arrow: tPe,
  triangle: JRe
}, rPe = {
  line: function(n, e, t, r, i) {
    i.x1 = n, i.y1 = e + r / 2, i.x2 = n + t, i.y2 = e + r / 2;
  },
  rect: function(n, e, t, r, i) {
    i.x = n, i.y = e, i.width = t, i.height = r;
  },
  roundRect: function(n, e, t, r, i) {
    i.x = n, i.y = e, i.width = t, i.height = r, i.r = Math.min(t, r) / 4;
  },
  square: function(n, e, t, r, i) {
    var a = Math.min(t, r);
    i.x = n, i.y = e, i.width = a, i.height = a;
  },
  circle: function(n, e, t, r, i) {
    i.cx = n + t / 2, i.cy = e + r / 2, i.r = Math.min(t, r) / 2;
  },
  diamond: function(n, e, t, r, i) {
    i.cx = n + t / 2, i.cy = e + r / 2, i.width = t, i.height = r;
  },
  pin: function(n, e, t, r, i) {
    i.x = n + t / 2, i.y = e + r / 2, i.width = t, i.height = r;
  },
  arrow: function(n, e, t, r, i) {
    i.x = n + t / 2, i.y = e + r / 2, i.width = t, i.height = r;
  },
  triangle: function(n, e, t, r, i) {
    i.cx = n + t / 2, i.cy = e + r / 2, i.width = t, i.height = r;
  }
}, c_ = {};
$(nPe, function(n, e) {
  c_[e] = new n();
});
var iPe = Ht.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(n, e, t) {
    var r = Jb(n, e, t), i = this.shape;
    return i && i.symbolType === "pin" && e.position === "inside" && (r.y = t.y + t.height * 0.4), r;
  },
  buildPath: function(n, e, t) {
    var r = e.symbolType;
    if (r !== "none") {
      var i = c_[r];
      i || (r = "rect", i = c_[r]), rPe[r](e.x, e.y, e.width, e.height, i.shape), i.buildPath(n, i.shape, t);
    }
  }
});
function aPe(n, e) {
  if (this.type !== "image") {
    var t = this.style;
    this.__isEmptyBrush ? (t.stroke = n, t.fill = e || "#fff", t.lineWidth = 2) : this.shape.symbolType === "line" ? t.stroke = n : t.fill = n, this.markRedraw();
  }
}
function yr(n, e, t, r, i, a, o) {
  var s = n.indexOf("empty") === 0;
  s && (n = n.substr(5, 1).toLowerCase() + n.substr(6));
  var l;
  return n.indexOf("image://") === 0 ? l = mU(n.slice(8), new Ot(e, t, r, i), o ? "center" : "cover") : n.indexOf("path://") === 0 ? l = ow(n.slice(7), {}, new Ot(e, t, r, i), o ? "center" : "cover") : l = new iPe({
    shape: {
      symbolType: n,
      x: e,
      y: t,
      width: r,
      height: i
    }
  }), l.__isEmptyBrush = s, l.setColor = aPe, a && l.setColor(a), l;
}
function _h(n) {
  return Me(n) || (n = [+n, +n]), [n[0] || 0, n[1] || 0];
}
function ef(n, e) {
  if (n != null)
    return Me(n) || (n = [n, n]), [ze(n[0], e[0]) || 0, ze(bt(n[1], n[0]), e[1]) || 0];
}
function Yc(n) {
  return isFinite(n);
}
function oPe(n, e, t) {
  var r = e.x == null ? 0 : e.x, i = e.x2 == null ? 1 : e.x2, a = e.y == null ? 0 : e.y, o = e.y2 == null ? 0 : e.y2;
  e.global || (r = r * t.width + t.x, i = i * t.width + t.x, a = a * t.height + t.y, o = o * t.height + t.y), r = Yc(r) ? r : 0, i = Yc(i) ? i : 1, a = Yc(a) ? a : 0, o = Yc(o) ? o : 0;
  var s = n.createLinearGradient(r, a, i, o);
  return s;
}
function sPe(n, e, t) {
  var r = t.width, i = t.height, a = Math.min(r, i), o = e.x == null ? 0.5 : e.x, s = e.y == null ? 0.5 : e.y, l = e.r == null ? 0.5 : e.r;
  e.global || (o = o * r + t.x, s = s * i + t.y, l = l * a), o = Yc(o) ? o : 0.5, s = Yc(s) ? s : 0.5, l = l >= 0 && Yc(l) ? l : 0.5;
  var u = n.createRadialGradient(o, s, 0, o, s, l);
  return u;
}
function Mk(n, e, t) {
  for (var r = e.type === "radial" ? sPe(n, e, t) : oPe(n, e, t), i = e.colorStops, a = 0; a < i.length; a++)
    r.addColorStop(i[a].offset, i[a].color);
  return r;
}
function lPe(n, e) {
  if (n === e || !n && !e)
    return !1;
  if (!n || !e || n.length !== e.length)
    return !0;
  for (var t = 0; t < n.length; t++)
    if (n[t] !== e[t])
      return !0;
  return !1;
}
function S0(n) {
  return parseInt(n, 10);
}
function cp(n, e, t) {
  var r = ["width", "height"][e], i = ["clientWidth", "clientHeight"][e], a = ["paddingLeft", "paddingTop"][e], o = ["paddingRight", "paddingBottom"][e];
  if (t[r] != null && t[r] !== "auto")
    return parseFloat(t[r]);
  var s = document.defaultView.getComputedStyle(n);
  return (n[i] || S0(s[r]) || S0(n.style[r])) - (S0(s[a]) || 0) - (S0(s[o]) || 0) | 0;
}
function uPe(n, e) {
  return !n || n === "solid" || !(e > 0) ? null : n === "dashed" ? [4 * e, 2 * e] : n === "dotted" ? [e] : sn(n) ? [n] : Me(n) ? n : null;
}
function uO(n) {
  var e = n.style, t = e.lineDash && e.lineWidth > 0 && uPe(e.lineDash, e.lineWidth), r = e.lineDashOffset;
  if (t) {
    var i = e.strokeNoScale && n.getLineScale ? n.getLineScale() : 1;
    i && i !== 1 && (t = De(t, function(a) {
      return a / i;
    }), r /= i);
  }
  return [t, r];
}
var cPe = new Ts(!0);
function d_(n) {
  var e = n.stroke;
  return !(e == null || e === "none" || !(n.lineWidth > 0));
}
function u5(n) {
  return typeof n == "string" && n !== "none";
}
function f_(n) {
  var e = n.fill;
  return e != null && e !== "none";
}
function c5(n, e) {
  if (e.fillOpacity != null && e.fillOpacity !== 1) {
    var t = n.globalAlpha;
    n.globalAlpha = e.fillOpacity * e.opacity, n.fill(), n.globalAlpha = t;
  } else
    n.fill();
}
function d5(n, e) {
  if (e.strokeOpacity != null && e.strokeOpacity !== 1) {
    var t = n.globalAlpha;
    n.globalAlpha = e.strokeOpacity * e.opacity, n.stroke(), n.globalAlpha = t;
  } else
    n.stroke();
}
function Dk(n, e, t) {
  var r = RD(e.image, e.__image, t);
  if (Qx(r)) {
    var i = n.createPattern(r, e.repeat || "repeat");
    if (typeof DOMMatrix == "function" && i && i.setTransform) {
      var a = new DOMMatrix();
      a.translateSelf(e.x || 0, e.y || 0), a.rotateSelf(0, 0, (e.rotation || 0) * g1), a.scaleSelf(e.scaleX || 1, e.scaleY || 1), i.setTransform(a);
    }
    return i;
  }
}
function dPe(n, e, t, r) {
  var i, a = d_(t), o = f_(t), s = t.strokePercent, l = s < 1, u = !e.path;
  (!e.silent || l) && u && e.createPathProxy();
  var c = e.path || cPe, d = e.__dirty;
  if (!r) {
    var f = t.fill, p = t.stroke, h = o && !!f.colorStops, v = a && !!p.colorStops, m = o && !!f.image, g = a && !!p.image, y = void 0, b = void 0, _ = void 0, x = void 0, w = void 0;
    (h || v) && (w = e.getBoundingRect()), h && (y = d ? Mk(n, f, w) : e.__canvasFillGradient, e.__canvasFillGradient = y), v && (b = d ? Mk(n, p, w) : e.__canvasStrokeGradient, e.__canvasStrokeGradient = b), m && (_ = d || !e.__canvasFillPattern ? Dk(n, f, e) : e.__canvasFillPattern, e.__canvasFillPattern = _), g && (x = d || !e.__canvasStrokePattern ? Dk(n, p, e) : e.__canvasStrokePattern, e.__canvasStrokePattern = _), h ? n.fillStyle = y : m && (_ ? n.fillStyle = _ : o = !1), v ? n.strokeStyle = b : g && (x ? n.strokeStyle = x : a = !1);
  }
  var S = e.getGlobalScale();
  c.setScale(S[0], S[1], e.segmentIgnoreThreshold);
  var C, k;
  n.setLineDash && t.lineDash && (i = uO(e), C = i[0], k = i[1]);
  var M = !0;
  (u || d & Jf) && (c.setDPR(n.dpr), l ? c.setContext(null) : (c.setContext(n), M = !1), c.reset(), e.buildPath(c, e.shape, r), c.toStatic(), e.pathUpdated()), M && c.rebuildPath(n, l ? s : 1), C && (n.setLineDash(C), n.lineDashOffset = k), r || (t.strokeFirst ? (a && d5(n, t), o && c5(n, t)) : (o && c5(n, t), a && d5(n, t))), C && n.setLineDash([]);
}
function fPe(n, e, t) {
  var r = e.__image = RD(t.image, e.__image, e, e.onload);
  if (!(!r || !Qx(r))) {
    var i = t.x || 0, a = t.y || 0, o = e.getWidth(), s = e.getHeight(), l = r.width / r.height;
    if (o == null && s != null ? o = s * l : s == null && o != null ? s = o / l : o == null && s == null && (o = r.width, s = r.height), t.sWidth && t.sHeight) {
      var u = t.sx || 0, c = t.sy || 0;
      n.drawImage(r, u, c, t.sWidth, t.sHeight, i, a, o, s);
    } else if (t.sx && t.sy) {
      var u = t.sx, c = t.sy, d = o - u, f = s - c;
      n.drawImage(r, u, c, d, f, i, a, o, s);
    } else
      n.drawImage(r, i, a, o, s);
  }
}
function pPe(n, e, t) {
  var r, i = t.text;
  if (i != null && (i += ""), i) {
    n.font = t.font || Iu, n.textAlign = t.textAlign, n.textBaseline = t.textBaseline;
    var a = void 0, o = void 0;
    n.setLineDash && t.lineDash && (r = uO(e), a = r[0], o = r[1]), a && (n.setLineDash(a), n.lineDashOffset = o), t.strokeFirst ? (d_(t) && n.strokeText(i, t.x, t.y), f_(t) && n.fillText(i, t.x, t.y)) : (f_(t) && n.fillText(i, t.x, t.y), d_(t) && n.strokeText(i, t.x, t.y)), a && n.setLineDash([]);
  }
}
var f5 = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], p5 = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function AW(n, e, t, r, i) {
  var a = !1;
  if (!r && (t = t || {}, e === t))
    return !1;
  if (r || e.opacity !== t.opacity) {
    Ki(n, i), a = !0;
    var o = Math.max(Math.min(e.opacity, 1), 0);
    n.globalAlpha = isNaN(o) ? fd.opacity : o;
  }
  (r || e.blend !== t.blend) && (a || (Ki(n, i), a = !0), n.globalCompositeOperation = e.blend || fd.blend);
  for (var s = 0; s < f5.length; s++) {
    var l = f5[s];
    (r || e[l] !== t[l]) && (a || (Ki(n, i), a = !0), n[l] = n.dpr * (e[l] || 0));
  }
  return (r || e.shadowColor !== t.shadowColor) && (a || (Ki(n, i), a = !0), n.shadowColor = e.shadowColor || fd.shadowColor), a;
}
function h5(n, e, t, r, i) {
  var a = sg(e, i.inHover), o = r ? null : t && sg(t, i.inHover) || {};
  if (a === o)
    return !1;
  var s = AW(n, a, o, r, i);
  if ((r || a.fill !== o.fill) && (s || (Ki(n, i), s = !0), u5(a.fill) && (n.fillStyle = a.fill)), (r || a.stroke !== o.stroke) && (s || (Ki(n, i), s = !0), u5(a.stroke) && (n.strokeStyle = a.stroke)), (r || a.opacity !== o.opacity) && (s || (Ki(n, i), s = !0), n.globalAlpha = a.opacity == null ? 1 : a.opacity), e.hasStroke()) {
    var l = a.lineWidth, u = l / (a.strokeNoScale && e.getLineScale ? e.getLineScale() : 1);
    n.lineWidth !== u && (s || (Ki(n, i), s = !0), n.lineWidth = u);
  }
  for (var c = 0; c < p5.length; c++) {
    var d = p5[c], f = d[0];
    (r || a[f] !== o[f]) && (s || (Ki(n, i), s = !0), n[f] = a[f] || d[1]);
  }
  return s;
}
function hPe(n, e, t, r, i) {
  return AW(n, sg(e, i.inHover), t && sg(t, i.inHover), r, i);
}
function MW(n, e) {
  var t = e.transform, r = n.dpr || 1;
  t ? n.setTransform(r * t[0], r * t[1], r * t[2], r * t[3], r * t[4], r * t[5]) : n.setTransform(r, 0, 0, r, 0, 0);
}
function vPe(n, e, t) {
  for (var r = !1, i = 0; i < n.length; i++) {
    var a = n[i];
    r = r || a.isZeroArea(), MW(e, a), e.beginPath(), a.buildPath(e, a.shape), e.clip();
  }
  t.allClipped = r;
}
function mPe(n, e) {
  return n && e ? n[0] !== e[0] || n[1] !== e[1] || n[2] !== e[2] || n[3] !== e[3] || n[4] !== e[4] || n[5] !== e[5] : !(!n && !e);
}
var v5 = 1, m5 = 2, g5 = 3, y5 = 4;
function gPe(n) {
  var e = f_(n), t = d_(n);
  return !(n.lineDash || !(+e ^ +t) || e && typeof n.fill != "string" || t && typeof n.stroke != "string" || n.strokePercent < 1 || n.strokeOpacity < 1 || n.fillOpacity < 1);
}
function Ki(n, e) {
  e.batchFill && n.fill(), e.batchStroke && n.stroke(), e.batchFill = "", e.batchStroke = "";
}
function sg(n, e) {
  return e && n.__hoverStyle || n.style;
}
function DW(n, e) {
  Kc(n, e, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function Kc(n, e, t, r) {
  var i = e.transform;
  if (!e.shouldBePainted(t.viewWidth, t.viewHeight, !1, !1)) {
    e.__dirty &= ~pa, e.__isRendered = !1;
    return;
  }
  var a = e.__clipPaths, o = t.prevElClipPaths, s = !1, l = !1;
  if ((!o || lPe(a, o)) && (o && o.length && (Ki(n, t), n.restore(), l = s = !0, t.prevElClipPaths = null, t.allClipped = !1, t.prevEl = null), a && a.length && (Ki(n, t), n.save(), vPe(a, n, t), s = !0), t.prevElClipPaths = a), t.allClipped) {
    e.__isRendered = !1;
    return;
  }
  e.beforeBrush && e.beforeBrush(), e.innerBeforeBrush();
  var u = t.prevEl;
  u || (l = s = !0);
  var c = e instanceof Ht && e.autoBatch && gPe(e.style);
  s || mPe(i, u.transform) ? (Ki(n, t), MW(n, e)) : c || Ki(n, t);
  var d = sg(e, t.inHover);
  e instanceof Ht ? (t.lastDrawType !== v5 && (l = !0, t.lastDrawType = v5), h5(n, e, u, l, t), (!c || !t.batchFill && !t.batchStroke) && n.beginPath(), dPe(n, e, d, c), c && (t.batchFill = d.fill || "", t.batchStroke = d.stroke || "")) : e instanceof zp ? (t.lastDrawType !== g5 && (l = !0, t.lastDrawType = g5), h5(n, e, u, l, t), pPe(n, e, d)) : e instanceof Ur ? (t.lastDrawType !== m5 && (l = !0, t.lastDrawType = m5), hPe(n, e, u, l, t), fPe(n, e, d)) : e.getTemporalDisplayables && (t.lastDrawType !== y5 && (l = !0, t.lastDrawType = y5), yPe(n, e, t)), c && r && Ki(n, t), e.innerAfterBrush(), e.afterBrush && e.afterBrush(), t.prevEl = e, e.__dirty = 0, e.__isRendered = !0;
}
function yPe(n, e, t) {
  var r = e.getDisplayables(), i = e.getTemporalDisplayables();
  n.save();
  var a = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: t.viewWidth,
    viewHeight: t.viewHeight,
    inHover: t.inHover
  }, o, s;
  for (o = e.getCursor(), s = r.length; o < s; o++) {
    var l = r[o];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Kc(n, l, a, o === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  for (var u = 0, c = i.length; u < c; u++) {
    var l = i[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Kc(n, l, a, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  e.clearTemporalDisplayables(), e.notClear = !0, n.restore();
}
var $2 = new ZRe(), b5 = new $g(100), _5 = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function Hp(n, e) {
  if (n === "none")
    return null;
  var t = e.getDevicePixelRatio(), r = e.getZr(), i = r.painter.type === "svg";
  n.dirty && $2.delete(n);
  var a = $2.get(n);
  if (a)
    return a;
  var o = dt(n, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  o.backgroundColor === "none" && (o.backgroundColor = null);
  var s = {
    repeat: "repeat"
  };
  return l(s), s.rotation = o.rotation, s.scaleX = s.scaleY = i ? 1 : 1 / t, $2.set(n, s), n.dirty = !1, s;
  function l(u) {
    for (var c = [t], d = !0, f = 0; f < _5.length; ++f) {
      var p = o[_5[f]];
      if (p != null && !Me(p) && !We(p) && !sn(p) && typeof p != "boolean") {
        d = !1;
        break;
      }
      c.push(p);
    }
    var h;
    if (d) {
      h = c.join(",") + (i ? "-svg" : "");
      var v = b5.get(h);
      v && (i ? u.svgElement = v : u.image = v);
    }
    var m = IW(o.dashArrayX), g = bPe(o.dashArrayY), y = OW(o.symbol), b = _Pe(m), _ = LW(g), x = !i && Lu.createCanvas(), w = i && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, S = k(), C;
    x && (x.width = S.width * t, x.height = S.height * t, C = x.getContext("2d")), M(), d && b5.put(h, x || w), u.image = x, u.svgElement = w, u.svgWidth = S.width, u.svgHeight = S.height;
    function k() {
      for (var D = 1, N = 0, R = b.length; N < R; ++N)
        D = N3(D, b[N]);
      for (var j = 1, N = 0, R = y.length; N < R; ++N)
        j = N3(j, y[N].length);
      D *= j;
      var z = _ * b.length * y.length;
      if (process.env.NODE_ENV !== "production") {
        var F = function(B) {
          console.warn("Calculated decal size is greater than " + B + " due to decal option settings so " + B + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + B + " to be larger to avoid incontinuity.");
        };
        D > o.maxTileWidth && F("maxTileWidth"), z > o.maxTileHeight && F("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(D, o.maxTileWidth)),
        height: Math.max(1, Math.min(z, o.maxTileHeight))
      };
    }
    function M() {
      C && (C.clearRect(0, 0, x.width, x.height), o.backgroundColor && (C.fillStyle = o.backgroundColor, C.fillRect(0, 0, x.width, x.height)));
      for (var D = 0, N = 0; N < g.length; ++N)
        D += g[N];
      if (D <= 0)
        return;
      for (var R = -_, j = 0, z = 0, F = 0; R < S.height; ) {
        if (j % 2 === 0) {
          for (var B = z / 2 % y.length, H = 0, Y = 0, ne = 0; H < S.width * 2; ) {
            for (var J = 0, N = 0; N < m[F].length; ++N)
              J += m[F][N];
            if (J <= 0)
              break;
            if (Y % 2 === 0) {
              var X = (1 - o.symbolSize) * 0.5, ie = H + m[F][Y] * X, ye = R + g[j] * X, pe = m[F][Y] * o.symbolSize, Be = g[j] * o.symbolSize, Ce = ne / 2 % y[B].length;
              Ee(ie, ye, pe, Be, y[B][Ce]);
            }
            H += m[F][Y], ++ne, ++Y, Y === m[F].length && (Y = 0);
          }
          ++F, F === m.length && (F = 0);
        }
        R += g[j], ++z, ++j, j === g.length && (j = 0);
      }
      function Ee(ce, Pe, Ae, fe, oe) {
        var he = i ? 1 : t, Oe = yr(oe, ce * he, Pe * he, Ae * he, fe * he, o.color, o.symbolKeepAspect);
        if (i) {
          var Te = r.painter.renderOneToVNode(Oe);
          Te && w.children.push(Te);
        } else
          DW(C, Oe);
      }
    }
  }
}
function OW(n) {
  if (!n || n.length === 0)
    return [["rect"]];
  if (We(n))
    return [[n]];
  for (var e = !0, t = 0; t < n.length; ++t)
    if (!We(n[t])) {
      e = !1;
      break;
    }
  if (e)
    return OW([n]);
  for (var r = [], t = 0; t < n.length; ++t)
    We(n[t]) ? r.push([n[t]]) : r.push(n[t]);
  return r;
}
function IW(n) {
  if (!n || n.length === 0)
    return [[0, 0]];
  if (sn(n)) {
    var e = Math.ceil(n);
    return [[e, e]];
  }
  for (var t = !0, r = 0; r < n.length; ++r)
    if (!sn(n[r])) {
      t = !1;
      break;
    }
  if (t)
    return IW([n]);
  for (var i = [], r = 0; r < n.length; ++r)
    if (sn(n[r])) {
      var e = Math.ceil(n[r]);
      i.push([e, e]);
    } else {
      var e = De(n[r], function(s) {
        return Math.ceil(s);
      });
      e.length % 2 === 1 ? i.push(e.concat(e)) : i.push(e);
    }
  return i;
}
function bPe(n) {
  if (!n || typeof n == "object" && n.length === 0)
    return [0, 0];
  if (sn(n)) {
    var e = Math.ceil(n);
    return [e, e];
  }
  var t = De(n, function(r) {
    return Math.ceil(r);
  });
  return n.length % 2 ? t.concat(t) : t;
}
function _Pe(n) {
  return De(n, function(e) {
    return LW(e);
  });
}
function LW(n) {
  for (var e = 0, t = 0; t < n.length; ++t)
    e += n[t];
  return n.length % 2 === 1 ? e * 2 : e;
}
function xPe(n, e) {
  n.eachRawSeries(function(t) {
    if (!n.isSeriesFiltered(t)) {
      var r = t.getData();
      r.hasItemVisual() && r.each(function(o) {
        var s = r.getItemVisual(o, "decal");
        if (s) {
          var l = r.ensureUniqueItemVisual(o, "style");
          l.decal = Hp(s, e);
        }
      });
      var i = r.getVisual("decal");
      if (i) {
        var a = r.getVisual("style");
        a.decal = Hp(i, e);
      }
    }
  });
}
var vo = new io(), p_ = {};
function wPe(n, e) {
  process.env.NODE_ENV !== "production" && p_[n] && Jr("Already has an implementation of " + n + "."), p_[n] = e;
}
function SPe(n) {
  return process.env.NODE_ENV !== "production" && (p_[n] || Jr("Implementation of " + n + " doesn't exists.")), p_[n];
}
var EPe = 1, TPe = 800, CPe = 900, kPe = 1e3, APe = 2e3, MPe = 5e3, NW = 1e3, DPe = 1100, cO = 2e3, RW = 3e3, OPe = 4e3, yw = 4500, IPe = 4600, LPe = 5e3, NPe = 6e3, PW = 7e3, RPe = {
  PROCESSOR: {
    FILTER: kPe,
    SERIES_FILTER: TPe,
    STATISTIC: MPe
  },
  VISUAL: {
    LAYOUT: NW,
    PROGRESSIVE_LAYOUT: DPe,
    GLOBAL: cO,
    CHART: RW,
    POST_CHART_LAYOUT: IPe,
    COMPONENT: OPe,
    BRUSH: LPe,
    CHART_ITEM: yw,
    ARIA: NPe,
    DECAL: PW
  }
}, ai = "__flagInMainProcess", Ui = "__pendingUpdate", z2 = "__needsUpdateStatus", x5 = /^[a-zA-Z0-9_]+$/, F2 = "__connectUpdateStatus", w5 = 0, PPe = 1, jPe = 2;
function jW(n) {
  return function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    if (this.isDisposed()) {
      sa(this.id);
      return;
    }
    return $W(this, n, e);
  };
}
function BW(n) {
  return function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return $W(this, n, e);
  };
}
function $W(n, e, t) {
  return t[0] = t[0] && t[0].toLowerCase(), io.prototype[e].apply(n, t);
}
var zW = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e;
  }(io)
), FW = zW.prototype;
FW.on = BW("on");
FW.off = BW("off");
var Df, V2, E0, Vl, H2, G2, U2, iv, av, S5, E5, W2, T5, T0, C5, VW, Da, k5, HW = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i) {
      var a = n.call(this, new URe()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], i = i || {}, We(r) && (r = GW[r]), a._dom = t;
      var o = "canvas", s = "auto", l = !1;
      if (process.env.NODE_ENV !== "production") {
        var u = (
          /* eslint-disable-next-line */
          Vt.hasGlobalWindow ? window : global
        );
        u && (o = bt(u.__ECHARTS__DEFAULT__RENDERER__, o), s = bt(u.__ECHARTS__DEFAULT__COARSE_POINTER, s), l = bt(u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, l));
      }
      i.ssr && AOe(function(p) {
        var h = yt(p), v = h.dataIndex;
        if (v != null) {
          var m = tt();
          return m.set("series_index", h.seriesIndex), m.set("data_index", v), h.ssrType && m.set("ssr_type", h.ssrType), m;
        }
      });
      var c = a._zr = D3(t, {
        renderer: i.renderer || o,
        devicePixelRatio: i.devicePixelRatio,
        width: i.width,
        height: i.height,
        ssr: i.ssr,
        useDirtyRect: bt(i.useDirtyRect, l),
        useCoarsePointer: bt(i.useCoarsePointer, s),
        pointerSize: i.pointerSize
      });
      a._ssr = i.ssr, a._throttledZrFlush = sO(Ze(c.flush, c), 17), r = ht(r), r && XU(r, !0), a._theme = r, a._locale = eNe(i.locale || CU), a._coordSysMgr = new gh();
      var d = a._api = C5(a);
      function f(p, h) {
        return p.__prio - h.__prio;
      }
      return _1(v_, f), _1(Ok, f), a._scheduler = new xW(a, d, Ok, v_), a._messageCenter = new zW(), a._initEvents(), a.resize = Ze(a.resize, a), c.animation.on("frame", a._onframe, a), S5(c, a), E5(c, a), Gb(a), a;
    }
    return e.prototype._onframe = function() {
      if (!this._disposed) {
        k5(this);
        var t = this._scheduler;
        if (this[Ui]) {
          var r = this[Ui].silent;
          this[ai] = !0;
          try {
            Df(this), Vl.update.call(this, null, this[Ui].updateParams);
          } catch (l) {
            throw this[ai] = !1, this[Ui] = null, l;
          }
          this._zr.flush(), this[ai] = !1, this[Ui] = null, iv.call(this, r), av.call(this, r);
        } else if (t.unfinished) {
          var i = EPe, a = this._model, o = this._api;
          t.unfinished = !1;
          do {
            var s = +/* @__PURE__ */ new Date();
            t.performSeriesTasks(a), t.performDataProcessorTasks(a), G2(this, a), t.performVisualTasks(a), T0(this, this._model, o, "remain", {}), i -= +/* @__PURE__ */ new Date() - s;
          } while (i > 0 && t.unfinished);
          t.unfinished || this._zr.flush();
        }
      }
    }, e.prototype.getDom = function() {
      return this._dom;
    }, e.prototype.getId = function() {
      return this.id;
    }, e.prototype.getZr = function() {
      return this._zr;
    }, e.prototype.isSSR = function() {
      return this._ssr;
    }, e.prototype.setOption = function(t, r, i) {
      if (this[ai]) {
        process.env.NODE_ENV !== "production" && Jr("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        sa(this.id);
        return;
      }
      var a, o, s;
      if (ut(r) && (i = r.lazyUpdate, a = r.silent, o = r.replaceMerge, s = r.transition, r = r.notMerge), this[ai] = !0, !this._model || r) {
        var l = new kNe(this._api), u = this._theme, c = this._model = new nO();
        c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
      }
      this._model.setOption(t, {
        replaceMerge: o
      }, Ik);
      var d = {
        seriesTransition: s,
        optionChanged: !0
      };
      if (i)
        this[Ui] = {
          silent: a,
          updateParams: d
        }, this[ai] = !1, this.getZr().wakeUp();
      else {
        try {
          Df(this), Vl.update.call(this, null, d);
        } catch (f) {
          throw this[Ui] = null, this[ai] = !1, f;
        }
        this._ssr || this._zr.flush(), this[Ui] = null, this[ai] = !1, iv.call(this, a), av.call(this, a);
      }
    }, e.prototype.setTheme = function() {
      Do("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
    }, e.prototype.getModel = function() {
      return this._model;
    }, e.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, e.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, e.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, e.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || Vt.hasGlobalWindow && window.devicePixelRatio || 1;
    }, e.prototype.getRenderedCanvas = function(t) {
      return process.env.NODE_ENV !== "production" && vr("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(t);
    }, e.prototype.renderToCanvas = function(t) {
      t = t || {};
      var r = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && r.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return r.getRenderedCanvas({
        backgroundColor: t.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: t.pixelRatio || this.getDevicePixelRatio()
      });
    }, e.prototype.renderToSVGString = function(t) {
      t = t || {};
      var r = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && r.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return r.renderToString({
        useViewBox: t.useViewBox
      });
    }, e.prototype.getSvgDataURL = function() {
      if (Vt.svgSupported) {
        var t = this._zr, r = t.storage.getDisplayList();
        return $(r, function(i) {
          i.stopAnimation(null, !0);
        }), t.painter.toDataURL();
      }
    }, e.prototype.getDataURL = function(t) {
      if (this._disposed) {
        sa(this.id);
        return;
      }
      t = t || {};
      var r = t.excludeComponents, i = this._model, a = [], o = this;
      $(r, function(l) {
        i.eachComponent({
          mainType: l
        }, function(u) {
          var c = o._componentsMap[u.__viewId];
          c.group.ignore || (a.push(c), c.group.ignore = !0);
        });
      });
      var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(t).toDataURL("image/" + (t && t.type || "png"));
      return $(a, function(l) {
        l.group.ignore = !1;
      }), s;
    }, e.prototype.getConnectedDataURL = function(t) {
      if (this._disposed) {
        sa(this.id);
        return;
      }
      var r = t.type === "svg", i = this.group, a = Math.min, o = Math.max, s = 1 / 0;
      if (A5[i]) {
        var l = s, u = s, c = -s, d = -s, f = [], p = t && t.pixelRatio || this.getDevicePixelRatio();
        $(gm, function(b, _) {
          if (b.group === i) {
            var x = r ? b.getZr().painter.getSvgDom().innerHTML : b.renderToCanvas(ht(t)), w = b.getDom().getBoundingClientRect();
            l = a(w.left, l), u = a(w.top, u), c = o(w.right, c), d = o(w.bottom, d), f.push({
              dom: x,
              left: w.left,
              top: w.top
            });
          }
        }), l *= p, u *= p, c *= p, d *= p;
        var h = c - l, v = d - u, m = Lu.createCanvas(), g = D3(m, {
          renderer: r ? "svg" : "canvas"
        });
        if (g.resize({
          width: h,
          height: v
        }), r) {
          var y = "";
          return $(f, function(b) {
            var _ = b.left - l, x = b.top - u;
            y += '<g transform="translate(' + _ + "," + x + ')">' + b.dom + "</g>";
          }), g.painter.getSvgRoot().innerHTML = y, t.connectedBackgroundColor && g.painter.setBackgroundColor(t.connectedBackgroundColor), g.refreshImmediately(), g.painter.toDataURL();
        } else
          return t.connectedBackgroundColor && g.add(new Qt({
            shape: {
              x: 0,
              y: 0,
              width: h,
              height: v
            },
            style: {
              fill: t.connectedBackgroundColor
            }
          })), $(f, function(b) {
            var _ = new Ur({
              style: {
                x: b.left * p - l,
                y: b.top * p - u,
                image: b.dom
              }
            });
            g.add(_);
          }), g.refreshImmediately(), m.toDataURL("image/" + (t && t.type || "png"));
      } else
        return this.getDataURL(t);
    }, e.prototype.convertToPixel = function(t, r) {
      return H2(this, "convertToPixel", t, r);
    }, e.prototype.convertFromPixel = function(t, r) {
      return H2(this, "convertFromPixel", t, r);
    }, e.prototype.containPixel = function(t, r) {
      if (this._disposed) {
        sa(this.id);
        return;
      }
      var i = this._model, a, o = cm(i, t);
      return $(o, function(s, l) {
        l.indexOf("Models") >= 0 && $(s, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint)
            a = a || !!c.containPoint(r);
          else if (l === "seriesModels") {
            var d = this._chartsMap[u.__viewId];
            d && d.containPoint ? a = a || d.containPoint(r, u) : process.env.NODE_ENV !== "production" && Jn(l + ": " + (d ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            process.env.NODE_ENV !== "production" && Jn(l + ": containPoint is not supported");
        }, this);
      }, this), !!a;
    }, e.prototype.getVisual = function(t, r) {
      var i = this._model, a = cm(i, t, {
        defaultMainType: "series"
      }), o = a.seriesModel;
      process.env.NODE_ENV !== "production" && (o || Jn("There is no specified series model"));
      var s = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? lO(s, l, r) : Yg(s, r);
    }, e.prototype.getViewOfComponentModel = function(t) {
      return this._componentsMap[t.__viewId];
    }, e.prototype.getViewOfSeriesModel = function(t) {
      return this._chartsMap[t.__viewId];
    }, e.prototype._initEvents = function() {
      var t = this;
      $(BPe, function(r) {
        var i = function(a) {
          var o = t.getModel(), s = a.target, l, u = r === "globalout";
          if (u ? l = {} : s && qc(s, function(h) {
            var v = yt(h);
            if (v && v.dataIndex != null) {
              var m = v.dataModel || o.getSeriesByIndex(v.seriesIndex);
              return l = m && m.getDataParams(v.dataIndex, v.dataType, s) || {}, !0;
            } else if (v.eventData)
              return l = xe({}, v.eventData), !0;
          }, !0), l) {
            var c = l.componentType, d = l.componentIndex;
            (c === "markLine" || c === "markPoint" || c === "markArea") && (c = "series", d = l.seriesIndex);
            var f = c && d != null && o.getComponent(c, d), p = f && t[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
            process.env.NODE_ENV !== "production" && !u && !(f && p) && Jn("model or view can not be found by params"), l.event = a, l.type = r, t._$eventProcessor.eventInfo = {
              targetEl: s,
              packedEvent: l,
              model: f,
              view: p
            }, t.trigger(r, l);
          }
        };
        i.zrEventfulCallAtLast = !0, t._zr.on(r, i, t);
      }), $(mm, function(r, i) {
        t._messageCenter.on(i, function(a) {
          this.trigger(i, a);
        }, t);
      }), $(["selectchanged"], function(r) {
        t._messageCenter.on(r, function(i) {
          this.trigger(r, i);
        }, t);
      }), YRe(this._messageCenter, this, this._api);
    }, e.prototype.isDisposed = function() {
      return this._disposed;
    }, e.prototype.clear = function() {
      if (this._disposed) {
        sa(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, e.prototype.dispose = function() {
      if (this._disposed) {
        sa(this.id);
        return;
      }
      this._disposed = !0;
      var t = this.getDom();
      t && BG(this.getDom(), fO, "");
      var r = this, i = r._api, a = r._model;
      $(r._componentsViews, function(o) {
        o.dispose(a, i);
      }), $(r._chartsViews, function(o) {
        o.dispose(a, i);
      }), r._zr.dispose(), r._dom = r._model = r._chartsMap = r._componentsMap = r._chartsViews = r._componentsViews = r._scheduler = r._api = r._zr = r._throttledZrFlush = r._theme = r._coordSysMgr = r._messageCenter = null, delete gm[r.id];
    }, e.prototype.resize = function(t) {
      if (this[ai]) {
        process.env.NODE_ENV !== "production" && Jr("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        sa(this.id);
        return;
      }
      this._zr.resize(t);
      var r = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!r) {
        var i = r.resetOption("media"), a = t && t.silent;
        this[Ui] && (a == null && (a = this[Ui].silent), i = !0, this[Ui] = null), this[ai] = !0;
        try {
          i && Df(this), Vl.update.call(this, {
            type: "resize",
            animation: xe({
              // Disable animation
              duration: 0
            }, t && t.animation)
          });
        } catch (o) {
          throw this[ai] = !1, o;
        }
        this[ai] = !1, iv.call(this, a), av.call(this, a);
      }
    }, e.prototype.showLoading = function(t, r) {
      if (this._disposed) {
        sa(this.id);
        return;
      }
      if (ut(t) && (r = t, t = ""), t = t || "default", this.hideLoading(), !Lk[t]) {
        process.env.NODE_ENV !== "production" && Jn("Loading effects " + t + " not exists.");
        return;
      }
      var i = Lk[t](this._api, r), a = this._zr;
      this._loadingFX = i, a.add(i);
    }, e.prototype.hideLoading = function() {
      if (this._disposed) {
        sa(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, e.prototype.makeActionFromEvent = function(t) {
      var r = xe({}, t);
      return r.type = mm[t.type], r;
    }, e.prototype.dispatchAction = function(t, r) {
      if (this._disposed) {
        sa(this.id);
        return;
      }
      if (ut(r) || (r = {
        silent: !!r
      }), !!h_[t.type] && this._model) {
        if (this[ai]) {
          this._pendingActions.push(t);
          return;
        }
        var i = r.silent;
        U2.call(this, t, i);
        var a = r.flush;
        a ? this._zr.flush() : a !== !1 && Vt.browser.weChat && this._throttledZrFlush(), iv.call(this, i), av.call(this, i);
      }
    }, e.prototype.updateLabelLayout = function() {
      vo.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, e.prototype.appendData = function(t) {
      if (this._disposed) {
        sa(this.id);
        return;
      }
      var r = t.seriesIndex, i = this.getModel(), a = i.getSeriesByIndex(r);
      process.env.NODE_ENV !== "production" && ct(t.data && a), a.appendData(t), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, e.internalField = function() {
      Df = function(d) {
        var f = d._scheduler;
        f.restorePipelines(d._model), f.prepareStageTasks(), V2(d, !0), V2(d, !1), f.plan();
      }, V2 = function(d, f) {
        for (var p = d._model, h = d._scheduler, v = f ? d._componentsViews : d._chartsViews, m = f ? d._componentsMap : d._chartsMap, g = d._zr, y = d._api, b = 0; b < v.length; b++)
          v[b].__alive = !1;
        f ? p.eachComponent(function(w, S) {
          w !== "series" && _(S);
        }) : p.eachSeries(_);
        function _(w) {
          var S = w.__requireNewView;
          w.__requireNewView = !1;
          var C = "_ec_" + w.id + "_" + w.type, k = !S && m[C];
          if (!k) {
            var M = ls(w.type), D = f ? Yn.getClass(M.main, M.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              Tn.getClass(M.sub)
            );
            process.env.NODE_ENV !== "production" && ct(D, M.sub + " does not exist."), k = new D(), k.init(p, y), m[C] = k, v.push(k), g.add(k.group);
          }
          w.__viewId = k.__id = C, k.__alive = !0, k.__model = w, k.group.__ecComponentInfo = {
            mainType: w.mainType,
            index: w.componentIndex
          }, !f && h.prepareView(k, w, p, y);
        }
        for (var b = 0; b < v.length; ) {
          var x = v[b];
          x.__alive ? b++ : (!f && x.renderTask.dispose(), g.remove(x.group), x.dispose(p, y), v.splice(b, 1), m[x.__id] === x && delete m[x.__id], x.__id = x.group.__ecComponentInfo = null);
        }
      }, E0 = function(d, f, p, h, v) {
        var m = d._model;
        if (m.setUpdatePayload(p), !h) {
          $([].concat(d._componentsViews).concat(d._chartsViews), x);
          return;
        }
        var g = {};
        g[h + "Id"] = p[h + "Id"], g[h + "Index"] = p[h + "Index"], g[h + "Name"] = p[h + "Name"];
        var y = {
          mainType: h,
          query: g
        };
        v && (y.subType = v);
        var b = p.excludeSeriesId, _;
        b != null && (_ = tt(), $(wn(b), function(w) {
          var S = wr(w, null);
          S != null && _.set(S, !0);
        })), m && m.eachComponent(y, function(w) {
          var S = _ && _.get(w.id) != null;
          if (!S)
            if (uj(p))
              if (w instanceof Rn)
                p.type === pd && !p.notBlur && !w.get(["emphasis", "disabled"]) && QIe(w, p, d._api);
              else {
                var C = FD(w.mainType, w.componentIndex, p.name, d._api), k = C.focusSelf, M = C.dispatchers;
                p.type === pd && k && !p.notBlur && fk(w.mainType, w.componentIndex, d._api), M && $(M, function(D) {
                  p.type === pd ? xl(D) : wl(D);
                });
              }
            else hk(p) && w instanceof Rn && (nLe(w, p, d._api), sj(w), Da(d));
        }, d), m && m.eachComponent(y, function(w) {
          var S = _ && _.get(w.id) != null;
          S || x(d[h === "series" ? "_chartsMap" : "_componentsMap"][w.__viewId]);
        }, d);
        function x(w) {
          w && w.__alive && w[f] && w[f](w.__model, m, d._api, p);
        }
      }, Vl = {
        prepareAndUpdate: function(d) {
          Df(this), Vl.update.call(this, d, {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: d.newOption != null
          });
        },
        update: function(d, f) {
          var p = this._model, h = this._api, v = this._zr, m = this._coordSysMgr, g = this._scheduler;
          if (p) {
            p.setUpdatePayload(d), g.restoreData(p, d), g.performSeriesTasks(p), m.create(p, h), g.performDataProcessorTasks(p, d), G2(this, p), m.update(p, h), t(p), g.performVisualTasks(p, d), W2(this, p, h, d, f);
            var y = p.get("backgroundColor") || "transparent", b = p.get("darkMode");
            v.setBackgroundColor(y), b != null && b !== "auto" && v.setDarkMode(b), vo.trigger("afterupdate", p, h);
          }
        },
        updateTransform: function(d) {
          var f = this, p = this._model, h = this._api;
          if (p) {
            p.setUpdatePayload(d);
            var v = [];
            p.eachComponent(function(g, y) {
              if (g !== "series") {
                var b = f.getViewOfComponentModel(y);
                if (b && b.__alive)
                  if (b.updateTransform) {
                    var _ = b.updateTransform(y, p, h, d);
                    _ && _.update && v.push(b);
                  } else
                    v.push(b);
              }
            });
            var m = tt();
            p.eachSeries(function(g) {
              var y = f._chartsMap[g.__viewId];
              if (y.updateTransform) {
                var b = y.updateTransform(g, p, h, d);
                b && b.update && m.set(g.uid, 1);
              } else
                m.set(g.uid, 1);
            }), t(p), this._scheduler.performVisualTasks(p, d, {
              setDirty: !0,
              dirtyMap: m
            }), T0(this, p, h, d, {}, m), vo.trigger("afterupdate", p, h);
          }
        },
        updateView: function(d) {
          var f = this._model;
          f && (f.setUpdatePayload(d), Tn.markUpdateMethod(d, "updateView"), t(f), this._scheduler.performVisualTasks(f, d, {
            setDirty: !0
          }), W2(this, f, this._api, d, {}), vo.trigger("afterupdate", f, this._api));
        },
        updateVisual: function(d) {
          var f = this, p = this._model;
          p && (p.setUpdatePayload(d), p.eachSeries(function(h) {
            h.getData().clearAllVisual();
          }), Tn.markUpdateMethod(d, "updateVisual"), t(p), this._scheduler.performVisualTasks(p, d, {
            visualType: "visual",
            setDirty: !0
          }), p.eachComponent(function(h, v) {
            if (h !== "series") {
              var m = f.getViewOfComponentModel(v);
              m && m.__alive && m.updateVisual(v, p, f._api, d);
            }
          }), p.eachSeries(function(h) {
            var v = f._chartsMap[h.__viewId];
            v.updateVisual(h, p, f._api, d);
          }), vo.trigger("afterupdate", p, this._api));
        },
        updateLayout: function(d) {
          Vl.update.call(this, d);
        }
      }, H2 = function(d, f, p, h) {
        if (d._disposed) {
          sa(d.id);
          return;
        }
        for (var v = d._model, m = d._coordSysMgr.getCoordinateSystems(), g, y = cm(v, p), b = 0; b < m.length; b++) {
          var _ = m[b];
          if (_[f] && (g = _[f](v, y, h)) != null)
            return g;
        }
        process.env.NODE_ENV !== "production" && Jn("No coordinate system that supports " + f + " found by the given finder.");
      }, G2 = function(d, f) {
        var p = d._chartsMap, h = d._scheduler;
        f.eachSeries(function(v) {
          h.updateStreamModes(v, p[v.__viewId]);
        });
      }, U2 = function(d, f) {
        var p = this, h = this.getModel(), v = d.type, m = d.escapeConnect, g = h_[v], y = g.actionInfo, b = (y.update || "update").split(":"), _ = b.pop(), x = b[0] != null && ls(b[0]);
        this[ai] = !0;
        var w = [d], S = !1;
        d.batch && (S = !0, w = De(d.batch, function(j) {
          return j = dt(xe({}, j), d), j.batch = null, j;
        }));
        var C = [], k, M = hk(d), D = uj(d);
        if (D && aU(this._api), $(w, function(j) {
          if (k = g.action(j, p._model, p._api), k = k || xe({}, j), k.type = y.event || k.type, C.push(k), D) {
            var z = LD(d), F = z.queryOptionMap, B = z.mainTypeSpecified, H = B ? F.keys()[0] : "series";
            E0(p, _, j, H), Da(p);
          } else M ? (E0(p, _, j, "series"), Da(p)) : x && E0(p, _, j, x.main, x.sub);
        }), _ !== "none" && !D && !M && !x)
          try {
            this[Ui] ? (Df(this), Vl.update.call(this, d), this[Ui] = null) : Vl[_].call(this, d);
          } catch (j) {
            throw this[ai] = !1, j;
          }
        if (S ? k = {
          type: y.event || v,
          escapeConnect: m,
          batch: C
        } : k = C[0], this[ai] = !1, !f) {
          var N = this._messageCenter;
          if (N.trigger(k.type, k), M) {
            var R = {
              type: "selectchanged",
              escapeConnect: m,
              selected: rLe(h),
              isFromClick: d.isFromClick || !1,
              fromAction: d.type,
              fromActionPayload: d
            };
            N.trigger(R.type, R);
          }
        }
      }, iv = function(d) {
        for (var f = this._pendingActions; f.length; ) {
          var p = f.shift();
          U2.call(this, p, d);
        }
      }, av = function(d) {
        !d && this.trigger("updated");
      }, S5 = function(d, f) {
        d.on("rendered", function(p) {
          f.trigger("rendered", p), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          d.animation.isFinished() && !f[Ui] && !f._scheduler.unfinished && !f._pendingActions.length && f.trigger("finished");
        });
      }, E5 = function(d, f) {
        d.on("mouseover", function(p) {
          var h = p.target, v = qc(h, Ru);
          v && (eLe(v, p, f._api), Da(f));
        }).on("mouseout", function(p) {
          var h = p.target, v = qc(h, Ru);
          v && (tLe(v, p, f._api), Da(f));
        }).on("click", function(p) {
          var h = p.target, v = qc(h, function(y) {
            return yt(y).dataIndex != null;
          }, !0);
          if (v) {
            var m = v.selected ? "unselect" : "select", g = yt(v);
            f._api.dispatchAction({
              type: m,
              dataType: g.dataType,
              dataIndexInside: g.dataIndex,
              seriesIndex: g.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function t(d) {
        d.clearColorPalette(), d.eachSeries(function(f) {
          f.clearColorPalette();
        });
      }
      function r(d) {
        var f = [], p = [], h = !1;
        if (d.eachComponent(function(y, b) {
          var _ = b.get("zlevel") || 0, x = b.get("z") || 0, w = b.getZLevelKey();
          h = h || !!w, (y === "series" ? p : f).push({
            zlevel: _,
            z: x,
            idx: b.componentIndex,
            type: y,
            key: w
          });
        }), h) {
          var v = f.concat(p), m, g;
          _1(v, function(y, b) {
            return y.zlevel === b.zlevel ? y.z - b.z : y.zlevel - b.zlevel;
          }), $(v, function(y) {
            var b = d.getComponent(y.type, y.idx), _ = y.zlevel, x = y.key;
            m != null && (_ = Math.max(m, _)), x ? (_ === m && x !== g && _++, g = x) : g && (_ === m && _++, g = ""), m = _, b.setZLevel(_);
          });
        }
      }
      W2 = function(d, f, p, h, v) {
        r(f), T5(d, f, p, h, v), $(d._chartsViews, function(m) {
          m.__alive = !1;
        }), T0(d, f, p, h, v), $(d._chartsViews, function(m) {
          m.__alive || m.remove(f, p);
        });
      }, T5 = function(d, f, p, h, v, m) {
        $(m || d._componentsViews, function(g) {
          var y = g.__model;
          u(y, g), g.render(y, f, p, h), s(y, g), c(y, g);
        });
      }, T0 = function(d, f, p, h, v, m) {
        var g = d._scheduler;
        v = xe(v || {}, {
          updatedSeries: f.getSeries()
        }), vo.trigger("series:beforeupdate", f, p, v);
        var y = !1;
        f.eachSeries(function(b) {
          var _ = d._chartsMap[b.__viewId];
          _.__alive = !0;
          var x = _.renderTask;
          g.updatePayload(x, h), u(b, _), m && m.get(b.uid) && x.dirty(), x.perform(g.getPerformArgs(x)) && (y = !0), _.group.silent = !!b.get("silent"), o(b, _), sj(b);
        }), g.unfinished = y || g.unfinished, vo.trigger("series:layoutlabels", f, p, v), vo.trigger("series:transition", f, p, v), f.eachSeries(function(b) {
          var _ = d._chartsMap[b.__viewId];
          s(b, _), c(b, _);
        }), a(d, f), vo.trigger("series:afterupdate", f, p, v);
      }, Da = function(d) {
        d[z2] = !0, d.getZr().wakeUp();
      }, k5 = function(d) {
        d[z2] && (d.getZr().storage.traverse(function(f) {
          bp(f) || i(f);
        }), d[z2] = !1);
      };
      function i(d) {
        for (var f = [], p = d.currentStates, h = 0; h < p.length; h++) {
          var v = p[h];
          v === "emphasis" || v === "blur" || v === "select" || f.push(v);
        }
        d.selected && d.states.select && f.push("select"), d.hoverState === nw && d.states.emphasis ? f.push("emphasis") : d.hoverState === Vg && d.states.blur && f.push("blur"), d.useStates(f);
      }
      function a(d, f) {
        var p = d._zr, h = p.storage, v = 0;
        h.traverse(function(m) {
          m.isGroup || v++;
        }), v > f.get("hoverLayerThreshold") && !Vt.node && !Vt.worker && f.eachSeries(function(m) {
          if (!m.preventUsingHoverLayer) {
            var g = d._chartsMap[m.__viewId];
            g.__alive && g.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function o(d, f) {
        var p = d.get("blendMode") || null;
        f.eachRendered(function(h) {
          h.isGroup || (h.style.blend = p);
        });
      }
      function s(d, f) {
        if (!d.preventAutoZ) {
          var p = d.get("z") || 0, h = d.get("zlevel") || 0;
          f.eachRendered(function(v) {
            return l(v, p, h, -1 / 0), !0;
          });
        }
      }
      function l(d, f, p, h) {
        var v = d.getTextContent(), m = d.getTextGuideLine(), g = d.isGroup;
        if (g)
          for (var y = d.childrenRef(), b = 0; b < y.length; b++)
            h = Math.max(l(y[b], f, p, h), h);
        else
          d.z = f, d.zlevel = p, h = Math.max(d.z2, h);
        if (v && (v.z = f, v.zlevel = p, isFinite(h) && (v.z2 = h + 2)), m) {
          var _ = d.textGuideLineConfig;
          m.z = f, m.zlevel = p, isFinite(h) && (m.z2 = h + (_ && _.showAbove ? 1 : -1));
        }
        return h;
      }
      function u(d, f) {
        f.eachRendered(function(p) {
          if (!bp(p)) {
            var h = p.getTextContent(), v = p.getTextGuideLine();
            p.stateTransition && (p.stateTransition = null), h && h.stateTransition && (h.stateTransition = null), v && v.stateTransition && (v.stateTransition = null), p.hasState() ? (p.prevStates = p.currentStates, p.clearStates()) : p.prevStates && (p.prevStates = null);
          }
        });
      }
      function c(d, f) {
        var p = d.getModel("stateAnimation"), h = d.isAnimationEnabled(), v = p.get("duration"), m = v > 0 ? {
          duration: v,
          delay: p.get("delay"),
          easing: p.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        f.eachRendered(function(g) {
          if (g.states && g.states.emphasis) {
            if (bp(g))
              return;
            if (g instanceof Ht && lLe(g), g.__dirty) {
              var y = g.prevStates;
              y && g.useStates(y);
            }
            if (h) {
              g.stateTransition = m;
              var b = g.getTextContent(), _ = g.getTextGuideLine();
              b && (b.stateTransition = m), _ && (_.stateTransition = m);
            }
            g.__dirty && i(g);
          }
        });
      }
      C5 = function(d) {
        return new /** @class */
        (function(f) {
          le(p, f);
          function p() {
            return f !== null && f.apply(this, arguments) || this;
          }
          return p.prototype.getCoordinateSystems = function() {
            return d._coordSysMgr.getCoordinateSystems();
          }, p.prototype.getComponentByElement = function(h) {
            for (; h; ) {
              var v = h.__ecComponentInfo;
              if (v != null)
                return d._model.getComponent(v.mainType, v.index);
              h = h.parent;
            }
          }, p.prototype.enterEmphasis = function(h, v) {
            xl(h, v), Da(d);
          }, p.prototype.leaveEmphasis = function(h, v) {
            wl(h, v), Da(d);
          }, p.prototype.enterBlur = function(h) {
            tU(h), Da(d);
          }, p.prototype.leaveBlur = function(h) {
            zD(h), Da(d);
          }, p.prototype.enterSelect = function(h) {
            nU(h), Da(d);
          }, p.prototype.leaveSelect = function(h) {
            rU(h), Da(d);
          }, p.prototype.getModel = function() {
            return d.getModel();
          }, p.prototype.getViewOfComponentModel = function(h) {
            return d.getViewOfComponentModel(h);
          }, p.prototype.getViewOfSeriesModel = function(h) {
            return d.getViewOfSeriesModel(h);
          }, p;
        }(YU))(d);
      }, VW = function(d) {
        function f(p, h) {
          for (var v = 0; v < p.length; v++) {
            var m = p[v];
            m[F2] = h;
          }
        }
        $(mm, function(p, h) {
          d._messageCenter.on(h, function(v) {
            if (A5[d.group] && d[F2] !== w5) {
              if (v && v.escapeConnect)
                return;
              var m = d.makeActionFromEvent(v), g = [];
              $(gm, function(y) {
                y !== d && y.group === d.group && g.push(y);
              }), f(g, w5), $(g, function(y) {
                y[F2] !== PPe && y.dispatchAction(m);
              }), f(g, jPe);
            }
          });
        });
      };
    }(), e;
  }(io)
), dO = HW.prototype;
dO.on = jW("on");
dO.off = jW("off");
dO.one = function(n, e, t) {
  var r = this;
  Do("ECharts#one is deprecated.");
  function i() {
    for (var a = [], o = 0; o < arguments.length; o++)
      a[o] = arguments[o];
    e && e.apply && e.apply(this, a), r.off(n, i);
  }
  this.on.call(this, n, i, t);
};
var BPe = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function sa(n) {
  process.env.NODE_ENV !== "production" && Jn("Instance " + n + " has been disposed");
}
var h_ = {}, mm = {}, Ok = [], Ik = [], v_ = [], GW = {}, Lk = {}, gm = {}, A5 = {}, $Pe = +/* @__PURE__ */ new Date() - 0, fO = "_echarts_instance_";
function zPe(n, e, t) {
  var r = !(t && t.ssr);
  if (r) {
    if (process.env.NODE_ENV !== "production" && !n)
      throw new Error("Initialize failed: invalid dom.");
    var i = FPe(n);
    if (i)
      return process.env.NODE_ENV !== "production" && Jn("There is a chart instance already initialized on the dom."), i;
    process.env.NODE_ENV !== "production" && Md(n) && n.nodeName.toUpperCase() !== "CANVAS" && (!n.clientWidth && (!t || t.width == null) || !n.clientHeight && (!t || t.height == null)) && Jn("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
  }
  var a = new HW(n, e, t);
  return a.id = "ec_" + $Pe++, gm[a.id] = a, r && BG(n, fO, a.id), VW(a), vo.trigger("afterinit", a), a;
}
function FPe(n) {
  return gm[XOe(n, fO)];
}
function UW(n, e) {
  GW[n] = e;
}
function WW(n) {
  Pt(Ik, n) < 0 && Ik.push(n);
}
function qW(n, e) {
  hO(Ok, n, e, APe);
}
function VPe(n) {
  pO("afterinit", n);
}
function HPe(n) {
  pO("afterupdate", n);
}
function pO(n, e) {
  vo.on(n, e);
}
function Ds(n, e, t) {
  at(e) && (t = e, e = "");
  var r = ut(n) ? n.type : [n, n = {
    event: e
  }][0];
  n.event = (n.event || r).toLowerCase(), e = n.event, !mm[e] && (ct(x5.test(r) && x5.test(e)), h_[r] || (h_[r] = {
    action: t,
    actionInfo: n
  }), mm[e] = r);
}
function GPe(n, e) {
  gh.register(n, e);
}
function UPe(n, e) {
  hO(v_, n, e, NW, "layout");
}
function tf(n, e) {
  hO(v_, n, e, RW, "visual");
}
var M5 = [];
function hO(n, e, t, r, i) {
  if ((at(e) || ut(e)) && (t = e, e = r), process.env.NODE_ENV !== "production") {
    if (isNaN(e) || e == null)
      throw new Error("Illegal priority");
    $(n, function(o) {
      ct(o.__raw !== t);
    });
  }
  if (!(Pt(M5, t) >= 0)) {
    M5.push(t);
    var a = xW.wrapStageHandler(t, i);
    a.__prio = e, a.__raw = t, n.push(a);
  }
}
function YW(n, e) {
  Lk[n] = e;
}
function WPe(n, e, t) {
  var r = SPe("registerMap");
  r && r(n, e, t);
}
var qPe = aRe;
tf(cO, ORe);
tf(yw, IRe);
tf(yw, LRe);
tf(cO, WRe);
tf(yw, qRe);
tf(PW, xPe);
WW(XU);
qW(CPe, $Ne);
YW("default", NRe);
Ds({
  type: pd,
  event: pd,
  update: pd
}, dr);
Ds({
  type: E1,
  event: E1,
  update: E1
}, dr);
Ds({
  type: dm,
  event: dm,
  update: dm
}, dr);
Ds({
  type: T1,
  event: T1,
  update: T1
}, dr);
Ds({
  type: fm,
  event: fm,
  update: fm
}, dr);
UW("light", GRe);
UW("dark", TW);
var D5 = [], YPe = {
  registerPreprocessor: WW,
  registerProcessor: qW,
  registerPostInit: VPe,
  registerPostUpdate: HPe,
  registerUpdateLifecycle: pO,
  registerAction: Ds,
  registerCoordinateSystem: GPe,
  registerLayout: UPe,
  registerVisual: tf,
  registerTransform: qPe,
  registerLoading: YW,
  registerMap: WPe,
  registerImpl: wPe,
  PRIORITY: RPe,
  ComponentModel: Ut,
  ComponentView: Yn,
  SeriesModel: Rn,
  ChartView: Tn,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(n) {
    Ut.registerClass(n);
  },
  registerComponentView: function(n) {
    Yn.registerClass(n);
  },
  registerSeriesModel: function(n) {
    Rn.registerClass(n);
  },
  registerChartView: function(n) {
    Tn.registerClass(n);
  },
  registerSubTypeDefaulter: function(n, e) {
    Ut.registerSubTypeDefaulter(n, e);
  },
  registerPainter: function(n, e) {
    COe(n, e);
  }
};
function $t(n) {
  if (Me(n)) {
    $(n, function(e) {
      $t(e);
    });
    return;
  }
  Pt(D5, n) >= 0 || (D5.push(n), at(n) && (n = {
    install: n
  }), n.install(YPe));
}
function ov(n) {
  return n == null ? 0 : n.length || 1;
}
function O5(n) {
  return n;
}
var Sl = (
  /** @class */
  function() {
    function n(e, t, r, i, a, o) {
      this._old = e, this._new = t, this._oldKeyGetter = r || O5, this._newKeyGetter = i || O5, this.context = a, this._diffModeMultiple = o === "multiple";
    }
    return n.prototype.add = function(e) {
      return this._add = e, this;
    }, n.prototype.update = function(e) {
      return this._update = e, this;
    }, n.prototype.updateManyToOne = function(e) {
      return this._updateManyToOne = e, this;
    }, n.prototype.updateOneToMany = function(e) {
      return this._updateOneToMany = e, this;
    }, n.prototype.updateManyToMany = function(e) {
      return this._updateManyToMany = e, this;
    }, n.prototype.remove = function(e) {
      return this._remove = e, this;
    }, n.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, n.prototype._executeOneToOne = function() {
      var e = this._old, t = this._new, r = {}, i = new Array(e.length), a = new Array(t.length);
      this._initIndexMap(e, null, i, "_oldKeyGetter"), this._initIndexMap(t, r, a, "_newKeyGetter");
      for (var o = 0; o < e.length; o++) {
        var s = i[o], l = r[s], u = ov(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (r[s] = l[0]), this._update && this._update(c, o);
        } else u === 1 ? (r[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o);
      }
      this._performRestAdd(a, r);
    }, n.prototype._executeMultiple = function() {
      var e = this._old, t = this._new, r = {}, i = {}, a = [], o = [];
      this._initIndexMap(e, r, a, "_oldKeyGetter"), this._initIndexMap(t, i, o, "_newKeyGetter");
      for (var s = 0; s < a.length; s++) {
        var l = a[s], u = r[l], c = i[l], d = ov(u), f = ov(c);
        if (d > 1 && f === 1)
          this._updateManyToOne && this._updateManyToOne(c, u), i[l] = null;
        else if (d === 1 && f > 1)
          this._updateOneToMany && this._updateOneToMany(c, u), i[l] = null;
        else if (d === 1 && f === 1)
          this._update && this._update(c, u), i[l] = null;
        else if (d > 1 && f > 1)
          this._updateManyToMany && this._updateManyToMany(c, u), i[l] = null;
        else if (d > 1)
          for (var p = 0; p < d; p++)
            this._remove && this._remove(u[p]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(o, i);
    }, n.prototype._performRestAdd = function(e, t) {
      for (var r = 0; r < e.length; r++) {
        var i = e[r], a = t[i], o = ov(a);
        if (o > 1)
          for (var s = 0; s < o; s++)
            this._add && this._add(a[s]);
        else o === 1 && this._add && this._add(a);
        t[i] = null;
      }
    }, n.prototype._initIndexMap = function(e, t, r, i) {
      for (var a = this._diffModeMultiple, o = 0; o < e.length; o++) {
        var s = "_ec_" + this[i](e[o], o);
        if (a || (r[o] = s), !!t) {
          var l = t[s], u = ov(l);
          u === 0 ? (t[s] = o, a && r.push(s)) : u === 1 ? t[s] = [l, o] : l.push(o);
        }
      }
    }, n;
  }()
), KPe = (
  /** @class */
  function() {
    function n(e, t) {
      this._encode = e, this._schema = t;
    }
    return n.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, n.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, n;
  }()
);
function XPe(n, e) {
  var t = {}, r = t.encode = {}, i = tt(), a = [], o = [], s = {};
  $(n.dimensions, function(f) {
    var p = n.getDimensionInfo(f), h = p.coordDim;
    if (h) {
      process.env.NODE_ENV !== "production" && ct(_k.get(h) == null);
      var v = p.coordDimIndex;
      q2(r, h)[v] = f, p.isExtraCoord || (i.set(h, 1), ZPe(p.type) && (a[0] = f), q2(s, h)[v] = n.getDimensionIndex(p.name)), p.defaultTooltip && o.push(f);
    }
    _k.each(function(m, g) {
      var y = q2(r, g), b = p.otherDims[g];
      b != null && b !== !1 && (y[b] = p.name);
    });
  });
  var l = [], u = {};
  i.each(function(f, p) {
    var h = r[p];
    u[p] = h[0], l = l.concat(h);
  }), t.dataDimsOnCoord = l, t.dataDimIndicesOnCoord = De(l, function(f) {
    return n.getDimensionInfo(f).storeDimIndex;
  }), t.encodeFirstDimNotExtra = u;
  var c = r.label;
  c && c.length && (a = c.slice());
  var d = r.tooltip;
  return d && d.length ? o = d.slice() : o.length || (o = a.slice()), r.defaultedLabel = a, r.defaultedTooltip = o, t.userOutput = new KPe(s, e), t;
}
function q2(n, e) {
  return n.hasOwnProperty(e) || (n[e] = []), n[e];
}
function m_(n) {
  return n === "category" ? "ordinal" : n === "time" ? "time" : "float";
}
function ZPe(n) {
  return !(n === "ordinal" || n === "time");
}
var D1 = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e) {
      this.otherDims = {}, e != null && xe(this, e);
    }
    return n;
  }()
), JPe = en(), QPe = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, KW = (
  /** @class */
  function() {
    function n(e) {
      this.dimensions = e.dimensions, this._dimOmitted = e.dimensionOmitted, this.source = e.source, this._fullDimCount = e.fullDimensionCount, this._updateDimOmitted(e.dimensionOmitted);
    }
    return n.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, n.prototype._updateDimOmitted = function(e) {
      this._dimOmitted = e, e && (this._dimNameMap || (this._dimNameMap = JW(this.source)));
    }, n.prototype.getSourceDimensionIndex = function(e) {
      return bt(this._dimNameMap.get(e), -1);
    }, n.prototype.getSourceDimension = function(e) {
      var t = this.source.dimensionsDefine;
      if (t)
        return t[e];
    }, n.prototype.makeStoreSchema = function() {
      for (var e = this._fullDimCount, t = JU(this.source), r = !QW(e), i = "", a = [], o = 0, s = 0; o < e; o++) {
        var l = void 0, u = void 0, c = void 0, d = this.dimensions[s];
        if (d && d.storeDimIndex === o)
          l = t ? d.name : null, u = d.type, c = d.ordinalMeta, s++;
        else {
          var f = this.getSourceDimension(o);
          f && (l = t ? f.name : null, u = f.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), t && l != null && (!d || !d.isCalculationCoord) && (i += r ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), i += "$", i += QPe[u] || "f", c && (i += c.uid), i += "$";
      }
      var p = this.source, h = [p.seriesLayoutBy, p.startIndex, i].join("$$");
      return {
        dimensions: a,
        hash: h
      };
    }, n.prototype.makeOutputDimensionNames = function() {
      for (var e = [], t = 0, r = 0; t < this._fullDimCount; t++) {
        var i = void 0, a = this.dimensions[r];
        if (a && a.storeDimIndex === t)
          a.isCalculationCoord || (i = a.name), r++;
        else {
          var o = this.getSourceDimension(t);
          o && (i = o.name);
        }
        e.push(i);
      }
      return e;
    }, n.prototype.appendCalculationDimension = function(e) {
      this.dimensions.push(e), e.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, n;
  }()
);
function XW(n) {
  return n instanceof KW;
}
function ZW(n) {
  for (var e = tt(), t = 0; t < (n || []).length; t++) {
    var r = n[t], i = ut(r) ? r.name : r;
    i != null && e.get(i) == null && e.set(i, t);
  }
  return e;
}
function JW(n) {
  var e = JPe(n);
  return e.dimNameMap || (e.dimNameMap = ZW(n.dimensionsDefine));
}
function QW(n) {
  return n > 30;
}
var sv = ut, Hl = De, e3e = typeof Int32Array > "u" ? Array : Int32Array, t3e = "e\0\0", I5 = -1, n3e = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], r3e = ["_approximateExtent"], L5, C0, lv, Of, Y2, uv, K2, Oi = (
  /** @class */
  function() {
    function n(e, t) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"];
      var r, i = !1;
      XW(e) ? (r = e.dimensions, this._dimOmitted = e.isDimensionOmitted(), this._schema = e) : (i = !0, r = e), r = r || ["x", "y"];
      for (var a = {}, o = [], s = {}, l = !1, u = {}, c = 0; c < r.length; c++) {
        var d = r[c], f = We(d) ? new D1({
          name: d
        }) : d instanceof D1 ? d : new D1(d), p = f.name;
        f.type = f.type || "float", f.coordDim || (f.coordDim = p, f.coordDimIndex = 0);
        var h = f.otherDims = f.otherDims || {};
        o.push(p), a[p] = f, u[p] != null && (l = !0), f.createInvertedIndices && (s[p] = []), h.itemName === 0 && (this._nameDimIdx = c), h.itemId === 0 && (this._idDimIdx = c), process.env.NODE_ENV !== "production" && ct(i || f.storeDimIndex >= 0), i && (f.storeDimIndex = c);
      }
      if (this.dimensions = o, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = t, this._invertedIndicesMap = s, this._dimOmitted) {
        var v = this._dimIdxToName = tt();
        $(o, function(m) {
          v.set(a[m].storeDimIndex, m);
        });
      }
    }
    return n.prototype.getDimension = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t == null)
        return e;
      if (t = e, !this._dimOmitted)
        return this.dimensions[t];
      var r = this._dimIdxToName.get(t);
      if (r != null)
        return r;
      var i = this._schema.getSourceDimension(t);
      if (i)
        return i.name;
    }, n.prototype.getDimensionIndex = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t != null)
        return t;
      if (e == null)
        return -1;
      var r = this._getDimInfo(e);
      return r ? r.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(e) : -1;
    }, n.prototype._recognizeDimIndex = function(e) {
      if (sn(e) || e != null && !isNaN(e) && !this._getDimInfo(e) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(e) < 0))
        return +e;
    }, n.prototype._getStoreDimIndex = function(e) {
      var t = this.getDimensionIndex(e);
      if (process.env.NODE_ENV !== "production" && t == null)
        throw new Error("Unknown dimension " + e);
      return t;
    }, n.prototype.getDimensionInfo = function(e) {
      return this._getDimInfo(this.getDimension(e));
    }, n.prototype._initGetDimensionInfo = function(e) {
      var t = this._dimInfos;
      this._getDimInfo = e ? function(r) {
        return t.hasOwnProperty(r) ? t[r] : void 0;
      } : function(r) {
        return t[r];
      };
    }, n.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, n.prototype.mapDimension = function(e, t) {
      var r = this._dimSummary;
      if (t == null)
        return r.encodeFirstDimNotExtra[e];
      var i = r.encode[e];
      return i ? i[t] : null;
    }, n.prototype.mapDimensionsAll = function(e) {
      var t = this._dimSummary, r = t.encode[e];
      return (r || []).slice();
    }, n.prototype.getStore = function() {
      return this._store;
    }, n.prototype.initData = function(e, t, r) {
      var i = this, a;
      if (e instanceof Ek && (a = e), !a) {
        var o = this.dimensions, s = rO(e) || hi(e) ? new QU(e, o.length) : e;
        a = new Ek();
        var l = Hl(o, function(u) {
          return {
            type: i._dimInfos[u].type,
            property: u
          };
        });
        a.initData(s, l, r);
      }
      this._store = a, this._nameList = (t || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = XPe(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, n.prototype.appendData = function(e) {
      var t = this._store.appendData(e);
      this._doInit(t[0], t[1]);
    }, n.prototype.appendValues = function(e, t) {
      var r = this._store.appendValues(e, t && t.length), i = r.start, a = r.end, o = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), t)
        for (var s = i; s < a; s++) {
          var l = s - i;
          this._nameList[s] = t[l], o && K2(this, s);
        }
    }, n.prototype._updateOrdinalMeta = function() {
      for (var e = this._store, t = this.dimensions, r = 0; r < t.length; r++) {
        var i = this._dimInfos[t[r]];
        i.ordinalMeta && e.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta);
      }
    }, n.prototype._shouldMakeIdFromName = function() {
      var e = this._store.getProvider();
      return this._idDimIdx == null && e.getSource().sourceFormat !== fl && !e.fillStorage;
    }, n.prototype._doInit = function(e, t) {
      if (!(e >= t)) {
        var r = this._store, i = r.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, o = this._idList, s = i.getSource().sourceFormat, l = s === ao;
        if (l && !i.pure)
          for (var u = [], c = e; c < t; c++) {
            var d = i.getItem(c, u);
            if (!this.hasItemOption && jOe(d) && (this.hasItemOption = !0), d) {
              var f = d.name;
              a[c] == null && f != null && (a[c] = wr(f, null));
              var p = d.id;
              o[c] == null && p != null && (o[c] = wr(p, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var c = e; c < t; c++)
            K2(this, c);
        L5(this);
      }
    }, n.prototype.getApproximateExtent = function(e) {
      return this._approximateExtent[e] || this._store.getDataExtent(this._getStoreDimIndex(e));
    }, n.prototype.setApproximateExtent = function(e, t) {
      t = this.getDimension(t), this._approximateExtent[t] = e.slice();
    }, n.prototype.getCalculationInfo = function(e) {
      return this._calculationInfo[e];
    }, n.prototype.setCalculationInfo = function(e, t) {
      sv(e) ? xe(this._calculationInfo, e) : this._calculationInfo[e] = t;
    }, n.prototype.getName = function(e) {
      var t = this.getRawIndex(e), r = this._nameList[t];
      return r == null && this._nameDimIdx != null && (r = lv(this, this._nameDimIdx, t)), r == null && (r = ""), r;
    }, n.prototype._getCategory = function(e, t) {
      var r = this._store.get(e, t), i = this._store.getOrdinalMeta(e);
      return i ? i.categories[r] : r;
    }, n.prototype.getId = function(e) {
      return C0(this, this.getRawIndex(e));
    }, n.prototype.count = function() {
      return this._store.count();
    }, n.prototype.get = function(e, t) {
      var r = this._store, i = this._dimInfos[e];
      if (i)
        return r.get(i.storeDimIndex, t);
    }, n.prototype.getByRawIndex = function(e, t) {
      var r = this._store, i = this._dimInfos[e];
      if (i)
        return r.getByRawIndex(i.storeDimIndex, t);
    }, n.prototype.getIndices = function() {
      return this._store.getIndices();
    }, n.prototype.getDataExtent = function(e) {
      return this._store.getDataExtent(this._getStoreDimIndex(e));
    }, n.prototype.getSum = function(e) {
      return this._store.getSum(this._getStoreDimIndex(e));
    }, n.prototype.getMedian = function(e) {
      return this._store.getMedian(this._getStoreDimIndex(e));
    }, n.prototype.getValues = function(e, t) {
      var r = this, i = this._store;
      return Me(e) ? i.getValues(Hl(e, function(a) {
        return r._getStoreDimIndex(a);
      }), t) : i.getValues(e);
    }, n.prototype.hasValue = function(e) {
      for (var t = this._dimSummary.dataDimIndicesOnCoord, r = 0, i = t.length; r < i; r++)
        if (isNaN(this._store.get(t[r], e)))
          return !1;
      return !0;
    }, n.prototype.indexOfName = function(e) {
      for (var t = 0, r = this._store.count(); t < r; t++)
        if (this.getName(t) === e)
          return t;
      return -1;
    }, n.prototype.getRawIndex = function(e) {
      return this._store.getRawIndex(e);
    }, n.prototype.indexOfRawIndex = function(e) {
      return this._store.indexOfRawIndex(e);
    }, n.prototype.rawIndexOf = function(e, t) {
      var r = e && this._invertedIndicesMap[e];
      if (process.env.NODE_ENV !== "production" && !r)
        throw new Error("Do not supported yet");
      var i = r && r[t];
      return i == null || isNaN(i) ? I5 : i;
    }, n.prototype.indicesOfNearest = function(e, t, r) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(e), t, r);
    }, n.prototype.each = function(e, t, r) {
      at(e) && (r = t, t = e, e = []);
      var i = r || this, a = Hl(Of(e), this._getStoreDimIndex, this);
      this._store.each(a, i ? Ze(t, i) : t);
    }, n.prototype.filterSelf = function(e, t, r) {
      at(e) && (r = t, t = e, e = []);
      var i = r || this, a = Hl(Of(e), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, i ? Ze(t, i) : t), this;
    }, n.prototype.selectRange = function(e) {
      var t = this, r = {}, i = Yt(e);
      return $(i, function(a) {
        var o = t._getStoreDimIndex(a);
        r[o] = e[a];
      }), this._store = this._store.selectRange(r), this;
    }, n.prototype.mapArray = function(e, t, r) {
      at(e) && (r = t, t = e, e = []), r = r || this;
      var i = [];
      return this.each(e, function() {
        i.push(t && t.apply(this, arguments));
      }, r), i;
    }, n.prototype.map = function(e, t, r, i) {
      var a = r || i || this, o = Hl(Of(e), this._getStoreDimIndex, this), s = uv(this);
      return s._store = this._store.map(o, a ? Ze(t, a) : t), s;
    }, n.prototype.modify = function(e, t, r, i) {
      var a = this, o = r || i || this;
      process.env.NODE_ENV !== "production" && $(Of(e), function(l) {
        var u = a.getDimensionInfo(l);
        u.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var s = Hl(Of(e), this._getStoreDimIndex, this);
      this._store.modify(s, o ? Ze(t, o) : t);
    }, n.prototype.downSample = function(e, t, r, i) {
      var a = uv(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(e), t, r, i), a;
    }, n.prototype.minmaxDownSample = function(e, t) {
      var r = uv(this);
      return r._store = this._store.minmaxDownSample(this._getStoreDimIndex(e), t), r;
    }, n.prototype.lttbDownSample = function(e, t) {
      var r = uv(this);
      return r._store = this._store.lttbDownSample(this._getStoreDimIndex(e), t), r;
    }, n.prototype.getRawDataItem = function(e) {
      return this._store.getRawDataItem(e);
    }, n.prototype.getItemModel = function(e) {
      var t = this.hostModel, r = this.getRawDataItem(e);
      return new yn(r, t, t && t.ecModel);
    }, n.prototype.diff = function(e) {
      var t = this;
      return new Sl(e ? e.getStore().getIndices() : [], this.getStore().getIndices(), function(r) {
        return C0(e, r);
      }, function(r) {
        return C0(t, r);
      });
    }, n.prototype.getVisual = function(e) {
      var t = this._visual;
      return t && t[e];
    }, n.prototype.setVisual = function(e, t) {
      this._visual = this._visual || {}, sv(e) ? xe(this._visual, e) : this._visual[e] = t;
    }, n.prototype.getItemVisual = function(e, t) {
      var r = this._itemVisuals[e], i = r && r[t];
      return i ?? this.getVisual(t);
    }, n.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, n.prototype.ensureUniqueItemVisual = function(e, t) {
      var r = this._itemVisuals, i = r[e];
      i || (i = r[e] = {});
      var a = i[t];
      return a == null && (a = this.getVisual(t), Me(a) ? a = a.slice() : sv(a) && (a = xe({}, a)), i[t] = a), a;
    }, n.prototype.setItemVisual = function(e, t, r) {
      var i = this._itemVisuals[e] || {};
      this._itemVisuals[e] = i, sv(t) ? xe(i, t) : i[t] = r;
    }, n.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, n.prototype.setLayout = function(e, t) {
      sv(e) ? xe(this._layout, e) : this._layout[e] = t;
    }, n.prototype.getLayout = function(e) {
      return this._layout[e];
    }, n.prototype.getItemLayout = function(e) {
      return this._itemLayouts[e];
    }, n.prototype.setItemLayout = function(e, t, r) {
      this._itemLayouts[e] = r ? xe(this._itemLayouts[e] || {}, t) : t;
    }, n.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, n.prototype.setItemGraphicEl = function(e, t) {
      var r = this.hostModel && this.hostModel.seriesIndex;
      ck(r, this.dataType, e, t), this._graphicEls[e] = t;
    }, n.prototype.getItemGraphicEl = function(e) {
      return this._graphicEls[e];
    }, n.prototype.eachItemGraphicEl = function(e, t) {
      $(this._graphicEls, function(r, i) {
        r && e && e.call(t, r, i);
      });
    }, n.prototype.cloneShallow = function(e) {
      return e || (e = new n(this._schema ? this._schema : Hl(this.dimensions, this._getDimInfo, this), this.hostModel)), Y2(e, this), e._store = this._store, e;
    }, n.prototype.wrapMethod = function(e, t) {
      var r = this[e];
      at(r) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(e), this[e] = function() {
        var i = r.apply(this, arguments);
        return t.apply(this, [i].concat(SD(arguments)));
      });
    }, n.internalField = function() {
      L5 = function(e) {
        var t = e._invertedIndicesMap;
        $(t, function(r, i) {
          var a = e._dimInfos[i], o = a.ordinalMeta, s = e._store;
          if (o) {
            r = t[i] = new e3e(o.categories.length);
            for (var l = 0; l < r.length; l++)
              r[l] = I5;
            for (var l = 0; l < s.count(); l++)
              r[s.get(a.storeDimIndex, l)] = l;
          }
        });
      }, lv = function(e, t, r) {
        return wr(e._getCategory(t, r), null);
      }, C0 = function(e, t) {
        var r = e._idList[t];
        return r == null && e._idDimIdx != null && (r = lv(e, e._idDimIdx, t)), r == null && (r = t3e + t), r;
      }, Of = function(e) {
        return Me(e) || (e = e != null ? [e] : []), e;
      }, uv = function(e) {
        var t = new n(e._schema ? e._schema : Hl(e.dimensions, e._getDimInfo, e), e.hostModel);
        return Y2(t, e), t;
      }, Y2 = function(e, t) {
        $(n3e.concat(t.__wrappedMethods || []), function(r) {
          t.hasOwnProperty(r) && (e[r] = t[r]);
        }), e.__wrappedMethods = t.__wrappedMethods, $(r3e, function(r) {
          e[r] = ht(t[r]);
        }), e._calculationInfo = xe({}, t._calculationInfo);
      }, K2 = function(e, t) {
        var r = e._nameList, i = e._idList, a = e._nameDimIdx, o = e._idDimIdx, s = r[t], l = i[t];
        if (s == null && a != null && (r[t] = s = lv(e, a, t)), l == null && o != null && (i[t] = l = lv(e, o, t)), l == null && s != null) {
          var u = e._nameRepeatCount, c = u[s] = (u[s] || 0) + 1;
          l = s, c > 1 && (l += "__ec__" + c), i[t] = l;
        }
      };
    }(), n;
  }()
);
function Kg(n, e) {
  rO(n) || (n = iO(n)), e = e || {};
  var t = e.coordDimensions || [], r = e.dimensionsDefine || n.dimensionsDefine || [], i = tt(), a = [], o = a3e(n, t, r, e.dimensionsCount), s = e.canOmitUnusedDimensions && QW(o), l = r === n.dimensionsDefine, u = l ? JW(n) : ZW(r), c = e.encodeDefine;
  !c && e.encodeDefaulter && (c = e.encodeDefaulter(n, o));
  for (var d = tt(c), f = new sW(o), p = 0; p < f.length; p++)
    f[p] = -1;
  function h(k) {
    var M = f[k];
    if (M < 0) {
      var D = r[k], N = ut(D) ? D : {
        name: D
      }, R = new D1(), j = N.name;
      j != null && u.get(j) != null && (R.name = R.displayName = j), N.type != null && (R.type = N.type), N.displayName != null && (R.displayName = N.displayName);
      var z = a.length;
      return f[k] = z, R.storeDimIndex = k, a.push(R), R;
    }
    return a[M];
  }
  if (!s)
    for (var p = 0; p < o; p++)
      h(p);
  d.each(function(k, M) {
    var D = wn(k).slice();
    if (D.length === 1 && !We(D[0]) && D[0] < 0) {
      d.set(M, !1);
      return;
    }
    var N = d.set(M, []);
    $(D, function(R, j) {
      var z = We(R) ? u.get(R) : R;
      z != null && z < o && (N[j] = z, m(h(z), M, j));
    });
  });
  var v = 0;
  $(t, function(k) {
    var M, D, N, R;
    if (We(k))
      M = k, R = {};
    else {
      R = k, M = R.name;
      var j = R.ordinalMeta;
      R.ordinalMeta = null, R = xe({}, R), R.ordinalMeta = j, D = R.dimsDef, N = R.otherDims, R.name = R.coordDim = R.coordDimIndex = R.dimsDef = R.otherDims = null;
    }
    var z = d.get(M);
    if (z !== !1) {
      if (z = wn(z), !z.length)
        for (var F = 0; F < (D && D.length || 1); F++) {
          for (; v < o && h(v).coordDim != null; )
            v++;
          v < o && z.push(v++);
        }
      $(z, function(B, H) {
        var Y = h(B);
        if (l && R.type != null && (Y.type = R.type), m(dt(Y, R), M, H), Y.name == null && D) {
          var ne = D[H];
          !ut(ne) && (ne = {
            name: ne
          }), Y.name = Y.displayName = ne.name, Y.defaultTooltip = ne.defaultTooltip;
        }
        N && dt(Y.otherDims, N);
      });
    }
  });
  function m(k, M, D) {
    _k.get(M) != null ? k.otherDims[M] = D : (k.coordDim = M, k.coordDimIndex = D, i.set(M, !0));
  }
  var g = e.generateCoord, y = e.generateCoordCount, b = y != null;
  y = g ? y || 1 : 0;
  var _ = g || "value";
  function x(k) {
    k.name == null && (k.name = k.coordDim);
  }
  if (s)
    $(a, function(k) {
      x(k);
    }), a.sort(function(k, M) {
      return k.storeDimIndex - M.storeDimIndex;
    });
  else
    for (var w = 0; w < o; w++) {
      var S = h(w), C = S.coordDim;
      C == null && (S.coordDim = o3e(_, i, b), S.coordDimIndex = 0, (!g || y <= 0) && (S.isExtraCoord = !0), y--), x(S), S.type == null && (UU(n, w) === qr.Must || S.isExtraCoord && (S.otherDims.itemName != null || S.otherDims.seriesName != null)) && (S.type = "ordinal");
    }
  return i3e(a), new KW({
    source: n,
    dimensions: a,
    fullDimensionCount: o,
    dimensionOmitted: s
  });
}
function i3e(n) {
  for (var e = tt(), t = 0; t < n.length; t++) {
    var r = n[t], i = r.name, a = e.get(i) || 0;
    a > 0 && (r.name = i + (a - 1)), a++, e.set(i, a);
  }
}
function a3e(n, e, t, r) {
  var i = Math.max(n.dimensionsDetectedCount || 1, e.length, t.length, r || 0);
  return $(e, function(a) {
    var o;
    ut(a) && (o = a.dimsDef) && (i = Math.max(i, o.length));
  }), i;
}
function o3e(n, e, t) {
  if (t || e.hasKey(n)) {
    for (var r = 0; e.hasKey(n + r); )
      r++;
    n += r;
  }
  return e.set(n, !0), n;
}
var s3e = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e) {
      this.coordSysDims = [], this.axisMap = tt(), this.categoryAxisMap = tt(), this.coordSysName = e;
    }
    return n;
  }()
);
function l3e(n) {
  var e = n.get("coordinateSystem"), t = new s3e(e), r = u3e[e];
  if (r)
    return r(n, t, t.axisMap, t.categoryAxisMap), t;
}
var u3e = {
  cartesian2d: function(n, e, t, r) {
    var i = n.getReferringComponents("xAxis", gr).models[0], a = n.getReferringComponents("yAxis", gr).models[0];
    if (process.env.NODE_ENV !== "production") {
      if (!i)
        throw new Error('xAxis "' + mr(n.get("xAxisIndex"), n.get("xAxisId"), 0) + '" not found');
      if (!a)
        throw new Error('yAxis "' + mr(n.get("xAxisIndex"), n.get("yAxisId"), 0) + '" not found');
    }
    e.coordSysDims = ["x", "y"], t.set("x", i), t.set("y", a), If(i) && (r.set("x", i), e.firstCategoryDimIndex = 0), If(a) && (r.set("y", a), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
  },
  singleAxis: function(n, e, t, r) {
    var i = n.getReferringComponents("singleAxis", gr).models[0];
    if (process.env.NODE_ENV !== "production" && !i)
      throw new Error("singleAxis should be specified.");
    e.coordSysDims = ["single"], t.set("single", i), If(i) && (r.set("single", i), e.firstCategoryDimIndex = 0);
  },
  polar: function(n, e, t, r) {
    var i = n.getReferringComponents("polar", gr).models[0], a = i.findAxisModel("radiusAxis"), o = i.findAxisModel("angleAxis");
    if (process.env.NODE_ENV !== "production") {
      if (!o)
        throw new Error("angleAxis option not found");
      if (!a)
        throw new Error("radiusAxis option not found");
    }
    e.coordSysDims = ["radius", "angle"], t.set("radius", a), t.set("angle", o), If(a) && (r.set("radius", a), e.firstCategoryDimIndex = 0), If(o) && (r.set("angle", o), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
  },
  geo: function(n, e, t, r) {
    e.coordSysDims = ["lng", "lat"];
  },
  parallel: function(n, e, t, r) {
    var i = n.ecModel, a = i.getComponent("parallel", n.get("parallelIndex")), o = e.coordSysDims = a.dimensions.slice();
    $(a.parallelAxisIndex, function(s, l) {
      var u = i.getComponent("parallelAxis", s), c = o[l];
      t.set(c, u), If(u) && (r.set(c, u), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = l));
    });
  }
};
function If(n) {
  return n.get("type") === "category";
}
function c3e(n, e, t) {
  t = t || {};
  var r = t.byIndex, i = t.stackedCoordDimension, a, o, s;
  d3e(e) ? a = e : (o = e.schema, a = o.dimensions, s = e.store);
  var l = !!(n && n.get("stack")), u, c, d, f;
  if ($(a, function(y, b) {
    We(y) && (a[b] = y = {
      name: y
    }), l && !y.isExtraCoord && (!r && !u && y.ordinalMeta && (u = y), !c && y.type !== "ordinal" && y.type !== "time" && (!i || i === y.coordDim) && (c = y));
  }), c && !r && !u && (r = !0), c) {
    d = "__\0ecstackresult_" + n.id, f = "__\0ecstackedover_" + n.id, u && (u.createInvertedIndices = !0);
    var p = c.coordDim, h = c.type, v = 0;
    $(a, function(y) {
      y.coordDim === p && v++;
    });
    var m = {
      name: d,
      coordDim: p,
      coordDimIndex: v,
      type: h,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length
    }, g = {
      name: f,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: f,
      coordDimIndex: v + 1,
      type: h,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length + 1
    };
    o ? (s && (m.storeDimIndex = s.ensureCalculationDimension(f, h), g.storeDimIndex = s.ensureCalculationDimension(d, h)), o.appendCalculationDimension(m), o.appendCalculationDimension(g)) : (a.push(m), a.push(g));
  }
  return {
    stackedDimension: c && c.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: r,
    stackedOverDimension: f,
    stackResultDimension: d
  };
}
function d3e(n) {
  return !XW(n.schema);
}
function Bu(n, e) {
  return !!e && e === n.getCalculationInfo("stackedDimension");
}
function eq(n, e) {
  return Bu(n, e) ? n.getCalculationInfo("stackResultDimension") : e;
}
function f3e(n, e) {
  var t = n.get("coordinateSystem"), r = gh.get(t), i;
  return e && e.coordSysDims && (i = De(e.coordSysDims, function(a) {
    var o = {
      name: a
    }, s = e.axisMap.get(a);
    if (s) {
      var l = s.get("type");
      o.type = m_(l);
    }
    return o;
  })), i || (i = r && (r.getDimensionsInfo ? r.getDimensionsInfo() : r.dimensions.slice()) || ["x", "y"]), i;
}
function p3e(n, e, t) {
  var r, i;
  return t && $(n, function(a, o) {
    var s = a.coordDim, l = t.categoryAxisMap.get(s);
    l && (r == null && (r = o), a.ordinalMeta = l.getOrdinalMeta(), e && (a.createInvertedIndices = !0)), a.otherDims.itemName != null && (i = !0);
  }), !i && r != null && (n[r].otherDims.itemName = 0), r;
}
function Dl(n, e, t) {
  t = t || {};
  var r = e.getSourceManager(), i, a = !1;
  n ? (a = !0, i = iO(n)) : (i = r.getSource(), a = i.sourceFormat === ao);
  var o = l3e(e), s = f3e(e, o), l = t.useEncodeDefaulter, u = at(l) ? l : l ? Tt(GU, s, e) : null, c = {
    coordDimensions: s,
    generateCoord: t.generateCoord,
    encodeDefine: e.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !a
  }, d = Kg(i, c), f = p3e(d.dimensions, t.createInvertedIndices, o), p = a ? null : r.getSharedDataStore(d), h = c3e(e, {
    schema: d,
    store: p
  }), v = new Oi(d, e);
  v.setCalculationInfo(h);
  var m = f != null && h3e(i) ? function(g, y, b, _) {
    return _ === f ? b : this.defaultDimValueGetter(g, y, b, _);
  } : null;
  return v.hasItemOption = !1, v.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    a ? i : p,
    null,
    m
  ), v;
}
function h3e(n) {
  if (n.sourceFormat === ao) {
    var e = v3e(n.data || []);
    return !Me(uh(e));
  }
}
function v3e(n) {
  for (var e = 0; e < n.length && n[e] == null; )
    e++;
  return n[e];
}
var Os = (
  /** @class */
  function() {
    function n(e) {
      this._setting = e || {}, this._extent = [1 / 0, -1 / 0];
    }
    return n.prototype.getSetting = function(e) {
      return this._setting[e];
    }, n.prototype.unionExtent = function(e) {
      var t = this._extent;
      e[0] < t[0] && (t[0] = e[0]), e[1] > t[1] && (t[1] = e[1]);
    }, n.prototype.unionExtentFromData = function(e, t) {
      this.unionExtent(e.getApproximateExtent(t));
    }, n.prototype.getExtent = function() {
      return this._extent.slice();
    }, n.prototype.setExtent = function(e, t) {
      var r = this._extent;
      isNaN(e) || (r[0] = e), isNaN(t) || (r[1] = t);
    }, n.prototype.isInExtentRange = function(e) {
      return this._extent[0] <= e && this._extent[1] >= e;
    }, n.prototype.isBlank = function() {
      return this._isBlank;
    }, n.prototype.setBlank = function(e) {
      this._isBlank = e;
    }, n;
  }()
);
Jx(Os);
var m3e = 0, Nk = (
  /** @class */
  function() {
    function n(e) {
      this.categories = e.categories || [], this._needCollect = e.needCollect, this._deduplication = e.deduplication, this.uid = ++m3e;
    }
    return n.createByAxisModel = function(e) {
      var t = e.option, r = t.data, i = r && De(r, g3e);
      return new n({
        categories: i,
        needCollect: !i,
        // deduplication is default in axis.
        deduplication: t.dedplication !== !1
      });
    }, n.prototype.getOrdinal = function(e) {
      return this._getOrCreateMap().get(e);
    }, n.prototype.parseAndCollect = function(e) {
      var t, r = this._needCollect;
      if (!We(e) && !r)
        return e;
      if (r && !this._deduplication)
        return t = this.categories.length, this.categories[t] = e, t;
      var i = this._getOrCreateMap();
      return t = i.get(e), t == null && (r ? (t = this.categories.length, this.categories[t] = e, i.set(e, t)) : t = NaN), t;
    }, n.prototype._getOrCreateMap = function() {
      return this._map || (this._map = tt(this.categories));
    }, n;
  }()
);
function g3e(n) {
  return ut(n) && n.value != null ? n.value : n + "";
}
function y3e(n) {
  var e = Math.pow(10, Xx(Math.abs(n))), t = Math.abs(n / e);
  return t === 0 || t === 1 || t === 2 || t === 3 || t === 5;
}
function Rk(n) {
  return n.type === "interval" || n.type === "log";
}
function b3e(n, e, t, r) {
  var i = {}, a = n[1] - n[0], o = i.interval = OG(a / e);
  t != null && o < t && (o = i.interval = t), r != null && o > r && (o = i.interval = r);
  var s = i.intervalPrecision = tq(o), l = i.niceTickExtent = [ir(Math.ceil(n[0] / o) * o, s), ir(Math.floor(n[1] / o) * o, s)];
  return _3e(l, n), i;
}
function X2(n) {
  var e = Math.pow(10, Xx(n)), t = n / e;
  return t ? t === 2 ? t = 3 : t === 3 ? t = 5 : t *= 2 : t = 1, ir(t * e);
}
function tq(n) {
  return ss(n) + 2;
}
function N5(n, e, t) {
  n[e] = Math.max(Math.min(n[e], t[1]), t[0]);
}
function _3e(n, e) {
  !isFinite(n[0]) && (n[0] = e[0]), !isFinite(n[1]) && (n[1] = e[1]), N5(n, 0, e), N5(n, 1, e), n[0] > n[1] && (n[0] = n[1]);
}
function bw(n, e) {
  return n >= e[0] && n <= e[1];
}
function _w(n, e) {
  return e[1] === e[0] ? 0.5 : (n - e[0]) / (e[1] - e[0]);
}
function xw(n, e) {
  return n * (e[1] - e[0]) + e[0];
}
var ww = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      r.type = "ordinal";
      var i = r.getSetting("ordinalMeta");
      return i || (i = new Nk({})), Me(i) && (i = new Nk({
        categories: De(i, function(a) {
          return ut(a) ? a.value : a;
        })
      })), r._ordinalMeta = i, r._extent = r.getSetting("extent") || [0, i.categories.length - 1], r;
    }
    return e.prototype.parse = function(t) {
      return t == null ? NaN : We(t) ? this._ordinalMeta.getOrdinal(t) : Math.round(t);
    }, e.prototype.contain = function(t) {
      return t = this.parse(t), bw(t, this._extent) && this._ordinalMeta.categories[t] != null;
    }, e.prototype.normalize = function(t) {
      return t = this._getTickNumber(this.parse(t)), _w(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = Math.round(xw(t, this._extent)), this.getRawOrdinalNumber(t);
    }, e.prototype.getTicks = function() {
      for (var t = [], r = this._extent, i = r[0]; i <= r[1]; )
        t.push({
          value: i
        }), i++;
      return t;
    }, e.prototype.getMinorTicks = function(t) {
    }, e.prototype.setSortInfo = function(t) {
      if (t == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var r = t.ordinalNumbers, i = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], o = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, r.length); o < l; ++o) {
        var u = r[o];
        i[o] = u, a[u] = o;
      }
      for (var c = 0; o < s; ++o) {
        for (; a[c] != null; )
          c++;
        i.push(c), a[c] = o;
      }
    }, e.prototype._getTickNumber = function(t) {
      var r = this._ticksByOrdinalNumber;
      return r && t >= 0 && t < r.length ? r[t] : t;
    }, e.prototype.getRawOrdinalNumber = function(t) {
      var r = this._ordinalNumbersByTick;
      return r && t >= 0 && t < r.length ? r[t] : t;
    }, e.prototype.getLabel = function(t) {
      if (!this.isBlank()) {
        var r = this.getRawOrdinalNumber(t.value), i = this._ordinalMeta.categories[r];
        return i == null ? "" : i + "";
      }
    }, e.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, e.prototype.unionExtentFromData = function(t, r) {
      this.unionExtent(t.getApproximateExtent(r));
    }, e.prototype.isInExtentRange = function(t) {
      return t = this._getTickNumber(t), this._extent[0] <= t && this._extent[1] >= t;
    }, e.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, e.prototype.calcNiceTicks = function() {
    }, e.prototype.calcNiceExtent = function() {
    }, e.type = "ordinal", e;
  }(Os)
);
Os.registerClass(ww);
var yc = ir, El = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "interval", t._interval = 0, t._intervalPrecision = 2, t;
    }
    return e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return bw(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return _w(t, this._extent);
    }, e.prototype.scale = function(t) {
      return xw(t, this._extent);
    }, e.prototype.setExtent = function(t, r) {
      var i = this._extent;
      isNaN(t) || (i[0] = parseFloat(t)), isNaN(r) || (i[1] = parseFloat(r));
    }, e.prototype.unionExtent = function(t) {
      var r = this._extent;
      t[0] < r[0] && (r[0] = t[0]), t[1] > r[1] && (r[1] = t[1]), this.setExtent(r[0], r[1]);
    }, e.prototype.getInterval = function() {
      return this._interval;
    }, e.prototype.setInterval = function(t) {
      this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = tq(t);
    }, e.prototype.getTicks = function(t) {
      var r = this._interval, i = this._extent, a = this._niceExtent, o = this._intervalPrecision, s = [];
      if (!r)
        return s;
      var l = 1e4;
      i[0] < a[0] && (t ? s.push({
        value: yc(a[0] - r, o)
      }) : s.push({
        value: i[0]
      }));
      for (var u = a[0]; u <= a[1] && (s.push({
        value: u
      }), u = yc(u + r, o), u !== s[s.length - 1].value); )
        if (s.length > l)
          return [];
      var c = s.length ? s[s.length - 1].value : a[1];
      return i[1] > c && (t ? s.push({
        value: yc(c + r, o)
      }) : s.push({
        value: i[1]
      })), s;
    }, e.prototype.getMinorTicks = function(t) {
      for (var r = this.getTicks(!0), i = [], a = this.getExtent(), o = 1; o < r.length; o++) {
        for (var s = r[o], l = r[o - 1], u = 0, c = [], d = s.value - l.value, f = d / t; u < t - 1; ) {
          var p = yc(l.value + (u + 1) * f);
          p > a[0] && p < a[1] && c.push(p), u++;
        }
        i.push(c);
      }
      return i;
    }, e.prototype.getLabel = function(t, r) {
      if (t == null)
        return "";
      var i = r && r.precision;
      i == null ? i = ss(t.value) || 0 : i === "auto" && (i = this._intervalPrecision);
      var a = yc(t.value, i, !0);
      return PU(a);
    }, e.prototype.calcNiceTicks = function(t, r, i) {
      t = t || 5;
      var a = this._extent, o = a[1] - a[0];
      if (isFinite(o)) {
        o < 0 && (o = -o, a.reverse());
        var s = b3e(a, t, r, i);
        this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      var r = this._extent;
      if (r[0] === r[1])
        if (r[0] !== 0) {
          var i = Math.abs(r[0]);
          t.fixMax || (r[1] += i / 2), r[0] -= i / 2;
        } else
          r[1] = 1;
      var a = r[1] - r[0];
      isFinite(a) || (r[0] = 0, r[1] = 1), this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
      var o = this._interval;
      t.fixMin || (r[0] = yc(Math.floor(r[0] / o) * o)), t.fixMax || (r[1] = yc(Math.ceil(r[1] / o) * o));
    }, e.prototype.setNiceExtent = function(t, r) {
      this._niceExtent = [t, r];
    }, e.type = "interval", e;
  }(Os)
);
Os.registerClass(El);
var nq = typeof Float32Array < "u", x3e = nq ? Float32Array : Array;
function us(n) {
  return Me(n) ? nq ? new Float32Array(n) : n : new x3e(n);
}
var Pk = "__ec_stack_";
function rq(n) {
  return n.get("stack") || Pk + n.seriesIndex;
}
function vO(n) {
  return n.dim + n.index;
}
function w3e(n) {
  var e = [], t = n.axis, r = "axis0";
  if (t.type === "category") {
    for (var i = t.getBandWidth(), a = 0; a < n.count; a++)
      e.push(dt({
        bandWidth: i,
        axisKey: r,
        stackId: Pk + a
      }, n));
    for (var o = oq(e), s = [], a = 0; a < n.count; a++) {
      var l = o[r][Pk + a];
      l.offsetCenter = l.offset + l.width / 2, s.push(l);
    }
    return s;
  }
}
function iq(n, e) {
  var t = [];
  return e.eachSeriesByType(n, function(r) {
    uq(r) && t.push(r);
  }), t;
}
function S3e(n) {
  var e = {};
  $(n, function(l) {
    var u = l.coordinateSystem, c = u.getBaseAxis();
    if (!(c.type !== "time" && c.type !== "value"))
      for (var d = l.getData(), f = c.dim + "_" + c.index, p = d.getDimensionIndex(d.mapDimension(c.dim)), h = d.getStore(), v = 0, m = h.count(); v < m; ++v) {
        var g = h.get(p, v);
        e[f] ? e[f].push(g) : e[f] = [g];
      }
  });
  var t = {};
  for (var r in e)
    if (e.hasOwnProperty(r)) {
      var i = e[r];
      if (i) {
        i.sort(function(l, u) {
          return l - u;
        });
        for (var a = null, o = 1; o < i.length; ++o) {
          var s = i[o] - i[o - 1];
          s > 0 && (a = a === null ? s : Math.min(a, s));
        }
        t[r] = a;
      }
    }
  return t;
}
function aq(n) {
  var e = S3e(n), t = [];
  return $(n, function(r) {
    var i = r.coordinateSystem, a = i.getBaseAxis(), o = a.getExtent(), s;
    if (a.type === "category")
      s = a.getBandWidth();
    else if (a.type === "value" || a.type === "time") {
      var l = a.dim + "_" + a.index, u = e[l], c = Math.abs(o[1] - o[0]), d = a.scale.getExtent(), f = Math.abs(d[1] - d[0]);
      s = u ? c / f * u : c;
    } else {
      var p = r.getData();
      s = Math.abs(o[1] - o[0]) / p.count();
    }
    var h = ze(r.get("barWidth"), s), v = ze(r.get("barMaxWidth"), s), m = ze(
      // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
      // the auto-calculated bar width might be less than 0.5 / 1.
      r.get("barMinWidth") || (cq(r) ? 0.5 : 1),
      s
    ), g = r.get("barGap"), y = r.get("barCategoryGap");
    t.push({
      bandWidth: s,
      barWidth: h,
      barMaxWidth: v,
      barMinWidth: m,
      barGap: g,
      barCategoryGap: y,
      axisKey: vO(a),
      stackId: rq(r)
    });
  }), oq(t);
}
function oq(n) {
  var e = {};
  $(n, function(r, i) {
    var a = r.axisKey, o = r.bandWidth, s = e[a] || {
      bandWidth: o,
      remainedWidth: o,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    }, l = s.stacks;
    e[a] = s;
    var u = r.stackId;
    l[u] || s.autoWidthCount++, l[u] = l[u] || {
      width: 0,
      maxWidth: 0
    };
    var c = r.barWidth;
    c && !l[u].width && (l[u].width = c, c = Math.min(s.remainedWidth, c), s.remainedWidth -= c);
    var d = r.barMaxWidth;
    d && (l[u].maxWidth = d);
    var f = r.barMinWidth;
    f && (l[u].minWidth = f);
    var p = r.barGap;
    p != null && (s.gap = p);
    var h = r.barCategoryGap;
    h != null && (s.categoryGap = h);
  });
  var t = {};
  return $(e, function(r, i) {
    t[i] = {};
    var a = r.stacks, o = r.bandWidth, s = r.categoryGap;
    if (s == null) {
      var l = Yt(a).length;
      s = Math.max(35 - l * 4, 15) + "%";
    }
    var u = ze(s, o), c = ze(r.gap, 1), d = r.remainedWidth, f = r.autoWidthCount, p = (d - u) / (f + (f - 1) * c);
    p = Math.max(p, 0), $(a, function(g) {
      var y = g.maxWidth, b = g.minWidth;
      if (g.width) {
        var _ = g.width;
        y && (_ = Math.min(_, y)), b && (_ = Math.max(_, b)), g.width = _, d -= _ + c * _, f--;
      } else {
        var _ = p;
        y && y < _ && (_ = Math.min(y, d)), b && b > _ && (_ = b), _ !== p && (g.width = _, d -= _ + c * _, f--);
      }
    }), p = (d - u) / (f + (f - 1) * c), p = Math.max(p, 0);
    var h = 0, v;
    $(a, function(g, y) {
      g.width || (g.width = p), v = g, h += g.width * (1 + c);
    }), v && (h -= v.width * c);
    var m = -h / 2;
    $(a, function(g, y) {
      t[i][y] = t[i][y] || {
        bandWidth: o,
        offset: m,
        width: g.width
      }, m += g.width * (1 + c);
    });
  }), t;
}
function E3e(n, e, t) {
  if (n && e) {
    var r = n[vO(e)];
    return r;
  }
}
function sq(n, e) {
  var t = iq(n, e), r = aq(t);
  $(t, function(i) {
    var a = i.getData(), o = i.coordinateSystem, s = o.getBaseAxis(), l = rq(i), u = r[vO(s)][l], c = u.offset, d = u.width;
    a.setLayout({
      bandWidth: u.bandWidth,
      offset: c,
      size: d
    });
  });
}
function lq(n) {
  return {
    seriesType: n,
    plan: yh(),
    reset: function(e) {
      if (uq(e)) {
        var t = e.getData(), r = e.coordinateSystem, i = r.getBaseAxis(), a = r.getOtherAxis(i), o = t.getDimensionIndex(t.mapDimension(a.dim)), s = t.getDimensionIndex(t.mapDimension(i.dim)), l = e.get("showBackground", !0), u = t.mapDimension(a.dim), c = t.getCalculationInfo("stackResultDimension"), d = Bu(t, u) && !!t.getCalculationInfo("stackedOnSeries"), f = a.isHorizontal(), p = T3e(i, a), h = cq(e), v = e.get("barMinHeight") || 0, m = c && t.getDimensionIndex(c), g = t.getLayout("size"), y = t.getLayout("offset");
        return {
          progress: function(b, _) {
            for (var x = b.count, w = h && us(x * 3), S = h && l && us(x * 3), C = h && us(x), k = r.master.getRect(), M = f ? k.width : k.height, D, N = _.getStore(), R = 0; (D = b.next()) != null; ) {
              var j = N.get(d ? m : o, D), z = N.get(s, D), F = p, B = void 0;
              d && (B = +j - N.get(o, D));
              var H = void 0, Y = void 0, ne = void 0, J = void 0;
              if (f) {
                var X = r.dataToPoint([j, z]);
                if (d) {
                  var ie = r.dataToPoint([B, z]);
                  F = ie[0];
                }
                H = F, Y = X[1] + y, ne = X[0] - F, J = g, Math.abs(ne) < v && (ne = (ne < 0 ? -1 : 1) * v);
              } else {
                var X = r.dataToPoint([z, j]);
                if (d) {
                  var ie = r.dataToPoint([z, B]);
                  F = ie[1];
                }
                H = X[0] + y, Y = F, ne = g, J = X[1] - F, Math.abs(J) < v && (J = (J <= 0 ? -1 : 1) * v);
              }
              h ? (w[R] = H, w[R + 1] = Y, w[R + 2] = f ? ne : J, S && (S[R] = f ? k.x : H, S[R + 1] = f ? Y : k.y, S[R + 2] = M), C[D] = D) : _.setItemLayout(D, {
                x: H,
                y: Y,
                width: ne,
                height: J
              }), R += 3;
            }
            h && _.setLayout({
              largePoints: w,
              largeDataIndices: C,
              largeBackgroundPoints: S,
              valueAxisHorizontal: f
            });
          }
        };
      }
    }
  };
}
function uq(n) {
  return n.coordinateSystem && n.coordinateSystem.type === "cartesian2d";
}
function cq(n) {
  return n.pipelineContext && n.pipelineContext.large;
}
function T3e(n, e) {
  var t = e.model.get("startValue");
  return t || (t = 0), e.toGlobalCoord(e.dataToCoord(e.type === "log" ? t > 0 ? t : 1 : t));
}
var C3e = function(n, e, t, r) {
  for (; t < r; ) {
    var i = t + r >>> 1;
    n[i][1] < e ? t = i + 1 : r = i;
  }
  return t;
}, mO = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "time", r;
    }
    return e.prototype.getLabel = function(t) {
      var r = this.getSetting("useUTC");
      return uw(t.value, Ej[rNe(xp(this._minLevelUnit))] || Ej.second, r, this.getSetting("locale"));
    }, e.prototype.getFormattedLabel = function(t, r, i) {
      var a = this.getSetting("useUTC"), o = this.getSetting("locale");
      return iNe(t, r, i, o, a);
    }, e.prototype.getTicks = function() {
      var t = this._interval, r = this._extent, i = [];
      if (!t)
        return i;
      i.push({
        value: r[0],
        level: 0
      });
      var a = this.getSetting("useUTC"), o = L3e(this._minLevelUnit, this._approxInterval, a, r);
      return i = i.concat(o), i.push({
        value: r[1],
        level: 0
      }), i;
    }, e.prototype.calcNiceExtent = function(t) {
      var r = this._extent;
      if (r[0] === r[1] && (r[0] -= qa, r[1] += qa), r[1] === -1 / 0 && r[0] === 1 / 0) {
        var i = /* @__PURE__ */ new Date();
        r[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), r[0] = r[1] - qa;
      }
      this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
    }, e.prototype.calcNiceTicks = function(t, r, i) {
      t = t || 10;
      var a = this._extent, o = a[1] - a[0];
      this._approxInterval = o / t, r != null && this._approxInterval < r && (this._approxInterval = r), i != null && this._approxInterval > i && (this._approxInterval = i);
      var s = k0.length, l = Math.min(C3e(k0, this._approxInterval, 0, s), s - 1);
      this._interval = k0[l][1], this._minLevelUnit = k0[Math.max(l - 1, 0)][0];
    }, e.prototype.parse = function(t) {
      return sn(t) ? t : +Es(t);
    }, e.prototype.contain = function(t) {
      return bw(this.parse(t), this._extent);
    }, e.prototype.normalize = function(t) {
      return _w(this.parse(t), this._extent);
    }, e.prototype.scale = function(t) {
      return xw(t, this._extent);
    }, e.type = "time", e;
  }(El)
), k0 = [
  // Format                           interval
  ["second", KD],
  ["minute", XD],
  ["hour", hm],
  ["quarter-day", hm * 6],
  ["half-day", hm * 12],
  ["day", qa * 1.2],
  ["half-week", qa * 3.5],
  ["week", qa * 7],
  ["month", qa * 31],
  ["quarter", qa * 95],
  ["half-year", Sj / 2],
  ["year", Sj]
  // 1Y
];
function k3e(n, e, t, r) {
  var i = Es(e), a = Es(t), o = function(h) {
    return Tj(i, h, r) === Tj(a, h, r);
  }, s = function() {
    return o("year");
  }, l = function() {
    return s() && o("month");
  }, u = function() {
    return l() && o("day");
  }, c = function() {
    return u() && o("hour");
  }, d = function() {
    return c() && o("minute");
  }, f = function() {
    return d() && o("second");
  }, p = function() {
    return f() && o("millisecond");
  };
  switch (n) {
    case "year":
      return s();
    case "month":
      return l();
    case "day":
      return u();
    case "hour":
      return c();
    case "minute":
      return d();
    case "second":
      return f();
    case "millisecond":
      return p();
  }
}
function A3e(n, e) {
  return n /= qa, n > 16 ? 16 : n > 7.5 ? 7 : n > 3.5 ? 4 : n > 1.5 ? 2 : 1;
}
function M3e(n) {
  var e = 30 * qa;
  return n /= e, n > 6 ? 6 : n > 3 ? 3 : n > 2 ? 2 : 1;
}
function D3e(n) {
  return n /= hm, n > 12 ? 12 : n > 6 ? 6 : n > 3.5 ? 4 : n > 2 ? 2 : 1;
}
function R5(n, e) {
  return n /= e ? XD : KD, n > 30 ? 30 : n > 20 ? 20 : n > 15 ? 15 : n > 10 ? 10 : n > 5 ? 5 : n > 2 ? 2 : 1;
}
function O3e(n) {
  return OG(n);
}
function I3e(n, e, t) {
  var r = new Date(n);
  switch (xp(e)) {
    case "year":
    case "month":
      r[DU(t)](0);
    case "day":
      r[OU(t)](1);
    case "hour":
      r[IU(t)](0);
    case "minute":
      r[LU(t)](0);
    case "second":
      r[NU(t)](0), r[RU(t)](0);
  }
  return r.getTime();
}
function L3e(n, e, t, r) {
  var i = 1e4, a = AU, o = 0;
  function s(M, D, N, R, j, z, F) {
    for (var B = new Date(D), H = D, Y = B[R](); H < N && H <= r[1]; )
      F.push({
        value: H
      }), Y += M, B[j](Y), H = B.getTime();
    F.push({
      value: H,
      notAdd: !0
    });
  }
  function l(M, D, N) {
    var R = [], j = !D.length;
    if (!k3e(xp(M), r[0], r[1], t)) {
      j && (D = [{
        // TODO Optimize. Not include so may ticks.
        value: I3e(new Date(r[0]), M, t)
      }, {
        value: r[1]
      }]);
      for (var z = 0; z < D.length - 1; z++) {
        var F = D[z].value, B = D[z + 1].value;
        if (F !== B) {
          var H = void 0, Y = void 0, ne = void 0, J = !1;
          switch (M) {
            case "year":
              H = Math.max(1, Math.round(e / qa / 365)), Y = ZD(t), ne = aNe(t);
              break;
            case "half-year":
            case "quarter":
            case "month":
              H = M3e(e), Y = wp(t), ne = DU(t);
              break;
            case "week":
            case "half-week":
            case "day":
              H = A3e(e), Y = cw(t), ne = OU(t), J = !0;
              break;
            case "half-day":
            case "quarter-day":
            case "hour":
              H = D3e(e), Y = ng(t), ne = IU(t);
              break;
            case "minute":
              H = R5(e, !0), Y = dw(t), ne = LU(t);
              break;
            case "second":
              H = R5(e, !1), Y = fw(t), ne = NU(t);
              break;
            case "millisecond":
              H = O3e(e), Y = pw(t), ne = RU(t);
              break;
          }
          s(H, F, B, Y, ne, J, R), M === "year" && N.length > 1 && z === 0 && N.unshift({
            value: N[0].value - H
          });
        }
      }
      for (var z = 0; z < R.length; z++)
        N.push(R[z]);
      return R;
    }
  }
  for (var u = [], c = [], d = 0, f = 0, p = 0; p < a.length && o++ < i; ++p) {
    var h = xp(a[p]);
    if (nNe(a[p])) {
      l(a[p], u[u.length - 1] || [], c);
      var v = a[p + 1] ? xp(a[p + 1]) : null;
      if (h !== v) {
        if (c.length) {
          f = d, c.sort(function(M, D) {
            return M.value - D.value;
          });
          for (var m = [], g = 0; g < c.length; ++g) {
            var y = c[g].value;
            (g === 0 || c[g - 1].value !== y) && (m.push(c[g]), y >= r[0] && y <= r[1] && d++);
          }
          var b = (r[1] - r[0]) / e;
          if (d > b * 1.5 && f > b / 1.5 || (u.push(m), d > b || n === a[p]))
            break;
        }
        c = [];
      }
    }
  }
  process.env.NODE_ENV !== "production" && o >= i && Jn("Exceed safe limit.");
  for (var _ = vn(De(u, function(M) {
    return vn(M, function(D) {
      return D.value >= r[0] && D.value <= r[1] && !D.notAdd;
    });
  }), function(M) {
    return M.length > 0;
  }), x = [], w = _.length - 1, p = 0; p < _.length; ++p)
    for (var S = _[p], C = 0; C < S.length; ++C)
      x.push({
        value: S[C].value,
        level: w - p
      });
  x.sort(function(M, D) {
    return M.value - D.value;
  });
  for (var k = [], p = 0; p < x.length; ++p)
    (p === 0 || x[p].value !== x[p - 1].value) && k.push(x[p]);
  return k;
}
Os.registerClass(mO);
var P5 = Os.prototype, ym = El.prototype, N3e = ir, R3e = Math.floor, P3e = Math.ceil, A0 = Math.pow, co = Math.log, gO = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "log", t.base = 10, t._originalScale = new El(), t._interval = 0, t;
    }
    return e.prototype.getTicks = function(t) {
      var r = this._originalScale, i = this._extent, a = r.getExtent(), o = ym.getTicks.call(this, t);
      return De(o, function(s) {
        var l = s.value, u = ir(A0(this.base, l));
        return u = l === i[0] && this._fixMin ? M0(u, a[0]) : u, u = l === i[1] && this._fixMax ? M0(u, a[1]) : u, {
          value: u
        };
      }, this);
    }, e.prototype.setExtent = function(t, r) {
      var i = co(this.base);
      t = co(Math.max(0, t)) / i, r = co(Math.max(0, r)) / i, ym.setExtent.call(this, t, r);
    }, e.prototype.getExtent = function() {
      var t = this.base, r = P5.getExtent.call(this);
      r[0] = A0(t, r[0]), r[1] = A0(t, r[1]);
      var i = this._originalScale, a = i.getExtent();
      return this._fixMin && (r[0] = M0(r[0], a[0])), this._fixMax && (r[1] = M0(r[1], a[1])), r;
    }, e.prototype.unionExtent = function(t) {
      this._originalScale.unionExtent(t);
      var r = this.base;
      t[0] = co(t[0]) / co(r), t[1] = co(t[1]) / co(r), P5.unionExtent.call(this, t);
    }, e.prototype.unionExtentFromData = function(t, r) {
      this.unionExtent(t.getApproximateExtent(r));
    }, e.prototype.calcNiceTicks = function(t) {
      t = t || 10;
      var r = this._extent, i = r[1] - r[0];
      if (!(i === 1 / 0 || i <= 0)) {
        var a = LOe(i), o = t / i * a;
        for (o <= 0.5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0; )
          a *= 10;
        var s = [ir(P3e(r[0] / a) * a), ir(R3e(r[1] / a) * a)];
        this._interval = a, this._niceExtent = s;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      ym.calcNiceExtent.call(this, t), this._fixMin = t.fixMin, this._fixMax = t.fixMax;
    }, e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return t = co(t) / co(this.base), bw(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return t = co(t) / co(this.base), _w(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = xw(t, this._extent), A0(this.base, t);
    }, e.type = "log", e;
  }(Os)
), dq = gO.prototype;
dq.getMinorTicks = ym.getMinorTicks;
dq.getLabel = ym.getLabel;
function M0(n, e) {
  return N3e(n, ss(e));
}
Os.registerClass(gO);
var j3e = (
  /** @class */
  function() {
    function n(e, t, r) {
      this._prepareParams(e, t, r);
    }
    return n.prototype._prepareParams = function(e, t, r) {
      r[1] < r[0] && (r = [NaN, NaN]), this._dataMin = r[0], this._dataMax = r[1];
      var i = this._isOrdinal = e.type === "ordinal";
      this._needCrossZero = e.type === "interval" && t.getNeedCrossZero && t.getNeedCrossZero();
      var a = t.get("min", !0);
      a == null && (a = t.get("startValue", !0));
      var o = this._modelMinRaw = a;
      at(o) ? this._modelMinNum = D0(e, o({
        min: r[0],
        max: r[1]
      })) : o !== "dataMin" && (this._modelMinNum = D0(e, o));
      var s = this._modelMaxRaw = t.get("max", !0);
      if (at(s) ? this._modelMaxNum = D0(e, s({
        min: r[0],
        max: r[1]
      })) : s !== "dataMax" && (this._modelMaxNum = D0(e, s)), i)
        this._axisDataLen = t.getCategories().length;
      else {
        var l = t.get("boundaryGap"), u = Me(l) ? l : [l || 0, l || 0];
        typeof u[0] == "boolean" || typeof u[1] == "boolean" ? (process.env.NODE_ENV !== "production" && console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.'), this._boundaryGapInner = [0, 0]) : this._boundaryGapInner = [Mo(u[0], 1), Mo(u[1], 1)];
      }
    }, n.prototype.calculate = function() {
      var e = this._isOrdinal, t = this._dataMin, r = this._dataMax, i = this._axisDataLen, a = this._boundaryGapInner, o = e ? null : r - t || Math.abs(t), s = this._modelMinRaw === "dataMin" ? t : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? r : this._modelMaxNum, u = s != null, c = l != null;
      s == null && (s = e ? i ? 0 : NaN : t - a[0] * o), l == null && (l = e ? i ? i - 1 : NaN : r + a[1] * o), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN);
      var d = Dd(s) || Dd(l) || e && !i;
      this._needCrossZero && (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !c && (l = 0));
      var f = this._determinedMin, p = this._determinedMax;
      return f != null && (s = f, u = !0), p != null && (l = p, c = !0), {
        min: s,
        max: l,
        minFixed: u,
        maxFixed: c,
        isBlank: d
      };
    }, n.prototype.modifyDataMinMax = function(e, t) {
      process.env.NODE_ENV !== "production" && ct(!this.frozen), this[$3e[e]] = t;
    }, n.prototype.setDeterminedMinMax = function(e, t) {
      var r = B3e[e];
      process.env.NODE_ENV !== "production" && ct(!this.frozen && this[r] == null), this[r] = t;
    }, n.prototype.freeze = function() {
      this.frozen = !0;
    }, n;
  }()
), B3e = {
  min: "_determinedMin",
  max: "_determinedMax"
}, $3e = {
  min: "_dataMin",
  max: "_dataMax"
};
function fq(n, e, t) {
  var r = n.rawExtentInfo;
  return r || (r = new j3e(n, e, t), n.rawExtentInfo = r, r);
}
function D0(n, e) {
  return e == null ? null : Dd(e) ? NaN : n.parse(e);
}
function pq(n, e) {
  var t = n.type, r = fq(n, e, n.getExtent()).calculate();
  n.setBlank(r.isBlank);
  var i = r.min, a = r.max, o = e.ecModel;
  if (o && t === "time") {
    var s = iq("bar", o), l = !1;
    if ($(s, function(d) {
      l = l || d.getBaseAxis() === e.axis;
    }), l) {
      var u = aq(s), c = z3e(i, a, e, u);
      i = c.min, a = c.max;
    }
  }
  return {
    extent: [i, a],
    // "fix" means "fixed", the value should not be
    // changed in the subsequent steps.
    fixMin: r.minFixed,
    fixMax: r.maxFixed
  };
}
function z3e(n, e, t, r) {
  var i = t.axis.getExtent(), a = Math.abs(i[1] - i[0]), o = E3e(r, t.axis);
  if (o === void 0)
    return {
      min: n,
      max: e
    };
  var s = 1 / 0;
  $(o, function(p) {
    s = Math.min(p.offset, s);
  });
  var l = -1 / 0;
  $(o, function(p) {
    l = Math.max(p.offset + p.width, l);
  }), s = Math.abs(s), l = Math.abs(l);
  var u = s + l, c = e - n, d = 1 - (s + l) / a, f = c / d - c;
  return e += f * (l / u), n -= f * (s / u), {
    min: n,
    max: e
  };
}
function Gp(n, e) {
  var t = e, r = pq(n, t), i = r.extent, a = t.get("splitNumber");
  n instanceof gO && (n.base = t.get("logBase"));
  var o = n.type, s = t.get("interval"), l = o === "interval" || o === "time";
  n.setExtent(i[0], i[1]), n.calcNiceExtent({
    splitNumber: a,
    fixMin: r.fixMin,
    fixMax: r.fixMax,
    minInterval: l ? t.get("minInterval") : null,
    maxInterval: l ? t.get("maxInterval") : null
  }), s != null && n.setInterval && n.setInterval(s);
}
function Sw(n, e) {
  if (e = e || n.get("type"), e)
    switch (e) {
      case "category":
        return new ww({
          ordinalMeta: n.getOrdinalMeta ? n.getOrdinalMeta() : n.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new mO({
          locale: n.ecModel.getLocaleModel(),
          useUTC: n.ecModel.get("useUTC")
        });
      default:
        return new (Os.getClass(e) || El)();
    }
}
function F3e(n) {
  var e = n.scale.getExtent(), t = e[0], r = e[1];
  return !(t > 0 && r > 0 || t < 0 && r < 0);
}
function xh(n) {
  var e = n.getLabelModel().get("formatter"), t = n.type === "category" ? n.scale.getExtent()[0] : null;
  return n.scale.type === "time" ? /* @__PURE__ */ function(r) {
    return function(i, a) {
      return n.scale.getFormattedLabel(i, a, r);
    };
  }(e) : We(e) ? /* @__PURE__ */ function(r) {
    return function(i) {
      var a = n.scale.getLabel(i), o = r.replace("{value}", a ?? "");
      return o;
    };
  }(e) : at(e) ? /* @__PURE__ */ function(r) {
    return function(i, a) {
      return t != null && (a = i.value - t), r(yO(n, i), a, i.level != null ? {
        level: i.level
      } : null);
    };
  }(e) : function(r) {
    return n.scale.getLabel(r);
  };
}
function yO(n, e) {
  return n.type === "category" ? n.scale.getLabel(e) : e.value;
}
function V3e(n) {
  var e = n.model, t = n.scale;
  if (!(!e.get(["axisLabel", "show"]) || t.isBlank())) {
    var r, i, a = t.getExtent();
    t instanceof ww ? i = t.count() : (r = t.getTicks(), i = r.length);
    var o = n.getLabelModel(), s = xh(n), l, u = 1;
    i > 40 && (u = Math.ceil(i / 40));
    for (var c = 0; c < i; c += u) {
      var d = r ? r[c] : {
        value: a[0] + c
      }, f = s(d, c), p = o.getTextRect(f), h = H3e(p, o.get("rotate") || 0);
      l ? l.union(h) : l = h;
    }
    return l;
  }
}
function H3e(n, e) {
  var t = e * Math.PI / 180, r = n.width, i = n.height, a = r * Math.abs(Math.cos(t)) + Math.abs(i * Math.sin(t)), o = r * Math.abs(Math.sin(t)) + Math.abs(i * Math.cos(t)), s = new Ot(n.x, n.y, a, o);
  return s;
}
function bO(n) {
  var e = n.get("interval");
  return e ?? "auto";
}
function hq(n) {
  return n.type === "category" && bO(n.getLabelModel()) === 0;
}
function g_(n, e) {
  var t = {};
  return $(n.mapDimensionsAll(e), function(r) {
    t[eq(n, r)] = !0;
  }), Yt(t);
}
function G3e(n, e, t) {
  e && $(g_(e, t), function(r) {
    var i = e.getApproximateExtent(r);
    i[0] < n[0] && (n[0] = i[0]), i[1] > n[1] && (n[1] = i[1]);
  });
}
var Xg = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getNeedCrossZero = function() {
      var e = this.option;
      return !e.scale;
    }, n.prototype.getCoordSysModel = function() {
    }, n;
  }()
), U3e = 1e-8;
function j5(n, e) {
  return Math.abs(n - e) < U3e;
}
function Nc(n, e, t) {
  var r = 0, i = n[0];
  if (!i)
    return !1;
  for (var a = 1; a < n.length; a++) {
    var o = n[a];
    r += Ys(i[0], i[1], o[0], o[1], e, t), i = o;
  }
  var s = n[0];
  return (!j5(i[0], s[0]) || !j5(i[1], s[1])) && (r += Ys(i[0], i[1], s[0], s[1], e, t)), r !== 0;
}
var W3e = [];
function Z2(n, e) {
  for (var t = 0; t < n.length; t++)
    Zr(n[t], n[t], e);
}
function B5(n, e, t, r) {
  for (var i = 0; i < n.length; i++) {
    var a = n[i];
    r && (a = r.project(a)), a && isFinite(a[0]) && isFinite(a[1]) && (fu(e, e, a), pu(t, t, a));
  }
}
function q3e(n) {
  for (var e = 0, t = 0, r = 0, i = n.length, a = n[i - 1][0], o = n[i - 1][1], s = 0; s < i; s++) {
    var l = n[s][0], u = n[s][1], c = a * u - l * o;
    e += c, t += (a + l) * c, r += (o + u) * c, a = l, o = u;
  }
  return e ? [t / e / 3, r / e / 3, e] : [n[0][0] || 0, n[0][1] || 0];
}
var vq = (
  /** @class */
  function() {
    function n(e) {
      this.name = e;
    }
    return n.prototype.setCenter = function(e) {
      this._center = e;
    }, n.prototype.getCenter = function() {
      var e = this._center;
      return e || (e = this._center = this.calcCenter()), e;
    }, n;
  }()
), $5 = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e, t) {
      this.type = "polygon", this.exterior = e, this.interiors = t;
    }
    return n;
  }()
), z5 = (
  /** @class */
  /* @__PURE__ */ function() {
    function n(e) {
      this.type = "linestring", this.points = e;
    }
    return n;
  }()
), mq = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i) {
      var a = n.call(this, t) || this;
      return a.type = "geoJSON", a.geometries = r, a._center = i && [i[0], i[1]], a;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this.geometries, r, i = 0, a = 0; a < t.length; a++) {
        var o = t[a], s = o.exterior, l = s && s.length;
        l > i && (r = o, i = l);
      }
      if (r)
        return q3e(r.exterior);
      var u = this.getBoundingRect();
      return [u.x + u.width / 2, u.y + u.height / 2];
    }, e.prototype.getBoundingRect = function(t) {
      var r = this._rect;
      if (r && !t)
        return r;
      var i = [1 / 0, 1 / 0], a = [-1 / 0, -1 / 0], o = this.geometries;
      return $(o, function(s) {
        s.type === "polygon" ? B5(s.exterior, i, a, t) : $(s.points, function(l) {
          B5(l, i, a, t);
        });
      }), isFinite(i[0]) && isFinite(i[1]) && isFinite(a[0]) && isFinite(a[1]) || (i[0] = i[1] = a[0] = a[1] = 0), r = new Ot(i[0], i[1], a[0] - i[0], a[1] - i[1]), t || (this._rect = r), r;
    }, e.prototype.contain = function(t) {
      var r = this.getBoundingRect(), i = this.geometries;
      if (!r.contain(t[0], t[1]))
        return !1;
      e: for (var a = 0, o = i.length; a < o; a++) {
        var s = i[a];
        if (s.type === "polygon") {
          var l = s.exterior, u = s.interiors;
          if (Nc(l, t[0], t[1])) {
            for (var c = 0; c < (u ? u.length : 0); c++)
              if (Nc(u[c], t[0], t[1]))
                continue e;
            return !0;
          }
        }
      }
      return !1;
    }, e.prototype.transformTo = function(t, r, i, a) {
      var o = this.getBoundingRect(), s = o.width / o.height;
      i ? a || (a = i / s) : i = s * a;
      for (var l = new Ot(t, r, i, a), u = o.calculateTransform(l), c = this.geometries, d = 0; d < c.length; d++) {
        var f = c[d];
        f.type === "polygon" ? (Z2(f.exterior, u), $(f.interiors, function(p) {
          Z2(p, u);
        })) : $(f.points, function(p) {
          Z2(p, u);
        });
      }
      o = this._rect, o.copy(l), this._center = [o.x + o.width / 2, o.y + o.height / 2];
    }, e.prototype.cloneShallow = function(t) {
      t == null && (t = this.name);
      var r = new e(t, this.geometries, this._center);
      return r._rect = this._rect, r.transformTo = null, r;
    }, e;
  }(vq)
), Y3e = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r) {
      var i = n.call(this, t) || this;
      return i.type = "geoSVG", i._elOnlyForCalculate = r, i;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this._elOnlyForCalculate, r = t.getBoundingRect(), i = [r.x + r.width / 2, r.y + r.height / 2], a = Wx(W3e), o = t; o && !o.isGeoSVGGraphicRoot; )
        cl(a, o.getLocalTransform(), a), o = o.parent;
      return lh(a, a), Zr(i, i, a), i;
    }, e;
  }(vq)
);
function K3e(n) {
  if (!n.UTF8Encoding)
    return n;
  var e = n, t = e.UTF8Scale;
  t == null && (t = 1024);
  var r = e.features;
  return $(r, function(i) {
    var a = i.geometry, o = a.encodeOffsets, s = a.coordinates;
    if (o)
      switch (a.type) {
        case "LineString":
          a.coordinates = gq(s, o, t);
          break;
        case "Polygon":
          J2(s, o, t);
          break;
        case "MultiLineString":
          J2(s, o, t);
          break;
        case "MultiPolygon":
          $(s, function(l, u) {
            return J2(l, o[u], t);
          });
      }
  }), e.UTF8Encoding = !1, e;
}
function J2(n, e, t) {
  for (var r = 0; r < n.length; r++)
    n[r] = gq(n[r], e[r], t);
}
function gq(n, e, t) {
  for (var r = [], i = e[0], a = e[1], o = 0; o < n.length; o += 2) {
    var s = n.charCodeAt(o) - 64, l = n.charCodeAt(o + 1) - 64;
    s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += i, l += a, i = s, a = l, r.push([s / t, l / t]);
  }
  return r;
}
function X3e(n, e) {
  return n = K3e(n), De(vn(n.features, function(t) {
    return t.geometry && t.properties && t.geometry.coordinates.length > 0;
  }), function(t) {
    var r = t.properties, i = t.geometry, a = [];
    switch (i.type) {
      case "Polygon":
        var o = i.coordinates;
        a.push(new $5(o[0], o.slice(1)));
        break;
      case "MultiPolygon":
        $(i.coordinates, function(l) {
          l[0] && a.push(new $5(l[0], l.slice(1)));
        });
        break;
      case "LineString":
        a.push(new z5([i.coordinates]));
        break;
      case "MultiLineString":
        a.push(new z5(i.coordinates));
    }
    var s = new mq(r[e || "name"], a, r.cp);
    return s.properties = r, s;
  });
}
var lg = en();
function yq(n, e) {
  var t = De(e, function(r) {
    return n.scale.parse(r);
  });
  return n.type === "time" && t.length > 0 && (t.sort(), t.unshift(t[0]), t.push(t[t.length - 1])), t;
}
function Z3e(n) {
  var e = n.getLabelModel().get("customValues");
  if (e) {
    var t = xh(n), r = n.scale.getExtent(), i = yq(n, e), a = vn(i, function(o) {
      return o >= r[0] && o <= r[1];
    });
    return {
      labels: De(a, function(o) {
        var s = {
          value: o
        };
        return {
          formattedLabel: t(s),
          rawLabel: n.scale.getLabel(s),
          tickValue: o
        };
      })
    };
  }
  return n.type === "category" ? Q3e(n) : tje(n);
}
function J3e(n, e) {
  var t = n.getTickModel().get("customValues");
  if (t) {
    var r = n.scale.getExtent(), i = yq(n, t);
    return {
      ticks: vn(i, function(a) {
        return a >= r[0] && a <= r[1];
      })
    };
  }
  return n.type === "category" ? eje(n, e) : {
    ticks: De(n.scale.getTicks(), function(a) {
      return a.value;
    })
  };
}
function Q3e(n) {
  var e = n.getLabelModel(), t = bq(n, e);
  return !e.get("show") || n.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: t.labelCategoryInterval
  } : t;
}
function bq(n, e) {
  var t = _q(n, "labels"), r = bO(e), i = xq(t, r);
  if (i)
    return i;
  var a, o;
  return at(r) ? a = Eq(n, r) : (o = r === "auto" ? nje(n) : r, a = Sq(n, o)), wq(t, r, {
    labels: a,
    labelCategoryInterval: o
  });
}
function eje(n, e) {
  var t = _q(n, "ticks"), r = bO(e), i = xq(t, r);
  if (i)
    return i;
  var a, o;
  if ((!e.get("show") || n.scale.isBlank()) && (a = []), at(r))
    a = Eq(n, r, !0);
  else if (r === "auto") {
    var s = bq(n, n.getLabelModel());
    o = s.labelCategoryInterval, a = De(s.labels, function(l) {
      return l.tickValue;
    });
  } else
    o = r, a = Sq(n, o, !0);
  return wq(t, r, {
    ticks: a,
    tickCategoryInterval: o
  });
}
function tje(n) {
  var e = n.scale.getTicks(), t = xh(n);
  return {
    labels: De(e, function(r, i) {
      return {
        level: r.level,
        formattedLabel: t(r, i),
        rawLabel: n.scale.getLabel(r),
        tickValue: r.value
      };
    })
  };
}
function _q(n, e) {
  return lg(n)[e] || (lg(n)[e] = []);
}
function xq(n, e) {
  for (var t = 0; t < n.length; t++)
    if (n[t].key === e)
      return n[t].value;
}
function wq(n, e, t) {
  return n.push({
    key: e,
    value: t
  }), t;
}
function nje(n) {
  var e = lg(n).autoInterval;
  return e ?? (lg(n).autoInterval = n.calculateCategoryInterval());
}
function rje(n) {
  var e = ije(n), t = xh(n), r = (e.axisRotate - e.labelRotate) / 180 * Math.PI, i = n.scale, a = i.getExtent(), o = i.count();
  if (a[1] - a[0] < 1)
    return 0;
  var s = 1;
  o > 40 && (s = Math.max(1, Math.floor(o / 40)));
  for (var l = a[0], u = n.dataToCoord(l + 1) - n.dataToCoord(l), c = Math.abs(u * Math.cos(r)), d = Math.abs(u * Math.sin(r)), f = 0, p = 0; l <= a[1]; l += s) {
    var h = 0, v = 0, m = zg(t({
      value: l
    }), e.font, "center", "top");
    h = m.width * 1.3, v = m.height * 1.3, f = Math.max(f, h, 7), p = Math.max(p, v, 7);
  }
  var g = f / c, y = p / d;
  isNaN(g) && (g = 1 / 0), isNaN(y) && (y = 1 / 0);
  var b = Math.max(0, Math.floor(Math.min(g, y))), _ = lg(n.model), x = n.getExtent(), w = _.lastAutoInterval, S = _.lastTickCount;
  return w != null && S != null && Math.abs(w - b) <= 1 && Math.abs(S - o) <= 1 && w > b && _.axisExtent0 === x[0] && _.axisExtent1 === x[1] ? b = w : (_.lastTickCount = o, _.lastAutoInterval = b, _.axisExtent0 = x[0], _.axisExtent1 = x[1]), b;
}
function ije(n) {
  var e = n.getLabelModel();
  return {
    axisRotate: n.getRotate ? n.getRotate() : n.isHorizontal && !n.isHorizontal() ? 90 : 0,
    labelRotate: e.get("rotate") || 0,
    font: e.getFont()
  };
}
function Sq(n, e, t) {
  var r = xh(n), i = n.scale, a = i.getExtent(), o = n.getLabelModel(), s = [], l = Math.max((e || 0) + 1, 1), u = a[0], c = i.count();
  u !== 0 && l > 1 && c / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
  var d = hq(n), f = o.get("showMinLabel") || d, p = o.get("showMaxLabel") || d;
  f && u !== a[0] && v(a[0]);
  for (var h = u; h <= a[1]; h += l)
    v(h);
  p && h - l !== a[1] && v(a[1]);
  function v(m) {
    var g = {
      value: m
    };
    s.push(t ? m : {
      formattedLabel: r(g),
      rawLabel: i.getLabel(g),
      tickValue: m
    });
  }
  return s;
}
function Eq(n, e, t) {
  var r = n.scale, i = xh(n), a = [];
  return $(r.getTicks(), function(o) {
    var s = r.getLabel(o), l = o.value;
    e(o.value, s) && a.push(t ? l : {
      formattedLabel: i(o),
      rawLabel: s,
      tickValue: l
    });
  }), a;
}
var F5 = [0, 1], Po = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.onBand = !1, this.inverse = !1, this.dim = e, this.scale = t, this._extent = r || [0, 0];
    }
    return n.prototype.contain = function(e) {
      var t = this._extent, r = Math.min(t[0], t[1]), i = Math.max(t[0], t[1]);
      return e >= r && e <= i;
    }, n.prototype.containData = function(e) {
      return this.scale.contain(e);
    }, n.prototype.getExtent = function() {
      return this._extent.slice();
    }, n.prototype.getPixelPrecision = function(e) {
      return MG(e || this.scale.getExtent(), this._extent);
    }, n.prototype.setExtent = function(e, t) {
      var r = this._extent;
      r[0] = e, r[1] = t;
    }, n.prototype.dataToCoord = function(e, t) {
      var r = this._extent, i = this.scale;
      return e = i.normalize(e), this.onBand && i.type === "ordinal" && (r = r.slice(), V5(r, i.count())), mn(e, F5, r, t);
    }, n.prototype.coordToData = function(e, t) {
      var r = this._extent, i = this.scale;
      this.onBand && i.type === "ordinal" && (r = r.slice(), V5(r, i.count()));
      var a = mn(e, r, F5, t);
      return this.scale.scale(a);
    }, n.prototype.pointToData = function(e, t) {
    }, n.prototype.getTicksCoords = function(e) {
      e = e || {};
      var t = e.tickModel || this.getTickModel(), r = J3e(this, t), i = r.ticks, a = De(i, function(s) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s),
          tickValue: s
        };
      }, this), o = t.get("alignWithLabel");
      return aje(this, a, o, e.clamp), a;
    }, n.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal")
        return [];
      var e = this.model.getModel("minorTick"), t = e.get("splitNumber");
      t > 0 && t < 100 || (t = 5);
      var r = this.scale.getMinorTicks(t), i = De(r, function(a) {
        return De(a, function(o) {
          return {
            coord: this.dataToCoord(o),
            tickValue: o
          };
        }, this);
      }, this);
      return i;
    }, n.prototype.getViewLabels = function() {
      return Z3e(this).labels;
    }, n.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, n.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, n.prototype.getBandWidth = function() {
      var e = this._extent, t = this.scale.getExtent(), r = t[1] - t[0] + (this.onBand ? 1 : 0);
      r === 0 && (r = 1);
      var i = Math.abs(e[1] - e[0]);
      return Math.abs(i) / r;
    }, n.prototype.calculateCategoryInterval = function() {
      return rje(this);
    }, n;
  }()
);
function V5(n, e) {
  var t = n[1] - n[0], r = e, i = t / r / 2;
  n[0] += i, n[1] -= i;
}
function aje(n, e, t, r) {
  var i = e.length;
  if (!n.onBand || t || !i)
    return;
  var a = n.getExtent(), o, s;
  if (i === 1)
    e[0].coord = a[0], o = e[1] = {
      coord: a[1],
      tickValue: e[0].tickValue
    };
  else {
    var l = e[i - 1].tickValue - e[0].tickValue, u = (e[i - 1].coord - e[0].coord) / l;
    $(e, function(p) {
      p.coord -= u / 2;
    });
    var c = n.scale.getExtent();
    s = 1 + c[1] - e[i - 1].tickValue, o = {
      coord: e[i - 1].coord + u * s,
      tickValue: c[1] + 1
    }, e.push(o);
  }
  var d = a[0] > a[1];
  f(e[0].coord, a[0]) && (r ? e[0].coord = a[0] : e.shift()), r && f(a[0], e[0].coord) && e.unshift({
    coord: a[0]
  }), f(a[1], o.coord) && (r ? o.coord = a[1] : e.pop()), r && f(o.coord, a[1]) && e.push({
    coord: a[1]
  });
  function f(p, h) {
    return p = ir(p), h = ir(h), d ? p > h : p < h;
  }
}
var cv = Math.PI * 2, bc = Ts.CMD, oje = ["top", "right", "bottom", "left"];
function sje(n, e, t, r, i) {
  var a = t.width, o = t.height;
  switch (n) {
    case "top":
      r.set(t.x + a / 2, t.y - e), i.set(0, -1);
      break;
    case "bottom":
      r.set(t.x + a / 2, t.y + o + e), i.set(0, 1);
      break;
    case "left":
      r.set(t.x - e, t.y + o / 2), i.set(-1, 0);
      break;
    case "right":
      r.set(t.x + a + e, t.y + o / 2), i.set(1, 0);
      break;
  }
}
function lje(n, e, t, r, i, a, o, s, l) {
  o -= n, s -= e;
  var u = Math.sqrt(o * o + s * s);
  o /= u, s /= u;
  var c = o * t + n, d = s * t + e;
  if (Math.abs(r - i) % cv < 1e-4)
    return l[0] = c, l[1] = d, u - t;
  if (a) {
    var f = r;
    r = va(i), i = va(f);
  } else
    r = va(r), i = va(i);
  r > i && (i += cv);
  var p = Math.atan2(s, o);
  if (p < 0 && (p += cv), p >= r && p <= i || p + cv >= r && p + cv <= i)
    return l[0] = c, l[1] = d, u - t;
  var h = t * Math.cos(r) + n, v = t * Math.sin(r) + e, m = t * Math.cos(i) + n, g = t * Math.sin(i) + e, y = (h - o) * (h - o) + (v - s) * (v - s), b = (m - o) * (m - o) + (g - s) * (g - s);
  return y < b ? (l[0] = h, l[1] = v, Math.sqrt(y)) : (l[0] = m, l[1] = g, Math.sqrt(b));
}
function y_(n, e, t, r, i, a, o, s) {
  var l = i - n, u = a - e, c = t - n, d = r - e, f = Math.sqrt(c * c + d * d);
  c /= f, d /= f;
  var p = l * c + u * d, h = p / f;
  s && (h = Math.min(Math.max(h, 0), 1)), h *= f;
  var v = o[0] = n + h * c, m = o[1] = e + h * d;
  return Math.sqrt((v - i) * (v - i) + (m - a) * (m - a));
}
function Tq(n, e, t, r, i, a, o) {
  t < 0 && (n = n + t, t = -t), r < 0 && (e = e + r, r = -r);
  var s = n + t, l = e + r, u = o[0] = Math.min(Math.max(i, n), s), c = o[1] = Math.min(Math.max(a, e), l);
  return Math.sqrt((u - i) * (u - i) + (c - a) * (c - a));
}
var mo = [];
function uje(n, e, t) {
  var r = Tq(e.x, e.y, e.width, e.height, n.x, n.y, mo);
  return t.set(mo[0], mo[1]), r;
}
function cje(n, e, t) {
  for (var r = 0, i = 0, a = 0, o = 0, s, l, u = 1 / 0, c = e.data, d = n.x, f = n.y, p = 0; p < c.length; ) {
    var h = c[p++];
    p === 1 && (r = c[p], i = c[p + 1], a = r, o = i);
    var v = u;
    switch (h) {
      case bc.M:
        a = c[p++], o = c[p++], r = a, i = o;
        break;
      case bc.L:
        v = y_(r, i, c[p], c[p + 1], d, f, mo, !0), r = c[p++], i = c[p++];
        break;
      case bc.C:
        v = dG(r, i, c[p++], c[p++], c[p++], c[p++], c[p], c[p + 1], d, f, mo), r = c[p++], i = c[p++];
        break;
      case bc.Q:
        v = pG(r, i, c[p++], c[p++], c[p], c[p + 1], d, f, mo), r = c[p++], i = c[p++];
        break;
      case bc.A:
        var m = c[p++], g = c[p++], y = c[p++], b = c[p++], _ = c[p++], x = c[p++];
        p += 1;
        var w = !!(1 - c[p++]);
        s = Math.cos(_) * y + m, l = Math.sin(_) * b + g, p <= 1 && (a = s, o = l);
        var S = (d - m) * b / y + m;
        v = lje(m, g, b, _, _ + x, w, S, f, mo), r = Math.cos(_ + x) * y + m, i = Math.sin(_ + x) * b + g;
        break;
      case bc.R:
        a = r = c[p++], o = i = c[p++];
        var C = c[p++], k = c[p++];
        v = Tq(a, o, C, k, d, f, mo);
        break;
      case bc.Z:
        v = y_(r, i, a, o, d, f, mo, !0), r = a, i = o;
        break;
    }
    v < u && (u = v, t.set(mo[0], mo[1]));
  }
  return u;
}
var bo = new Mt(), On = new Mt(), sr = new Mt(), cs = new Mt(), ts = new Mt();
function H5(n, e) {
  if (n) {
    var t = n.getTextGuideLine(), r = n.getTextContent();
    if (r && t) {
      var i = n.textGuideLineConfig || {}, a = [[0, 0], [0, 0], [0, 0]], o = i.candidates || oje, s = r.getBoundingRect().clone();
      s.applyTransform(r.getComputedTransform());
      var l = 1 / 0, u = i.anchor, c = n.getComputedTransform(), d = c && lh([], c), f = e.get("length2") || 0;
      u && sr.copy(u);
      for (var p = 0; p < o.length; p++) {
        var h = o[p];
        sje(h, 0, s, bo, cs), Mt.scaleAndAdd(On, bo, cs, f), On.transform(d);
        var v = n.getBoundingRect(), m = u ? u.distance(On) : n instanceof Ht ? cje(On, n.path, sr) : uje(On, v, sr);
        m < l && (l = m, On.transform(c), sr.transform(c), sr.toArray(a[0]), On.toArray(a[1]), bo.toArray(a[2]));
      }
      Cq(a, e.get("minTurnAngle")), t.setShape({
        points: a
      });
    }
  }
}
var b_ = [], Ci = new Mt();
function Cq(n, e) {
  if (e <= 180 && e > 0) {
    e = e / 180 * Math.PI, bo.fromArray(n[0]), On.fromArray(n[1]), sr.fromArray(n[2]), Mt.sub(cs, bo, On), Mt.sub(ts, sr, On);
    var t = cs.len(), r = ts.len();
    if (!(t < 1e-3 || r < 1e-3)) {
      cs.scale(1 / t), ts.scale(1 / r);
      var i = cs.dot(ts), a = Math.cos(e);
      if (a < i) {
        var o = y_(On.x, On.y, sr.x, sr.y, bo.x, bo.y, b_, !1);
        Ci.fromArray(b_), Ci.scaleAndAdd(ts, o / Math.tan(Math.PI - e));
        var s = sr.x !== On.x ? (Ci.x - On.x) / (sr.x - On.x) : (Ci.y - On.y) / (sr.y - On.y);
        if (isNaN(s))
          return;
        s < 0 ? Mt.copy(Ci, On) : s > 1 && Mt.copy(Ci, sr), Ci.toArray(n[1]);
      }
    }
  }
}
function dje(n, e, t) {
  if (t <= 180 && t > 0) {
    t = t / 180 * Math.PI, bo.fromArray(n[0]), On.fromArray(n[1]), sr.fromArray(n[2]), Mt.sub(cs, On, bo), Mt.sub(ts, sr, On);
    var r = cs.len(), i = ts.len();
    if (!(r < 1e-3 || i < 1e-3)) {
      cs.scale(1 / r), ts.scale(1 / i);
      var a = cs.dot(e), o = Math.cos(t);
      if (a < o) {
        var s = y_(On.x, On.y, sr.x, sr.y, bo.x, bo.y, b_, !1);
        Ci.fromArray(b_);
        var l = Math.PI / 2, u = Math.acos(ts.dot(e)), c = l + u - t;
        if (c >= l)
          Mt.copy(Ci, sr);
        else {
          Ci.scaleAndAdd(ts, s / Math.tan(Math.PI / 2 - c));
          var d = sr.x !== On.x ? (Ci.x - On.x) / (sr.x - On.x) : (Ci.y - On.y) / (sr.y - On.y);
          if (isNaN(d))
            return;
          d < 0 ? Mt.copy(Ci, On) : d > 1 && Mt.copy(Ci, sr);
        }
        Ci.toArray(n[1]);
      }
    }
  }
}
function Q2(n, e, t, r) {
  var i = t === "normal", a = i ? n : n.ensureState(t);
  a.ignore = e;
  var o = r.get("smooth");
  o && o === !0 && (o = 0.3), a.shape = a.shape || {}, o > 0 && (a.shape.smooth = o);
  var s = r.getModel("lineStyle").getLineStyle();
  i ? n.useStyle(s) : a.style = s;
}
function fje(n, e) {
  var t = e.smooth, r = e.points;
  if (r)
    if (n.moveTo(r[0][0], r[0][1]), t > 0 && r.length >= 3) {
      var i = du(r[0], r[1]), a = du(r[1], r[2]);
      if (!i || !a) {
        n.lineTo(r[1][0], r[1][1]), n.lineTo(r[2][0], r[2][1]);
        return;
      }
      var o = Math.min(i, a) * t, s = b1([], r[1], r[0], o / i), l = b1([], r[1], r[2], o / a), u = b1([], s, l, 0.5);
      n.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), n.bezierCurveTo(l[0], l[1], l[0], l[1], r[2][0], r[2][1]);
    } else
      for (var c = 1; c < r.length; c++)
        n.lineTo(r[c][0], r[c][1]);
}
function _O(n, e, t) {
  var r = n.getTextGuideLine(), i = n.getTextContent();
  if (!i) {
    r && n.removeTextGuideLine();
    return;
  }
  for (var a = e.normal, o = a.get("show"), s = i.ignore, l = 0; l < eg.length; l++) {
    var u = eg[l], c = e[u], d = u === "normal";
    if (c) {
      var f = c.get("show"), p = d ? s : bt(i.states[u] && i.states[u].ignore, s);
      if (p || !bt(f, o)) {
        var h = d ? r : r && r.states[u];
        h && (h.ignore = !0), r && Q2(r, !0, u, c);
        continue;
      }
      r || (r = new Hi(), n.setTextGuideLine(r), !d && (s || !o) && Q2(r, !0, "normal", e.normal), n.stateProxy && (r.stateProxy = n.stateProxy)), Q2(r, !1, u, c);
    }
  }
  if (r) {
    dt(r.style, t), r.style.fill = null;
    var v = a.get("showAbove"), m = n.textGuideLineConfig = n.textGuideLineConfig || {};
    m.showAbove = v || !1, r.buildPath = fje;
  }
}
function xO(n, e) {
  e = e || "labelLine";
  for (var t = {
    normal: n.getModel(e)
  }, r = 0; r < zi.length; r++) {
    var i = zi[r];
    t[i] = n.getModel([i, e]);
  }
  return t;
}
function kq(n) {
  for (var e = [], t = 0; t < n.length; t++) {
    var r = n[t];
    if (!r.defaultAttr.ignore) {
      var i = r.label, a = i.getComputedTransform(), o = i.getBoundingRect(), s = !a || a[1] < 1e-5 && a[2] < 1e-5, l = i.style.margin || 0, u = o.clone();
      u.applyTransform(a), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l;
      var c = s ? new t_(o, a) : null;
      e.push({
        label: i,
        labelLine: r.labelLine,
        rect: u,
        localRect: o,
        obb: c,
        priority: r.priority,
        defaultAttr: r.defaultAttr,
        layoutOption: r.computedLayoutOption,
        axisAligned: s,
        transform: a
      });
    }
  }
  return e;
}
function Aq(n, e, t, r, i, a) {
  var o = n.length;
  if (o < 2)
    return;
  n.sort(function(w, S) {
    return w.rect[e] - S.rect[e];
  });
  for (var s = 0, l, u = !1, c = 0; c < o; c++) {
    var d = n[c], f = d.rect;
    l = f[e] - s, l < 0 && (f[e] -= l, d.label[e] -= l, u = !0), s = f[e] + f[t];
  }
  var p = n[0], h = n[o - 1], v, m;
  g(), v < 0 && _(-v, 0.8), m < 0 && _(m, 0.8), g(), y(v, m, 1), y(m, v, -1), g(), v < 0 && x(-v), m < 0 && x(m);
  function g() {
    v = p.rect[e] - r, m = i - h.rect[e] - h.rect[t];
  }
  function y(w, S, C) {
    if (w < 0) {
      var k = Math.min(S, -w);
      if (k > 0) {
        b(k * C, 0, o);
        var M = k + w;
        M < 0 && _(-M * C, 1);
      } else
        _(-w * C, 1);
    }
  }
  function b(w, S, C) {
    w !== 0 && (u = !0);
    for (var k = S; k < C; k++) {
      var M = n[k], D = M.rect;
      D[e] += w, M.label[e] += w;
    }
  }
  function _(w, S) {
    for (var C = [], k = 0, M = 1; M < o; M++) {
      var D = n[M - 1].rect, N = Math.max(n[M].rect[e] - D[e] - D[t], 0);
      C.push(N), k += N;
    }
    if (k) {
      var R = Math.min(Math.abs(w) / k, S);
      if (w > 0)
        for (var M = 0; M < o - 1; M++) {
          var j = C[M] * R;
          b(j, 0, M + 1);
        }
      else
        for (var M = o - 1; M > 0; M--) {
          var j = C[M - 1] * R;
          b(-j, M, o);
        }
    }
  }
  function x(w) {
    var S = w < 0 ? -1 : 1;
    w = Math.abs(w);
    for (var C = Math.ceil(w / (o - 1)), k = 0; k < o - 1; k++)
      if (S > 0 ? b(C, 0, k + 1) : b(-C, o - k - 1, o), w -= C, w <= 0)
        return;
  }
  return u;
}
function pje(n, e, t, r) {
  return Aq(n, "x", "width", e, t);
}
function Mq(n, e, t, r) {
  return Aq(n, "y", "height", e, t);
}
function Dq(n) {
  var e = [];
  n.sort(function(v, m) {
    return m.priority - v.priority;
  });
  var t = new Ot(0, 0, 0, 0);
  function r(v) {
    if (!v.ignore) {
      var m = v.ensureState("emphasis");
      m.ignore == null && (m.ignore = !1);
    }
    v.ignore = !0;
  }
  for (var i = 0; i < n.length; i++) {
    var a = n[i], o = a.axisAligned, s = a.localRect, l = a.transform, u = a.label, c = a.labelLine;
    t.copy(a.rect), t.width -= 0.1, t.height -= 0.1, t.x += 0.05, t.y += 0.05;
    for (var d = a.obb, f = !1, p = 0; p < e.length; p++) {
      var h = e[p];
      if (t.intersect(h.rect)) {
        if (o && h.axisAligned) {
          f = !0;
          break;
        }
        if (h.obb || (h.obb = new t_(h.localRect, h.transform)), d || (d = new t_(s, l)), d.intersect(h.obb)) {
          f = !0;
          break;
        }
      }
    }
    f ? (r(u), c && r(c)) : (u.attr("ignore", a.defaultAttr.ignore), c && c.attr("ignore", a.defaultAttr.labelGuideIgnore), e.push(a));
  }
}
function hje(n) {
  if (n) {
    for (var e = [], t = 0; t < n.length; t++)
      e.push(n[t].slice());
    return e;
  }
}
function vje(n, e) {
  var t = n.label, r = e && e.getTextGuideLine();
  return {
    dataIndex: n.dataIndex,
    dataType: n.dataType,
    seriesIndex: n.seriesModel.seriesIndex,
    text: n.label.style.text,
    rect: n.hostRect,
    labelRect: n.rect,
    // x: labelAttr.x,
    // y: labelAttr.y,
    align: t.style.align,
    verticalAlign: t.style.verticalAlign,
    labelLinePoints: hje(r && r.shape.points)
  };
}
var G5 = ["align", "verticalAlign", "width", "height", "fontSize"], xi = new rl(), eE = en(), mje = en();
function O0(n, e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    e[i] != null && (n[i] = e[i]);
  }
}
var I0 = ["x", "y", "rotation"], gje = (
  /** @class */
  function() {
    function n() {
      this._labelList = [], this._chartViewList = [];
    }
    return n.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, n.prototype._addLabel = function(e, t, r, i, a) {
      var o = i.style, s = i.__hostTarget, l = s.textConfig || {}, u = i.getComputedTransform(), c = i.getBoundingRect().plain();
      Ot.applyTransform(c, c, u), u ? xi.setLocalTransform(u) : (xi.x = xi.y = xi.rotation = xi.originX = xi.originY = 0, xi.scaleX = xi.scaleY = 1), xi.rotation = va(xi.rotation);
      var d = i.__hostTarget, f;
      if (d) {
        f = d.getBoundingRect().plain();
        var p = d.getComputedTransform();
        Ot.applyTransform(f, f, p);
      }
      var h = f && d.getTextGuideLine();
      this._labelList.push({
        label: i,
        labelLine: h,
        seriesModel: r,
        dataIndex: e,
        dataType: t,
        layoutOption: a,
        computedLayoutOption: null,
        rect: c,
        hostRect: f,
        // Label with lower priority will be hidden when overlapped
        // Use rect size as default priority
        priority: f ? f.width * f.height : 0,
        // Save default label attributes.
        // For restore if developers want get back to default value in callback.
        defaultAttr: {
          ignore: i.ignore,
          labelGuideIgnore: h && h.ignore,
          x: xi.x,
          y: xi.y,
          scaleX: xi.scaleX,
          scaleY: xi.scaleY,
          rotation: xi.rotation,
          style: {
            x: o.x,
            y: o.y,
            align: o.align,
            verticalAlign: o.verticalAlign,
            width: o.width,
            height: o.height,
            fontSize: o.fontSize
          },
          cursor: i.cursor,
          attachedPos: l.position,
          attachedRot: l.rotation
        }
      });
    }, n.prototype.addLabelsOfSeries = function(e) {
      var t = this;
      this._chartViewList.push(e);
      var r = e.__model, i = r.get("labelLayout");
      (at(i) || Yt(i).length) && e.group.traverse(function(a) {
        if (a.ignore)
          return !0;
        var o = a.getTextContent(), s = yt(a);
        o && !o.disableLabelLayout && t._addLabel(s.dataIndex, s.dataType, r, o, i);
      });
    }, n.prototype.updateLayoutConfig = function(e) {
      var t = e.getWidth(), r = e.getHeight();
      function i(b, _) {
        return function() {
          H5(b, _);
        };
      }
      for (var a = 0; a < this._labelList.length; a++) {
        var o = this._labelList[a], s = o.label, l = s.__hostTarget, u = o.defaultAttr, c = void 0;
        at(o.layoutOption) ? c = o.layoutOption(vje(o, l)) : c = o.layoutOption, c = c || {}, o.computedLayoutOption = c;
        var d = Math.PI / 180;
        l && l.setTextConfig({
          // Force to set local false.
          local: !1,
          // Ignore position and rotation config on the host el if x or y is changed.
          position: c.x != null || c.y != null ? null : u.attachedPos,
          // Ignore rotation config on the host el if rotation is changed.
          rotation: c.rotate != null ? c.rotate * d : u.attachedRot,
          offset: [c.dx || 0, c.dy || 0]
        });
        var f = !1;
        if (c.x != null ? (s.x = ze(c.x, t), s.setStyle("x", 0), f = !0) : (s.x = u.x, s.setStyle("x", u.style.x)), c.y != null ? (s.y = ze(c.y, r), s.setStyle("y", 0), f = !0) : (s.y = u.y, s.setStyle("y", u.style.y)), c.labelLinePoints) {
          var p = l.getTextGuideLine();
          p && (p.setShape({
            points: c.labelLinePoints
          }), f = !1);
        }
        var h = eE(s);
        h.needsUpdateLabelLine = f, s.rotation = c.rotate != null ? c.rotate * d : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
        for (var v = 0; v < G5.length; v++) {
          var m = G5[v];
          s.setStyle(m, c[m] != null ? c[m] : u.style[m]);
        }
        if (c.draggable) {
          if (s.draggable = !0, s.cursor = "move", l) {
            var g = o.seriesModel;
            if (o.dataIndex != null) {
              var y = o.seriesModel.getData(o.dataType);
              g = y.getItemModel(o.dataIndex);
            }
            s.on("drag", i(l, g.getModel("labelLine")));
          }
        } else
          s.off("drag"), s.cursor = u.cursor;
      }
    }, n.prototype.layout = function(e) {
      var t = e.getWidth(), r = e.getHeight(), i = kq(this._labelList), a = vn(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftX";
      }), o = vn(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftY";
      });
      pje(a, 0, t), Mq(o, 0, r);
      var s = vn(i, function(l) {
        return l.layoutOption.hideOverlap;
      });
      Dq(s);
    }, n.prototype.processLabelsOverall = function() {
      var e = this;
      $(this._chartViewList, function(t) {
        var r = t.__model, i = t.ignoreLabelLineUpdate, a = r.isAnimationEnabled();
        t.group.traverse(function(o) {
          if (o.ignore && !o.forceLabelAnimation)
            return !0;
          var s = !i, l = o.getTextContent();
          !s && l && (s = eE(l).needsUpdateLabelLine), s && e._updateLabelLine(o, r), a && e._animateLabels(o, r);
        });
      });
    }, n.prototype._updateLabelLine = function(e, t) {
      var r = e.getTextContent(), i = yt(e), a = i.dataIndex;
      if (r && a != null) {
        var o = t.getData(i.dataType), s = o.getItemModel(a), l = {}, u = o.getItemVisual(a, "style");
        if (u) {
          var c = o.getVisual("drawType");
          l.stroke = u[c];
        }
        var d = s.getModel("labelLine");
        _O(e, xO(s), l), H5(e, d);
      }
    }, n.prototype._animateLabels = function(e, t) {
      var r = e.getTextContent(), i = e.getTextGuideLine();
      if (r && (e.forceLabelAnimation || !r.ignore && !r.invisible && !e.disableLabelAnimation && !bp(e))) {
        var a = eE(r), o = a.oldLayout, s = yt(e), l = s.dataIndex, u = {
          x: r.x,
          y: r.y,
          rotation: r.rotation
        }, c = t.getData(s.dataType);
        if (o) {
          r.attr(o);
          var f = e.prevStates;
          f && (Pt(f, "select") >= 0 && r.attr(a.oldLayoutSelect), Pt(f, "emphasis") >= 0 && r.attr(a.oldLayoutEmphasis)), ln(r, u, t, l);
        } else if (r.attr(u), !fh(r).valueAnimation) {
          var d = bt(r.style.opacity, 1);
          r.style.opacity = 0, Gn(r, {
            style: {
              opacity: d
            }
          }, t, l);
        }
        if (a.oldLayout = u, r.states.select) {
          var p = a.oldLayoutSelect = {};
          O0(p, u, I0), O0(p, r.states.select, I0);
        }
        if (r.states.emphasis) {
          var h = a.oldLayoutEmphasis = {};
          O0(h, u, I0), O0(h, r.states.emphasis, I0);
        }
        SU(r, l, c, t, t);
      }
      if (i && !i.ignore && !i.invisible) {
        var a = mje(i), o = a.oldLayout, v = {
          points: i.shape.points
        };
        o ? (i.attr({
          shape: o
        }), ln(i, {
          shape: v
        }, t)) : (i.setShape(v), i.style.strokePercent = 0, Gn(i, {
          style: {
            strokePercent: 1
          }
        }, t)), a.oldLayout = v;
      }
    }, n;
  }()
), tE = en();
function yje(n) {
  n.registerUpdateLifecycle("series:beforeupdate", function(e, t, r) {
    var i = tE(t).labelManager;
    i || (i = tE(t).labelManager = new gje()), i.clearLabels();
  }), n.registerUpdateLifecycle("series:layoutlabels", function(e, t, r) {
    var i = tE(t).labelManager;
    r.updatedSeries.forEach(function(a) {
      i.addLabelsOfSeries(t.getViewOfSeriesModel(a));
    }), i.updateLayoutConfig(t), i.layout(t), i.processLabelsOverall();
  });
}
var nE = Math.sin, rE = Math.cos, Oq = Math.PI, _c = Math.PI * 2, bje = 180 / Oq, Iq = function() {
  function n() {
  }
  return n.prototype.reset = function(e) {
    this._start = !0, this._d = [], this._str = "", this._p = Math.pow(10, e || 4);
  }, n.prototype.moveTo = function(e, t) {
    this._add("M", e, t);
  }, n.prototype.lineTo = function(e, t) {
    this._add("L", e, t);
  }, n.prototype.bezierCurveTo = function(e, t, r, i, a, o) {
    this._add("C", e, t, r, i, a, o);
  }, n.prototype.quadraticCurveTo = function(e, t, r, i) {
    this._add("Q", e, t, r, i);
  }, n.prototype.arc = function(e, t, r, i, a, o) {
    this.ellipse(e, t, r, r, 0, i, a, o);
  }, n.prototype.ellipse = function(e, t, r, i, a, o, s, l) {
    var u = s - o, c = !l, d = Math.abs(u), f = mu(d - _c) || (c ? u >= _c : -u >= _c), p = u > 0 ? u % _c : u % _c + _c, h = !1;
    f ? h = !0 : mu(d) ? h = !1 : h = p >= Oq == !!c;
    var v = e + r * rE(o), m = t + i * nE(o);
    this._start && this._add("M", v, m);
    var g = Math.round(a * bje);
    if (f) {
      var y = 1 / this._p, b = (c ? 1 : -1) * (_c - y);
      this._add("A", r, i, g, 1, +c, e + r * rE(o + b), t + i * nE(o + b)), y > 0.01 && this._add("A", r, i, g, 0, +c, v, m);
    } else {
      var _ = e + r * rE(s), x = t + i * nE(s);
      this._add("A", r, i, g, +h, +c, _, x);
    }
  }, n.prototype.rect = function(e, t, r, i) {
    this._add("M", e, t), this._add("l", r, 0), this._add("l", 0, i), this._add("l", -r, 0), this._add("Z");
  }, n.prototype.closePath = function() {
    this._d.length > 0 && this._add("Z");
  }, n.prototype._add = function(e, t, r, i, a, o, s, l, u) {
    for (var c = [], d = this._p, f = 1; f < arguments.length; f++) {
      var p = arguments[f];
      if (isNaN(p)) {
        this._invalid = !0;
        return;
      }
      c.push(Math.round(p * d) / d);
    }
    this._d.push(e + c.join(" ")), this._start = e === "Z";
  }, n.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join(""), this._d = [];
  }, n.prototype.getStr = function() {
    return this._str;
  }, n;
}(), wO = "none", _je = Math.round;
function xje(n) {
  var e = n.fill;
  return e != null && e !== wO;
}
function wje(n) {
  var e = n.stroke;
  return e != null && e !== wO;
}
var jk = ["lineCap", "miterLimit", "lineJoin"], Sje = De(jk, function(n) {
  return "stroke-" + n.toLowerCase();
});
function Eje(n, e, t, r) {
  var i = e.opacity == null ? 1 : e.opacity;
  if (t instanceof Ur) {
    n("opacity", i);
    return;
  }
  if (xje(e)) {
    var a = Jm(e.fill);
    n("fill", a.color);
    var o = e.fillOpacity != null ? e.fillOpacity * a.opacity * i : a.opacity * i;
    o < 1 && n("fill-opacity", o);
  } else
    n("fill", wO);
  if (wje(e)) {
    var s = Jm(e.stroke);
    n("stroke", s.color);
    var l = e.strokeNoScale ? t.getLineScale() : 1, u = l ? (e.lineWidth || 0) / l : 0, c = e.strokeOpacity != null ? e.strokeOpacity * s.opacity * i : s.opacity * i, d = e.strokeFirst;
    if (u !== 1 && n("stroke-width", u), d && n("paint-order", d ? "stroke" : "fill"), c < 1 && n("stroke-opacity", c), e.lineDash) {
      var f = uO(t), p = f[0], h = f[1];
      p && (h = _je(h || 0), n("stroke-dasharray", p.join(",")), (h || r) && n("stroke-dashoffset", h));
    }
    for (var v = 0; v < jk.length; v++) {
      var m = jk[v];
      if (e[m] !== Qb[m]) {
        var g = e[m] || Qb[m];
        g && n(Sje[v], g);
      }
    }
  }
}
var Lq = "http://www.w3.org/2000/svg", Nq = "http://www.w3.org/1999/xlink", Tje = "http://www.w3.org/2000/xmlns/", Cje = "http://www.w3.org/XML/1998/namespace", U5 = "ecmeta_";
function Rq(n) {
  return document.createElementNS(Lq, n);
}
function Or(n, e, t, r, i) {
  return {
    tag: n,
    attrs: t || {},
    children: r,
    text: i,
    key: e
  };
}
function kje(n, e) {
  var t = [];
  if (e)
    for (var r in e) {
      var i = e[r], a = r;
      i !== !1 && (i !== !0 && i != null && (a += '="' + i + '"'), t.push(a));
    }
  return "<" + n + " " + t.join(" ") + ">";
}
function Aje(n) {
  return "</" + n + ">";
}
function SO(n, e) {
  e = e || {};
  var t = e.newline ? `
` : "";
  function r(i) {
    var a = i.children, o = i.tag, s = i.attrs, l = i.text;
    return kje(o, s) + (o !== "style" ? Ai(l) : l || "") + (a ? "" + t + De(a, function(u) {
      return r(u);
    }).join(t) + t : "") + Aje(o);
  }
  return r(n);
}
function Mje(n, e, t) {
  t = t || {};
  var r = t.newline ? `
` : "", i = " {" + r, a = r + "}", o = De(Yt(n), function(l) {
    return l + i + De(Yt(n[l]), function(u) {
      return u + ":" + n[l][u] + ";";
    }).join(r) + a;
  }).join(r), s = De(Yt(e), function(l) {
    return "@keyframes " + l + i + De(Yt(e[l]), function(u) {
      return u + i + De(Yt(e[l][u]), function(c) {
        var d = e[l][u][c];
        return c === "d" && (d = 'path("' + d + '")'), c + ":" + d + ";";
      }).join(r) + a;
    }).join(r) + a;
  }).join(r);
  return !o && !s ? "" : ["<![CDATA[", o, s, "]]>"].join(r);
}
function Bk(n) {
  return {
    zrId: n,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssStyleCache: {},
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function W5(n, e, t, r) {
  return Or("svg", "root", {
    width: n,
    height: e,
    xmlns: Lq,
    "xmlns:xlink": Nq,
    version: "1.1",
    baseProfile: "full",
    viewBox: r ? "0 0 " + n + " " + e : !1
  }, t);
}
var Dje = 0;
function Pq() {
  return Dje++;
}
var q5 = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
}, Ec = "transform-origin";
function Oje(n, e, t) {
  var r = xe({}, n.shape);
  xe(r, e), n.buildPath(t, r);
  var i = new Iq();
  return i.reset(_G(n)), t.rebuildPath(i, 1), i.generateStr(), i.getStr();
}
function Ije(n, e) {
  var t = e.originX, r = e.originY;
  (t || r) && (n[Ec] = t + "px " + r + "px");
}
var Lje = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function jq(n, e) {
  var t = e.zrId + "-ani-" + e.cssAnimIdx++;
  return e.cssAnims[t] = n, t;
}
function Nje(n, e, t) {
  var r = n.shape.paths, i = {}, a, o;
  if ($(r, function(l) {
    var u = Bk(t.zrId);
    u.animation = !0, Ew(l, {}, u, !0);
    var c = u.cssAnims, d = u.cssNodes, f = Yt(c), p = f.length;
    if (p) {
      o = f[p - 1];
      var h = c[o];
      for (var v in h) {
        var m = h[v];
        i[v] = i[v] || { d: "" }, i[v].d += m.d || "";
      }
      for (var g in d) {
        var y = d[g].animation;
        y.indexOf(o) >= 0 && (a = y);
      }
    }
  }), !!a) {
    e.d = !1;
    var s = jq(i, t);
    return a.replace(o, s);
  }
}
function Y5(n) {
  return We(n) ? q5[n] ? "cubic-bezier(" + q5[n] + ")" : AD(n) ? n : "" : "";
}
function Ew(n, e, t, r) {
  var i = n.animators, a = i.length, o = [];
  if (n instanceof HD) {
    var s = Nje(n, e, t);
    if (s)
      o.push(s);
    else if (!a)
      return;
  } else if (!a)
    return;
  for (var l = {}, u = 0; u < a; u++) {
    var c = i[u], d = [c.getMaxTime() / 1e3 + "s"], f = Y5(c.getClip().easing), p = c.getDelay();
    f ? d.push(f) : d.push("linear"), p && d.push(p / 1e3 + "s"), c.getLoop() && d.push("infinite");
    var h = d.join(" ");
    l[h] = l[h] || [h, []], l[h][1].push(c);
  }
  function v(y) {
    var b = y[1], _ = b.length, x = {}, w = {}, S = {}, C = "animation-timing-function";
    function k(Ee, ce, Pe) {
      for (var Ae = Ee.getTracks(), fe = Ee.getMaxTime(), oe = 0; oe < Ae.length; oe++) {
        var he = Ae[oe];
        if (he.needsAnimate()) {
          var Oe = he.keyframes, Te = he.propName;
          if (Pe && (Te = Pe(Te)), Te)
            for (var Ge = 0; Ge < Oe.length; Ge++) {
              var je = Oe[Ge], Qe = Math.round(je.time / fe * 100) + "%", ot = Y5(je.easing), it = je.rawValue;
              (We(it) || sn(it)) && (ce[Qe] = ce[Qe] || {}, ce[Qe][Te] = je.rawValue, ot && (ce[Qe][C] = ot));
            }
        }
      }
    }
    for (var M = 0; M < _; M++) {
      var D = b[M], N = D.targetName;
      N ? N === "shape" && k(D, w) : !r && k(D, x);
    }
    for (var R in x) {
      var j = {};
      TG(j, n), xe(j, x[R]);
      var z = xG(j), F = x[R][C];
      S[R] = z ? {
        transform: z
      } : {}, Ije(S[R], j), F && (S[R][C] = F);
    }
    var B, H = !0;
    for (var R in w) {
      S[R] = S[R] || {};
      var Y = !B, F = w[R][C];
      Y && (B = new Ts());
      var ne = B.len();
      B.reset(), S[R].d = Oje(n, w[R], B);
      var J = B.len();
      if (!Y && ne !== J) {
        H = !1;
        break;
      }
      F && (S[R][C] = F);
    }
    if (!H)
      for (var R in S)
        delete S[R].d;
    if (!r)
      for (var M = 0; M < _; M++) {
        var D = b[M], N = D.targetName;
        N === "style" && k(D, S, function(Ae) {
          return Lje[Ae];
        });
      }
    for (var X = Yt(S), ie = !0, ye, M = 1; M < X.length; M++) {
      var pe = X[M - 1], Be = X[M];
      if (S[pe][Ec] !== S[Be][Ec]) {
        ie = !1;
        break;
      }
      ye = S[pe][Ec];
    }
    if (ie && ye) {
      for (var R in S)
        S[R][Ec] && delete S[R][Ec];
      e[Ec] = ye;
    }
    if (vn(X, function(Ee) {
      return Yt(S[Ee]).length > 0;
    }).length) {
      var Ce = jq(S, t);
      return Ce + " " + y[0] + " both";
    }
  }
  for (var m in l) {
    var s = v(l[m]);
    s && o.push(s);
  }
  if (o.length) {
    var g = t.zrId + "-cls-" + Pq();
    t.cssNodes["." + g] = {
      animation: o.join(",")
    }, e.class = g;
  }
}
function Rje(n, e, t) {
  if (!n.ignore)
    if (n.isSilent()) {
      var r = {
        "pointer-events": "none"
      };
      K5(r, e, t);
    } else {
      var i = n.states.emphasis && n.states.emphasis.style ? n.states.emphasis.style : {}, a = i.fill;
      if (!a) {
        var o = n.style && n.style.fill, s = n.states.select && n.states.select.style && n.states.select.style.fill, l = n.currentStates.indexOf("select") >= 0 && s || o;
        l && (a = YC(l));
      }
      var u = i.lineWidth;
      if (u) {
        var c = !i.strokeNoScale && n.transform ? n.transform[0] : 1;
        u = u / c;
      }
      var r = {
        cursor: "pointer"
      };
      a && (r.fill = a), i.stroke && (r.stroke = i.stroke), u && (r["stroke-width"] = u), K5(r, e, t);
    }
}
function K5(n, e, t, r) {
  var i = JSON.stringify(n), a = t.cssStyleCache[i];
  a || (a = t.zrId + "-cls-" + Pq(), t.cssStyleCache[i] = a, t.cssNodes["." + a + ":hover"] = n), e.class = e.class ? e.class + " " + a : a;
}
var ug = Math.round;
function Bq(n) {
  return n && We(n.src);
}
function $q(n) {
  return n && at(n.toDataURL);
}
function EO(n, e, t, r) {
  Eje(function(i, a) {
    var o = i === "fill" || i === "stroke";
    o && bG(a) ? Fq(e, n, i, r) : o && MD(a) ? Vq(t, n, i, r) : n[i] = a, o && r.ssr && a === "none" && (n["pointer-events"] = "visible");
  }, e, t, !1), Vje(t, n, r);
}
function TO(n, e) {
  var t = kOe(e);
  t && (t.each(function(r, i) {
    r != null && (n[(U5 + i).toLowerCase()] = r + "");
  }), e.isSilent() && (n[U5 + "silent"] = "true"));
}
function X5(n) {
  return mu(n[0] - 1) && mu(n[1]) && mu(n[2]) && mu(n[3] - 1);
}
function Pje(n) {
  return mu(n[4]) && mu(n[5]);
}
function CO(n, e, t) {
  if (e && !(Pje(e) && X5(e))) {
    var r = 1e4;
    n.transform = X5(e) ? "translate(" + ug(e[4] * r) / r + " " + ug(e[5] * r) / r + ")" : XDe(e);
  }
}
function Z5(n, e, t) {
  for (var r = n.points, i = [], a = 0; a < r.length; a++)
    i.push(ug(r[a][0] * t) / t), i.push(ug(r[a][1] * t) / t);
  e.points = i.join(" ");
}
function J5(n) {
  return !n.smooth;
}
function jje(n) {
  var e = De(n, function(t) {
    return typeof t == "string" ? [t, t] : t;
  });
  return function(t, r, i) {
    for (var a = 0; a < e.length; a++) {
      var o = e[a], s = t[o[0]];
      s != null && (r[o[1]] = ug(s * i) / i);
    }
  };
}
var Bje = {
  circle: [jje(["cx", "cy", "r"])],
  polyline: [Z5, J5],
  polygon: [Z5, J5]
};
function $je(n) {
  for (var e = n.animators, t = 0; t < e.length; t++)
    if (e[t].targetName === "shape")
      return !0;
  return !1;
}
function zq(n, e) {
  var t = n.style, r = n.shape, i = Bje[n.type], a = {}, o = e.animation, s = "path", l = n.style.strokePercent, u = e.compress && _G(n) || 4;
  if (i && !e.willUpdate && !(i[1] && !i[1](r)) && !(o && $je(n)) && !(l < 1)) {
    s = n.type;
    var c = Math.pow(10, u);
    i[0](r, a, c);
  } else {
    var d = !n.path || n.shapeChanged();
    n.path || n.createPathProxy();
    var f = n.path;
    d && (f.beginPath(), n.buildPath(f, n.shape), n.pathUpdated());
    var p = f.getVersion(), h = n, v = h.__svgPathBuilder;
    (h.__svgPathVersion !== p || !v || l !== h.__svgPathStrokePercent) && (v || (v = h.__svgPathBuilder = new Iq()), v.reset(u), f.rebuildPath(v, l), v.generateStr(), h.__svgPathVersion = p, h.__svgPathStrokePercent = l), a.d = v.getStr();
  }
  return CO(a, n.transform), EO(a, t, n, e), TO(a, n), e.animation && Ew(n, a, e), e.emphasis && Rje(n, a, e), Or(s, n.id + "", a);
}
function zje(n, e) {
  var t = n.style, r = t.image;
  if (r && !We(r) && (Bq(r) ? r = r.src : $q(r) && (r = r.toDataURL())), !!r) {
    var i = t.x || 0, a = t.y || 0, o = t.width, s = t.height, l = {
      href: r,
      width: o,
      height: s
    };
    return i && (l.x = i), a && (l.y = a), CO(l, n.transform), EO(l, t, n, e), TO(l, n), e.animation && Ew(n, l, e), Or("image", n.id + "", l);
  }
}
function Fje(n, e) {
  var t = n.style, r = t.text;
  if (r != null && (r += ""), !(!r || isNaN(t.x) || isNaN(t.y))) {
    var i = t.font || Iu, a = t.x || 0, o = JDe(t.y || 0, Yx(i), t.textBaseline), s = ZDe[t.textAlign] || t.textAlign, l = {
      "dominant-baseline": "central",
      "text-anchor": s
    };
    if (XG(t)) {
      var u = "", c = t.fontStyle, d = KG(t.fontSize);
      if (!parseFloat(d))
        return;
      var f = t.fontFamily || K9, p = t.fontWeight;
      u += "font-size:" + d + ";font-family:" + f + ";", c && c !== "normal" && (u += "font-style:" + c + ";"), p && p !== "normal" && (u += "font-weight:" + p + ";"), l.style = u;
    } else
      l.style = "font: " + i;
    return r.match(/\s/) && (l["xml:space"] = "preserve"), a && (l.x = a), o && (l.y = o), CO(l, n.transform), EO(l, t, n, e), TO(l, n), e.animation && Ew(n, l, e), Or("text", n.id + "", l, void 0, r);
  }
}
function Q5(n, e) {
  if (n instanceof Ht)
    return zq(n, e);
  if (n instanceof Ur)
    return zje(n, e);
  if (n instanceof zp)
    return Fje(n, e);
}
function Vje(n, e, t) {
  var r = n.style;
  if (QDe(r)) {
    var i = eOe(n), a = t.shadowCache, o = a[i];
    if (!o) {
      var s = n.getGlobalScale(), l = s[0], u = s[1];
      if (!l || !u)
        return;
      var c = r.shadowOffsetX || 0, d = r.shadowOffsetY || 0, f = r.shadowBlur, p = Jm(r.shadowColor), h = p.opacity, v = p.color, m = f / 2 / l, g = f / 2 / u, y = m + " " + g;
      o = t.zrId + "-s" + t.shadowIdx++, t.defs[o] = Or("filter", o, {
        id: o,
        x: "-100%",
        y: "-100%",
        width: "300%",
        height: "300%"
      }, [
        Or("feDropShadow", "", {
          dx: c / l,
          dy: d / u,
          stdDeviation: y,
          "flood-color": v,
          "flood-opacity": h
        })
      ]), a[i] = o;
    }
    e.filter = qx(o);
  }
}
function Fq(n, e, t, r) {
  var i = n[t], a, o = {
    gradientUnits: i.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (gG(i))
    a = "linearGradient", o.x1 = i.x, o.y1 = i.y, o.x2 = i.x2, o.y2 = i.y2;
  else if (yG(i))
    a = "radialGradient", o.cx = bt(i.x, 0.5), o.cy = bt(i.y, 0.5), o.r = bt(i.r, 0.5);
  else {
    process.env.NODE_ENV !== "production" && _o("Illegal gradient type.");
    return;
  }
  for (var s = i.colorStops, l = [], u = 0, c = s.length; u < c; ++u) {
    var d = KC(s[u].offset) * 100 + "%", f = s[u].color, p = Jm(f), h = p.color, v = p.opacity, m = {
      offset: d
    };
    m["stop-color"] = h, v < 1 && (m["stop-opacity"] = v), l.push(Or("stop", u + "", m));
  }
  var g = Or(a, "", o, l), y = SO(g), b = r.gradientCache, _ = b[y];
  _ || (_ = r.zrId + "-g" + r.gradientIdx++, b[y] = _, o.id = _, r.defs[_] = Or(a, _, o, l)), e[t] = qx(_);
}
function Vq(n, e, t, r) {
  var i = n.style[t], a = n.getBoundingRect(), o = {}, s = i.repeat, l = s === "no-repeat", u = s === "repeat-x", c = s === "repeat-y", d;
  if (mG(i)) {
    var f = i.imageWidth, p = i.imageHeight, h = void 0, v = i.image;
    if (We(v) ? h = v : Bq(v) ? h = v.src : $q(v) && (h = v.toDataURL()), typeof Image > "u") {
      var m = "Image width/height must been given explictly in svg-ssr renderer.";
      ct(f, m), ct(p, m);
    } else if (f == null || p == null) {
      var g = function(M, D) {
        if (M) {
          var N = M.elm, R = f || D.width, j = p || D.height;
          M.tag === "pattern" && (u ? (j = 1, R /= a.width) : c && (R = 1, j /= a.height)), M.attrs.width = R, M.attrs.height = j, N && (N.setAttribute("width", R), N.setAttribute("height", j));
        }
      }, y = RD(h, null, n, function(M) {
        l || g(w, M), g(d, M);
      });
      y && y.width && y.height && (f = f || y.width, p = p || y.height);
    }
    d = Or("image", "img", {
      href: h,
      width: f,
      height: p
    }), o.width = f, o.height = p;
  } else i.svgElement && (d = ht(i.svgElement), o.width = i.svgWidth, o.height = i.svgHeight);
  if (d) {
    var b, _;
    l ? b = _ = 1 : u ? (_ = 1, b = o.width / a.width) : c ? (b = 1, _ = o.height / a.height) : o.patternUnits = "userSpaceOnUse", b != null && !isNaN(b) && (o.width = b), _ != null && !isNaN(_) && (o.height = _);
    var x = xG(i);
    x && (o.patternTransform = x);
    var w = Or("pattern", "", o, [d]), S = SO(w), C = r.patternCache, k = C[S];
    k || (k = r.zrId + "-p" + r.patternIdx++, C[S] = k, o.id = k, w = r.defs[k] = Or("pattern", k, o, [d])), e[t] = qx(k);
  }
}
function Hje(n, e, t) {
  var r = t.clipPathCache, i = t.defs, a = r[n.id];
  if (!a) {
    a = t.zrId + "-c" + t.clipPathIdx++;
    var o = {
      id: a
    };
    r[n.id] = a, i[a] = Or("clipPath", a, o, [zq(n, t)]);
  }
  e["clip-path"] = qx(a);
}
function eB(n) {
  return document.createTextNode(n);
}
function Rc(n, e, t) {
  n.insertBefore(e, t);
}
function tB(n, e) {
  n.removeChild(e);
}
function nB(n, e) {
  n.appendChild(e);
}
function Hq(n) {
  return n.parentNode;
}
function Gq(n) {
  return n.nextSibling;
}
function iE(n, e) {
  n.textContent = e;
}
var rB = 58, Gje = 120, Uje = Or("", "");
function $k(n) {
  return n === void 0;
}
function Jo(n) {
  return n !== void 0;
}
function Wje(n, e, t) {
  for (var r = {}, i = e; i <= t; ++i) {
    var a = n[i].key;
    a !== void 0 && (process.env.NODE_ENV !== "production" && r[a] != null && console.error("Duplicate key " + a), r[a] = i);
  }
  return r;
}
function Nv(n, e) {
  var t = n.key === e.key, r = n.tag === e.tag;
  return r && t;
}
function cg(n) {
  var e, t = n.children, r = n.tag;
  if (Jo(r)) {
    var i = n.elm = Rq(r);
    if (kO(Uje, n), Me(t))
      for (e = 0; e < t.length; ++e) {
        var a = t[e];
        a != null && nB(i, cg(a));
      }
    else Jo(n.text) && !ut(n.text) && nB(i, eB(n.text));
  } else
    n.elm = eB(n.text);
  return n.elm;
}
function Uq(n, e, t, r, i) {
  for (; r <= i; ++r) {
    var a = t[r];
    a != null && Rc(n, cg(a), e);
  }
}
function __(n, e, t, r) {
  for (; t <= r; ++t) {
    var i = e[t];
    if (i != null)
      if (Jo(i.tag)) {
        var a = Hq(i.elm);
        tB(a, i.elm);
      } else
        tB(n, i.elm);
  }
}
function kO(n, e) {
  var t, r = e.elm, i = n && n.attrs || {}, a = e.attrs || {};
  if (i !== a) {
    for (t in a) {
      var o = a[t], s = i[t];
      s !== o && (o === !0 ? r.setAttribute(t, "") : o === !1 ? r.removeAttribute(t) : t === "style" ? r.style.cssText = o : t.charCodeAt(0) !== Gje ? r.setAttribute(t, o) : t === "xmlns:xlink" || t === "xmlns" ? r.setAttributeNS(Tje, t, o) : t.charCodeAt(3) === rB ? r.setAttributeNS(Cje, t, o) : t.charCodeAt(5) === rB ? r.setAttributeNS(Nq, t, o) : r.setAttribute(t, o));
    }
    for (t in i)
      t in a || r.removeAttribute(t);
  }
}
function qje(n, e, t) {
  for (var r = 0, i = 0, a = e.length - 1, o = e[0], s = e[a], l = t.length - 1, u = t[0], c = t[l], d, f, p, h; r <= a && i <= l; )
    o == null ? o = e[++r] : s == null ? s = e[--a] : u == null ? u = t[++i] : c == null ? c = t[--l] : Nv(o, u) ? (ep(o, u), o = e[++r], u = t[++i]) : Nv(s, c) ? (ep(s, c), s = e[--a], c = t[--l]) : Nv(o, c) ? (ep(o, c), Rc(n, o.elm, Gq(s.elm)), o = e[++r], c = t[--l]) : Nv(s, u) ? (ep(s, u), Rc(n, s.elm, o.elm), s = e[--a], u = t[++i]) : ($k(d) && (d = Wje(e, r, a)), f = d[u.key], $k(f) ? Rc(n, cg(u), o.elm) : (p = e[f], p.tag !== u.tag ? Rc(n, cg(u), o.elm) : (ep(p, u), e[f] = void 0, Rc(n, p.elm, o.elm))), u = t[++i]);
  (r <= a || i <= l) && (r > a ? (h = t[l + 1] == null ? null : t[l + 1].elm, Uq(n, h, t, i, l)) : __(n, e, r, a));
}
function ep(n, e) {
  var t = e.elm = n.elm, r = n.children, i = e.children;
  n !== e && (kO(n, e), $k(e.text) ? Jo(r) && Jo(i) ? r !== i && qje(t, r, i) : Jo(i) ? (Jo(n.text) && iE(t, ""), Uq(t, null, i, 0, i.length - 1)) : Jo(r) ? __(t, r, 0, r.length - 1) : Jo(n.text) && iE(t, "") : n.text !== e.text && (Jo(r) && __(t, r, 0, r.length - 1), iE(t, e.text)));
}
function Yje(n, e) {
  if (Nv(n, e))
    ep(n, e);
  else {
    var t = n.elm, r = Hq(t);
    cg(e), r !== null && (Rc(r, e.elm, Gq(t)), __(r, [n], 0, 0));
  }
  return e;
}
var Kje = 0, Xje = function() {
  function n(e, t, r) {
    if (this.type = "svg", this.refreshHover = iB("refreshHover"), this.configLayer = iB("configLayer"), this.storage = t, this._opts = r = xe({}, r), this.root = e, this._id = "zr" + Kje++, this._oldVNode = W5(r.width, r.height), e && !r.ssr) {
      var i = this._viewport = document.createElement("div");
      i.style.cssText = "position:relative;overflow:hidden";
      var a = this._svgDom = this._oldVNode.elm = Rq("svg");
      kO(null, this._oldVNode), i.appendChild(a), e.appendChild(i);
    }
    this.resize(r.width, r.height);
  }
  return n.prototype.getType = function() {
    return this.type;
  }, n.prototype.getViewportRoot = function() {
    return this._viewport;
  }, n.prototype.getViewportRootOffset = function() {
    var e = this.getViewportRoot();
    if (e)
      return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
  }, n.prototype.getSvgDom = function() {
    return this._svgDom;
  }, n.prototype.refresh = function() {
    if (this.root) {
      var e = this.renderToVNode({
        willUpdate: !0
      });
      e.attrs.style = "position:absolute;left:0;top:0;user-select:none", Yje(this._oldVNode, e), this._oldVNode = e;
    }
  }, n.prototype.renderOneToVNode = function(e) {
    return Q5(e, Bk(this._id));
  }, n.prototype.renderToVNode = function(e) {
    e = e || {};
    var t = this.storage.getDisplayList(!0), r = this._width, i = this._height, a = Bk(this._id);
    a.animation = e.animation, a.willUpdate = e.willUpdate, a.compress = e.compress, a.emphasis = e.emphasis, a.ssr = this._opts.ssr;
    var o = [], s = this._bgVNode = Zje(r, i, this._backgroundColor, a);
    s && o.push(s);
    var l = e.compress ? null : this._mainVNode = Or("g", "main", {}, []);
    this._paintList(t, a, l ? l.children : o), l && o.push(l);
    var u = De(Yt(a.defs), function(f) {
      return a.defs[f];
    });
    if (u.length && o.push(Or("defs", "defs", {}, u)), e.animation) {
      var c = Mje(a.cssNodes, a.cssAnims, { newline: !0 });
      if (c) {
        var d = Or("style", "stl", {}, [], c);
        o.push(d);
      }
    }
    return W5(r, i, o, e.useViewBox);
  }, n.prototype.renderToString = function(e) {
    return e = e || {}, SO(this.renderToVNode({
      animation: bt(e.cssAnimation, !0),
      emphasis: bt(e.cssEmphasis, !0),
      willUpdate: !1,
      compress: !0,
      useViewBox: bt(e.useViewBox, !0)
    }), { newline: !0 });
  }, n.prototype.setBackgroundColor = function(e) {
    this._backgroundColor = e;
  }, n.prototype.getSvgRoot = function() {
    return this._mainVNode && this._mainVNode.elm;
  }, n.prototype._paintList = function(e, t, r) {
    for (var i = e.length, a = [], o = 0, s, l, u = 0, c = 0; c < i; c++) {
      var d = e[c];
      if (!d.invisible) {
        var f = d.__clipPaths, p = f && f.length || 0, h = l && l.length || 0, v = void 0;
        for (v = Math.max(p - 1, h - 1); v >= 0 && !(f && l && f[v] === l[v]); v--)
          ;
        for (var m = h - 1; m > v; m--)
          o--, s = a[o - 1];
        for (var g = v + 1; g < p; g++) {
          var y = {};
          Hje(f[g], y, t);
          var b = Or("g", "clip-g-" + u++, y, []);
          (s ? s.children : r).push(b), a[o++] = b, s = b;
        }
        l = f;
        var _ = Q5(d, t);
        _ && (s ? s.children : r).push(_);
      }
    }
  }, n.prototype.resize = function(e, t) {
    var r = this._opts, i = this.root, a = this._viewport;
    if (e != null && (r.width = e), t != null && (r.height = t), i && a && (a.style.display = "none", e = cp(i, 0, r), t = cp(i, 1, r), a.style.display = ""), this._width !== e || this._height !== t) {
      if (this._width = e, this._height = t, a) {
        var o = a.style;
        o.width = e + "px", o.height = t + "px";
      }
      if (MD(this._backgroundColor))
        this.refresh();
      else {
        var s = this._svgDom;
        s && (s.setAttribute("width", e), s.setAttribute("height", t));
        var l = this._bgVNode && this._bgVNode.elm;
        l && (l.setAttribute("width", e), l.setAttribute("height", t));
      }
    }
  }, n.prototype.getWidth = function() {
    return this._width;
  }, n.prototype.getHeight = function() {
    return this._height;
  }, n.prototype.dispose = function() {
    this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  }, n.prototype.clear = function() {
    this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
  }, n.prototype.toDataURL = function(e) {
    var t = this.renderToString(), r = "data:image/svg+xml;";
    return e ? (t = nOe(t), t && r + "base64," + t) : r + "charset=UTF-8," + encodeURIComponent(t);
  }, n;
}();
function iB(n) {
  return function() {
    process.env.NODE_ENV !== "production" && _o('In SVG mode painter not support method "' + n + '"');
  };
}
function Zje(n, e, t, r) {
  var i;
  if (t && t !== "none")
    if (i = Or("rect", "bg", {
      width: n,
      height: e,
      x: "0",
      y: "0"
    }), bG(t))
      Fq({ fill: t }, i.attrs, "fill", r);
    else if (MD(t))
      Vq({
        style: {
          fill: t
        },
        dirty: dr,
        getBoundingRect: function() {
          return { width: n, height: e };
        }
      }, i.attrs, "fill", r);
    else {
      var a = Jm(t), o = a.color, s = a.opacity;
      i.attrs.fill = o, s < 1 && (i.attrs["fill-opacity"] = s);
    }
  return i;
}
function Jje(n) {
  n.registerPainter("svg", Xje);
}
function aB(n, e, t) {
  var r = Lu.createCanvas(), i = e.getWidth(), a = e.getHeight(), o = r.style;
  return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = i + "px", o.height = a + "px", r.setAttribute("data-zr-dom-id", n)), r.width = i * t, r.height = a * t, r;
}
var aE = function(n) {
  le(e, n);
  function e(t, r, i) {
    var a = n.call(this) || this;
    a.motionBlur = !1, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = !1, a.config = {}, a.incremental = !1, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = !0, a.__firstTimePaint = !0, a.__used = !1, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
    var o;
    i = i || Zb, typeof t == "string" ? o = aB(t, r, i) : ut(t) && (o = t, t = o.id), a.id = t, a.dom = o;
    var s = o.style;
    return s && (nG(o), o.onselectstart = function() {
      return !1;
    }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), a.painter = r, a.dpr = i, a;
  }
  return e.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, e.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, e.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, e.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, e.prototype.createBackBuffer = function() {
    var t = this.dpr;
    this.domBack = aB("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), t !== 1 && this.ctxBack.scale(t, t);
  }, e.prototype.createRepaintRects = function(t, r, i, a) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var o = [], s = this.maxRepaintRectCount, l = !1, u = new Ot(0, 0, 0, 0);
    function c(y) {
      if (!(!y.isFinite() || y.isZero()))
        if (o.length === 0) {
          var b = new Ot(0, 0, 0, 0);
          b.copy(y), o.push(b);
        } else {
          for (var _ = !1, x = 1 / 0, w = 0, S = 0; S < o.length; ++S) {
            var C = o[S];
            if (C.intersect(y)) {
              var k = new Ot(0, 0, 0, 0);
              k.copy(C), k.union(y), o[S] = k, _ = !0;
              break;
            } else if (l) {
              u.copy(y), u.union(C);
              var M = y.width * y.height, D = C.width * C.height, N = u.width * u.height, R = N - M - D;
              R < x && (x = R, w = S);
            }
          }
          if (l && (o[w].union(y), _ = !0), !_) {
            var b = new Ot(0, 0, 0, 0);
            b.copy(y), o.push(b);
          }
          l || (l = o.length >= s);
        }
    }
    for (var d = this.__startIndex; d < this.__endIndex; ++d) {
      var f = t[d];
      if (f) {
        var p = f.shouldBePainted(i, a, !0, !0), h = f.__isRendered && (f.__dirty & pa || !p) ? f.getPrevPaintRect() : null;
        h && c(h);
        var v = p && (f.__dirty & pa || !f.__isRendered) ? f.getPaintRect() : null;
        v && c(v);
      }
    }
    for (var d = this.__prevStartIndex; d < this.__prevEndIndex; ++d) {
      var f = r[d], p = f && f.shouldBePainted(i, a, !0, !0);
      if (f && (!p || !f.__zr) && f.__isRendered) {
        var h = f.getPrevPaintRect();
        h && c(h);
      }
    }
    var m;
    do {
      m = !1;
      for (var d = 0; d < o.length; ) {
        if (o[d].isZero()) {
          o.splice(d, 1);
          continue;
        }
        for (var g = d + 1; g < o.length; )
          o[d].intersect(o[g]) ? (m = !0, o[d].union(o[g]), o.splice(g, 1)) : g++;
        d++;
      }
    } while (m);
    return this._paintRects = o, o;
  }, e.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, e.prototype.resize = function(t, r) {
    var i = this.dpr, a = this.dom, o = a.style, s = this.domBack;
    o && (o.width = t + "px", o.height = r + "px"), a.width = t * i, a.height = r * i, s && (s.width = t * i, s.height = r * i, i !== 1 && this.ctxBack.scale(i, i));
  }, e.prototype.clear = function(t, r, i) {
    var a = this.dom, o = this.ctx, s = a.width, l = a.height;
    r = r || this.clearColor;
    var u = this.motionBlur && !t, c = this.lastFrameAlpha, d = this.dpr, f = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / d, l / d));
    var p = this.domBack;
    function h(v, m, g, y) {
      if (o.clearRect(v, m, g, y), r && r !== "transparent") {
        var b = void 0;
        if (Gx(r)) {
          var _ = r.global || r.__width === g && r.__height === y;
          b = _ && r.__canvasGradient || Mk(o, r, {
            x: 0,
            y: 0,
            width: g,
            height: y
          }), r.__canvasGradient = b, r.__width = g, r.__height = y;
        } else dDe(r) && (r.scaleX = r.scaleX || d, r.scaleY = r.scaleY || d, b = Dk(o, r, {
          dirty: function() {
            f.setUnpainted(), f.painter.refresh();
          }
        }));
        o.save(), o.fillStyle = b || r, o.fillRect(v, m, g, y), o.restore();
      }
      u && (o.save(), o.globalAlpha = c, o.drawImage(p, v, m, g, y), o.restore());
    }
    !i || u ? h(0, 0, s, l) : i.length && $(i, function(v) {
      h(v.x * d, v.y * d, v.width * d, v.height * d);
    });
  }, e;
}(io), oB = 1e5, xc = 314159, L0 = 0.01, Qje = 1e-3;
function e5e(n) {
  return n ? n.__builtin__ ? !0 : !(typeof n.resize != "function" || typeof n.refresh != "function") : !1;
}
function t5e(n, e) {
  var t = document.createElement("div");
  return t.style.cssText = [
    "position:relative",
    "width:" + n + "px",
    "height:" + e + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", t;
}
var n5e = function() {
  function n(e, t, r, i) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var a = !e.nodeName || e.nodeName.toUpperCase() === "CANVAS";
    this._opts = r = xe({}, r || {}), this.dpr = r.devicePixelRatio || Zb, this._singleCanvas = a, this.root = e;
    var o = e.style;
    o && (nG(e), e.innerHTML = ""), this.storage = t;
    var s = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (a) {
      var c = e, d = c.width, f = c.height;
      r.width != null && (d = r.width), r.height != null && (f = r.height), this.dpr = r.devicePixelRatio || 1, c.width = d * this.dpr, c.height = f * this.dpr, this._width = d, this._height = f;
      var p = new aE(c, this, this.dpr);
      p.__builtin__ = !0, p.initContext(), l[xc] = p, p.zlevel = xc, s.push(xc), this._domRoot = e;
    } else {
      this._width = cp(e, 0, r), this._height = cp(e, 1, r);
      var u = this._domRoot = t5e(this._width, this._height);
      e.appendChild(u);
    }
  }
  return n.prototype.getType = function() {
    return "canvas";
  }, n.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, n.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, n.prototype.getViewportRootOffset = function() {
    var e = this.getViewportRoot();
    if (e)
      return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
  }, n.prototype.refresh = function(e) {
    var t = this.storage.getDisplayList(!0), r = this._prevDisplayList, i = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(t, r, e, this._redrawId);
    for (var a = 0; a < i.length; a++) {
      var o = i[a], s = this._layers[o];
      if (!s.__builtin__ && s.refresh) {
        var l = a === 0 ? this._backgroundColor : null;
        s.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = t.slice()), this;
  }, n.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, n.prototype._paintHoverList = function(e) {
    var t = e.length, r = this._hoverlayer;
    if (r && r.clear(), !!t) {
      for (var i = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, a, o = 0; o < t; o++) {
        var s = e[o];
        s.__inHover && (r || (r = this._hoverlayer = this.getLayer(oB)), a || (a = r.ctx, a.save()), Kc(a, s, i, o === t - 1));
      }
      a && a.restore();
    }
  }, n.prototype.getHoverLayer = function() {
    return this.getLayer(oB);
  }, n.prototype.paintOne = function(e, t) {
    DW(e, t);
  }, n.prototype._paintList = function(e, t, r, i) {
    if (this._redrawId === i) {
      r = r || !1, this._updateLayerStatus(e);
      var a = this._doPaintList(e, t, r), o = a.finished, s = a.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(e), o)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        Ub(function() {
          l._paintList(e, t, r, i);
        });
      }
    }
  }, n.prototype._compositeManually = function() {
    var e = this.getLayer(xc).ctx, t = this._domRoot.width, r = this._domRoot.height;
    e.clearRect(0, 0, t, r), this.eachBuiltinLayer(function(i) {
      i.virtual && e.drawImage(i.dom, 0, 0, t, r);
    });
  }, n.prototype._doPaintList = function(e, t, r) {
    for (var i = this, a = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
      var l = this._zlevelList[s], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || r) && a.push(u);
    }
    for (var c = !0, d = !1, f = function(v) {
      var m = a[v], g = m.ctx, y = o && m.createRepaintRects(e, t, p._width, p._height), b = r ? m.__startIndex : m.__drawIndex, _ = !r && m.incremental && Date.now, x = _ && Date.now(), w = m.zlevel === p._zlevelList[0] ? p._backgroundColor : null;
      if (m.__startIndex === m.__endIndex)
        m.clear(!1, w, y);
      else if (b === m.__startIndex) {
        var S = e[b];
        (!S.incremental || !S.notClear || r) && m.clear(!1, w, y);
      }
      b === -1 && (console.error("For some unknown reason. drawIndex is -1"), b = m.__startIndex);
      var C, k = function(R) {
        var j = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: i._width,
          viewHeight: i._height
        };
        for (C = b; C < m.__endIndex; C++) {
          var z = e[C];
          if (z.__inHover && (d = !0), i._doPaintEl(z, m, o, R, j, C === m.__endIndex - 1), _) {
            var F = Date.now() - x;
            if (F > 15)
              break;
          }
        }
        j.prevElClipPaths && g.restore();
      };
      if (y)
        if (y.length === 0)
          C = m.__endIndex;
        else
          for (var M = p.dpr, D = 0; D < y.length; ++D) {
            var N = y[D];
            g.save(), g.beginPath(), g.rect(N.x * M, N.y * M, N.width * M, N.height * M), g.clip(), k(N), g.restore();
          }
      else
        g.save(), k(), g.restore();
      m.__drawIndex = C, m.__drawIndex < m.__endIndex && (c = !1);
    }, p = this, h = 0; h < a.length; h++)
      f(h);
    return Vt.wxa && $(this._layers, function(v) {
      v && v.ctx && v.ctx.draw && v.ctx.draw();
    }), {
      finished: c,
      needsRefreshHover: d
    };
  }, n.prototype._doPaintEl = function(e, t, r, i, a, o) {
    var s = t.ctx;
    if (r) {
      var l = e.getPaintRect();
      (!i || l && l.intersect(i)) && (Kc(s, e, a, o), e.setPrevPaintRect(l));
    } else
      Kc(s, e, a, o);
  }, n.prototype.getLayer = function(e, t) {
    this._singleCanvas && !this._needsManuallyCompositing && (e = xc);
    var r = this._layers[e];
    return r || (r = new aE("zr_" + e, this, this.dpr), r.zlevel = e, r.__builtin__ = !0, this._layerConfig[e] ? At(r, this._layerConfig[e], !0) : this._layerConfig[e - L0] && At(r, this._layerConfig[e - L0], !0), t && (r.virtual = t), this.insertLayer(e, r), r.initContext()), r;
  }, n.prototype.insertLayer = function(e, t) {
    var r = this._layers, i = this._zlevelList, a = i.length, o = this._domRoot, s = null, l = -1;
    if (r[e]) {
      process.env.NODE_ENV !== "production" && _o("ZLevel " + e + " has been used already");
      return;
    }
    if (!e5e(t)) {
      process.env.NODE_ENV !== "production" && _o("Layer of zlevel " + e + " is not valid");
      return;
    }
    if (a > 0 && e > i[0]) {
      for (l = 0; l < a - 1 && !(i[l] < e && i[l + 1] > e); l++)
        ;
      s = r[i[l]];
    }
    if (i.splice(l + 1, 0, e), r[e] = t, !t.virtual)
      if (s) {
        var u = s.dom;
        u.nextSibling ? o.insertBefore(t.dom, u.nextSibling) : o.appendChild(t.dom);
      } else
        o.firstChild ? o.insertBefore(t.dom, o.firstChild) : o.appendChild(t.dom);
    t.painter || (t.painter = this);
  }, n.prototype.eachLayer = function(e, t) {
    for (var r = this._zlevelList, i = 0; i < r.length; i++) {
      var a = r[i];
      e.call(t, this._layers[a], a);
    }
  }, n.prototype.eachBuiltinLayer = function(e, t) {
    for (var r = this._zlevelList, i = 0; i < r.length; i++) {
      var a = r[i], o = this._layers[a];
      o.__builtin__ && e.call(t, o, a);
    }
  }, n.prototype.eachOtherLayer = function(e, t) {
    for (var r = this._zlevelList, i = 0; i < r.length; i++) {
      var a = r[i], o = this._layers[a];
      o.__builtin__ || e.call(t, o, a);
    }
  }, n.prototype.getLayers = function() {
    return this._layers;
  }, n.prototype._updateLayerStatus = function(e) {
    this.eachBuiltinLayer(function(d, f) {
      d.__dirty = d.__used = !1;
    });
    function t(d) {
      a && (a.__endIndex !== d && (a.__dirty = !0), a.__endIndex = d);
    }
    if (this._singleCanvas)
      for (var r = 1; r < e.length; r++) {
        var i = e[r];
        if (i.zlevel !== e[r - 1].zlevel || i.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var a = null, o = 0, s, l;
    for (l = 0; l < e.length; l++) {
      var i = e[l], u = i.zlevel, c = void 0;
      s !== u && (s = u, o = 0), i.incremental ? (c = this.getLayer(u + Qje, this._needsManuallyCompositing), c.incremental = !0, o = 1) : c = this.getLayer(u + (o > 0 ? L0 : 0), this._needsManuallyCompositing), c.__builtin__ || _o("ZLevel " + u + " has been used by unkown layer " + c.id), c !== a && (c.__used = !0, c.__startIndex !== l && (c.__dirty = !0), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, t(l), a = c), i.__dirty & pa && !i.__inHover && (c.__dirty = !0, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
    }
    t(l), this.eachBuiltinLayer(function(d, f) {
      !d.__used && d.getElementCount() > 0 && (d.__dirty = !0, d.__startIndex = d.__endIndex = d.__drawIndex = 0), d.__dirty && d.__drawIndex < 0 && (d.__drawIndex = d.__startIndex);
    });
  }, n.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, n.prototype._clearLayer = function(e) {
    e.clear();
  }, n.prototype.setBackgroundColor = function(e) {
    this._backgroundColor = e, $(this._layers, function(t) {
      t.setUnpainted();
    });
  }, n.prototype.configLayer = function(e, t) {
    if (t) {
      var r = this._layerConfig;
      r[e] ? At(r[e], t, !0) : r[e] = t;
      for (var i = 0; i < this._zlevelList.length; i++) {
        var a = this._zlevelList[i];
        if (a === e || a === e + L0) {
          var o = this._layers[a];
          At(o, r[e], !0);
        }
      }
    }
  }, n.prototype.delLayer = function(e) {
    var t = this._layers, r = this._zlevelList, i = t[e];
    i && (i.dom.parentNode.removeChild(i.dom), delete t[e], r.splice(Pt(r, e), 1));
  }, n.prototype.resize = function(e, t) {
    if (this._domRoot.style) {
      var r = this._domRoot;
      r.style.display = "none";
      var i = this._opts, a = this.root;
      if (e != null && (i.width = e), t != null && (i.height = t), e = cp(a, 0, i), t = cp(a, 1, i), r.style.display = "", this._width !== e || t !== this._height) {
        r.style.width = e + "px", r.style.height = t + "px";
        for (var o in this._layers)
          this._layers.hasOwnProperty(o) && this._layers[o].resize(e, t);
        this.refresh(!0);
      }
      this._width = e, this._height = t;
    } else {
      if (e == null || t == null)
        return;
      this._width = e, this._height = t, this.getLayer(xc).resize(e, t);
    }
    return this;
  }, n.prototype.clearLayer = function(e) {
    var t = this._layers[e];
    t && t.clear();
  }, n.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, n.prototype.getRenderedCanvas = function(e) {
    if (e = e || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[xc].dom;
    var t = new aE("image", this, e.pixelRatio || this.dpr);
    t.initContext(), t.clear(!1, e.backgroundColor || this._backgroundColor);
    var r = t.ctx;
    if (e.pixelRatio <= this.dpr) {
      this.refresh();
      var i = t.dom.width, a = t.dom.height;
      this.eachLayer(function(d) {
        d.__builtin__ ? r.drawImage(d.dom, 0, 0, i, a) : d.renderToCanvas && (r.save(), d.renderToCanvas(r), r.restore());
      });
    } else
      for (var o = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, s = this.storage.getDisplayList(!0), l = 0, u = s.length; l < u; l++) {
        var c = s[l];
        Kc(r, c, o, l === u - 1);
      }
    return t.dom;
  }, n.prototype.getWidth = function() {
    return this._width;
  }, n.prototype.getHeight = function() {
    return this._height;
  }, n;
}();
function r5e(n) {
  n.registerPainter("canvas", n5e);
}
var i5e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t) {
      if (process.env.NODE_ENV !== "production") {
        var r = t.coordinateSystem;
        if (r !== "polar" && r !== "cartesian2d")
          throw new Error("Line not support coordinateSystem besides cartesian and polar");
      }
      return Dl(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getLegendIcon = function(t) {
      var r = new mt(), i = yr("line", 0, t.itemHeight / 2, t.itemWidth, 0, t.lineStyle.stroke, !1);
      r.add(i), i.setStyle(t.lineStyle);
      var a = this.getData().getVisual("symbol"), o = this.getData().getVisual("symbolRotate"), s = a === "none" ? "circle" : a, l = t.itemHeight * 0.8, u = yr(s, (t.itemWidth - l) / 2, (t.itemHeight - l) / 2, l, l, t.itemStyle.fill);
      r.add(u), u.setStyle(t.itemStyle);
      var c = t.iconRotate === "inherit" ? o : t.iconRotate || 0;
      return u.rotation = c * Math.PI / 180, u.setOrigin([t.itemWidth / 2, t.itemHeight / 2]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), r;
    }, e.type = "series.line", e.dependencies = ["grid", "polar"], e.defaultOption = {
      // zlevel: 0,
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      clip: !0,
      label: {
        position: "top"
      },
      // itemStyle: {
      // },
      endLabel: {
        show: !1,
        valueAnimation: !0,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: !0
      },
      // areaStyle: {
      // origin of areaStyle. Valid values:
      // `'auto'/null/undefined`: from axisLine to data
      // `'start'`: from min to data
      // `'end'`: from data to max
      // origin: 'auto'
      // },
      // false, 'start', 'end', 'middle'
      step: !1,
      // Disabled if step is true
      smooth: !1,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: !0,
      // `false`: follow the label interval strategy.
      // `true`: show all symbols.
      // `'auto'`: If possible, show all symbols, otherwise
      //           follow the label interval strategy.
      showAllSymbol: "auto",
      // Whether to connect break point.
      connectNulls: !1,
      // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
      sampling: "none",
      animationEasing: "linear",
      // Disable progressive
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: !1
    }, e;
  }(Rn)
);
function Up(n, e) {
  var t = n.mapDimensionsAll("defaultedLabel"), r = t.length;
  if (r === 1) {
    var i = Vp(n, e, t[0]);
    return i != null ? i + "" : null;
  } else if (r) {
    for (var a = [], o = 0; o < t.length; o++)
      a.push(Vp(n, e, t[o]));
    return a.join(" ");
  }
}
function Wq(n, e) {
  var t = n.mapDimensionsAll("defaultedLabel");
  if (!Me(e))
    return e + "";
  for (var r = [], i = 0; i < t.length; i++) {
    var a = n.getDimensionIndex(t[i]);
    a >= 0 && r.push(e[a]);
  }
  return r.join(" ");
}
var Zg = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i, a) {
      var o = n.call(this) || this;
      return o.updateData(t, r, i, a), o;
    }
    return e.prototype._createSymbol = function(t, r, i, a, o) {
      this.removeAll();
      var s = yr(t, -1, -1, 2, 2, null, o);
      s.attr({
        z2: 100,
        culling: !0,
        scaleX: a[0] / 2,
        scaleY: a[1] / 2
      }), s.drift = a5e, this._symbolType = t, this.add(s);
    }, e.prototype.stopSymbolAnimation = function(t) {
      this.childAt(0).stopAnimation(null, t);
    }, e.prototype.getSymbolType = function() {
      return this._symbolType;
    }, e.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, e.prototype.highlight = function() {
      xl(this.childAt(0));
    }, e.prototype.downplay = function() {
      wl(this.childAt(0));
    }, e.prototype.setZ = function(t, r) {
      var i = this.childAt(0);
      i.zlevel = t, i.z = r;
    }, e.prototype.setDraggable = function(t, r) {
      var i = this.childAt(0);
      i.draggable = t, i.cursor = !r && t ? "move" : i.cursor;
    }, e.prototype.updateData = function(t, r, i, a) {
      this.silent = !1;
      var o = t.getItemVisual(r, "symbol") || "circle", s = t.hostModel, l = e.getSymbolSize(t, r), u = o !== this._symbolType, c = a && a.disableAnimation;
      if (u) {
        var d = t.getItemVisual(r, "symbolKeepAspect");
        this._createSymbol(o, t, r, l, d);
      } else {
        var f = this.childAt(0);
        f.silent = !1;
        var p = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2
        };
        c ? f.attr(p) : ln(f, p, s, r), Oo(f);
      }
      if (this._updateCommon(t, r, l, i, a), u) {
        var f = this.childAt(0);
        if (!c) {
          var p = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              // Always fadeIn. Because it has fadeOut animation when symbol is removed..
              opacity: f.style.opacity
            }
          };
          f.scaleX = f.scaleY = 0, f.style.opacity = 0, Gn(f, p, s, r);
        }
      }
      c && this.childAt(0).stopAnimation("leave");
    }, e.prototype._updateCommon = function(t, r, i, a, o) {
      var s = this.childAt(0), l = t.hostModel, u, c, d, f, p, h, v, m, g;
      if (a && (u = a.emphasisItemStyle, c = a.blurItemStyle, d = a.selectItemStyle, f = a.focus, p = a.blurScope, v = a.labelStatesModels, m = a.hoverScale, g = a.cursorStyle, h = a.emphasisDisabled), !a || t.hasItemOption) {
        var y = a && a.itemModel ? a.itemModel : t.getItemModel(r), b = y.getModel("emphasis");
        u = b.getModel("itemStyle").getItemStyle(), d = y.getModel(["select", "itemStyle"]).getItemStyle(), c = y.getModel(["blur", "itemStyle"]).getItemStyle(), f = b.get("focus"), p = b.get("blurScope"), h = b.get("disabled"), v = Nr(y), m = b.getShallow("scale"), g = y.getShallow("cursor");
      }
      var _ = t.getItemVisual(r, "symbolRotate");
      s.attr("rotation", (_ || 0) * Math.PI / 180 || 0);
      var x = ef(t.getItemVisual(r, "symbolOffset"), i);
      x && (s.x = x[0], s.y = x[1]), g && s.attr("cursor", g);
      var w = t.getItemVisual(r, "style"), S = w.fill;
      if (s instanceof Ur) {
        var C = s.style;
        s.useStyle(xe({
          // TODO other properties like x, y ?
          image: C.image,
          x: C.x,
          y: C.y,
          width: C.width,
          height: C.height
        }, w));
      } else
        s.__isEmptyBrush ? s.useStyle(xe({}, w)) : s.useStyle(w), s.style.decal = null, s.setColor(S, o && o.symbolInnerColor), s.style.strokeNoScale = !0;
      var k = t.getItemVisual(r, "liftZ"), M = this._z2;
      k != null ? M == null && (this._z2 = s.z2, s.z2 += k) : M != null && (s.z2 = M, this._z2 = null);
      var D = o && o.useNameLabel;
      ei(s, v, {
        labelFetcher: l,
        labelDataIndex: r,
        defaultText: N,
        inheritColor: S,
        defaultOpacity: w.opacity
      });
      function N(z) {
        return D ? t.getName(z) : Up(t, z);
      }
      this._sizeX = i[0] / 2, this._sizeY = i[1] / 2;
      var R = s.ensureState("emphasis");
      R.style = u, s.ensureState("select").style = d, s.ensureState("blur").style = c;
      var j = m == null || m === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(m) && m > 0 ? +m : 1;
      R.scaleX = this._sizeX * j, R.scaleY = this._sizeY * j, this.setSymbolScale(1), er(this, f, p, h);
    }, e.prototype.setSymbolScale = function(t) {
      this.scaleX = this.scaleY = t;
    }, e.prototype.fadeOut = function(t, r, i) {
      var a = this.childAt(0), o = yt(this).dataIndex, s = i && i.animation;
      if (this.silent = a.silent = !0, i && i.fadeLabel) {
        var l = a.getTextContent();
        l && Pu(l, {
          style: {
            opacity: 0
          }
        }, r, {
          dataIndex: o,
          removeOpt: s,
          cb: function() {
            a.removeTextContent();
          }
        });
      } else
        a.removeTextContent();
      Pu(a, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, r, {
        dataIndex: o,
        cb: t,
        removeOpt: s
      });
    }, e.getSymbolSize = function(t, r) {
      return _h(t.getItemVisual(r, "symbolSize"));
    }, e;
  }(mt)
);
function a5e(n, e) {
  this.parent.drift(n, e);
}
function oE(n, e, t, r) {
  return e && !isNaN(e[0]) && !isNaN(e[1]) && !(r.isIgnore && r.isIgnore(t)) && !(r.clipShape && !r.clipShape.contain(e[0], e[1])) && n.getItemVisual(t, "symbol") !== "none";
}
function sB(n) {
  return n != null && !ut(n) && (n = {
    isIgnore: n
  }), n || {};
}
function lB(n) {
  var e = n.hostModel, t = e.getModel("emphasis");
  return {
    emphasisItemStyle: t.getModel("itemStyle").getItemStyle(),
    blurItemStyle: e.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: e.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: t.get("focus"),
    blurScope: t.get("blurScope"),
    emphasisDisabled: t.get("disabled"),
    hoverScale: t.get("scale"),
    labelStatesModels: Nr(e),
    cursorStyle: e.get("cursor")
  };
}
var Jg = (
  /** @class */
  function() {
    function n(e) {
      this.group = new mt(), this._SymbolCtor = e || Zg;
    }
    return n.prototype.updateData = function(e, t) {
      this._progressiveEls = null, t = sB(t);
      var r = this.group, i = e.hostModel, a = this._data, o = this._SymbolCtor, s = t.disableAnimation, l = lB(e), u = {
        disableAnimation: s
      }, c = t.getSymbolPoint || function(d) {
        return e.getItemLayout(d);
      };
      a || r.removeAll(), e.diff(a).add(function(d) {
        var f = c(d);
        if (oE(e, f, d, t)) {
          var p = new o(e, d, l, u);
          p.setPosition(f), e.setItemGraphicEl(d, p), r.add(p);
        }
      }).update(function(d, f) {
        var p = a.getItemGraphicEl(f), h = c(d);
        if (!oE(e, h, d, t)) {
          r.remove(p);
          return;
        }
        var v = e.getItemVisual(d, "symbol") || "circle", m = p && p.getSymbolType && p.getSymbolType();
        if (!p || m && m !== v)
          r.remove(p), p = new o(e, d, l, u), p.setPosition(h);
        else {
          p.updateData(e, d, l, u);
          var g = {
            x: h[0],
            y: h[1]
          };
          s ? p.attr(g) : ln(p, g, i);
        }
        r.add(p), e.setItemGraphicEl(d, p);
      }).remove(function(d) {
        var f = a.getItemGraphicEl(d);
        f && f.fadeOut(function() {
          r.remove(f);
        }, i);
      }).execute(), this._getSymbolPoint = c, this._data = e;
    }, n.prototype.updateLayout = function() {
      var e = this, t = this._data;
      t && t.eachItemGraphicEl(function(r, i) {
        var a = e._getSymbolPoint(i);
        r.setPosition(a), r.markRedraw();
      });
    }, n.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = lB(e), this._data = null, this.group.removeAll();
    }, n.prototype.incrementalUpdate = function(e, t, r) {
      this._progressiveEls = [], r = sB(r);
      function i(l) {
        l.isGroup || (l.incremental = !0, l.ensureState("emphasis").hoverLayer = !0);
      }
      for (var a = e.start; a < e.end; a++) {
        var o = t.getItemLayout(a);
        if (oE(t, o, a, r)) {
          var s = new this._SymbolCtor(t, a, this._seriesScope);
          s.traverse(i), s.setPosition(o), this.group.add(s), t.setItemGraphicEl(a, s), this._progressiveEls.push(s);
        }
      }
    }, n.prototype.eachRendered = function(e) {
      Yu(this._progressiveEls || this.group, e);
    }, n.prototype.remove = function(e) {
      var t = this.group, r = this._data;
      r && e ? r.eachItemGraphicEl(function(i) {
        i.fadeOut(function() {
          t.remove(i);
        }, r.hostModel);
      }) : t.removeAll();
    }, n;
  }()
);
function qq(n, e, t) {
  var r = n.getBaseAxis(), i = n.getOtherAxis(r), a = o5e(i, t), o = r.dim, s = i.dim, l = e.mapDimension(s), u = e.mapDimension(o), c = s === "x" || s === "radius" ? 1 : 0, d = De(n.dimensions, function(h) {
    return e.mapDimension(h);
  }), f = !1, p = e.getCalculationInfo("stackResultDimension");
  return Bu(
    e,
    d[0]
    /* , dims[1] */
  ) && (f = !0, d[0] = p), Bu(
    e,
    d[1]
    /* , dims[0] */
  ) && (f = !0, d[1] = p), {
    dataDimsForPoint: d,
    valueStart: a,
    valueAxisDim: s,
    baseAxisDim: o,
    stacked: !!f,
    valueDim: l,
    baseDim: u,
    baseDataOffset: c,
    stackedOverDimension: e.getCalculationInfo("stackedOverDimension")
  };
}
function o5e(n, e) {
  var t = 0, r = n.scale.getExtent();
  return e === "start" ? t = r[0] : e === "end" ? t = r[1] : sn(e) && !isNaN(e) ? t = e : r[0] > 0 ? t = r[0] : r[1] < 0 && (t = r[1]), t;
}
function Yq(n, e, t, r) {
  var i = NaN;
  n.stacked && (i = t.get(t.getCalculationInfo("stackedOverDimension"), r)), isNaN(i) && (i = n.valueStart);
  var a = n.baseDataOffset, o = [];
  return o[a] = t.get(n.baseDim, r), o[1 - a] = i, e.dataToPoint(o);
}
function s5e(n, e) {
  var t = [];
  return e.diff(n).add(function(r) {
    t.push({
      cmd: "+",
      idx: r
    });
  }).update(function(r, i) {
    t.push({
      cmd: "=",
      idx: i,
      idx1: r
    });
  }).remove(function(r) {
    t.push({
      cmd: "-",
      idx: r
    });
  }).execute(), t;
}
function l5e(n, e, t, r, i, a, o, s) {
  for (var l = s5e(n, e), u = [], c = [], d = [], f = [], p = [], h = [], v = [], m = qq(i, e, o), g = n.getLayout("points") || [], y = e.getLayout("points") || [], b = 0; b < l.length; b++) {
    var _ = l[b], x = !0, w = void 0, S = void 0;
    switch (_.cmd) {
      case "=":
        w = _.idx * 2, S = _.idx1 * 2;
        var C = g[w], k = g[w + 1], M = y[S], D = y[S + 1];
        (isNaN(C) || isNaN(k)) && (C = M, k = D), u.push(C, k), c.push(M, D), d.push(t[w], t[w + 1]), f.push(r[S], r[S + 1]), v.push(e.getRawIndex(_.idx1));
        break;
      case "+":
        var N = _.idx, R = m.dataDimsForPoint, j = i.dataToPoint([e.get(R[0], N), e.get(R[1], N)]);
        S = N * 2, u.push(j[0], j[1]), c.push(y[S], y[S + 1]);
        var z = Yq(m, i, e, N);
        d.push(z[0], z[1]), f.push(r[S], r[S + 1]), v.push(e.getRawIndex(N));
        break;
      case "-":
        x = !1;
    }
    x && (p.push(_), h.push(h.length));
  }
  h.sort(function(pe, Be) {
    return v[pe] - v[Be];
  });
  for (var F = u.length, B = us(F), H = us(F), Y = us(F), ne = us(F), J = [], b = 0; b < h.length; b++) {
    var X = h[b], ie = b * 2, ye = X * 2;
    B[ie] = u[ye], B[ie + 1] = u[ye + 1], H[ie] = c[ye], H[ie + 1] = c[ye + 1], Y[ie] = d[ye], Y[ie + 1] = d[ye + 1], ne[ie] = f[ye], ne[ie + 1] = f[ye + 1], J[b] = p[X];
  }
  return {
    current: B,
    next: H,
    stackedOnCurrent: Y,
    stackedOnNext: ne,
    status: J
  };
}
var Gl = Math.min, Ul = Math.max;
function gd(n, e) {
  return isNaN(n) || isNaN(e);
}
function zk(n, e, t, r, i, a, o, s, l) {
  for (var u, c, d, f, p, h, v = t, m = 0; m < r; m++) {
    var g = e[v * 2], y = e[v * 2 + 1];
    if (v >= i || v < 0)
      break;
    if (gd(g, y)) {
      if (l) {
        v += a;
        continue;
      }
      break;
    }
    if (v === t)
      n[a > 0 ? "moveTo" : "lineTo"](g, y), d = g, f = y;
    else {
      var b = g - u, _ = y - c;
      if (b * b + _ * _ < 0.5) {
        v += a;
        continue;
      }
      if (o > 0) {
        for (var x = v + a, w = e[x * 2], S = e[x * 2 + 1]; w === g && S === y && m < r; )
          m++, x += a, v += a, w = e[x * 2], S = e[x * 2 + 1], g = e[v * 2], y = e[v * 2 + 1], b = g - u, _ = y - c;
        var C = m + 1;
        if (l)
          for (; gd(w, S) && C < r; )
            C++, x += a, w = e[x * 2], S = e[x * 2 + 1];
        var k = 0.5, M = 0, D = 0, N = void 0, R = void 0;
        if (C >= r || gd(w, S))
          p = g, h = y;
        else {
          M = w - u, D = S - c;
          var j = g - u, z = w - g, F = y - c, B = S - y, H = void 0, Y = void 0;
          if (s === "x") {
            H = Math.abs(j), Y = Math.abs(z);
            var ne = M > 0 ? 1 : -1;
            p = g - ne * H * o, h = y, N = g + ne * Y * o, R = y;
          } else if (s === "y") {
            H = Math.abs(F), Y = Math.abs(B);
            var J = D > 0 ? 1 : -1;
            p = g, h = y - J * H * o, N = g, R = y + J * Y * o;
          } else
            H = Math.sqrt(j * j + F * F), Y = Math.sqrt(z * z + B * B), k = Y / (Y + H), p = g - M * o * (1 - k), h = y - D * o * (1 - k), N = g + M * o * k, R = y + D * o * k, N = Gl(N, Ul(w, g)), R = Gl(R, Ul(S, y)), N = Ul(N, Gl(w, g)), R = Ul(R, Gl(S, y)), M = N - g, D = R - y, p = g - M * H / Y, h = y - D * H / Y, p = Gl(p, Ul(u, g)), h = Gl(h, Ul(c, y)), p = Ul(p, Gl(u, g)), h = Ul(h, Gl(c, y)), M = g - p, D = y - h, N = g + M * Y / H, R = y + D * Y / H;
        }
        n.bezierCurveTo(d, f, p, h, g, y), d = N, f = R;
      } else
        n.lineTo(g, y);
    }
    u = g, c = y, v += a;
  }
  return m;
}
var Kq = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.smooth = 0, this.smoothConstraint = !0;
    }
    return n;
  }()
), u5e = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "ec-polyline", r;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new Kq();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points, a = 0, o = i.length / 2;
      if (r.connectNulls) {
        for (; o > 0 && gd(i[o * 2 - 2], i[o * 2 - 1]); o--)
          ;
        for (; a < o && gd(i[a * 2], i[a * 2 + 1]); a++)
          ;
      }
      for (; a < o; )
        a += zk(t, i, a, o, o, 1, r.smooth, r.smoothMonotone, r.connectNulls) + 1;
    }, e.prototype.getPointOn = function(t, r) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var i = this.path, a = i.data, o = Ts.CMD, s, l, u = r === "x", c = [], d = 0; d < a.length; ) {
        var f = a[d++], p = void 0, h = void 0, v = void 0, m = void 0, g = void 0, y = void 0, b = void 0;
        switch (f) {
          case o.M:
            s = a[d++], l = a[d++];
            break;
          case o.L:
            if (p = a[d++], h = a[d++], b = u ? (t - s) / (p - s) : (t - l) / (h - l), b <= 1 && b >= 0) {
              var _ = u ? (h - l) * b + l : (p - s) * b + s;
              return u ? [t, _] : [_, t];
            }
            s = p, l = h;
            break;
          case o.C:
            p = a[d++], h = a[d++], v = a[d++], m = a[d++], g = a[d++], y = a[d++];
            var x = u ? qb(s, p, v, g, t, c) : qb(l, h, m, y, t, c);
            if (x > 0)
              for (var w = 0; w < x; w++) {
                var S = c[w];
                if (S <= 1 && S >= 0) {
                  var _ = u ? Ar(l, h, m, y, S) : Ar(s, p, v, g, S);
                  return u ? [t, _] : [_, t];
                }
              }
            s = g, l = y;
            break;
        }
      }
    }, e;
  }(Ht)
), c5e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e;
  }(Kq)
), Xq = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "ec-polygon", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new c5e();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points, a = r.stackedOnPoints, o = 0, s = i.length / 2, l = r.smoothMonotone;
      if (r.connectNulls) {
        for (; s > 0 && gd(i[s * 2 - 2], i[s * 2 - 1]); s--)
          ;
        for (; o < s && gd(i[o * 2], i[o * 2 + 1]); o++)
          ;
      }
      for (; o < s; ) {
        var u = zk(t, i, o, s, s, 1, r.smooth, l, r.connectNulls);
        zk(t, a, o + u - 1, u, s, -1, r.stackedOnSmooth, l, r.connectNulls), o += u + 1, t.closePath();
      }
    }, e;
  }(Ht)
);
function Zq(n, e, t, r, i) {
  var a = n.getArea(), o = a.x, s = a.y, l = a.width, u = a.height, c = t.get(["lineStyle", "width"]) || 0;
  o -= c / 2, s -= c / 2, l += c, u += c, l = Math.ceil(l), o !== Math.floor(o) && (o = Math.floor(o), l++);
  var d = new Qt({
    shape: {
      x: o,
      y: s,
      width: l,
      height: u
    }
  });
  if (e) {
    var f = n.getBaseAxis(), p = f.isHorizontal(), h = f.inverse;
    p ? (h && (d.shape.x += l), d.shape.width = 0) : (h || (d.shape.y += u), d.shape.height = 0);
    var v = at(i) ? function(m) {
      i(m, d);
    } : null;
    Gn(d, {
      shape: {
        width: l,
        height: u,
        x: o,
        y: s
      }
    }, t, null, r, v);
  }
  return d;
}
function Jq(n, e, t) {
  var r = n.getArea(), i = ir(r.r0, 1), a = ir(r.r, 1), o = new Fi({
    shape: {
      cx: ir(n.cx, 1),
      cy: ir(n.cy, 1),
      r0: i,
      r: a,
      startAngle: r.startAngle,
      endAngle: r.endAngle,
      clockwise: r.clockwise
    }
  });
  if (e) {
    var s = n.getBaseAxis().dim === "angle";
    s ? o.shape.endAngle = r.startAngle : o.shape.r = i, Gn(o, {
      shape: {
        endAngle: r.endAngle,
        r: a
      }
    }, t);
  }
  return o;
}
function Qg(n, e, t, r, i) {
  if (n) {
    if (n.type === "polar")
      return Jq(n, e, t);
    if (n.type === "cartesian2d")
      return Zq(n, e, t, r, i);
  } else return null;
  return null;
}
function nf(n, e) {
  return n.type === e;
}
function uB(n, e) {
  if (n.length === e.length) {
    for (var t = 0; t < n.length; t++)
      if (n[t] !== e[t])
        return;
    return !0;
  }
}
function cB(n) {
  for (var e = 1 / 0, t = 1 / 0, r = -1 / 0, i = -1 / 0, a = 0; a < n.length; ) {
    var o = n[a++], s = n[a++];
    isNaN(o) || (e = Math.min(o, e), r = Math.max(o, r)), isNaN(s) || (t = Math.min(s, t), i = Math.max(s, i));
  }
  return [[e, t], [r, i]];
}
function dB(n, e) {
  var t = cB(n), r = t[0], i = t[1], a = cB(e), o = a[0], s = a[1];
  return Math.max(Math.abs(r[0] - o[0]), Math.abs(r[1] - o[1]), Math.abs(i[0] - s[0]), Math.abs(i[1] - s[1]));
}
function fB(n) {
  return sn(n) ? n : n ? 0.5 : 0;
}
function d5e(n, e, t) {
  if (!t.valueDim)
    return [];
  for (var r = e.count(), i = us(r * 2), a = 0; a < r; a++) {
    var o = Yq(t, n, e, a);
    i[a * 2] = o[0], i[a * 2 + 1] = o[1];
  }
  return i;
}
function Wl(n, e, t, r, i) {
  var a = t.getBaseAxis(), o = a.dim === "x" || a.dim === "radius" ? 0 : 1, s = [], l = 0, u = [], c = [], d = [], f = [];
  if (i) {
    for (l = 0; l < n.length; l += 2) {
      var p = e || n;
      !isNaN(p[l]) && !isNaN(p[l + 1]) && f.push(n[l], n[l + 1]);
    }
    n = f;
  }
  for (l = 0; l < n.length - 2; l += 2)
    switch (d[0] = n[l + 2], d[1] = n[l + 3], c[0] = n[l], c[1] = n[l + 1], s.push(c[0], c[1]), r) {
      case "end":
        u[o] = d[o], u[1 - o] = c[1 - o], s.push(u[0], u[1]);
        break;
      case "middle":
        var h = (c[o] + d[o]) / 2, v = [];
        u[o] = v[o] = h, u[1 - o] = c[1 - o], v[1 - o] = d[1 - o], s.push(u[0], u[1]), s.push(v[0], v[1]);
        break;
      default:
        u[o] = c[o], u[1 - o] = d[1 - o], s.push(u[0], u[1]);
    }
  return s.push(n[l++], n[l++]), s;
}
function f5e(n, e) {
  var t = [], r = n.length, i, a;
  function o(c, d, f) {
    var p = c.coord, h = (f - p) / (d.coord - p), v = KDe(h, [c.color, d.color]);
    return {
      coord: f,
      color: v
    };
  }
  for (var s = 0; s < r; s++) {
    var l = n[s], u = l.coord;
    if (u < 0)
      i = l;
    else if (u > e) {
      a ? t.push(o(a, l, e)) : i && t.push(o(i, l, 0), o(i, l, e));
      break;
    } else
      i && (t.push(o(i, l, 0)), i = null), t.push(l), a = l;
  }
  return t;
}
function p5e(n, e, t) {
  var r = n.getVisual("visualMeta");
  if (!(!r || !r.length || !n.count())) {
    if (e.type !== "cartesian2d") {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style is only supported on cartesian2d.");
      return;
    }
    for (var i, a, o = r.length - 1; o >= 0; o--) {
      var s = n.getDimensionInfo(r[o].dimension);
      if (i = s && s.coordDim, i === "x" || i === "y") {
        a = r[o];
        break;
      }
    }
    if (!a) {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style only support x or y dimension.");
      return;
    }
    var l = e.getAxis(i), u = De(a.stops, function(b) {
      return {
        coord: l.toGlobalCoord(l.dataToCoord(b.value)),
        color: b.color
      };
    }), c = u.length, d = a.outerColors.slice();
    c && u[0].coord > u[c - 1].coord && (u.reverse(), d.reverse());
    var f = f5e(u, i === "x" ? t.getWidth() : t.getHeight()), p = f.length;
    if (!p && c)
      return u[0].coord < 0 ? d[1] ? d[1] : u[c - 1].color : d[0] ? d[0] : u[0].color;
    var h = 10, v = f[0].coord - h, m = f[p - 1].coord + h, g = m - v;
    if (g < 1e-3)
      return "transparent";
    $(f, function(b) {
      b.offset = (b.coord - v) / g;
    }), f.push({
      // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
      offset: p ? f[p - 1].offset : 0.5,
      color: d[1] || "transparent"
    }), f.unshift({
      offset: p ? f[0].offset : 0.5,
      color: d[0] || "transparent"
    });
    var y = new Ug(0, 0, 0, 0, f, !0);
    return y[i] = v, y[i + "2"] = m, y;
  }
}
function h5e(n, e, t) {
  var r = n.get("showAllSymbol"), i = r === "auto";
  if (!(r && !i)) {
    var a = t.getAxesByScale("ordinal")[0];
    if (a && !(i && v5e(a, e))) {
      var o = e.mapDimension(a.dim), s = {};
      return $(a.getViewLabels(), function(l) {
        var u = a.scale.getRawOrdinalNumber(l.tickValue);
        s[u] = 1;
      }), function(l) {
        return !s.hasOwnProperty(e.get(o, l));
      };
    }
  }
}
function v5e(n, e) {
  var t = n.getExtent(), r = Math.abs(t[1] - t[0]) / n.scale.count();
  isNaN(r) && (r = 0);
  for (var i = e.count(), a = Math.max(1, Math.round(i / 5)), o = 0; o < i; o += a)
    if (Zg.getSymbolSize(
      e,
      o
      // Only for cartesian, where `isHorizontal` exists.
    )[n.isHorizontal() ? 1 : 0] * 1.5 > r)
      return !1;
  return !0;
}
function m5e(n, e) {
  return isNaN(n) || isNaN(e);
}
function g5e(n) {
  for (var e = n.length / 2; e > 0 && m5e(n[e * 2 - 2], n[e * 2 - 1]); e--)
    ;
  return e - 1;
}
function pB(n, e) {
  return [n[e * 2], n[e * 2 + 1]];
}
function y5e(n, e, t) {
  for (var r = n.length / 2, i = t === "x" ? 0 : 1, a, o, s = 0, l = -1, u = 0; u < r; u++)
    if (o = n[u * 2 + i], !(isNaN(o) || isNaN(n[u * 2 + 1 - i]))) {
      if (u === 0) {
        a = o;
        continue;
      }
      if (a <= e && o >= e || a >= e && o <= e) {
        l = u;
        break;
      }
      s = u, a = o;
    }
  return {
    range: [s, l],
    t: (e - a) / (o - a)
  };
}
function Qq(n) {
  if (n.get(["endLabel", "show"]))
    return !0;
  for (var e = 0; e < zi.length; e++)
    if (n.get([zi[e], "endLabel", "show"]))
      return !0;
  return !1;
}
function sE(n, e, t, r) {
  if (nf(e, "cartesian2d")) {
    var i = r.getModel("endLabel"), a = i.get("valueAnimation"), o = r.getData(), s = {
      lastFrameIndex: 0
    }, l = Qq(r) ? function(p, h) {
      n._endLabelOnDuring(p, h, o, s, a, i, e);
    } : null, u = e.getBaseAxis().isHorizontal(), c = Zq(e, t, r, function() {
      var p = n._endLabel;
      p && t && s.originalX != null && p.attr({
        x: s.originalX,
        y: s.originalY
      });
    }, l);
    if (!r.get("clip", !0)) {
      var d = c.shape, f = Math.max(d.width, d.height);
      u ? (d.y -= f, d.height += f * 2) : (d.x -= f, d.width += f * 2);
    }
    return l && l(1, c), c;
  } else
    return process.env.NODE_ENV !== "production" && r.get(["endLabel", "show"]) && console.warn("endLabel is not supported for lines in polar systems."), Jq(e, t, r);
}
function b5e(n, e) {
  var t = e.getBaseAxis(), r = t.isHorizontal(), i = t.inverse, a = r ? i ? "right" : "left" : "center", o = r ? "middle" : i ? "top" : "bottom";
  return {
    normal: {
      align: n.get("align") || a,
      verticalAlign: n.get("verticalAlign") || o
    }
  };
}
var _5e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      var t = new mt(), r = new Jg();
      this.group.add(r.group), this._symbolDraw = r, this._lineGroup = t, this._changePolyState = Ze(this._changePolyState, this);
    }, e.prototype.render = function(t, r, i) {
      var a = t.coordinateSystem, o = this.group, s = t.getData(), l = t.getModel("lineStyle"), u = t.getModel("areaStyle"), c = s.getLayout("points") || [], d = a.type === "polar", f = this._coordSys, p = this._symbolDraw, h = this._polyline, v = this._polygon, m = this._lineGroup, g = !r.ssr && t.get("animation"), y = !u.isEmpty(), b = u.get("origin"), _ = qq(a, s, b), x = y && d5e(a, s, _), w = t.get("showSymbol"), S = t.get("connectNulls"), C = w && !d && h5e(t, s, a), k = this._data;
      k && k.eachItemGraphicEl(function(pe, Be) {
        pe.__temp && (o.remove(pe), k.setItemGraphicEl(Be, null));
      }), w || p.remove(), o.add(m);
      var M = d ? !1 : t.get("step"), D;
      a && a.getArea && t.get("clip", !0) && (D = a.getArea(), D.width != null ? (D.x -= 0.1, D.y -= 0.1, D.width += 0.2, D.height += 0.2) : D.r0 && (D.r0 -= 0.5, D.r += 0.5)), this._clipShapeForSymbol = D;
      var N = p5e(s, a, i) || s.getVisual("style")[s.getVisual("drawType")];
      if (!(h && f.type === a.type && M === this._step))
        w && p.updateData(s, {
          isIgnore: C,
          clipShape: D,
          disableAnimation: !0,
          getSymbolPoint: function(pe) {
            return [c[pe * 2], c[pe * 2 + 1]];
          }
        }), g && this._initSymbolLabelAnimation(s, a, D), M && (x && (x = Wl(x, c, a, M, S)), c = Wl(c, null, a, M, S)), h = this._newPolyline(c), y ? v = this._newPolygon(c, x) : v && (m.remove(v), v = this._polygon = null), d || this._initOrUpdateEndLabel(t, a, Rd(N)), m.setClipPath(sE(this, a, !0, t));
      else {
        y && !v ? v = this._newPolygon(c, x) : v && !y && (m.remove(v), v = this._polygon = null), d || this._initOrUpdateEndLabel(t, a, Rd(N));
        var R = m.getClipPath();
        if (R) {
          var j = sE(this, a, !1, t);
          Gn(R, {
            shape: j.shape
          }, t);
        } else
          m.setClipPath(sE(this, a, !0, t));
        w && p.updateData(s, {
          isIgnore: C,
          clipShape: D,
          disableAnimation: !0,
          getSymbolPoint: function(pe) {
            return [c[pe * 2], c[pe * 2 + 1]];
          }
        }), (!uB(this._stackedOnPoints, x) || !uB(this._points, c)) && (g ? this._doUpdateAnimation(s, x, a, i, M, b, S) : (M && (x && (x = Wl(x, c, a, M, S)), c = Wl(c, null, a, M, S)), h.setShape({
          points: c
        }), v && v.setShape({
          points: c,
          stackedOnPoints: x
        })));
      }
      var z = t.getModel("emphasis"), F = z.get("focus"), B = z.get("blurScope"), H = z.get("disabled");
      if (h.useStyle(dt(
        // Use color in lineStyle first
        l.getLineStyle(),
        {
          fill: "none",
          stroke: N,
          lineJoin: "bevel"
        }
      )), Qr(h, t, "lineStyle"), h.style.lineWidth > 0 && t.get(["emphasis", "lineStyle", "width"]) === "bolder") {
        var Y = h.getState("emphasis").style;
        Y.lineWidth = +h.style.lineWidth + 1;
      }
      yt(h).seriesIndex = t.seriesIndex, er(h, F, B, H);
      var ne = fB(t.get("smooth")), J = t.get("smoothMonotone");
      if (h.setShape({
        smooth: ne,
        smoothMonotone: J,
        connectNulls: S
      }), v) {
        var X = s.getCalculationInfo("stackedOnSeries"), ie = 0;
        v.useStyle(dt(u.getAreaStyle(), {
          fill: N,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: s.getVisual("style").decal
        })), X && (ie = fB(X.get("smooth"))), v.setShape({
          smooth: ne,
          stackedOnSmooth: ie,
          smoothMonotone: J,
          connectNulls: S
        }), Qr(v, t, "areaStyle"), yt(v).seriesIndex = t.seriesIndex, er(v, F, B, H);
      }
      var ye = this._changePolyState;
      s.eachItemGraphicEl(function(pe) {
        pe && (pe.onHoverStateChange = ye);
      }), this._polyline.onHoverStateChange = ye, this._data = s, this._coordSys = a, this._stackedOnPoints = x, this._points = c, this._step = M, this._valueOrigin = b, t.get("triggerLineEvent") && (this.packEventData(t, h), v && this.packEventData(t, v));
    }, e.prototype.packEventData = function(t, r) {
      yt(r).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: t.componentIndex,
        seriesIndex: t.seriesIndex,
        seriesName: t.name,
        seriesType: "line"
      };
    }, e.prototype.highlight = function(t, r, i, a) {
      var o = t.getData(), s = Id(o, a);
      if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
        var l = o.getLayout("points"), u = o.getItemGraphicEl(s);
        if (!u) {
          var c = l[s * 2], d = l[s * 2 + 1];
          if (isNaN(c) || isNaN(d) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(c, d))
            return;
          var f = t.get("zlevel") || 0, p = t.get("z") || 0;
          u = new Zg(o, s), u.x = c, u.y = d, u.setZ(f, p);
          var h = u.getSymbolPath().getTextContent();
          h && (h.zlevel = f, h.z = p, h.z2 = this._polyline.z2 + 1), u.__temp = !0, o.setItemGraphicEl(s, u), u.stopSymbolAnimation(!0), this.group.add(u);
        }
        u.highlight();
      } else
        Tn.prototype.highlight.call(this, t, r, i, a);
    }, e.prototype.downplay = function(t, r, i, a) {
      var o = t.getData(), s = Id(o, a);
      if (this._changePolyState("normal"), s != null && s >= 0) {
        var l = o.getItemGraphicEl(s);
        l && (l.__temp ? (o.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay());
      } else
        Tn.prototype.downplay.call(this, t, r, i, a);
    }, e.prototype._changePolyState = function(t) {
      var r = this._polygon;
      e_(this._polyline, t), r && e_(r, t);
    }, e.prototype._newPolyline = function(t) {
      var r = this._polyline;
      return r && this._lineGroup.remove(r), r = new u5e({
        shape: {
          points: t
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(r), this._polyline = r, r;
    }, e.prototype._newPolygon = function(t, r) {
      var i = this._polygon;
      return i && this._lineGroup.remove(i), i = new Xq({
        shape: {
          points: t,
          stackedOnPoints: r
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(i), this._polygon = i, i;
    }, e.prototype._initSymbolLabelAnimation = function(t, r, i) {
      var a, o, s = r.getBaseAxis(), l = s.inverse;
      r.type === "cartesian2d" ? (a = s.isHorizontal(), o = !1) : r.type === "polar" && (a = s.dim === "angle", o = !0);
      var u = t.hostModel, c = u.get("animationDuration");
      at(c) && (c = c(null));
      var d = u.get("animationDelay") || 0, f = at(d) ? d(null) : d;
      t.eachItemGraphicEl(function(p, h) {
        var v = p;
        if (v) {
          var m = [p.x, p.y], g = void 0, y = void 0, b = void 0;
          if (i)
            if (o) {
              var _ = i, x = r.pointToCoord(m);
              a ? (g = _.startAngle, y = _.endAngle, b = -x[1] / 180 * Math.PI) : (g = _.r0, y = _.r, b = x[0]);
            } else {
              var w = i;
              a ? (g = w.x, y = w.x + w.width, b = p.x) : (g = w.y + w.height, y = w.y, b = p.y);
            }
          var S = y === g ? 0 : (b - g) / (y - g);
          l && (S = 1 - S);
          var C = at(d) ? d(h) : c * S + f, k = v.getSymbolPath(), M = k.getTextContent();
          v.attr({
            scaleX: 0,
            scaleY: 0
          }), v.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: !0,
            delay: C
          }), M && M.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: C
          }), k.disableLabelAnimation = !0;
        }
      });
    }, e.prototype._initOrUpdateEndLabel = function(t, r, i) {
      var a = t.getModel("endLabel");
      if (Qq(t)) {
        var o = t.getData(), s = this._polyline, l = o.getLayout("points");
        if (!l) {
          s.removeTextContent(), this._endLabel = null;
          return;
        }
        var u = this._endLabel;
        u || (u = this._endLabel = new nn({
          z2: 200
          // should be higher than item symbol
        }), u.ignoreClip = !0, s.setTextContent(this._endLabel), s.disableLabelAnimation = !0);
        var c = g5e(l);
        c >= 0 && (ei(s, Nr(t, "endLabel"), {
          inheritColor: i,
          labelFetcher: t,
          labelDataIndex: c,
          defaultText: function(d, f, p) {
            return p != null ? Wq(o, p) : Up(o, d);
          },
          enableTextSetter: !0
        }, b5e(a, r)), s.textConfig.position = null);
      } else this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, e.prototype._endLabelOnDuring = function(t, r, i, a, o, s, l) {
      var u = this._endLabel, c = this._polyline;
      if (u) {
        t < 1 && a.originalX == null && (a.originalX = u.x, a.originalY = u.y);
        var d = i.getLayout("points"), f = i.hostModel, p = f.get("connectNulls"), h = s.get("precision"), v = s.get("distance") || 0, m = l.getBaseAxis(), g = m.isHorizontal(), y = m.inverse, b = r.shape, _ = y ? g ? b.x : b.y + b.height : g ? b.x + b.width : b.y, x = (g ? v : 0) * (y ? -1 : 1), w = (g ? 0 : -v) * (y ? -1 : 1), S = g ? "x" : "y", C = y5e(d, _, S), k = C.range, M = k[1] - k[0], D = void 0;
        if (M >= 1) {
          if (M > 1 && !p) {
            var N = pB(d, k[0]);
            u.attr({
              x: N[0] + x,
              y: N[1] + w
            }), o && (D = f.getRawValue(k[0]));
          } else {
            var N = c.getPointOn(_, S);
            N && u.attr({
              x: N[0] + x,
              y: N[1] + w
            });
            var R = f.getRawValue(k[0]), j = f.getRawValue(k[1]);
            o && (D = $G(i, h, R, j, C.t));
          }
          a.lastFrameIndex = k[0];
        } else {
          var z = t === 1 || a.lastFrameIndex > 0 ? k[0] : 0, N = pB(d, z);
          o && (D = f.getRawValue(z)), u.attr({
            x: N[0] + x,
            y: N[1] + w
          });
        }
        if (o) {
          var F = fh(u);
          typeof F.setLabelText == "function" && F.setLabelText(D);
        }
      }
    }, e.prototype._doUpdateAnimation = function(t, r, i, a, o, s, l) {
      var u = this._polyline, c = this._polygon, d = t.hostModel, f = l5e(this._data, t, this._stackedOnPoints, r, this._coordSys, i, this._valueOrigin), p = f.current, h = f.stackedOnCurrent, v = f.next, m = f.stackedOnNext;
      if (o && (h = Wl(f.stackedOnCurrent, f.current, i, o, l), p = Wl(f.current, null, i, o, l), m = Wl(f.stackedOnNext, f.next, i, o, l), v = Wl(f.next, null, i, o, l)), dB(p, v) > 3e3 || c && dB(h, m) > 3e3) {
        u.stopAnimation(), u.setShape({
          points: v
        }), c && (c.stopAnimation(), c.setShape({
          points: v,
          stackedOnPoints: m
        }));
        return;
      }
      u.shape.__points = f.current, u.shape.points = p;
      var g = {
        shape: {
          points: v
        }
      };
      f.current !== p && (g.shape.__points = f.next), u.stopAnimation(), ln(u, g, d), c && (c.setShape({
        // Reuse the points with polyline.
        points: p,
        stackedOnPoints: h
      }), c.stopAnimation(), ln(c, {
        shape: {
          stackedOnPoints: m
        }
      }, d), u.shape.points !== c.shape.points && (c.shape.points = u.shape.points));
      for (var y = [], b = f.status, _ = 0; _ < b.length; _++) {
        var x = b[_].cmd;
        if (x === "=") {
          var w = t.getItemGraphicEl(b[_].idx1);
          w && y.push({
            el: w,
            ptIdx: _
            // Index of points
          });
        }
      }
      u.animators && u.animators.length && u.animators[0].during(function() {
        c && c.dirtyShape();
        for (var S = u.shape.__points, C = 0; C < y.length; C++) {
          var k = y[C].el, M = y[C].ptIdx * 2;
          k.x = S[M], k.y = S[M + 1], k.markRedraw();
        }
      });
    }, e.prototype.remove = function(t) {
      var r = this.group, i = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl(function(a, o) {
        a.__temp && (r.remove(a), i.setItemGraphicEl(o, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, e.type = "line", e;
  }(Tn)
);
function ey(n, e) {
  return {
    seriesType: n,
    plan: yh(),
    reset: function(t) {
      var r = t.getData(), i = t.coordinateSystem, a = t.pipelineContext, o = e || a.large;
      if (i) {
        var s = De(i.dimensions, function(p) {
          return r.mapDimension(p);
        }).slice(0, 2), l = s.length, u = r.getCalculationInfo("stackResultDimension");
        Bu(r, s[0]) && (s[0] = u), Bu(r, s[1]) && (s[1] = u);
        var c = r.getStore(), d = r.getDimensionIndex(s[0]), f = r.getDimensionIndex(s[1]);
        return l && {
          progress: function(p, h) {
            for (var v = p.end - p.start, m = o && us(v * l), g = [], y = [], b = p.start, _ = 0; b < p.end; b++) {
              var x = void 0;
              if (l === 1) {
                var w = c.get(d, b);
                x = i.dataToPoint(w, null, y);
              } else
                g[0] = c.get(d, b), g[1] = c.get(f, b), x = i.dataToPoint(g, null, y);
              o ? (m[_++] = x[0], m[_++] = x[1]) : h.setItemLayout(b, x.slice());
            }
            o && h.setLayout("points", m);
          }
        };
      }
    }
  };
}
var x5e = {
  average: function(n) {
    for (var e = 0, t = 0, r = 0; r < n.length; r++)
      isNaN(n[r]) || (e += n[r], t++);
    return t === 0 ? NaN : e / t;
  },
  sum: function(n) {
    for (var e = 0, t = 0; t < n.length; t++)
      e += n[t] || 0;
    return e;
  },
  max: function(n) {
    for (var e = -1 / 0, t = 0; t < n.length; t++)
      n[t] > e && (e = n[t]);
    return isFinite(e) ? e : NaN;
  },
  min: function(n) {
    for (var e = 1 / 0, t = 0; t < n.length; t++)
      n[t] < e && (e = n[t]);
    return isFinite(e) ? e : NaN;
  },
  // TODO
  // Median
  nearest: function(n) {
    return n[0];
  }
}, w5e = function(n) {
  return Math.round(n.length / 2);
};
function eY(n) {
  return {
    seriesType: n,
    // FIXME:TS never used, so comment it
    // modifyOutputEnd: true,
    reset: function(e, t, r) {
      var i = e.getData(), a = e.get("sampling"), o = e.coordinateSystem, s = i.count();
      if (s > 10 && o.type === "cartesian2d" && a) {
        var l = o.getBaseAxis(), u = o.getOtherAxis(l), c = l.getExtent(), d = r.getDevicePixelRatio(), f = Math.abs(c[1] - c[0]) * (d || 1), p = Math.round(s / f);
        if (isFinite(p) && p > 1) {
          a === "lttb" ? e.setData(i.lttbDownSample(i.mapDimension(u.dim), 1 / p)) : a === "minmax" && e.setData(i.minmaxDownSample(i.mapDimension(u.dim), 1 / p));
          var h = void 0;
          We(a) ? h = x5e[a] : at(a) && (h = a), h && e.setData(i.downSample(i.mapDimension(u.dim), 1 / p, h, w5e));
        }
      }
    }
  };
}
function S5e(n) {
  n.registerChartView(_5e), n.registerSeriesModel(i5e), n.registerLayout(ey("line", !0)), n.registerVisual({
    seriesType: "line",
    reset: function(e) {
      var t = e.getData(), r = e.getModel("lineStyle").getLineStyle();
      r && !r.stroke && (r.stroke = t.getVisual("style").fill), t.setVisual("legendLineStyle", r);
    }
  }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, eY("line"));
}
var dg = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return Dl(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getMarkerPosition = function(t, r, i) {
      var a = this.coordinateSystem;
      if (a && a.clampData) {
        var o = a.clampData(t), s = a.dataToPoint(o);
        if (i)
          $(a.getAxes(), function(f, p) {
            if (f.type === "category" && r != null) {
              var h = f.getTicksCoords(), v = f.getTickModel().get("alignWithLabel"), m = o[p], g = r[p] === "x1" || r[p] === "y1";
              if (g && !v && (m += 1), h.length < 2)
                return;
              if (h.length === 2) {
                s[p] = f.toGlobalCoord(f.getExtent()[g ? 1 : 0]);
                return;
              }
              for (var y = void 0, b = void 0, _ = 1, x = 0; x < h.length; x++) {
                var w = h[x].coord, S = x === h.length - 1 ? h[x - 1].tickValue + _ : h[x].tickValue;
                if (S === m) {
                  b = w;
                  break;
                } else if (S < m)
                  y = w;
                else if (y != null && S > m) {
                  b = (w + y) / 2;
                  break;
                }
                x === 1 && (_ = S - h[0].tickValue);
              }
              b == null && (y ? y && (b = h[h.length - 1].coord) : b = h[0].coord), s[p] = f.toGlobalCoord(b);
            }
          });
        else {
          var l = this.getData(), u = l.getLayout("offset"), c = l.getLayout("size"), d = a.getBaseAxis().isHorizontal() ? 0 : 1;
          s[d] += u + c / 2;
        }
        return s;
      }
      return [NaN, NaN];
    }, e.type = "series.__base_bar__", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // stack: null
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      barMinHeight: 0,
      barMinAngle: 0,
      // cursor: null,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    }, e;
  }(Rn)
);
Rn.registerClass(dg);
var E5e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function() {
      return Dl(null, this, {
        useEncodeDefaulter: !0,
        createInvertedIndices: !!this.get("realtimeSort", !0) || null
      });
    }, e.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : !1;
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.get("progressiveThreshold"), r = this.get("largeThreshold");
      return r > t && (t = r), t;
    }, e.prototype.brushSelector = function(t, r, i) {
      return i.rect(r.getItemLayout(t));
    }, e.type = "series.bar", e.dependencies = ["grid", "polar"], e.defaultOption = Ku(dg.defaultOption, {
      // If clipped
      // Only available on cartesian2d
      clip: !0,
      roundCap: !1,
      showBackground: !1,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: !1
    }), e;
  }(dg)
), T5e = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
    }
    return n;
  }()
), x_ = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "sausage", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new T5e();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.cx, a = r.cy, o = Math.max(r.r0 || 0, 0), s = Math.max(r.r, 0), l = (s - o) * 0.5, u = o + l, c = r.startAngle, d = r.endAngle, f = r.clockwise, p = Math.PI * 2, h = f ? d - c < p : c - d < p;
      h || (c = d - (f ? p : -p));
      var v = Math.cos(c), m = Math.sin(c), g = Math.cos(d), y = Math.sin(d);
      h ? (t.moveTo(v * o + i, m * o + a), t.arc(v * u + i, m * u + a, l, -Math.PI + c, c, !f)) : t.moveTo(v * s + i, m * s + a), t.arc(i, a, s, c, d, !f), t.arc(g * u + i, y * u + a, l, d - Math.PI * 2, d - Math.PI, !f), o !== 0 && t.arc(i, a, o, d, c, f);
    }, e;
  }(Ht)
);
function C5e(n, e) {
  e = e || {};
  var t = e.isRoundCap;
  return function(r, i, a) {
    var o = i.position;
    if (!o || o instanceof Array)
      return Jb(r, i, a);
    var s = n(o), l = i.distance != null ? i.distance : 5, u = this.shape, c = u.cx, d = u.cy, f = u.r, p = u.r0, h = (f + p) / 2, v = u.startAngle, m = u.endAngle, g = (v + m) / 2, y = t ? Math.abs(f - p) / 2 : 0, b = Math.cos, _ = Math.sin, x = c + f * b(v), w = d + f * _(v), S = "left", C = "top";
    switch (s) {
      case "startArc":
        x = c + (p - l) * b(g), w = d + (p - l) * _(g), S = "center", C = "top";
        break;
      case "insideStartArc":
        x = c + (p + l) * b(g), w = d + (p + l) * _(g), S = "center", C = "bottom";
        break;
      case "startAngle":
        x = c + h * b(v) + N0(v, l + y, !1), w = d + h * _(v) + R0(v, l + y, !1), S = "right", C = "middle";
        break;
      case "insideStartAngle":
        x = c + h * b(v) + N0(v, -l + y, !1), w = d + h * _(v) + R0(v, -l + y, !1), S = "left", C = "middle";
        break;
      case "middle":
        x = c + h * b(g), w = d + h * _(g), S = "center", C = "middle";
        break;
      case "endArc":
        x = c + (f + l) * b(g), w = d + (f + l) * _(g), S = "center", C = "bottom";
        break;
      case "insideEndArc":
        x = c + (f - l) * b(g), w = d + (f - l) * _(g), S = "center", C = "top";
        break;
      case "endAngle":
        x = c + h * b(m) + N0(m, l + y, !0), w = d + h * _(m) + R0(m, l + y, !0), S = "left", C = "middle";
        break;
      case "insideEndAngle":
        x = c + h * b(m) + N0(m, -l + y, !0), w = d + h * _(m) + R0(m, -l + y, !0), S = "right", C = "middle";
        break;
      default:
        return Jb(r, i, a);
    }
    return r = r || {}, r.x = x, r.y = w, r.align = S, r.verticalAlign = C, r;
  };
}
function k5e(n, e, t, r) {
  if (sn(r)) {
    n.setTextConfig({
      rotation: r
    });
    return;
  } else if (Me(e)) {
    n.setTextConfig({
      rotation: 0
    });
    return;
  }
  var i = n.shape, a = i.clockwise ? i.startAngle : i.endAngle, o = i.clockwise ? i.endAngle : i.startAngle, s = (a + o) / 2, l, u = t(e);
  switch (u) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      l = s;
      break;
    case "startAngle":
    case "insideStartAngle":
      l = a;
      break;
    case "endAngle":
    case "insideEndAngle":
      l = o;
      break;
    default:
      n.setTextConfig({
        rotation: 0
      });
      return;
  }
  var c = Math.PI * 1.5 - l;
  u === "middle" && c > Math.PI / 2 && c < Math.PI * 1.5 && (c -= Math.PI), n.setTextConfig({
    rotation: c
  });
}
function N0(n, e, t) {
  return e * Math.sin(n) * (t ? -1 : 1);
}
function R0(n, e, t) {
  return e * Math.cos(n) * (t ? 1 : -1);
}
function Xc(n, e, t) {
  var r = n.get("borderRadius");
  if (r == null)
    return t ? {
      cornerRadius: 0
    } : null;
  Me(r) || (r = [r, r, r, r]);
  var i = Math.abs(e.r || 0 - e.r0 || 0);
  return {
    cornerRadius: De(r, function(a) {
      return Mo(a, i);
    })
  };
}
var lE = Math.max, uE = Math.min;
function A5e(n, e) {
  var t = n.getArea && n.getArea();
  if (nf(n, "cartesian2d")) {
    var r = n.getBaseAxis();
    if (r.type !== "category" || !r.onBand) {
      var i = e.getLayout("bandWidth");
      r.isHorizontal() ? (t.x -= i, t.width += i * 2) : (t.y -= i, t.height += i * 2);
    }
  }
  return t;
}
var M5e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n.call(this) || this;
      return t.type = e.type, t._isFirstFrame = !0, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      this._model = t, this._removeOnRenderedListener(i), this._updateDrawMode(t);
      var o = t.get("coordinateSystem");
      o === "cartesian2d" || o === "polar" ? (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(t, r, i) : this._renderNormal(t, r, i, a)) : process.env.NODE_ENV !== "production" && Jn("Only cartesian2d and polar supported for bar.");
    }, e.prototype.incrementalPrepareRender = function(t) {
      this._clear(), this._updateDrawMode(t), this._updateLargeClip(t);
    }, e.prototype.incrementalRender = function(t, r) {
      this._progressiveEls = [], this._incrementalRenderLarge(t, r);
    }, e.prototype.eachRendered = function(t) {
      Yu(this._progressiveEls || this.group, t);
    }, e.prototype._updateDrawMode = function(t) {
      var r = t.pipelineContext.large;
      (this._isLargeDraw == null || r !== this._isLargeDraw) && (this._isLargeDraw = r, this._clear());
    }, e.prototype._renderNormal = function(t, r, i, a) {
      var o = this.group, s = t.getData(), l = this._data, u = t.coordinateSystem, c = u.getBaseAxis(), d;
      u.type === "cartesian2d" ? d = c.isHorizontal() : u.type === "polar" && (d = c.dim === "angle");
      var f = t.isAnimationEnabled() ? t : null, p = D5e(t, u);
      p && this._enableRealtimeSort(p, s, i);
      var h = t.get("clip", !0) || p, v = A5e(u, s);
      o.removeClipPath();
      var m = t.get("roundCap", !0), g = t.get("showBackground", !0), y = t.getModel("backgroundStyle"), b = y.get("borderRadius") || 0, _ = [], x = this._backgroundEls, w = a && a.isInitSort, S = a && a.type === "changeAxisOrder";
      function C(D) {
        var N = P0[u.type](s, D), R = j5e(u, d, N);
        return R.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? R.setShape("r", b) : R.setShape("cornerRadius", b), _[D] = R, R;
      }
      s.diff(l).add(function(D) {
        var N = s.getItemModel(D), R = P0[u.type](s, D, N);
        if (g && C(D), !(!s.hasValue(D) || !yB[u.type](R))) {
          var j = !1;
          h && (j = hB[u.type](v, R));
          var z = vB[u.type](t, s, D, R, d, f, c.model, !1, m);
          p && (z.forceLabelAnimation = !0), bB(z, s, D, N, R, t, d, u.type === "polar"), w ? z.attr({
            shape: R
          }) : p ? mB(p, f, z, R, D, d, !1, !1) : Gn(z, {
            shape: R
          }, t, D), s.setItemGraphicEl(D, z), o.add(z), z.ignore = j;
        }
      }).update(function(D, N) {
        var R = s.getItemModel(D), j = P0[u.type](s, D, R);
        if (g) {
          var z = void 0;
          x.length === 0 ? z = C(N) : (z = x[N], z.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? z.setShape("r", b) : z.setShape("cornerRadius", b), _[D] = z);
          var F = P0[u.type](s, D), B = nY(d, F, u);
          ln(z, {
            shape: B
          }, f, D);
        }
        var H = l.getItemGraphicEl(N);
        if (!s.hasValue(D) || !yB[u.type](j)) {
          o.remove(H);
          return;
        }
        var Y = !1;
        if (h && (Y = hB[u.type](v, j), Y && o.remove(H)), H ? Oo(H) : H = vB[u.type](t, s, D, j, d, f, c.model, !!H, m), p && (H.forceLabelAnimation = !0), S) {
          var ne = H.getTextContent();
          if (ne) {
            var J = fh(ne);
            J.prevValue != null && (J.prevValue = J.value);
          }
        } else
          bB(H, s, D, R, j, t, d, u.type === "polar");
        w ? H.attr({
          shape: j
        }) : p ? mB(p, f, H, j, D, d, !0, S) : ln(H, {
          shape: j
        }, t, D, null), s.setItemGraphicEl(D, H), H.ignore = Y, o.add(H);
      }).remove(function(D) {
        var N = l.getItemGraphicEl(D);
        N && tg(N, t, D);
      }).execute();
      var k = this._backgroundGroup || (this._backgroundGroup = new mt());
      k.removeAll();
      for (var M = 0; M < _.length; ++M)
        k.add(_[M]);
      o.add(k), this._backgroundEls = _, this._data = s;
    }, e.prototype._renderLarge = function(t, r, i) {
      this._clear(), xB(t, this.group), this._updateLargeClip(t);
    }, e.prototype._incrementalRenderLarge = function(t, r) {
      this._removeBackground(), xB(r, this.group, this._progressiveEls, !0);
    }, e.prototype._updateLargeClip = function(t) {
      var r = t.get("clip", !0) && Qg(t.coordinateSystem, !1, t), i = this.group;
      r ? i.setClipPath(r) : i.removeClipPath();
    }, e.prototype._enableRealtimeSort = function(t, r, i) {
      var a = this;
      if (r.count()) {
        var o = t.baseAxis;
        if (this._isFirstFrame)
          this._dispatchInitSort(r, t, i), this._isFirstFrame = !1;
        else {
          var s = function(l) {
            var u = r.getItemGraphicEl(l), c = u && u.shape;
            return c && // The result should be consistent with the initial sort by data value.
            // Do not support the case that both positive and negative exist.
            Math.abs(o.isHorizontal() ? c.height : c.width) || 0;
          };
          this._onRendered = function() {
            a._updateSortWithinSameData(r, s, o, i);
          }, i.getZr().on("rendered", this._onRendered);
        }
      }
    }, e.prototype._dataSort = function(t, r, i) {
      var a = [];
      return t.each(t.mapDimension(r.dim), function(o, s) {
        var l = i(s);
        l = l ?? NaN, a.push({
          dataIndex: s,
          mappedValue: l,
          ordinalNumber: o
        });
      }), a.sort(function(o, s) {
        return s.mappedValue - o.mappedValue;
      }), {
        ordinalNumbers: De(a, function(o) {
          return o.ordinalNumber;
        })
      };
    }, e.prototype._isOrderChangedWithinSameData = function(t, r, i) {
      for (var a = i.scale, o = t.mapDimension(i.dim), s = Number.MAX_VALUE, l = 0, u = a.getOrdinalMeta().categories.length; l < u; ++l) {
        var c = t.rawIndexOf(o, a.getRawOrdinalNumber(l)), d = c < 0 ? Number.MIN_VALUE : r(t.indexOfRawIndex(c));
        if (d > s)
          return !0;
        s = d;
      }
      return !1;
    }, e.prototype._isOrderDifferentInView = function(t, r) {
      for (var i = r.scale, a = i.getExtent(), o = Math.max(0, a[0]), s = Math.min(a[1], i.getOrdinalMeta().categories.length - 1); o <= s; ++o)
        if (t.ordinalNumbers[o] !== i.getRawOrdinalNumber(o))
          return !0;
    }, e.prototype._updateSortWithinSameData = function(t, r, i, a) {
      if (this._isOrderChangedWithinSameData(t, r, i)) {
        var o = this._dataSort(t, i, r);
        this._isOrderDifferentInView(o, i) && (this._removeOnRenderedListener(a), a.dispatchAction({
          type: "changeAxisOrder",
          componentType: i.dim + "Axis",
          axisId: i.index,
          sortInfo: o
        }));
      }
    }, e.prototype._dispatchInitSort = function(t, r, i) {
      var a = r.baseAxis, o = this._dataSort(t, a, function(s) {
        return t.get(t.mapDimension(r.otherAxis.dim), s);
      });
      i.dispatchAction({
        type: "changeAxisOrder",
        componentType: a.dim + "Axis",
        isInitSort: !0,
        axisId: a.index,
        sortInfo: o
      });
    }, e.prototype.remove = function(t, r) {
      this._clear(this._model), this._removeOnRenderedListener(r);
    }, e.prototype.dispose = function(t, r) {
      this._removeOnRenderedListener(r);
    }, e.prototype._removeOnRenderedListener = function(t) {
      this._onRendered && (t.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, e.prototype._clear = function(t) {
      var r = this.group, i = this._data;
      t && t.isAnimationEnabled() && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl(function(a) {
        tg(a, t, yt(a).dataIndex);
      })) : r.removeAll(), this._data = null, this._isFirstFrame = !0;
    }, e.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, e.type = "bar", e;
  }(Tn)
), hB = {
  cartesian2d: function(n, e) {
    var t = e.width < 0 ? -1 : 1, r = e.height < 0 ? -1 : 1;
    t < 0 && (e.x += e.width, e.width = -e.width), r < 0 && (e.y += e.height, e.height = -e.height);
    var i = n.x + n.width, a = n.y + n.height, o = lE(e.x, n.x), s = uE(e.x + e.width, i), l = lE(e.y, n.y), u = uE(e.y + e.height, a), c = s < o, d = u < l;
    return e.x = c && o > i ? s : o, e.y = d && l > a ? u : l, e.width = c ? 0 : s - o, e.height = d ? 0 : u - l, t < 0 && (e.x += e.width, e.width = -e.width), r < 0 && (e.y += e.height, e.height = -e.height), c || d;
  },
  polar: function(n, e) {
    var t = e.r0 <= e.r ? 1 : -1;
    if (t < 0) {
      var r = e.r;
      e.r = e.r0, e.r0 = r;
    }
    var i = uE(e.r, n.r), a = lE(e.r0, n.r0);
    e.r = i, e.r0 = a;
    var o = i - a < 0;
    if (t < 0) {
      var r = e.r;
      e.r = e.r0, e.r0 = r;
    }
    return o;
  }
}, vB = {
  cartesian2d: function(n, e, t, r, i, a, o, s, l) {
    var u = new Qt({
      shape: xe({}, r),
      z2: 1
    });
    if (u.__dataIndex = t, u.name = "item", a) {
      var c = u.shape, d = i ? "height" : "width";
      c[d] = 0;
    }
    return u;
  },
  polar: function(n, e, t, r, i, a, o, s, l) {
    var u = !i && l ? x_ : Fi, c = new u({
      shape: r,
      z2: 1
    });
    c.name = "item";
    var d = tY(i);
    if (c.calculateTextPosition = C5e(d, {
      isRoundCap: u === x_
    }), a) {
      var f = c.shape, p = i ? "r" : "endAngle", h = {};
      f[p] = i ? r.r0 : r.startAngle, h[p] = r[p], (s ? ln : Gn)(c, {
        shape: h
        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue
      }, a);
    }
    return c;
  }
};
function D5e(n, e) {
  var t = n.get("realtimeSort", !0), r = e.getBaseAxis();
  if (process.env.NODE_ENV !== "production" && t && (r.type !== "category" && Jn("`realtimeSort` will not work because this bar series is not based on a category axis."), e.type !== "cartesian2d" && Jn("`realtimeSort` will not work because this bar series is not on cartesian2d.")), t && r.type === "category" && e.type === "cartesian2d")
    return {
      baseAxis: r,
      otherAxis: e.getOtherAxis(r)
    };
}
function mB(n, e, t, r, i, a, o, s) {
  var l, u;
  a ? (u = {
    x: r.x,
    width: r.width
  }, l = {
    y: r.y,
    height: r.height
  }) : (u = {
    y: r.y,
    height: r.height
  }, l = {
    x: r.x,
    width: r.width
  }), s || (o ? ln : Gn)(t, {
    shape: l
  }, e, i, null);
  var c = e ? n.baseAxis.model : null;
  (o ? ln : Gn)(t, {
    shape: u
  }, c, i);
}
function gB(n, e) {
  for (var t = 0; t < e.length; t++)
    if (!isFinite(n[e[t]]))
      return !0;
  return !1;
}
var O5e = ["x", "y", "width", "height"], I5e = ["cx", "cy", "r", "startAngle", "endAngle"], yB = {
  cartesian2d: function(n) {
    return !gB(n, O5e);
  },
  polar: function(n) {
    return !gB(n, I5e);
  }
}, P0 = {
  // itemModel is only used to get borderWidth, which is not needed
  // when calculating bar background layout.
  cartesian2d: function(n, e, t) {
    var r = n.getItemLayout(e), i = t ? N5e(t, r) : 0, a = r.width > 0 ? 1 : -1, o = r.height > 0 ? 1 : -1;
    return {
      x: r.x + a * i / 2,
      y: r.y + o * i / 2,
      width: r.width - a * i,
      height: r.height - o * i
    };
  },
  polar: function(n, e, t) {
    var r = n.getItemLayout(e);
    return {
      cx: r.cx,
      cy: r.cy,
      r0: r.r0,
      r: r.r,
      startAngle: r.startAngle,
      endAngle: r.endAngle,
      clockwise: r.clockwise
    };
  }
};
function L5e(n) {
  return n.startAngle != null && n.endAngle != null && n.startAngle === n.endAngle;
}
function tY(n) {
  return /* @__PURE__ */ function(e) {
    var t = e ? "Arc" : "Angle";
    return function(r) {
      switch (r) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return r + t;
        default:
          return r;
      }
    };
  }(n);
}
function bB(n, e, t, r, i, a, o, s) {
  var l = e.getItemVisual(t, "style");
  if (s) {
    if (!a.get("roundCap")) {
      var c = n.shape, d = Xc(r.getModel("itemStyle"), c, !0);
      xe(c, d), n.setShape(c);
    }
  } else {
    var u = r.get(["itemStyle", "borderRadius"]) || 0;
    n.setShape("r", u);
  }
  n.useStyle(l);
  var f = r.getShallow("cursor");
  f && n.attr("cursor", f);
  var p = s ? o ? i.r >= i.r0 ? "endArc" : "startArc" : i.endAngle >= i.startAngle ? "endAngle" : "startAngle" : o ? i.height >= 0 ? "bottom" : "top" : i.width >= 0 ? "right" : "left", h = Nr(r);
  ei(n, h, {
    labelFetcher: a,
    labelDataIndex: t,
    defaultText: Up(a.getData(), t),
    inheritColor: l.fill,
    defaultOpacity: l.opacity,
    defaultOutsidePosition: p
  });
  var v = n.getTextContent();
  if (s && v) {
    var m = r.get(["label", "position"]);
    n.textConfig.inside = m === "middle" ? !0 : null, k5e(n, m === "outside" ? p : m, tY(o), r.get(["label", "rotate"]));
  }
  wU(v, h, a.getRawValue(t), function(y) {
    return Wq(e, y);
  });
  var g = r.getModel(["emphasis"]);
  er(n, g.get("focus"), g.get("blurScope"), g.get("disabled")), Qr(n, r), L5e(i) && (n.style.fill = "none", n.style.stroke = "none", $(n.states, function(y) {
    y.style && (y.style.fill = y.style.stroke = "none");
  }));
}
function N5e(n, e) {
  var t = n.get(["itemStyle", "borderColor"]);
  if (!t || t === "none")
    return 0;
  var r = n.get(["itemStyle", "borderWidth"]) || 0, i = isNaN(e.width) ? Number.MAX_VALUE : Math.abs(e.width), a = isNaN(e.height) ? Number.MAX_VALUE : Math.abs(e.height);
  return Math.min(r, i, a);
}
var R5e = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }()
), _B = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "largeBar", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new R5e();
    }, e.prototype.buildPath = function(t, r) {
      for (var i = r.points, a = this.baseDimIdx, o = 1 - this.baseDimIdx, s = [], l = [], u = this.barWidth, c = 0; c < i.length; c += 3)
        l[a] = u, l[o] = i[c + 2], s[a] = i[c + a], s[o] = i[c + o], t.rect(s[0], s[1], l[0], l[1]);
    }, e;
  }(Ht)
);
function xB(n, e, t, r) {
  var i = n.getData(), a = i.getLayout("valueAxisHorizontal") ? 1 : 0, o = i.getLayout("largeDataIndices"), s = i.getLayout("size"), l = n.getModel("backgroundStyle"), u = i.getLayout("largeBackgroundPoints");
  if (u) {
    var c = new _B({
      shape: {
        points: u
      },
      incremental: !!r,
      silent: !0,
      z2: 0
    });
    c.baseDimIdx = a, c.largeDataIndices = o, c.barWidth = s, c.useStyle(l.getItemStyle()), e.add(c), t && t.push(c);
  }
  var d = new _B({
    shape: {
      points: i.getLayout("largePoints")
    },
    incremental: !!r,
    ignoreCoarsePointer: !0,
    z2: 1
  });
  d.baseDimIdx = a, d.largeDataIndices = o, d.barWidth = s, e.add(d), d.useStyle(i.getVisual("style")), d.style.stroke = null, yt(d).seriesIndex = n.seriesIndex, n.get("silent") || (d.on("mousedown", wB), d.on("mousemove", wB)), t && t.push(d);
}
var wB = sO(function(n) {
  var e = this, t = P5e(e, n.offsetX, n.offsetY);
  yt(e).dataIndex = t >= 0 ? t : null;
}, 30, !1);
function P5e(n, e, t) {
  for (var r = n.baseDimIdx, i = 1 - r, a = n.shape.points, o = n.largeDataIndices, s = [], l = [], u = n.barWidth, c = 0, d = a.length / 3; c < d; c++) {
    var f = c * 3;
    if (l[r] = u, l[i] = a[f + 2], s[r] = a[f + r], s[i] = a[f + i], l[i] < 0 && (s[i] += l[i], l[i] = -l[i]), e >= s[0] && e <= s[0] + l[0] && t >= s[1] && t <= s[1] + l[1])
      return o[c];
  }
  return -1;
}
function nY(n, e, t) {
  if (nf(t, "cartesian2d")) {
    var r = e, i = t.getArea();
    return {
      x: n ? r.x : i.x,
      y: n ? i.y : r.y,
      width: n ? r.width : i.width,
      height: n ? i.height : r.height
    };
  } else {
    var i = t.getArea(), a = e;
    return {
      cx: i.cx,
      cy: i.cy,
      r0: n ? i.r0 : a.r0,
      r: n ? i.r : a.r,
      startAngle: n ? a.startAngle : 0,
      endAngle: n ? a.endAngle : Math.PI * 2
    };
  }
}
function j5e(n, e, t) {
  var r = n.type === "polar" ? Fi : Qt;
  return new r({
    shape: nY(e, t, n),
    silent: !0,
    z2: 0
  });
}
function B5e(n) {
  n.registerChartView(M5e), n.registerSeriesModel(E5e), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, Tt(sq, "bar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, lq("bar")), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, eY("bar")), n.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(e, t) {
    var r = e.componentType || "series";
    t.eachComponent({
      mainType: r,
      query: e
    }, function(i) {
      e.sortInfo && i.axis.setCategorySortInfo(e.sortInfo);
    });
  });
}
var SB = Math.PI * 2, j0 = Math.PI / 180;
function rY(n, e) {
  return Er(n.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function iY(n, e) {
  var t = rY(n, e), r = n.get("center"), i = n.get("radius");
  Me(i) || (i = [0, i]);
  var a = ze(t.width, e.getWidth()), o = ze(t.height, e.getHeight()), s = Math.min(a, o), l = ze(i[0], s / 2), u = ze(i[1], s / 2), c, d, f = n.coordinateSystem;
  if (f) {
    var p = f.dataToPoint(r);
    c = p[0] || 0, d = p[1] || 0;
  } else
    Me(r) || (r = [r, r]), c = ze(r[0], a) + t.x, d = ze(r[1], o) + t.y;
  return {
    cx: c,
    cy: d,
    r0: l,
    r: u
  };
}
function $5e(n, e, t) {
  e.eachSeriesByType(n, function(r) {
    var i = r.getData(), a = i.mapDimension("value"), o = rY(r, t), s = iY(r, t), l = s.cx, u = s.cy, c = s.r, d = s.r0, f = -r.get("startAngle") * j0, p = r.get("endAngle"), h = r.get("padAngle") * j0;
    p = p === "auto" ? f - SB : -p * j0;
    var v = r.get("minAngle") * j0, m = v + h, g = 0;
    i.each(a, function(B) {
      !isNaN(B) && g++;
    });
    var y = i.getSum(a), b = Math.PI / (y || g) * 2, _ = r.get("clockwise"), x = r.get("roseType"), w = r.get("stillShowZeroSum"), S = i.getDataExtent(a);
    S[0] = 0;
    var C = _ ? 1 : -1, k = [f, p], M = C * h / 2;
    PD(k, !_), f = k[0], p = k[1];
    var D = aY(r);
    D.startAngle = f, D.endAngle = p, D.clockwise = _;
    var N = Math.abs(p - f), R = N, j = 0, z = f;
    if (i.setLayout({
      viewRect: o,
      r: c
    }), i.each(a, function(B, H) {
      var Y;
      if (isNaN(B)) {
        i.setItemLayout(H, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise: _,
          cx: l,
          cy: u,
          r0: d,
          r: x ? NaN : c
        });
        return;
      }
      x !== "area" ? Y = y === 0 && w ? b : B * b : Y = N / g, Y < m ? (Y = m, R -= m) : j += B;
      var ne = z + C * Y, J = 0, X = 0;
      h > Y ? (J = z + C * Y / 2, X = J) : (J = z + M, X = ne - M), i.setItemLayout(H, {
        angle: Y,
        startAngle: J,
        endAngle: X,
        clockwise: _,
        cx: l,
        cy: u,
        r0: d,
        r: x ? mn(B, S, [d, c]) : c
      }), z = ne;
    }), R < SB && g)
      if (R <= 1e-3) {
        var F = N / g;
        i.each(a, function(B, H) {
          if (!isNaN(B)) {
            var Y = i.getItemLayout(H);
            Y.angle = F;
            var ne = 0, J = 0;
            F < h ? (ne = f + C * (H + 1 / 2) * F, J = ne) : (ne = f + C * H * F + M, J = f + C * (H + 1) * F - M), Y.startAngle = ne, Y.endAngle = J;
          }
        });
      } else
        b = R / j, z = f, i.each(a, function(B, H) {
          if (!isNaN(B)) {
            var Y = i.getItemLayout(H), ne = Y.angle === m ? m : B * b, J = 0, X = 0;
            ne < h ? (J = z + C * ne / 2, X = J) : (J = z + M, X = z + C * ne - M), Y.startAngle = J, Y.endAngle = X, z += C * ne;
          }
        });
  });
}
var aY = en();
function ty(n) {
  return {
    seriesType: n,
    reset: function(e, t) {
      var r = t.findComponents({
        mainType: "legend"
      });
      if (!(!r || !r.length)) {
        var i = e.getData();
        i.filterSelf(function(a) {
          for (var o = i.getName(a), s = 0; s < r.length; s++)
            if (!r[s].isSelected(o))
              return !1;
          return !0;
        });
      }
    }
  };
}
var z5e = Math.PI / 180;
function EB(n, e, t, r, i, a, o, s, l, u) {
  if (n.length < 2)
    return;
  function c(v) {
    for (var m = v.rB, g = m * m, y = 0; y < v.list.length; y++) {
      var b = v.list[y], _ = Math.abs(b.label.y - t), x = r + b.len, w = x * x, S = Math.sqrt(Math.abs((1 - _ * _ / g) * w)), C = e + (S + b.len2) * i, k = C - b.label.x, M = b.targetTextWidth - k * i;
      oY(b, M, !0), b.label.x = C;
    }
  }
  function d(v) {
    for (var m = {
      list: [],
      maxY: 0
    }, g = {
      list: [],
      maxY: 0
    }, y = 0; y < v.length; y++)
      if (v[y].labelAlignTo === "none") {
        var b = v[y], _ = b.label.y > t ? g : m, x = Math.abs(b.label.y - t);
        if (x >= _.maxY) {
          var w = b.label.x - e - b.len2 * i, S = r + b.len, C = Math.abs(w) < S ? Math.sqrt(x * x / (1 - w * w / S / S)) : S;
          _.rB = C, _.maxY = x;
        }
        _.list.push(b);
      }
    c(m), c(g);
  }
  for (var f = n.length, p = 0; p < f; p++)
    if (n[p].position === "outer" && n[p].labelAlignTo === "labelLine") {
      var h = n[p].label.x - u;
      n[p].linePoints[1][0] += h, n[p].label.x = u;
    }
  Mq(n, l, l + o) && d(n);
}
function F5e(n, e, t, r, i, a, o, s) {
  for (var l = [], u = [], c = Number.MAX_VALUE, d = -Number.MAX_VALUE, f = 0; f < n.length; f++) {
    var p = n[f].label;
    cE(n[f]) || (p.x < e ? (c = Math.min(c, p.x), l.push(n[f])) : (d = Math.max(d, p.x), u.push(n[f])));
  }
  for (var f = 0; f < n.length; f++) {
    var h = n[f];
    if (!cE(h) && h.linePoints) {
      if (h.labelStyleWidth != null)
        continue;
      var p = h.label, v = h.linePoints, m = void 0;
      h.labelAlignTo === "edge" ? p.x < e ? m = v[2][0] - h.labelDistance - o - h.edgeDistance : m = o + i - h.edgeDistance - v[2][0] - h.labelDistance : h.labelAlignTo === "labelLine" ? p.x < e ? m = c - o - h.bleedMargin : m = o + i - d - h.bleedMargin : p.x < e ? m = p.x - o - h.bleedMargin : m = o + i - p.x - h.bleedMargin, h.targetTextWidth = m, oY(h, m);
    }
  }
  EB(u, e, t, r, 1, i, a, o, s, d), EB(l, e, t, r, -1, i, a, o, s, c);
  for (var f = 0; f < n.length; f++) {
    var h = n[f];
    if (!cE(h) && h.linePoints) {
      var p = h.label, v = h.linePoints, g = h.labelAlignTo === "edge", y = p.style.padding, b = y ? y[1] + y[3] : 0, _ = p.style.backgroundColor ? 0 : b, x = h.rect.width + _, w = v[1][0] - v[2][0];
      g ? p.x < e ? v[2][0] = o + h.edgeDistance + x + h.labelDistance : v[2][0] = o + i - h.edgeDistance - x - h.labelDistance : (p.x < e ? v[2][0] = p.x + h.labelDistance : v[2][0] = p.x - h.labelDistance, v[1][0] = v[2][0] + w), v[1][1] = v[2][1] = p.y;
    }
  }
}
function oY(n, e, t) {
  if (t === void 0 && (t = !1), n.labelStyleWidth == null) {
    var r = n.label, i = r.style, a = n.rect, o = i.backgroundColor, s = i.padding, l = s ? s[1] + s[3] : 0, u = i.overflow, c = a.width + (o ? 0 : l);
    if (e < c || t) {
      var d = a.height;
      if (u && u.match("break")) {
        r.setStyle("backgroundColor", null), r.setStyle("width", e - l);
        var f = r.getBoundingRect();
        r.setStyle("width", Math.ceil(f.width)), r.setStyle("backgroundColor", o);
      } else {
        var p = e - l, h = e < c ? p : (
          // Current available width is enough, but the text may have
          // already been wrapped with a smaller available width.
          t ? p > n.unconstrainedWidth ? null : p : null
        );
        r.setStyle("width", h);
      }
      var v = r.getBoundingRect();
      a.width = v.width;
      var m = (r.style.margin || 0) + 2.1;
      a.height = v.height + m, a.y -= (a.height - d) / 2;
    }
  }
}
function cE(n) {
  return n.position === "center";
}
function V5e(n) {
  var e = n.getData(), t = [], r, i, a = !1, o = (n.get("minShowLabelAngle") || 0) * z5e, s = e.getLayout("viewRect"), l = e.getLayout("r"), u = s.width, c = s.x, d = s.y, f = s.height;
  function p(w) {
    w.ignore = !0;
  }
  function h(w) {
    if (!w.ignore)
      return !0;
    for (var S in w.states)
      if (w.states[S].ignore === !1)
        return !0;
    return !1;
  }
  e.each(function(w) {
    var S = e.getItemGraphicEl(w), C = S.shape, k = S.getTextContent(), M = S.getTextGuideLine(), D = e.getItemModel(w), N = D.getModel("label"), R = N.get("position") || D.get(["emphasis", "label", "position"]), j = N.get("distanceToLabelLine"), z = N.get("alignTo"), F = ze(N.get("edgeDistance"), u), B = N.get("bleedMargin"), H = D.getModel("labelLine"), Y = H.get("length");
    Y = ze(Y, u);
    var ne = H.get("length2");
    if (ne = ze(ne, u), Math.abs(C.endAngle - C.startAngle) < o) {
      $(k.states, p), k.ignore = !0, M && ($(M.states, p), M.ignore = !0);
      return;
    }
    if (h(k)) {
      var J = (C.startAngle + C.endAngle) / 2, X = Math.cos(J), ie = Math.sin(J), ye, pe, Be, Ce;
      r = C.cx, i = C.cy;
      var Ee = R === "inside" || R === "inner";
      if (R === "center")
        ye = C.cx, pe = C.cy, Ce = "center";
      else {
        var ce = (Ee ? (C.r + C.r0) / 2 * X : C.r * X) + r, Pe = (Ee ? (C.r + C.r0) / 2 * ie : C.r * ie) + i;
        if (ye = ce + X * 3, pe = Pe + ie * 3, !Ee) {
          var Ae = ce + X * (Y + l - C.r), fe = Pe + ie * (Y + l - C.r), oe = Ae + (X < 0 ? -1 : 1) * ne, he = fe;
          z === "edge" ? ye = X < 0 ? c + F : c + u - F : ye = oe + (X < 0 ? -j : j), pe = he, Be = [[ce, Pe], [Ae, fe], [oe, he]];
        }
        Ce = Ee ? "center" : z === "edge" ? X > 0 ? "right" : "left" : X > 0 ? "left" : "right";
      }
      var Oe = Math.PI, Te = 0, Ge = N.get("rotate");
      if (sn(Ge))
        Te = Ge * (Oe / 180);
      else if (R === "center")
        Te = 0;
      else if (Ge === "radial" || Ge === !0) {
        var je = X < 0 ? -J + Oe : -J;
        Te = je;
      } else if (Ge === "tangential" && R !== "outside" && R !== "outer") {
        var Qe = Math.atan2(X, ie);
        Qe < 0 && (Qe = Oe * 2 + Qe);
        var ot = ie > 0;
        ot && (Qe = Oe + Qe), Te = Qe - Oe;
      }
      if (a = !!Te, k.x = ye, k.y = pe, k.rotation = Te, k.setStyle({
        verticalAlign: "middle"
      }), Ee) {
        k.setStyle({
          align: Ce
        });
        var Le = k.states.select;
        Le && (Le.x += k.x, Le.y += k.y);
      } else {
        var it = k.getBoundingRect().clone();
        it.applyTransform(k.getComputedTransform());
        var Nt = (k.style.margin || 0) + 2.1;
        it.y -= Nt / 2, it.height += Nt, t.push({
          label: k,
          labelLine: M,
          position: R,
          len: Y,
          len2: ne,
          minTurnAngle: H.get("minTurnAngle"),
          maxSurfaceAngle: H.get("maxSurfaceAngle"),
          surfaceNormal: new Mt(X, ie),
          linePoints: Be,
          textAlign: Ce,
          labelDistance: j,
          labelAlignTo: z,
          edgeDistance: F,
          bleedMargin: B,
          rect: it,
          unconstrainedWidth: it.width,
          labelStyleWidth: k.style.width
        });
      }
      S.setTextConfig({
        inside: Ee
      });
    }
  }), !a && n.get("avoidLabelOverlap") && F5e(t, r, i, l, u, f, c, d);
  for (var v = 0; v < t.length; v++) {
    var m = t[v], g = m.label, y = m.labelLine, b = isNaN(g.x) || isNaN(g.y);
    if (g) {
      g.setStyle({
        align: m.textAlign
      }), b && ($(g.states, p), g.ignore = !0);
      var _ = g.states.select;
      _ && (_.x += g.x, _.y += g.y);
    }
    if (y) {
      var x = m.linePoints;
      b || !x ? ($(y.states, p), y.ignore = !0) : (Cq(x, m.minTurnAngle), dje(x, m.surfaceNormal, m.maxSurfaceAngle), y.setShape({
        points: x
      }), g.__hostTarget.textGuideLineConfig = {
        anchor: new Mt(x[0][0], x[0][1])
      });
    }
  }
}
var H5e = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i) {
      var a = n.call(this) || this;
      a.z2 = 2;
      var o = new nn();
      return a.setTextContent(o), a.updateData(t, r, i, !0), a;
    }
    return e.prototype.updateData = function(t, r, i, a) {
      var o = this, s = t.hostModel, l = t.getItemModel(r), u = l.getModel("emphasis"), c = t.getItemLayout(r), d = xe(Xc(l.getModel("itemStyle"), c, !0), c);
      if (isNaN(d.startAngle)) {
        o.setShape(d);
        return;
      }
      if (a) {
        o.setShape(d);
        var f = s.getShallow("animationType");
        s.ecModel.ssr ? (Gn(o, {
          scaleX: 0,
          scaleY: 0
        }, s, {
          dataIndex: r,
          isFrom: !0
        }), o.originX = d.cx, o.originY = d.cy) : f === "scale" ? (o.shape.r = c.r0, Gn(o, {
          shape: {
            r: c.r
          }
        }, s, r)) : i != null ? (o.setShape({
          startAngle: i,
          endAngle: i
        }), Gn(o, {
          shape: {
            startAngle: c.startAngle,
            endAngle: c.endAngle
          }
        }, s, r)) : (o.shape.endAngle = c.startAngle, ln(o, {
          shape: {
            endAngle: c.endAngle
          }
        }, s, r));
      } else
        Oo(o), ln(o, {
          shape: d
        }, s, r);
      o.useStyle(t.getItemVisual(r, "style")), Qr(o, l);
      var p = (c.startAngle + c.endAngle) / 2, h = s.get("selectedOffset"), v = Math.cos(p) * h, m = Math.sin(p) * h, g = l.getShallow("cursor");
      g && o.attr("cursor", g), this._updateLabel(s, t, r), o.ensureState("emphasis").shape = xe({
        r: c.r + (u.get("scale") && u.get("scaleSize") || 0)
      }, Xc(u.getModel("itemStyle"), c)), xe(o.ensureState("select"), {
        x: v,
        y: m,
        shape: Xc(l.getModel(["select", "itemStyle"]), c)
      }), xe(o.ensureState("blur"), {
        shape: Xc(l.getModel(["blur", "itemStyle"]), c)
      });
      var y = o.getTextGuideLine(), b = o.getTextContent();
      y && xe(y.ensureState("select"), {
        x: v,
        y: m
      }), xe(b.ensureState("select"), {
        x: v,
        y: m
      }), er(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t, r, i) {
      var a = this, o = r.getItemModel(i), s = o.getModel("labelLine"), l = r.getItemVisual(i, "style"), u = l && l.fill, c = l && l.opacity;
      ei(a, Nr(o), {
        labelFetcher: r.hostModel,
        labelDataIndex: i,
        inheritColor: u,
        defaultOpacity: c,
        defaultText: t.getFormattedLabel(i, "normal") || r.getName(i)
      });
      var d = a.getTextContent();
      a.setTextConfig({
        // reset position, rotation
        position: null,
        rotation: null
      }), d.attr({
        z2: 10
      });
      var f = t.get(["label", "position"]);
      if (f !== "outside" && f !== "outer")
        a.removeTextGuideLine();
      else {
        var p = this.getTextGuideLine();
        p || (p = new Hi(), this.setTextGuideLine(p)), _O(this, xO(o), {
          stroke: u,
          opacity: Za(s.get(["lineStyle", "opacity"]), c, 1)
        });
      }
    }, e;
  }(Fi)
), G5e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.ignoreLabelLineUpdate = !0, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      var o = t.getData(), s = this._data, l = this.group, u;
      if (!s && o.count() > 0) {
        for (var c = o.getItemLayout(0), d = 1; isNaN(c && c.startAngle) && d < o.count(); ++d)
          c = o.getItemLayout(d);
        c && (u = c.startAngle);
      }
      if (this._emptyCircleSector && l.remove(this._emptyCircleSector), o.count() === 0 && t.get("showEmptyCircle")) {
        var f = aY(t), p = new Fi({
          shape: xe(iY(t, i), f)
        });
        p.useStyle(t.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = p, l.add(p);
      }
      o.diff(s).add(function(h) {
        var v = new H5e(o, h, u);
        o.setItemGraphicEl(h, v), l.add(v);
      }).update(function(h, v) {
        var m = s.getItemGraphicEl(v);
        m.updateData(o, h, u), m.off("click"), l.add(m), o.setItemGraphicEl(h, m);
      }).remove(function(h) {
        var v = s.getItemGraphicEl(h);
        tg(v, t, h);
      }).execute(), V5e(t), t.get("animationTypeUpdate") !== "expansion" && (this._data = o);
    }, e.prototype.dispose = function() {
    }, e.prototype.containPoint = function(t, r) {
      var i = r.getData(), a = i.getItemLayout(0);
      if (a) {
        var o = t[0] - a.cx, s = t[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, e.type = "pie", e;
  }(Tn)
);
function wh(n, e, t) {
  e = Me(e) && {
    coordDimensions: e
  } || xe({
    encodeDefine: n.getEncode()
  }, e);
  var r = n.getSource(), i = Kg(r, e).dimensions, a = new Oi(i, n);
  return a.initData(r, t), a;
}
var ny = (
  /** @class */
  function() {
    function n(e, t) {
      this._getDataWithEncodedVisual = e, this._getRawData = t;
    }
    return n.prototype.getAllNames = function() {
      var e = this._getRawData();
      return e.mapArray(e.getName);
    }, n.prototype.containName = function(e) {
      var t = this._getRawData();
      return t.indexOfName(e) >= 0;
    }, n.prototype.indexOfName = function(e) {
      var t = this._getDataWithEncodedVisual();
      return t.indexOfName(e);
    }, n.prototype.getItemVisual = function(e, t) {
      var r = this._getDataWithEncodedVisual();
      return r.getItemVisual(e, t);
    }, n;
  }()
), U5e = en(), W5e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new ny(Ze(this.getData, this), Ze(this.getRawData, this)), this._defaultLabelLine(t);
    }, e.prototype.mergeOption = function() {
      n.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.getInitialData = function() {
      return wh(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Tt(QD, this)
      });
    }, e.prototype.getDataParams = function(t) {
      var r = this.getData(), i = U5e(r), a = i.seats;
      if (!a) {
        var o = [];
        r.each(r.mapDimension("value"), function(l) {
          o.push(l);
        }), a = i.seats = DOe(o, r.hostModel.get("percentPrecision"));
      }
      var s = n.prototype.getDataParams.call(this, t);
      return s.percent = a[t] || 0, s.$vars.push("percent"), s;
    }, e.prototype._defaultLabelLine = function(t) {
      Od(t, "labelLine", ["show"]);
      var r = t.labelLine, i = t.emphasis.labelLine;
      r.show = r.show && t.label.show, i.show = i.show && t.emphasis.label.show;
    }, e.type = "series.pie", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      // 默认全局居中
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 默认顺时针
      clockwise: !0,
      startAngle: 90,
      endAngle: "auto",
      padAngle: 0,
      // 最小角度改为0
      minAngle: 0,
      // If the angle of a sector less than `minShowLabelAngle`,
      // the label will not be displayed.
      minShowLabelAngle: 0,
      // 选中时扇区偏移量
      selectedOffset: 10,
      // 选择模式，默认关闭，可选single，multiple
      // selectedMode: false,
      // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
      // roseType: null,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // cursor: null,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        // color: 'inherit',
        // If rotate around circle
        rotate: 0,
        show: !0,
        overflow: "truncate",
        // 'outer', 'inside', 'center'
        position: "outer",
        // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
        alignTo: "none",
        // Closest distance between label and chart edge.
        // Works only position is 'outer' and alignTo is 'edge'.
        edgeDistance: "25%",
        // Works only position is 'outer' and alignTo is not 'edge'.
        bleedMargin: 10,
        // Distance between text and label line.
        distanceToLabelLine: 5
        // formatter: 标签文本格式器，同 tooltip.formatter，不支持异步回调
        // 默认使用全局文本样式，详见 textStyle
        // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数
      },
      // Enabled when label.normal.position is 'outer'
      labelLine: {
        show: !0,
        // 引导线两段中的第一段长度
        length: 15,
        // 引导线两段中的第二段长度
        length2: 15,
        smooth: !1,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          // color: 各异,
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: !0,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        // Hide the overlapped label.
        hideOverlap: !0
      },
      emphasis: {
        scale: !0,
        scaleSize: 5
      },
      // If use strategy to avoid label overlapping
      avoidLabelOverlap: !0,
      // Animation type. Valid values: expansion, scale
      animationType: "expansion",
      animationDuration: 1e3,
      // Animation type when update. Valid values: transition, expansion
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, e;
  }(Rn)
);
function q5e(n) {
  return {
    seriesType: n,
    reset: function(e, t) {
      var r = e.getData();
      r.filterSelf(function(i) {
        var a = r.mapDimension("value"), o = r.get(a, i);
        return !(sn(o) && !isNaN(o) && o < 0);
      });
    }
  };
}
function Y5e(n) {
  n.registerChartView(G5e), n.registerSeriesModel(W5e), kW("pie", n.registerAction), n.registerLayout(Tt($5e, "pie")), n.registerProcessor(ty("pie")), n.registerProcessor(q5e("pie"));
}
var K5e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return Dl(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getProgressive = function() {
      var t = this.option.progressive;
      return t ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.option.progressiveThreshold;
      return t ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, e.prototype.brushSelector = function(t, r, i) {
      return i.point(r.getItemLayout(t));
    }, e.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, e.type = "series.scatter", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      symbolSize: 10,
      // symbolRotate: null,  // 图形旋转控制
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      // cursor: null,
      itemStyle: {
        opacity: 0.8
        // color: 各异
      },
      emphasis: {
        scale: !0
      },
      // If clip the overflow graphics
      // Works on cartesian / polar series
      clip: !0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
      // progressive: null
    }, e;
  }(Rn)
), sY = 4, X5e = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }()
), Z5e = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r._off = 0, r.hoverDataIdx = -1, r;
    }
    return e.prototype.getDefaultShape = function() {
      return new X5e();
    }, e.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points, a = r.size, o = this.symbolProxy, s = o.shape, l = t.getContext ? t.getContext() : t, u = l && a[0] < sY, c = this.softClipShape, d;
      if (u) {
        this._ctx = l;
        return;
      }
      for (this._ctx = null, d = this._off; d < i.length; ) {
        var f = i[d++], p = i[d++];
        isNaN(f) || isNaN(p) || c && !c.contain(f, p) || (s.x = f - a[0] / 2, s.y = p - a[1] / 2, s.width = a[0], s.height = a[1], o.buildPath(t, s, !0));
      }
      this.incremental && (this._off = d, this.notClear = !0);
    }, e.prototype.afterBrush = function() {
      var t = this.shape, r = t.points, i = t.size, a = this._ctx, o = this.softClipShape, s;
      if (a) {
        for (s = this._off; s < r.length; ) {
          var l = r[s++], u = r[s++];
          isNaN(l) || isNaN(u) || o && !o.contain(l, u) || a.fillRect(l - i[0] / 2, u - i[1] / 2, i[0], i[1]);
        }
        this.incremental && (this._off = s, this.notClear = !0);
      }
    }, e.prototype.findDataIndex = function(t, r) {
      for (var i = this.shape, a = i.points, o = i.size, s = Math.max(o[0], 4), l = Math.max(o[1], 4), u = a.length / 2 - 1; u >= 0; u--) {
        var c = u * 2, d = a[c] - s / 2, f = a[c + 1] - l / 2;
        if (t >= d && r >= f && t <= d + s && r <= f + l)
          return u;
      }
      return -1;
    }, e.prototype.contain = function(t, r) {
      var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect();
      if (t = i[0], r = i[1], a.contain(t, r)) {
        var o = this.hoverDataIdx = this.findDataIndex(t, r);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect;
      if (!t) {
        for (var r = this.shape, i = r.points, a = r.size, o = a[0], s = a[1], l = 1 / 0, u = 1 / 0, c = -1 / 0, d = -1 / 0, f = 0; f < i.length; ) {
          var p = i[f++], h = i[f++];
          l = Math.min(p, l), c = Math.max(p, c), u = Math.min(h, u), d = Math.max(h, d);
        }
        t = this._rect = new Ot(l - o / 2, u - s / 2, c - l + o, d - u + s);
      }
      return t;
    }, e;
  }(Ht)
), J5e = (
  /** @class */
  function() {
    function n() {
      this.group = new mt();
    }
    return n.prototype.updateData = function(e, t) {
      this._clear();
      var r = this._create();
      r.setShape({
        points: e.getLayout("points")
      }), this._setCommon(r, e, t);
    }, n.prototype.updateLayout = function(e) {
      var t = e.getLayout("points");
      this.group.eachChild(function(r) {
        if (r.startIndex != null) {
          var i = (r.endIndex - r.startIndex) * 2, a = r.startIndex * 4 * 2;
          t = new Float32Array(t.buffer, a, i);
        }
        r.setShape("points", t), r.reset();
      });
    }, n.prototype.incrementalPrepareUpdate = function(e) {
      this._clear();
    }, n.prototype.incrementalUpdate = function(e, t, r) {
      var i = this._newAdded[0], a = t.getLayout("points"), o = i && i.shape.points;
      if (o && o.length < 2e4) {
        var s = o.length, l = new Float32Array(s + a.length);
        l.set(o), l.set(a, s), i.endIndex = e.end, i.setShape({
          points: l
        });
      } else {
        this._newAdded = [];
        var u = this._create();
        u.startIndex = e.start, u.endIndex = e.end, u.incremental = !0, u.setShape({
          points: a
        }), this._setCommon(u, t, r);
      }
    }, n.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, n.prototype._create = function() {
      var e = new Z5e({
        cursor: "default"
      });
      return e.ignoreCoarsePointer = !0, this.group.add(e), this._newAdded.push(e), e;
    }, n.prototype._setCommon = function(e, t, r) {
      var i = t.hostModel;
      r = r || {};
      var a = t.getVisual("symbolSize");
      e.setShape("size", a instanceof Array ? a : [a, a]), e.softClipShape = r.clipShape || null, e.symbolProxy = yr(t.getVisual("symbol"), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor;
      var o = e.shape.size[0] < sY;
      e.useStyle(
        // Draw shadow when doing fillRect is extremely slow.
        i.getModel("itemStyle").getItemStyle(o ? ["color", "shadowBlur", "shadowColor"] : ["color"])
      );
      var s = t.getVisual("style"), l = s && s.fill;
      l && e.setColor(l);
      var u = yt(e);
      u.seriesIndex = i.seriesIndex, e.on("mousemove", function(c) {
        u.dataIndex = null;
        var d = e.hoverDataIdx;
        d >= 0 && (u.dataIndex = d + (e.startIndex || 0));
      });
    }, n.prototype.remove = function() {
      this._clear();
    }, n.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, n;
  }()
), Q5e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = t.getData(), o = this._updateSymbolDraw(a, t);
      o.updateData(a, {
        // TODO
        // If this parameter should be a shape or a bounding volume
        // shape will be more general.
        // But bounding volume like bounding rect will be much faster in the contain calculation
        clipShape: this._getClipShape(t)
      }), this._finished = !0;
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      var a = t.getData(), o = this._updateSymbolDraw(a, t);
      o.incrementalPrepareUpdate(a), this._finished = !1;
    }, e.prototype.incrementalRender = function(t, r, i) {
      this._symbolDraw.incrementalUpdate(t, r.getData(), {
        clipShape: this._getClipShape(r)
      }), this._finished = t.end === r.getData().count();
    }, e.prototype.updateTransform = function(t, r, i) {
      var a = t.getData();
      if (this.group.dirty(), !this._finished || a.count() > 1e4)
        return {
          update: !0
        };
      var o = ey("").reset(t, r, i);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout(a);
    }, e.prototype.eachRendered = function(t) {
      this._symbolDraw && this._symbolDraw.eachRendered(t);
    }, e.prototype._getClipShape = function(t) {
      if (t.get("clip", !0)) {
        var r = t.coordinateSystem;
        return r && r.getArea && r.getArea(0.1);
      }
    }, e.prototype._updateSymbolDraw = function(t, r) {
      var i = this._symbolDraw, a = r.pipelineContext, o = a.large;
      return (!i || o !== this._isLargeDraw) && (i && i.remove(), i = this._symbolDraw = o ? new J5e() : new Jg(), this._isLargeDraw = o, this.group.removeAll()), this.group.add(i.group), i;
    }, e.prototype.remove = function(t, r) {
      this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
    }, e.prototype.dispose = function() {
    }, e.type = "scatter", e;
  }(Tn)
), eBe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.type = "grid", e.dependencies = ["xAxis", "yAxis"], e.layoutMode = "box", e.defaultOption = {
      show: !1,
      // zlevel: 0,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      // If grid size contain label
      containLabel: !1,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }, e;
  }(Ut)
), Fk = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", gr).models[0];
    }, e.type = "cartesian2dAxis", e;
  }(Ut)
);
_r(Fk, Xg);
var lY = {
  show: !0,
  // zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: !1,
  // Axis name displayed.
  name: "",
  // 'start' | 'middle' | 'end'
  nameLocation: "end",
  // By degree. By default auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  // Use global text style by default.
  nameTextStyle: {},
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: !1,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: !1,
  tooltip: {
    show: !1
  },
  axisPointer: {},
  axisLine: {
    show: !0,
    onZero: !0,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    // The arrow at both ends the the axis.
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: !0,
    // Whether axisTick is inside the grid or outside the grid.
    inside: !1,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: !0,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: !1,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12
  },
  splitLine: {
    show: !0,
    showMinLine: !0,
    showMaxLine: !0,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: !1,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
}, tBe = At({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: !0,
  // Set false to faster category collection.
  deduplication: null,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: !1
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: !1,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, lY), AO = At({
  boundaryGap: [0, 0],
  axisLine: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  axisTick: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  splitNumber: 5,
  minorTick: {
    // Minor tick, not available for cateogry axis.
    show: !1,
    // Split number of minor ticks. The value should be in range of (0, 100)
    splitNumber: 5,
    // Length of minor tick
    length: 3,
    // Line style
    lineStyle: {
      // Default to be same with axisTick
    }
  },
  minorSplitLine: {
    show: !1,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, lY), nBe = At({
  splitNumber: 6,
  axisLabel: {
    // To eliminate labels that are not nice
    showMinLabel: !1,
    showMaxLabel: !1,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: !1
  }
}, AO), rBe = dt({
  logBase: 10
}, AO);
const uY = {
  category: tBe,
  value: AO,
  time: nBe,
  log: rBe
};
var iBe = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};
function Wp(n, e, t, r) {
  $(iBe, function(i, a) {
    var o = At(At({}, uY[a], !0), r, !0), s = (
      /** @class */
      function(l) {
        le(u, l);
        function u() {
          var c = l !== null && l.apply(this, arguments) || this;
          return c.type = e + "Axis." + a, c;
        }
        return u.prototype.mergeDefaultAndTheme = function(c, d) {
          var f = rg(this), p = f ? vh(c) : {}, h = d.getTheme();
          At(c, h.get(a + "Axis")), At(c, this.getDefaultOption()), c.type = TB(c), f && ju(c, p, f);
        }, u.prototype.optionUpdated = function() {
          var c = this.option;
          c.type === "category" && (this.__ordinalMeta = Nk.createByAxisModel(this));
        }, u.prototype.getCategories = function(c) {
          var d = this.option;
          if (d.type === "category")
            return c ? d.data : this.__ordinalMeta.categories;
        }, u.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, u.type = e + "Axis." + a, u.defaultOption = o, u;
      }(t)
    );
    n.registerComponentModel(s);
  }), n.registerSubTypeDefaulter(e + "Axis", TB);
}
function TB(n) {
  return n.type || (n.data ? "category" : "value");
}
var aBe = (
  /** @class */
  function() {
    function n(e) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = e || "";
    }
    return n.prototype.getAxis = function(e) {
      return this._axes[e];
    }, n.prototype.getAxes = function() {
      return De(this._dimList, function(e) {
        return this._axes[e];
      }, this);
    }, n.prototype.getAxesByScale = function(e) {
      return e = e.toLowerCase(), vn(this.getAxes(), function(t) {
        return t.scale.type === e;
      });
    }, n.prototype.addAxis = function(e) {
      var t = e.dim;
      this._axes[t] = e, this._dimList.push(t);
    }, n;
  }()
), Vk = ["x", "y"];
function CB(n) {
  return n.type === "interval" || n.type === "time";
}
var oBe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "cartesian2d", t.dimensions = Vk, t;
    }
    return e.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var t = this.getAxis("x").scale, r = this.getAxis("y").scale;
      if (!(!CB(t) || !CB(r))) {
        var i = t.getExtent(), a = r.getExtent(), o = this.dataToPoint([i[0], a[0]]), s = this.dataToPoint([i[1], a[1]]), l = i[1] - i[0], u = a[1] - a[0];
        if (!(!l || !u)) {
          var c = (s[0] - o[0]) / l, d = (s[1] - o[1]) / u, f = o[0] - i[0] * c, p = o[1] - a[0] * d, h = this._transform = [c, 0, 0, d, f, p];
          this._invTransform = lh([], h);
        }
      }
    }, e.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, e.prototype.containPoint = function(t) {
      var r = this.getAxis("x"), i = this.getAxis("y");
      return r.contain(r.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1]));
    }, e.prototype.containData = function(t) {
      return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]);
    }, e.prototype.containZone = function(t, r) {
      var i = this.dataToPoint(t), a = this.dataToPoint(r), o = this.getArea(), s = new Ot(i[0], i[1], a[0] - i[0], a[1] - i[1]);
      return o.intersect(s);
    }, e.prototype.dataToPoint = function(t, r, i) {
      i = i || [];
      var a = t[0], o = t[1];
      if (this._transform && a != null && isFinite(a) && o != null && isFinite(o))
        return Zr(i, t, this._transform);
      var s = this.getAxis("x"), l = this.getAxis("y");
      return i[0] = s.toGlobalCoord(s.dataToCoord(a, r)), i[1] = l.toGlobalCoord(l.dataToCoord(o, r)), i;
    }, e.prototype.clampData = function(t, r) {
      var i = this.getAxis("x").scale, a = this.getAxis("y").scale, o = i.getExtent(), s = a.getExtent(), l = i.parse(t[0]), u = a.parse(t[1]);
      return r = r || [], r[0] = Math.min(Math.max(Math.min(o[0], o[1]), l), Math.max(o[0], o[1])), r[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), r;
    }, e.prototype.pointToData = function(t, r) {
      var i = [];
      if (this._invTransform)
        return Zr(i, t, this._invTransform);
      var a = this.getAxis("x"), o = this.getAxis("y");
      return i[0] = a.coordToData(a.toLocalCoord(t[0]), r), i[1] = o.coordToData(o.toLocalCoord(t[1]), r), i;
    }, e.prototype.getOtherAxis = function(t) {
      return this.getAxis(t.dim === "x" ? "y" : "x");
    }, e.prototype.getArea = function(t) {
      t = t || 0;
      var r = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), a = Math.min(r[0], r[1]) - t, o = Math.min(i[0], i[1]) - t, s = Math.max(r[0], r[1]) - a + t, l = Math.max(i[0], i[1]) - o + t;
      return new Ot(a, o, s, l);
    }, e;
  }(aBe)
), sBe = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i, a, o) {
      var s = n.call(this, t, r, i) || this;
      return s.index = 0, s.type = a || "value", s.position = o || "bottom", s;
    }
    return e.prototype.isHorizontal = function() {
      var t = this.position;
      return t === "top" || t === "bottom";
    }, e.prototype.getGlobalExtent = function(t) {
      var r = this.getExtent();
      return r[0] = this.toGlobalCoord(r[0]), r[1] = this.toGlobalCoord(r[1]), t && r[0] > r[1] && r.reverse(), r;
    }, e.prototype.pointToData = function(t, r) {
      return this.coordToData(this.toLocalCoord(t[this.dim === "x" ? 0 : 1]), r);
    }, e.prototype.setCategorySortInfo = function(t) {
      if (this.type !== "category")
        return !1;
      this.model.option.categorySortInfo = t, this.scale.setSortInfo(t);
    }, e;
  }(Po)
);
function Hk(n, e, t) {
  t = t || {};
  var r = n.coordinateSystem, i = e.axis, a = {}, o = i.getAxesOnZeroOf()[0], s = i.position, l = o ? "onZero" : s, u = i.dim, c = r.getRect(), d = [c.x, c.x + c.width, c.y, c.y + c.height], f = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, p = e.get("offset") || 0, h = u === "x" ? [d[2] - p, d[3] + p] : [d[0] - p, d[1] + p];
  if (o) {
    var v = o.toGlobalCoord(o.dataToCoord(0));
    h[f.onZero] = Math.max(Math.min(v, h[1]), h[0]);
  }
  a.position = [u === "y" ? h[f[l]] : d[0], u === "x" ? h[f[l]] : d[3]], a.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
  var m = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  a.labelDirection = a.tickDirection = a.nameDirection = m[s], a.labelOffset = o ? h[f[s]] - h[f.onZero] : 0, e.get(["axisTick", "inside"]) && (a.tickDirection = -a.tickDirection), mr(t.labelInside, e.get(["axisLabel", "inside"])) && (a.labelDirection = -a.labelDirection);
  var g = e.get(["axisLabel", "rotate"]);
  return a.labelRotate = l === "top" ? -g : g, a.z2 = 1, a;
}
function kB(n) {
  return n.get("coordinateSystem") === "cartesian2d";
}
function AB(n) {
  var e = {
    xAxisModel: null,
    yAxisModel: null
  };
  return $(e, function(t, r) {
    var i = r.replace(/Model$/, ""), a = n.getReferringComponents(i, gr).models[0];
    if (process.env.NODE_ENV !== "production" && !a)
      throw new Error(i + ' "' + Za(n.get(i + "Index"), n.get(i + "Id"), 0) + '" not found');
    e[r] = a;
  }), e;
}
var dE = Math.log;
function cY(n, e, t) {
  var r = El.prototype, i = r.getTicks.call(t), a = r.getTicks.call(t, !0), o = i.length - 1, s = r.getInterval.call(t), l = pq(n, e), u = l.extent, c = l.fixMin, d = l.fixMax;
  if (n.type === "log") {
    var f = dE(n.base);
    u = [dE(u[0]) / f, dE(u[1]) / f];
  }
  n.setExtent(u[0], u[1]), n.calcNiceExtent({
    splitNumber: o,
    fixMin: c,
    fixMax: d
  });
  var p = r.getExtent.call(n);
  c && (u[0] = p[0]), d && (u[1] = p[1]);
  var h = r.getInterval.call(n), v = u[0], m = u[1];
  if (c && d)
    h = (m - v) / o;
  else if (c)
    for (m = u[0] + h * o; m < u[1] && isFinite(m) && isFinite(u[1]); )
      h = X2(h), m = u[0] + h * o;
  else if (d)
    for (v = u[1] - h * o; v > u[0] && isFinite(v) && isFinite(u[0]); )
      h = X2(h), v = u[1] - h * o;
  else {
    var g = n.getTicks().length - 1;
    g > o && (h = X2(h));
    var y = h * o;
    m = Math.ceil(u[1] / h) * h, v = ir(m - y), v < 0 && u[0] >= 0 ? (v = 0, m = ir(y)) : m > 0 && u[1] <= 0 && (m = 0, v = -ir(y));
  }
  var b = (i[0].value - a[0].value) / s, _ = (i[o].value - a[o].value) / s;
  if (r.setExtent.call(n, v + h * b, m + h * _), r.setInterval.call(n, h), (b || _) && r.setNiceExtent.call(n, v + h, m - h), process.env.NODE_ENV !== "production") {
    var x = r.getTicks.call(n);
    x[1] && (!y3e(h) || ak(x[1].value) > ak(h)) && Jn(
      // eslint-disable-next-line
      "The ticks may be not readable when set min: " + e.get("min") + ", max: " + e.get("max") + " and alignTicks: true"
    );
  }
}
var lBe = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = Vk, this._initCartesian(e, t, r), this.model = e;
    }
    return n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype.update = function(e, t) {
      var r = this._axesMap;
      this._updateScale(e, this.model);
      function i(o) {
        var s, l = Yt(o), u = l.length;
        if (u) {
          for (var c = [], d = u - 1; d >= 0; d--) {
            var f = +l[d], p = o[f], h = p.model, v = p.scale;
            // Only value and log axis without interval support alignTicks.
            Rk(v) && h.get("alignTicks") && h.get("interval") == null ? c.push(p) : (Gp(v, h), Rk(v) && (s = p));
          }
          c.length && (s || (s = c.pop(), Gp(s.scale, s.model)), $(c, function(m) {
            cY(m.scale, m.model, s.scale);
          }));
        }
      }
      i(r.x), i(r.y);
      var a = {};
      $(r.x, function(o) {
        MB(r, "y", o, a);
      }), $(r.y, function(o) {
        MB(r, "x", o, a);
      }), this.resize(this.model, t);
    }, n.prototype.resize = function(e, t, r) {
      var i = e.getBoxLayoutParams(), a = !r && e.get("containLabel"), o = Er(i, {
        width: t.getWidth(),
        height: t.getHeight()
      });
      this._rect = o;
      var s = this._axesList;
      l(), a && ($(s, function(u) {
        if (!u.model.get(["axisLabel", "inside"])) {
          var c = V3e(u);
          if (c) {
            var d = u.isHorizontal() ? "height" : "width", f = u.model.get(["axisLabel", "margin"]);
            o[d] -= c[d] + f, u.position === "top" ? o.y += c.height + f : u.position === "left" && (o.x += c.width + f);
          }
        }
      }), l()), $(this._coordsList, function(u) {
        u.calcAffineTransform();
      });
      function l() {
        $(s, function(u) {
          var c = u.isHorizontal(), d = c ? [0, o.width] : [0, o.height], f = u.inverse ? 1 : 0;
          u.setExtent(d[f], d[1 - f]), uBe(u, c ? o.x : o.y);
        });
      }
    }, n.prototype.getAxis = function(e, t) {
      var r = this._axesMap[e];
      if (r != null)
        return r[t || 0];
    }, n.prototype.getAxes = function() {
      return this._axesList.slice();
    }, n.prototype.getCartesian = function(e, t) {
      if (e != null && t != null) {
        var r = "x" + e + "y" + t;
        return this._coordsMap[r];
      }
      ut(e) && (t = e.yAxisIndex, e = e.xAxisIndex);
      for (var i = 0, a = this._coordsList; i < a.length; i++)
        if (a[i].getAxis("x").index === e || a[i].getAxis("y").index === t)
          return a[i];
    }, n.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, n.prototype.convertToPixel = function(e, t, r) {
      var i = this._findConvertTarget(t);
      return i.cartesian ? i.cartesian.dataToPoint(r) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(r)) : null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      var i = this._findConvertTarget(t);
      return i.cartesian ? i.cartesian.pointToData(r) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(r)) : null;
    }, n.prototype._findConvertTarget = function(e) {
      var t = e.seriesModel, r = e.xAxisModel || t && t.getReferringComponents("xAxis", gr).models[0], i = e.yAxisModel || t && t.getReferringComponents("yAxis", gr).models[0], a = e.gridModel, o = this._coordsList, s, l;
      if (t)
        s = t.coordinateSystem, Pt(o, s) < 0 && (s = null);
      else if (r && i)
        s = this.getCartesian(r.componentIndex, i.componentIndex);
      else if (r)
        l = this.getAxis("x", r.componentIndex);
      else if (i)
        l = this.getAxis("y", i.componentIndex);
      else if (a) {
        var u = a.coordinateSystem;
        u === this && (s = this._coordsList[0]);
      }
      return {
        cartesian: s,
        axis: l
      };
    }, n.prototype.containPoint = function(e) {
      var t = this._coordsList[0];
      if (t)
        return t.containPoint(e);
    }, n.prototype._initCartesian = function(e, t, r) {
      var i = this, a = this, o = {
        left: !1,
        right: !1,
        top: !1,
        bottom: !1
      }, s = {
        x: {},
        y: {}
      }, l = {
        x: 0,
        y: 0
      };
      if (t.eachComponent("xAxis", u("x"), this), t.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = s, $(s.x, function(c, d) {
        $(s.y, function(f, p) {
          var h = "x" + d + "y" + p, v = new oBe(h);
          v.master = i, v.model = e, i._coordsMap[h] = v, i._coordsList.push(v), v.addAxis(c), v.addAxis(f);
        });
      });
      function u(c) {
        return function(d, f) {
          if (fE(d, e)) {
            var p = d.get("position");
            c === "x" ? p !== "top" && p !== "bottom" && (p = o.bottom ? "top" : "bottom") : p !== "left" && p !== "right" && (p = o.left ? "right" : "left"), o[p] = !0;
            var h = new sBe(c, Sw(d), [0, 0], d.get("type"), p), v = h.type === "category";
            h.onBand = v && d.get("boundaryGap"), h.inverse = d.get("inverse"), d.axis = h, h.model = d, h.grid = a, h.index = f, a._axesList.push(h), s[c][f] = h, l[c]++;
          }
        };
      }
    }, n.prototype._updateScale = function(e, t) {
      $(this._axesList, function(i) {
        if (i.scale.setExtent(1 / 0, -1 / 0), i.type === "category") {
          var a = i.model.get("categorySortInfo");
          i.scale.setSortInfo(a);
        }
      }), e.eachSeries(function(i) {
        if (kB(i)) {
          var a = AB(i), o = a.xAxisModel, s = a.yAxisModel;
          if (!fE(o, t) || !fE(s, t))
            return;
          var l = this.getCartesian(o.componentIndex, s.componentIndex), u = i.getData(), c = l.getAxis("x"), d = l.getAxis("y");
          r(u, c), r(u, d);
        }
      }, this);
      function r(i, a) {
        $(g_(i, a.dim), function(o) {
          a.scale.unionExtentFromData(i, o);
        });
      }
    }, n.prototype.getTooltipAxes = function(e) {
      var t = [], r = [];
      return $(this.getCartesians(), function(i) {
        var a = e != null && e !== "auto" ? i.getAxis(e) : i.getBaseAxis(), o = i.getOtherAxis(a);
        Pt(t, a) < 0 && t.push(a), Pt(r, o) < 0 && r.push(o);
      }), {
        baseAxes: t,
        otherAxes: r
      };
    }, n.create = function(e, t) {
      var r = [];
      return e.eachComponent("grid", function(i, a) {
        var o = new n(i, e, t);
        o.name = "grid_" + a, o.resize(i, t, !0), i.coordinateSystem = o, r.push(o);
      }), e.eachSeries(function(i) {
        if (kB(i)) {
          var a = AB(i), o = a.xAxisModel, s = a.yAxisModel, l = o.getCoordSysModel();
          if (process.env.NODE_ENV !== "production") {
            if (!l)
              throw new Error('Grid "' + Za(o.get("gridIndex"), o.get("gridId"), 0) + '" not found');
            if (o.getCoordSysModel() !== s.getCoordSysModel())
              throw new Error("xAxis and yAxis must use the same grid");
          }
          var u = l.coordinateSystem;
          i.coordinateSystem = u.getCartesian(o.componentIndex, s.componentIndex);
        }
      }), r;
    }, n.dimensions = Vk, n;
  }()
);
function fE(n, e) {
  return n.getCoordSysModel() === e;
}
function MB(n, e, t, r) {
  t.getAxesOnZeroOf = function() {
    return a ? [a] : [];
  };
  var i = n[e], a, o = t.model, s = o.get(["axisLine", "onZero"]), l = o.get(["axisLine", "onZeroAxisIndex"]);
  if (!s)
    return;
  if (l != null)
    DB(i[l]) && (a = i[l]);
  else
    for (var u in i)
      if (i.hasOwnProperty(u) && DB(i[u]) && !r[c(i[u])]) {
        a = i[u];
        break;
      }
  a && (r[c(a)] = !0);
  function c(d) {
    return d.dim + "_" + d.index;
  }
}
function DB(n) {
  return n && n.type !== "category" && n.type !== "time" && F3e(n);
}
function uBe(n, e) {
  var t = n.getExtent(), r = t[0] + t[1];
  n.toGlobalCoord = n.dim === "x" ? function(i) {
    return i + e;
  } : function(i) {
    return r - i + e;
  }, n.toLocalCoord = n.dim === "x" ? function(i) {
    return i - e;
  } : function(i) {
    return r - i + e;
  };
}
var gu = Math.PI, Ii = (
  /** @class */
  function() {
    function n(e, t) {
      this.group = new mt(), this.opt = t, this.axisModel = e, dt(t, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: !0,
        handleAutoShown: function() {
          return !0;
        }
      });
      var r = new mt({
        x: t.position[0],
        y: t.position[1],
        rotation: t.rotation
      });
      r.updateTransform(), this._transformGroup = r;
    }
    return n.prototype.hasBuilder = function(e) {
      return !!OB[e];
    }, n.prototype.add = function(e) {
      OB[e](this.opt, this.axisModel, this.group, this._transformGroup);
    }, n.prototype.getGroup = function() {
      return this.group;
    }, n.innerTextLayout = function(e, t, r) {
      var i = DG(t - e), a, o;
      return Qm(i) ? (o = r > 0 ? "top" : "bottom", a = "center") : Qm(i - gu) ? (o = r > 0 ? "bottom" : "top", a = "center") : (o = "middle", i > 0 && i < gu ? a = r > 0 ? "right" : "left" : a = r > 0 ? "left" : "right"), {
        rotation: i,
        textAlign: a,
        textVerticalAlign: o
      };
    }, n.makeAxisEventDataBase = function(e) {
      var t = {
        componentType: e.mainType,
        componentIndex: e.componentIndex
      };
      return t[e.mainType + "Index"] = e.componentIndex, t;
    }, n.isLabelSilent = function(e) {
      var t = e.get("tooltip");
      return e.get("silent") || !(e.get("triggerEvent") || t && t.show);
    }, n;
  }()
), OB = {
  axisLine: function(n, e, t, r) {
    var i = e.get(["axisLine", "show"]);
    if (i === "auto" && n.handleAutoShown && (i = n.handleAutoShown("axisLine")), !!i) {
      var a = e.axis.getExtent(), o = r.transform, s = [a[0], 0], l = [a[1], 0], u = s[0] > l[0];
      o && (Zr(s, s, o), Zr(l, l, o));
      var c = xe({
        lineCap: "round"
      }, e.getModel(["axisLine", "lineStyle"]).getLineStyle()), d = new Dr({
        shape: {
          x1: s[0],
          y1: s[1],
          x2: l[0],
          y2: l[1]
        },
        style: c,
        strokeContainThreshold: n.strokeContainThreshold || 5,
        silent: !0,
        z2: 1
      });
      Fp(d.shape, d.style.lineWidth), d.anid = "line", t.add(d);
      var f = e.get(["axisLine", "symbol"]);
      if (f != null) {
        var p = e.get(["axisLine", "symbolSize"]);
        We(f) && (f = [f, f]), (We(p) || sn(p)) && (p = [p, p]);
        var h = ef(e.get(["axisLine", "symbolOffset"]) || 0, p), v = p[0], m = p[1];
        $([{
          rotate: n.rotation + Math.PI / 2,
          offset: h[0],
          r: 0
        }, {
          rotate: n.rotation - Math.PI / 2,
          offset: h[1],
          r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1]))
        }], function(g, y) {
          if (f[y] !== "none" && f[y] != null) {
            var b = yr(f[y], -v / 2, -m / 2, v, m, c.stroke, !0), _ = g.r + g.offset, x = u ? l : s;
            b.attr({
              rotation: g.rotate,
              x: x[0] + _ * Math.cos(n.rotation),
              y: x[1] - _ * Math.sin(n.rotation),
              silent: !0,
              z2: 11
            }), t.add(b);
          }
        });
      }
    }
  },
  axisTickLabel: function(n, e, t, r) {
    var i = fBe(t, r, e, n), a = hBe(t, r, e, n);
    if (dBe(e, a, i), pBe(t, r, e, n.tickDirection), e.get(["axisLabel", "hideOverlap"])) {
      var o = kq(De(a, function(s) {
        return {
          label: s,
          priority: s.z2,
          defaultAttr: {
            ignore: s.ignore
          }
        };
      }));
      Dq(o);
    }
  },
  axisName: function(n, e, t, r) {
    var i = mr(n.axisName, e.get("name"));
    if (i) {
      var a = e.get("nameLocation"), o = n.nameDirection, s = e.getModel("nameTextStyle"), l = e.get("nameGap") || 0, u = e.axis.getExtent(), c = u[0] > u[1] ? -1 : 1, d = [
        a === "start" ? u[0] - c * l : a === "end" ? u[1] + c * l : (u[0] + u[1]) / 2,
        // Reuse labelOffset.
        LB(a) ? n.labelOffset + o * l : 0
      ], f, p = e.get("nameRotate");
      p != null && (p = p * gu / 180);
      var h;
      LB(a) ? f = Ii.innerTextLayout(
        n.rotation,
        p ?? n.rotation,
        // Adapt to axis.
        o
      ) : (f = cBe(n.rotation, a, p || 0, u), h = n.axisNameAvailableWidth, h != null && (h = Math.abs(h / Math.sin(f.rotation)), !isFinite(h) && (h = null)));
      var v = s.getFont(), m = e.get("nameTruncate", !0) || {}, g = m.ellipsis, y = mr(n.nameTruncateMaxWidth, m.maxWidth, h), b = new nn({
        x: d[0],
        y: d[1],
        rotation: f.rotation,
        silent: Ii.isLabelSilent(e),
        style: Ln(s, {
          text: i,
          font: v,
          overflow: "truncate",
          width: y,
          ellipsis: g,
          fill: s.getTextColor() || e.get(["axisLine", "lineStyle", "color"]),
          align: s.get("align") || f.textAlign,
          verticalAlign: s.get("verticalAlign") || f.textVerticalAlign
        }),
        z2: 1
      });
      if (Jd({
        el: b,
        componentModel: e,
        itemName: i
      }), b.__fullText = i, b.anid = "name", e.get("triggerEvent")) {
        var _ = Ii.makeAxisEventDataBase(e);
        _.targetType = "axisName", _.name = i, yt(b).eventData = _;
      }
      r.add(b), b.updateTransform(), t.add(b), b.decomposeTransform();
    }
  }
};
function cBe(n, e, t, r) {
  var i = DG(t - n), a, o, s = r[0] > r[1], l = e === "start" && !s || e !== "start" && s;
  return Qm(i - gu / 2) ? (o = l ? "bottom" : "top", a = "center") : Qm(i - gu * 1.5) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", i < gu * 1.5 && i > gu / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
    rotation: i,
    textAlign: a,
    textVerticalAlign: o
  };
}
function dBe(n, e, t) {
  if (!hq(n.axis)) {
    var r = n.get(["axisLabel", "showMinLabel"]), i = n.get(["axisLabel", "showMaxLabel"]);
    e = e || [], t = t || [];
    var a = e[0], o = e[1], s = e[e.length - 1], l = e[e.length - 2], u = t[0], c = t[1], d = t[t.length - 1], f = t[t.length - 2];
    r === !1 ? (Oa(a), Oa(u)) : IB(a, o) && (r ? (Oa(o), Oa(c)) : (Oa(a), Oa(u))), i === !1 ? (Oa(s), Oa(d)) : IB(l, s) && (i ? (Oa(l), Oa(f)) : (Oa(s), Oa(d)));
  }
}
function Oa(n) {
  n && (n.ignore = !0);
}
function IB(n, e) {
  var t = n && n.getBoundingRect().clone(), r = e && e.getBoundingRect().clone();
  if (!(!t || !r)) {
    var i = Wx([]);
    return Zd(i, i, -n.rotation), t.applyTransform(cl([], i, n.getLocalTransform())), r.applyTransform(cl([], i, e.getLocalTransform())), t.intersect(r);
  }
}
function LB(n) {
  return n === "middle" || n === "center";
}
function dY(n, e, t, r, i) {
  for (var a = [], o = [], s = [], l = 0; l < n.length; l++) {
    var u = n[l].coord;
    o[0] = u, o[1] = 0, s[0] = u, s[1] = t, e && (Zr(o, o, e), Zr(s, s, e));
    var c = new Dr({
      shape: {
        x1: o[0],
        y1: o[1],
        x2: s[0],
        y2: s[1]
      },
      style: r,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    Fp(c.shape, c.style.lineWidth), c.anid = i + "_" + n[l].tickValue, a.push(c);
  }
  return a;
}
function fBe(n, e, t, r) {
  var i = t.axis, a = t.getModel("axisTick"), o = a.get("show");
  if (o === "auto" && r.handleAutoShown && (o = r.handleAutoShown("axisTick")), !(!o || i.scale.isBlank())) {
    for (var s = a.getModel("lineStyle"), l = r.tickDirection * a.get("length"), u = i.getTicksCoords(), c = dY(u, e.transform, l, dt(s.getLineStyle(), {
      stroke: t.get(["axisLine", "lineStyle", "color"])
    }), "ticks"), d = 0; d < c.length; d++)
      n.add(c[d]);
    return c;
  }
}
function pBe(n, e, t, r) {
  var i = t.axis, a = t.getModel("minorTick");
  if (!(!a.get("show") || i.scale.isBlank())) {
    var o = i.getMinorTicksCoords();
    if (o.length)
      for (var s = a.getModel("lineStyle"), l = r * a.get("length"), u = dt(s.getLineStyle(), dt(t.getModel("axisTick").getLineStyle(), {
        stroke: t.get(["axisLine", "lineStyle", "color"])
      })), c = 0; c < o.length; c++)
        for (var d = dY(o[c], e.transform, l, u, "minorticks_" + c), f = 0; f < d.length; f++)
          n.add(d[f]);
  }
}
function hBe(n, e, t, r) {
  var i = t.axis, a = mr(r.axisLabelShow, t.get(["axisLabel", "show"]));
  if (!(!a || i.scale.isBlank())) {
    var o = t.getModel("axisLabel"), s = o.get("margin"), l = i.getViewLabels(), u = (mr(r.labelRotate, o.get("rotate")) || 0) * gu / 180, c = Ii.innerTextLayout(r.rotation, u, r.labelDirection), d = t.getCategories && t.getCategories(!0), f = [], p = Ii.isLabelSilent(t), h = t.get("triggerEvent");
    return $(l, function(v, m) {
      var g = i.scale.type === "ordinal" ? i.scale.getRawOrdinalNumber(v.tickValue) : v.tickValue, y = v.formattedLabel, b = v.rawLabel, _ = o;
      if (d && d[g]) {
        var x = d[g];
        ut(x) && x.textStyle && (_ = new yn(x.textStyle, o, t.ecModel));
      }
      var w = _.getTextColor() || t.get(["axisLine", "lineStyle", "color"]), S = i.dataToCoord(g), C = _.getShallow("align", !0) || c.textAlign, k = bt(_.getShallow("alignMinLabel", !0), C), M = bt(_.getShallow("alignMaxLabel", !0), C), D = _.getShallow("verticalAlign", !0) || _.getShallow("baseline", !0) || c.textVerticalAlign, N = bt(_.getShallow("verticalAlignMinLabel", !0), D), R = bt(_.getShallow("verticalAlignMaxLabel", !0), D), j = new nn({
        x: S,
        y: r.labelOffset + r.labelDirection * s,
        rotation: c.rotation,
        silent: p,
        z2: 10 + (v.level || 0),
        style: Ln(_, {
          text: y,
          align: m === 0 ? k : m === l.length - 1 ? M : C,
          verticalAlign: m === 0 ? N : m === l.length - 1 ? R : D,
          fill: at(w) ? w(
            // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user replace ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            i.type === "category" ? b : i.type === "value" ? g + "" : g,
            m
          ) : w
        })
      });
      if (j.anid = "label_" + g, Jd({
        el: j,
        componentModel: t,
        itemName: y,
        formatterParamsExtra: {
          isTruncated: function() {
            return j.isTruncated;
          },
          value: b,
          tickIndex: m
        }
      }), h) {
        var z = Ii.makeAxisEventDataBase(t);
        z.targetType = "axisLabel", z.value = b, z.tickIndex = m, i.type === "category" && (z.dataIndex = g), yt(j).eventData = z;
      }
      e.add(j), j.updateTransform(), f.push(j), n.add(j), j.decomposeTransform();
    }), f;
  }
}
function vBe(n, e) {
  var t = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return mBe(t, n, e), t.seriesInvolved && yBe(t, n), t;
}
function mBe(n, e, t) {
  var r = e.getComponent("tooltip"), i = e.getComponent("axisPointer"), a = i.get("link", !0) || [], o = [];
  $(t.getCoordinateSystems(), function(s) {
    if (!s.axisPointerEnabled)
      return;
    var l = fg(s.model), u = n.coordSysAxesInfo[l] = {};
    n.coordSysMap[l] = s;
    var c = s.model, d = c.getModel("tooltip", r);
    if ($(s.getAxes(), Tt(v, !1, null)), s.getTooltipAxes && r && d.get("show")) {
      var f = d.get("trigger") === "axis", p = d.get(["axisPointer", "type"]) === "cross", h = s.getTooltipAxes(d.get(["axisPointer", "axis"]));
      (f || p) && $(h.baseAxes, Tt(v, p ? "cross" : !0, f)), p && $(h.otherAxes, Tt(v, "cross", !1));
    }
    function v(m, g, y) {
      var b = y.model.getModel("axisPointer", i), _ = b.get("show");
      if (!(!_ || _ === "auto" && !m && !Gk(b))) {
        g == null && (g = b.get("triggerTooltip")), b = m ? gBe(y, d, i, e, m, g) : b;
        var x = b.get("snap"), w = b.get("triggerEmphasis"), S = fg(y.model), C = g || x || y.type === "category", k = n.axesInfo[S] = {
          key: S,
          axis: y,
          coordSys: s,
          axisPointerModel: b,
          triggerTooltip: g,
          triggerEmphasis: w,
          involveSeries: C,
          snap: x,
          useHandle: Gk(b),
          seriesModels: [],
          linkGroup: null
        };
        u[S] = k, n.seriesInvolved = n.seriesInvolved || C;
        var M = bBe(a, y);
        if (M != null) {
          var D = o[M] || (o[M] = {
            axesInfo: {}
          });
          D.axesInfo[S] = k, D.mapper = a[M].mapper, k.linkGroup = D;
        }
      }
    }
  });
}
function gBe(n, e, t, r, i, a) {
  var o = e.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  $(s, function(f) {
    l[f] = ht(o.get(f));
  }), l.snap = n.type !== "category" && !!a, o.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), i === "cross") {
    var c = o.get(["label", "show"]);
    if (u.show = c ?? !0, !a) {
      var d = l.lineStyle = o.get("crossStyle");
      d && dt(u, d.textStyle);
    }
  }
  return n.model.getModel("axisPointer", new yn(l, t, r));
}
function yBe(n, e) {
  e.eachSeries(function(t) {
    var r = t.coordinateSystem, i = t.get(["tooltip", "trigger"], !0), a = t.get(["tooltip", "show"], !0);
    !r || i === "none" || i === !1 || i === "item" || a === !1 || t.get(["axisPointer", "show"], !0) === !1 || $(n.coordSysAxesInfo[fg(r.model)], function(o) {
      var s = o.axis;
      r.getAxis(s.dim) === s && (o.seriesModels.push(t), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += t.getData().count());
    });
  });
}
function bBe(n, e) {
  for (var t = e.model, r = e.dim, i = 0; i < n.length; i++) {
    var a = n[i] || {};
    if (pE(a[r + "AxisId"], t.id) || pE(a[r + "AxisIndex"], t.componentIndex) || pE(a[r + "AxisName"], t.name))
      return i;
  }
}
function pE(n, e) {
  return n === "all" || Me(n) && Pt(n, e) >= 0 || n === e;
}
function _Be(n) {
  var e = MO(n);
  if (e) {
    var t = e.axisPointerModel, r = e.axis.scale, i = t.option, a = t.get("status"), o = t.get("value");
    o != null && (o = r.parse(o));
    var s = Gk(t);
    a == null && (i.status = s ? "show" : "hide");
    var l = r.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), i.value = o, s && (i.status = e.axis.scale.isBlank() ? "hide" : "show");
  }
}
function MO(n) {
  var e = (n.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return e && e.axesInfo[fg(n)];
}
function xBe(n) {
  var e = MO(n);
  return e && e.axisPointerModel;
}
function Gk(n) {
  return !!n.get(["handle", "show"]);
}
function fg(n) {
  return n.type + "||" + n.id;
}
var hE = {}, rf = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      this.axisPointerClass && _Be(t), n.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(t, i, !0);
    }, e.prototype.updateAxisPointer = function(t, r, i, a) {
      this._doUpdateAxisPointerClass(t, i, !1);
    }, e.prototype.remove = function(t, r) {
      var i = this._axisPointer;
      i && i.remove(r);
    }, e.prototype.dispose = function(t, r) {
      this._disposeAxisPointer(r), n.prototype.dispose.apply(this, arguments);
    }, e.prototype._doUpdateAxisPointerClass = function(t, r, i) {
      var a = e.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var o = xBe(t);
        o ? (this._axisPointer || (this._axisPointer = new a())).render(t, o, r, i) : this._disposeAxisPointer(r);
      }
    }, e.prototype._disposeAxisPointer = function(t) {
      this._axisPointer && this._axisPointer.dispose(t), this._axisPointer = null;
    }, e.registerAxisPointerClass = function(t, r) {
      if (process.env.NODE_ENV !== "production" && hE[t])
        throw new Error("axisPointer " + t + " exists");
      hE[t] = r;
    }, e.getAxisPointerClass = function(t) {
      return t && hE[t];
    }, e.type = "axis", e;
  }(Yn)
), Uk = en();
function fY(n, e, t, r) {
  var i = t.axis;
  if (!i.scale.isBlank()) {
    var a = t.getModel("splitArea"), o = a.getModel("areaStyle"), s = o.get("color"), l = r.coordinateSystem.getRect(), u = i.getTicksCoords({
      tickModel: a,
      clamp: !0
    });
    if (u.length) {
      var c = s.length, d = Uk(n).splitAreaColors, f = tt(), p = 0;
      if (d)
        for (var h = 0; h < u.length; h++) {
          var v = d.get(u[h].tickValue);
          if (v != null) {
            p = (v + (c - 1) * h) % c;
            break;
          }
        }
      var m = i.toGlobalCoord(u[0].coord), g = o.getAreaStyle();
      s = Me(s) ? s : [s];
      for (var h = 1; h < u.length; h++) {
        var y = i.toGlobalCoord(u[h].coord), b = void 0, _ = void 0, x = void 0, w = void 0;
        i.isHorizontal() ? (b = m, _ = l.y, x = y - b, w = l.height, m = b + x) : (b = l.x, _ = m, x = l.width, w = y - _, m = _ + w);
        var S = u[h - 1].tickValue;
        S != null && f.set(S, p), e.add(new Qt({
          anid: S != null ? "area_" + S : null,
          shape: {
            x: b,
            y: _,
            width: x,
            height: w
          },
          style: dt({
            fill: s[p]
          }, g),
          autoBatch: !0,
          silent: !0
        })), p = (p + 1) % c;
      }
      Uk(n).splitAreaColors = f;
    }
  }
}
function pY(n) {
  Uk(n).splitAreaColors = null;
}
var wBe = ["axisLine", "axisTickLabel", "axisName"], SBe = ["splitArea", "splitLine", "minorSplitLine"], hY = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "CartesianAxisPointer", t;
    }
    return e.prototype.render = function(t, r, i, a) {
      this.group.removeAll();
      var o = this._axisGroup;
      if (this._axisGroup = new mt(), this.group.add(this._axisGroup), !!t.get("show")) {
        var s = t.getCoordSysModel(), l = Hk(s, t), u = new Ii(t, xe({
          handleAutoShown: function(d) {
            for (var f = s.coordinateSystem.getCartesians(), p = 0; p < f.length; p++)
              if (Rk(f[p].getOtherAxis(t.axis).scale))
                return !0;
            return !1;
          }
        }, l));
        $(wBe, u.add, u), this._axisGroup.add(u.getGroup()), $(SBe, function(d) {
          t.get([d, "show"]) && EBe[d](this, this._axisGroup, t, s);
        }, this);
        var c = a && a.type === "changeAxisOrder" && a.isInitSort;
        c || Wg(o, this._axisGroup, t), n.prototype.render.call(this, t, r, i, a);
      }
    }, e.prototype.remove = function() {
      pY(this);
    }, e.type = "cartesianAxis", e;
  }(rf)
), EBe = {
  splitLine: function(n, e, t, r) {
    var i = t.axis;
    if (!i.scale.isBlank()) {
      var a = t.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color"), l = a.get("showMinLine") !== !1, u = a.get("showMaxLine") !== !1;
      s = Me(s) ? s : [s];
      for (var c = r.coordinateSystem.getRect(), d = i.isHorizontal(), f = 0, p = i.getTicksCoords({
        tickModel: a
      }), h = [], v = [], m = o.getLineStyle(), g = 0; g < p.length; g++) {
        var y = i.toGlobalCoord(p[g].coord);
        if (!(g === 0 && !l || g === p.length - 1 && !u)) {
          var b = p[g].tickValue;
          d ? (h[0] = y, h[1] = c.y, v[0] = y, v[1] = c.y + c.height) : (h[0] = c.x, h[1] = y, v[0] = c.x + c.width, v[1] = y);
          var _ = f++ % s.length, x = new Dr({
            anid: b != null ? "line_" + b : null,
            autoBatch: !0,
            shape: {
              x1: h[0],
              y1: h[1],
              x2: v[0],
              y2: v[1]
            },
            style: dt({
              stroke: s[_]
            }, m),
            silent: !0
          });
          Fp(x.shape, m.lineWidth), e.add(x);
        }
      }
    }
  },
  minorSplitLine: function(n, e, t, r) {
    var i = t.axis, a = t.getModel("minorSplitLine"), o = a.getModel("lineStyle"), s = r.coordinateSystem.getRect(), l = i.isHorizontal(), u = i.getMinorTicksCoords();
    if (u.length)
      for (var c = [], d = [], f = o.getLineStyle(), p = 0; p < u.length; p++)
        for (var h = 0; h < u[p].length; h++) {
          var v = i.toGlobalCoord(u[p][h].coord);
          l ? (c[0] = v, c[1] = s.y, d[0] = v, d[1] = s.y + s.height) : (c[0] = s.x, c[1] = v, d[0] = s.x + s.width, d[1] = v);
          var m = new Dr({
            anid: "minor_line_" + u[p][h].tickValue,
            autoBatch: !0,
            shape: {
              x1: c[0],
              y1: c[1],
              x2: d[0],
              y2: d[1]
            },
            style: f,
            silent: !0
          });
          Fp(m.shape, f.lineWidth), e.add(m);
        }
  },
  splitArea: function(n, e, t, r) {
    fY(n, e, t, r);
  }
}, vY = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "xAxis", e;
  }(hY)
), TBe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = vY.type, t;
    }
    return e.type = "yAxis", e;
  }(hY)
), CBe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "grid", t;
    }
    return e.prototype.render = function(t, r) {
      this.group.removeAll(), t.get("show") && this.group.add(new Qt({
        shape: t.coordinateSystem.getRect(),
        style: dt({
          fill: t.get("backgroundColor")
        }, t.getItemStyle()),
        silent: !0,
        z2: -1
      }));
    }, e.type = "grid", e;
  }(Yn)
), NB = {
  // gridIndex: 0,
  // gridId: '',
  offset: 0
};
function mY(n) {
  n.registerComponentView(CBe), n.registerComponentModel(eBe), n.registerCoordinateSystem("cartesian2d", lBe), Wp(n, "x", Fk, NB), Wp(n, "y", Fk, NB), n.registerComponentView(vY), n.registerComponentView(TBe), n.registerPreprocessor(function(e) {
    e.xAxis && e.yAxis && !e.grid && (e.grid = {});
  });
}
function kBe(n) {
  $t(mY), n.registerSeriesModel(K5e), n.registerChartView(Q5e), n.registerLayout(ey("scatter"));
}
function ABe(n) {
  n.eachSeriesByType("radar", function(e) {
    var t = e.getData(), r = [], i = e.coordinateSystem;
    if (i) {
      var a = i.getIndicatorAxes();
      $(a, function(o, s) {
        t.each(t.mapDimension(a[s].dim), function(l, u) {
          r[u] = r[u] || [];
          var c = i.dataToPoint(l, s);
          r[u][s] = RB(c) ? c : PB(i);
        });
      }), t.each(function(o) {
        var s = uDe(r[o], function(l) {
          return RB(l);
        }) || PB(i);
        r[o].push(s.slice()), t.setItemLayout(o, r[o]);
      });
    }
  });
}
function RB(n) {
  return !isNaN(n[0]) && !isNaN(n[1]);
}
function PB(n) {
  return [n.cx, n.cy];
}
function MBe(n) {
  var e = n.polar;
  if (e) {
    Me(e) || (e = [e]);
    var t = [];
    $(e, function(r, i) {
      r.indicator ? (r.type && !r.shape && (r.shape = r.type), n.radar = n.radar || [], Me(n.radar) || (n.radar = [n.radar]), n.radar.push(r)) : t.push(r);
    }), n.polar = t;
  }
  $(n.series, function(r) {
    r && r.type === "radar" && r.polarIndex && (r.radarIndex = r.polarIndex);
  });
}
var DBe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = t.coordinateSystem, o = this.group, s = t.getData(), l = this._data;
      function u(f, p) {
        var h = f.getItemVisual(p, "symbol") || "circle";
        if (h !== "none") {
          var v = _h(f.getItemVisual(p, "symbolSize")), m = yr(h, -1, -1, 2, 2), g = f.getItemVisual(p, "symbolRotate") || 0;
          return m.attr({
            style: {
              strokeNoScale: !0
            },
            z2: 100,
            scaleX: v[0] / 2,
            scaleY: v[1] / 2,
            rotation: g * Math.PI / 180 || 0
          }), m;
        }
      }
      function c(f, p, h, v, m, g) {
        h.removeAll();
        for (var y = 0; y < p.length - 1; y++) {
          var b = u(v, m);
          b && (b.__dimIdx = y, f[y] ? (b.setPosition(f[y]), Qd[g ? "initProps" : "updateProps"](b, {
            x: p[y][0],
            y: p[y][1]
          }, t, m)) : b.setPosition(p[y]), h.add(b));
        }
      }
      function d(f) {
        return De(f, function(p) {
          return [a.cx, a.cy];
        });
      }
      s.diff(l).add(function(f) {
        var p = s.getItemLayout(f);
        if (p) {
          var h = new Vi(), v = new Hi(), m = {
            shape: {
              points: p
            }
          };
          h.shape.points = d(p), v.shape.points = d(p), Gn(h, m, t, f), Gn(v, m, t, f);
          var g = new mt(), y = new mt();
          g.add(v), g.add(h), g.add(y), c(v.shape.points, p, y, s, f, !0), s.setItemGraphicEl(f, g);
        }
      }).update(function(f, p) {
        var h = l.getItemGraphicEl(p), v = h.childAt(0), m = h.childAt(1), g = h.childAt(2), y = {
          shape: {
            points: s.getItemLayout(f)
          }
        };
        y.shape.points && (c(v.shape.points, y.shape.points, g, s, f, !1), Oo(m), Oo(v), ln(v, y, t), ln(m, y, t), s.setItemGraphicEl(f, h));
      }).remove(function(f) {
        o.remove(l.getItemGraphicEl(f));
      }).execute(), s.eachItemGraphicEl(function(f, p) {
        var h = s.getItemModel(p), v = f.childAt(0), m = f.childAt(1), g = f.childAt(2), y = s.getItemVisual(p, "style"), b = y.fill;
        o.add(f), v.useStyle(dt(h.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: b
        })), Qr(v, h, "lineStyle"), Qr(m, h, "areaStyle");
        var _ = h.getModel("areaStyle"), x = _.isEmpty() && _.parentModel.isEmpty();
        m.ignore = x, $(["emphasis", "select", "blur"], function(C) {
          var k = h.getModel([C, "areaStyle"]), M = k.isEmpty() && k.parentModel.isEmpty();
          m.ensureState(C).ignore = M && x;
        }), m.useStyle(dt(_.getAreaStyle(), {
          fill: b,
          opacity: 0.7,
          decal: y.decal
        }));
        var w = h.getModel("emphasis"), S = w.getModel("itemStyle").getItemStyle();
        g.eachChild(function(C) {
          if (C instanceof Ur) {
            var k = C.style;
            C.useStyle(xe({
              // TODO other properties like x, y ?
              image: k.image,
              x: k.x,
              y: k.y,
              width: k.width,
              height: k.height
            }, y));
          } else
            C.useStyle(y), C.setColor(b), C.style.strokeNoScale = !0;
          var M = C.ensureState("emphasis");
          M.style = ht(S);
          var D = s.getStore().get(s.getDimensionIndex(C.__dimIdx), p);
          (D == null || isNaN(D)) && (D = ""), ei(C, Nr(h), {
            labelFetcher: s.hostModel,
            labelDataIndex: p,
            labelDimIndex: C.__dimIdx,
            defaultText: D,
            inheritColor: b,
            defaultOpacity: y.opacity
          });
        }), er(f, w.get("focus"), w.get("blurScope"), w.get("disabled"));
      }), this._data = s;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "radar", e;
  }(Tn)
), OBe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new ny(Ze(this.getData, this), Ze(this.getRawData, this));
    }, e.prototype.getInitialData = function(t, r) {
      return wh(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, e.prototype.formatTooltip = function(t, r, i) {
      var a = this.getData(), o = this.coordinateSystem, s = o.getIndicatorAxes(), l = this.getData().getName(t), u = l === "" ? this.name : l, c = vW(this, t);
      return Rr("section", {
        header: u,
        sortBlocks: !0,
        blocks: De(s, function(d) {
          var f = a.get(a.mapDimension(d.dim), t);
          return Rr("nameValue", {
            markerType: "subItem",
            markerColor: c,
            name: d.name,
            value: f,
            sortParam: f
          });
        })
      });
    }, e.prototype.getTooltipPosition = function(t) {
      if (t != null) {
        for (var r = this.getData(), i = this.coordinateSystem, a = r.getValues(De(i.dimensions, function(u) {
          return r.mapDimension(u);
        }), t), o = 0, s = a.length; o < s; o++)
          if (!isNaN(a[o])) {
            var l = i.getIndicatorAxes();
            return i.coordToPoint(l[o].dataToCoord(a[o]), o);
          }
      }
    }, e.type = "series.radar", e.dependencies = ["radar"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: !0,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      // areaStyle: {
      // },
      // itemStyle: {}
      symbolSize: 8
      // symbolRotate: null
    }, e;
  }(Rn)
), dv = uY.value;
function B0(n, e) {
  return dt({
    show: e
  }, n);
}
var IBe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      var t = this.get("boundaryGap"), r = this.get("splitNumber"), i = this.get("scale"), a = this.get("axisLine"), o = this.get("axisTick"), s = this.get("axisLabel"), l = this.get("axisName"), u = this.get(["axisName", "show"]), c = this.get(["axisName", "formatter"]), d = this.get("axisNameGap"), f = this.get("triggerEvent"), p = De(this.get("indicator") || [], function(h) {
        h.max != null && h.max > 0 && !h.min ? h.min = 0 : h.min != null && h.min < 0 && !h.max && (h.max = 0);
        var v = l;
        h.color != null && (v = dt({
          color: h.color
        }, l));
        var m = At(ht(h), {
          boundaryGap: t,
          splitNumber: r,
          scale: i,
          axisLine: a,
          axisTick: o,
          // axisType: axisType,
          axisLabel: s,
          // Compatible with 2 and use text
          name: h.text,
          showName: u,
          nameLocation: "end",
          nameGap: d,
          // min: 0,
          nameTextStyle: v,
          triggerEvent: f
        }, !1);
        if (We(c)) {
          var g = m.name;
          m.name = c.replace("{value}", g ?? "");
        } else at(c) && (m.name = c(m.name, m));
        var y = new yn(m, null, this.ecModel);
        return _r(y, Xg.prototype), y.mainType = "radar", y.componentIndex = this.componentIndex, y;
      }, this);
      this._indicatorModels = p;
    }, e.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, e.type = "radar", e.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "75%",
      startAngle: 90,
      axisName: {
        show: !0
        // formatter: null
        // textStyle: {}
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      axisNameGap: 15,
      scale: !1,
      // Polygon or circle
      shape: "polygon",
      axisLine: At({
        lineStyle: {
          color: "#bbb"
        }
      }, dv.axisLine),
      axisLabel: B0(dv.axisLabel, !1),
      axisTick: B0(dv.axisTick, !1),
      // axisType: 'value',
      splitLine: B0(dv.splitLine, !0),
      splitArea: B0(dv.splitArea, !0),
      // {text, min, max}
      indicator: []
    }, e;
  }(Ut)
), LBe = ["axisLine", "axisTickLabel", "axisName"], NBe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = this.group;
      a.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t);
    }, e.prototype._buildAxes = function(t) {
      var r = t.coordinateSystem, i = r.getIndicatorAxes(), a = De(i, function(o) {
        var s = o.model.get("showName") ? o.name : "", l = new Ii(o.model, {
          axisName: s,
          position: [r.cx, r.cy],
          rotation: o.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return l;
      });
      $(a, function(o) {
        $(LBe, o.add, o), this.group.add(o.getGroup());
      }, this);
    }, e.prototype._buildSplitLineAndArea = function(t) {
      var r = t.coordinateSystem, i = r.getIndicatorAxes();
      if (!i.length)
        return;
      var a = t.get("shape"), o = t.getModel("splitLine"), s = t.getModel("splitArea"), l = o.getModel("lineStyle"), u = s.getModel("areaStyle"), c = o.get("show"), d = s.get("show"), f = l.get("color"), p = u.get("color"), h = Me(f) ? f : [f], v = Me(p) ? p : [p], m = [], g = [];
      function y(z, F, B) {
        var H = B % F.length;
        return z[H] = z[H] || [], H;
      }
      if (a === "circle")
        for (var b = i[0].getTicksCoords(), _ = r.cx, x = r.cy, w = 0; w < b.length; w++) {
          if (c) {
            var S = y(m, h, w);
            m[S].push(new Ml({
              shape: {
                cx: _,
                cy: x,
                r: b[w].coord
              }
            }));
          }
          if (d && w < b.length - 1) {
            var S = y(g, v, w);
            g[S].push(new Hg({
              shape: {
                cx: _,
                cy: x,
                r0: b[w].coord,
                r: b[w + 1].coord
              }
            }));
          }
        }
      else
        for (var C, k = De(i, function(z, F) {
          var B = z.getTicksCoords();
          return C = C == null ? B.length - 1 : Math.min(B.length - 1, C), De(B, function(H) {
            return r.coordToPoint(H.coord, F);
          });
        }), M = [], w = 0; w <= C; w++) {
          for (var D = [], N = 0; N < i.length; N++)
            D.push(k[N][w]);
          if (D[0] ? D.push(D[0].slice()) : process.env.NODE_ENV !== "production" && console.error("Can't draw value axis " + w), c) {
            var S = y(m, h, w);
            m[S].push(new Hi({
              shape: {
                points: D
              }
            }));
          }
          if (d && M) {
            var S = y(g, v, w - 1);
            g[S].push(new Vi({
              shape: {
                points: D.concat(M)
              }
            }));
          }
          M = D.slice().reverse();
        }
      var R = l.getLineStyle(), j = u.getAreaStyle();
      $(g, function(z, F) {
        this.group.add(Wa(z, {
          style: dt({
            stroke: "none",
            fill: v[F % v.length]
          }, j),
          silent: !0
        }));
      }, this), $(m, function(z, F) {
        this.group.add(Wa(z, {
          style: dt({
            fill: "none",
            stroke: h[F % h.length]
          }, R),
          silent: !0
        }));
      }, this);
    }, e.type = "radar", e;
  }(Yn)
), RBe = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i) {
      var a = n.call(this, t, r, i) || this;
      return a.type = "value", a.angle = 0, a.name = "", a;
    }
    return e;
  }(Po)
), PBe = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.dimensions = [], this._model = e, this._indicatorAxes = De(e.getIndicatorModels(), function(i, a) {
        var o = "indicator_" + a, s = new RBe(
          o,
          new El()
          // (indicatorModel.get('axisType') === 'log') ? new LogScale() : new IntervalScale()
        );
        return s.name = i.get("name"), s.model = i, i.axis = s, this.dimensions.push(o), s;
      }, this), this.resize(e, r);
    }
    return n.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, n.prototype.dataToPoint = function(e, t) {
      var r = this._indicatorAxes[t];
      return this.coordToPoint(r.dataToCoord(e), t);
    }, n.prototype.coordToPoint = function(e, t) {
      var r = this._indicatorAxes[t], i = r.angle, a = this.cx + e * Math.cos(i), o = this.cy - e * Math.sin(i);
      return [a, o];
    }, n.prototype.pointToData = function(e) {
      var t = e[0] - this.cx, r = e[1] - this.cy, i = Math.sqrt(t * t + r * r);
      t /= i, r /= i;
      for (var a = Math.atan2(-r, t), o = 1 / 0, s, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
        var c = this._indicatorAxes[u], d = Math.abs(a - c.angle);
        d < o && (s = c, l = u, o = d);
      }
      return [l, +(s && s.coordToData(i))];
    }, n.prototype.resize = function(e, t) {
      var r = e.get("center"), i = t.getWidth(), a = t.getHeight(), o = Math.min(i, a) / 2;
      this.cx = ze(r[0], i), this.cy = ze(r[1], a), this.startAngle = e.get("startAngle") * Math.PI / 180;
      var s = e.get("radius");
      (We(s) || sn(s)) && (s = [0, s]), this.r0 = ze(s[0], o), this.r = ze(s[1], o), $(this._indicatorAxes, function(l, u) {
        l.setExtent(this.r0, this.r);
        var c = this.startAngle + u * Math.PI * 2 / this._indicatorAxes.length;
        c = Math.atan2(Math.sin(c), Math.cos(c)), l.angle = c;
      }, this);
    }, n.prototype.update = function(e, t) {
      var r = this._indicatorAxes, i = this._model;
      $(r, function(s) {
        s.scale.setExtent(1 / 0, -1 / 0);
      }), e.eachSeriesByType("radar", function(s, l) {
        if (!(s.get("coordinateSystem") !== "radar" || e.getComponent("radar", s.get("radarIndex")) !== i)) {
          var u = s.getData();
          $(r, function(c) {
            c.scale.unionExtentFromData(u, u.mapDimension(c.dim));
          });
        }
      }, this);
      var a = i.get("splitNumber"), o = new El();
      o.setExtent(0, a), o.setInterval(1), $(r, function(s, l) {
        cY(s.scale, s.model, o);
      });
    }, n.prototype.convertToPixel = function(e, t, r) {
      return console.warn("Not implemented."), null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      return console.warn("Not implemented."), null;
    }, n.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), !1;
    }, n.create = function(e, t) {
      var r = [];
      return e.eachComponent("radar", function(i) {
        var a = new n(i, e, t);
        r.push(a), i.coordinateSystem = a;
      }), e.eachSeriesByType("radar", function(i) {
        i.get("coordinateSystem") === "radar" && (i.coordinateSystem = r[i.get("radarIndex") || 0]);
      }), r;
    }, n.dimensions = [], n;
  }()
);
function jBe(n) {
  n.registerCoordinateSystem("radar", PBe), n.registerComponentModel(IBe), n.registerComponentView(NBe), n.registerVisual({
    seriesType: "radar",
    reset: function(e) {
      var t = e.getData();
      t.each(function(r) {
        t.setItemVisual(r, "legendIcon", "roundRect");
      }), t.setVisual("legendIcon", "roundRect");
    }
  });
}
function BBe(n) {
  $t(jBe), n.registerChartView(DBe), n.registerSeriesModel(OBe), n.registerLayout(ABe), n.registerProcessor(ty("radar")), n.registerPreprocessor(MBe);
}
var jB = "\0_ec_interaction_mutex";
function $Be(n, e, t) {
  var r = DO(n);
  r[e] = t;
}
function zBe(n, e, t) {
  var r = DO(n), i = r[e];
  i === t && (r[e] = null);
}
function BB(n, e) {
  return !!DO(n)[e];
}
function DO(n) {
  return n[jB] || (n[jB] = {});
}
Ds({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, dr);
var ry = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this) || this;
      r._zr = t;
      var i = Ze(r._mousedownHandler, r), a = Ze(r._mousemoveHandler, r), o = Ze(r._mouseupHandler, r), s = Ze(r._mousewheelHandler, r), l = Ze(r._pinchHandler, r);
      return r.enable = function(u, c) {
        this.disable(), this._opt = dt(ht(c) || {}, {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0
        }), u == null && (u = !0), (u === !0 || u === "move" || u === "pan") && (t.on("mousedown", i), t.on("mousemove", a), t.on("mouseup", o)), (u === !0 || u === "scale" || u === "zoom") && (t.on("mousewheel", s), t.on("pinch", l));
      }, r.disable = function() {
        t.off("mousedown", i), t.off("mousemove", a), t.off("mouseup", o), t.off("mousewheel", s), t.off("pinch", l);
      }, r;
    }
    return e.prototype.isDragging = function() {
      return this._dragging;
    }, e.prototype.isPinching = function() {
      return this._pinching;
    }, e.prototype.setPointerChecker = function(t) {
      this.pointerChecker = t;
    }, e.prototype.dispose = function() {
      this.disable();
    }, e.prototype._mousedownHandler = function(t) {
      if (!l3(t)) {
        for (var r = t.target; r; ) {
          if (r.draggable)
            return;
          r = r.__hostTarget || r.parent;
        }
        var i = t.offsetX, a = t.offsetY;
        this.pointerChecker && this.pointerChecker(t, i, a) && (this._x = i, this._y = a, this._dragging = !0);
      }
    }, e.prototype._mousemoveHandler = function(t) {
      if (!(!this._dragging || !O1("moveOnMouseMove", t, this._opt) || t.gestureEvent === "pinch" || BB(this._zr, "globalPan"))) {
        var r = t.offsetX, i = t.offsetY, a = this._x, o = this._y, s = r - a, l = i - o;
        this._x = r, this._y = i, this._opt.preventDefaultMouseMove && bl(t.event), gY(this, "pan", "moveOnMouseMove", t, {
          dx: s,
          dy: l,
          oldX: a,
          oldY: o,
          newX: r,
          newY: i,
          isAvailableBehavior: null
        });
      }
    }, e.prototype._mouseupHandler = function(t) {
      l3(t) || (this._dragging = !1);
    }, e.prototype._mousewheelHandler = function(t) {
      var r = O1("zoomOnMouseWheel", t, this._opt), i = O1("moveOnMouseWheel", t, this._opt), a = t.wheelDelta, o = Math.abs(a), s = t.offsetX, l = t.offsetY;
      if (!(a === 0 || !r && !i)) {
        if (r) {
          var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, c = a > 0 ? u : 1 / u;
          vE(this, "zoom", "zoomOnMouseWheel", t, {
            scale: c,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
        if (i) {
          var d = Math.abs(a), f = (a > 0 ? 1 : -1) * (d > 3 ? 0.4 : d > 1 ? 0.15 : 0.05);
          vE(this, "scrollMove", "moveOnMouseWheel", t, {
            scrollDelta: f,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
      }
    }, e.prototype._pinchHandler = function(t) {
      if (!BB(this._zr, "globalPan")) {
        var r = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
        vE(this, "zoom", null, t, {
          scale: r,
          originX: t.pinchX,
          originY: t.pinchY,
          isAvailableBehavior: null
        });
      }
    }, e;
  }(io)
);
function vE(n, e, t, r, i) {
  n.pointerChecker && n.pointerChecker(r, i.originX, i.originY) && (bl(r.event), gY(n, e, t, r, i));
}
function gY(n, e, t, r, i) {
  i.isAvailableBehavior = Ze(O1, null, t, r), n.trigger(e, i);
}
function O1(n, e, t) {
  var r = t[n];
  return !n || r && (!We(r) || e.event[r + "Key"]);
}
function OO(n, e, t) {
  var r = n.target;
  r.x += e, r.y += t, r.dirty();
}
function IO(n, e, t, r) {
  var i = n.target, a = n.zoomLimit, o = n.zoom = n.zoom || 1;
  if (o *= e, a) {
    var s = a.min || 0, l = a.max || 1 / 0;
    o = Math.max(Math.min(l, o), s);
  }
  var u = o / n.zoom;
  n.zoom = o, i.x -= (t - i.x) * (u - 1), i.y -= (r - i.y) * (u - 1), i.scaleX *= u, i.scaleY *= u, i.dirty();
}
var FBe = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function Tw(n, e, t) {
  var r = e.getComponentByElement(n.topTarget), i = r && r.coordinateSystem;
  return r && r !== t && !FBe.hasOwnProperty(r.mainType) && i && i.model !== t;
}
function yY(n) {
  if (We(n)) {
    var e = new DOMParser();
    n = e.parseFromString(n, "text/xml");
  }
  var t = n;
  for (t.nodeType === 9 && (t = t.firstChild); t.nodeName.toLowerCase() !== "svg" || t.nodeType !== 1; )
    t = t.nextSibling;
  return t;
}
var mE, w_ = {
  fill: "fill",
  stroke: "stroke",
  "stroke-width": "lineWidth",
  opacity: "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  visibility: "visibility",
  display: "display"
}, $B = Yt(w_), S_ = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
}, zB = Yt(S_), VBe = function() {
  function n() {
    this._defs = {}, this._root = null;
  }
  return n.prototype.parse = function(e, t) {
    t = t || {};
    var r = yY(e);
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("Illegal svg");
    this._defsUsePending = [];
    var i = new mt();
    this._root = i;
    var a = [], o = r.getAttribute("viewBox") || "", s = parseFloat(r.getAttribute("width") || t.width), l = parseFloat(r.getAttribute("height") || t.height);
    isNaN(s) && (s = null), isNaN(l) && (l = null), oa(r, i, null, !0, !1);
    for (var u = r.firstChild; u; )
      this._parseNode(u, i, a, null, !1, !1), u = u.nextSibling;
    UBe(this._defs, this._defsUsePending), this._defsUsePending = [];
    var c, d;
    if (o) {
      var f = Cw(o);
      f.length >= 4 && (c = {
        x: parseFloat(f[0] || 0),
        y: parseFloat(f[1] || 0),
        width: parseFloat(f[2]),
        height: parseFloat(f[3])
      });
    }
    if (c && s != null && l != null && (d = _Y(c, { x: 0, y: 0, width: s, height: l }), !t.ignoreViewBox)) {
      var p = i;
      i = new mt(), i.add(p), p.scaleX = p.scaleY = d.scale, p.x = d.x, p.y = d.y;
    }
    return !t.ignoreRootClip && s != null && l != null && i.setClipPath(new Qt({
      shape: { x: 0, y: 0, width: s, height: l }
    })), {
      root: i,
      width: s,
      height: l,
      viewBoxRect: c,
      viewBoxTransform: d,
      named: a
    };
  }, n.prototype._parseNode = function(e, t, r, i, a, o) {
    var s = e.nodeName.toLowerCase(), l, u = i;
    if (s === "defs" && (a = !0), s === "text" && (o = !0), s === "defs" || s === "switch")
      l = t;
    else {
      if (!a) {
        var c = mE[s];
        if (c && Je(mE, s)) {
          l = c.call(this, e, t);
          var d = e.getAttribute("name");
          if (d) {
            var f = {
              name: d,
              namedFrom: null,
              svgNodeTagLower: s,
              el: l
            };
            r.push(f), s === "g" && (u = f);
          } else i && r.push({
            name: i.name,
            namedFrom: i,
            svgNodeTagLower: s,
            el: l
          });
          t.add(l);
        }
      }
      var p = FB[s];
      if (p && Je(FB, s)) {
        var h = p.call(this, e), v = e.getAttribute("id");
        v && (this._defs[v] = h);
      }
    }
    if (l && l.isGroup)
      for (var m = e.firstChild; m; )
        m.nodeType === 1 ? this._parseNode(m, l, r, u, a, o) : m.nodeType === 3 && o && this._parseText(m, l), m = m.nextSibling;
  }, n.prototype._parseText = function(e, t) {
    var r = new zp({
      style: {
        text: e.textContent
      },
      silent: !0,
      x: this._textX || 0,
      y: this._textY || 0
    });
    Ia(t, r), oa(e, r, this._defsUsePending, !1, !1), HBe(r, t);
    var i = r.style, a = i.fontSize;
    a && a < 9 && (i.fontSize = 9, r.scaleX *= a / 9, r.scaleY *= a / 9);
    var o = (i.fontSize || i.fontFamily) && [
      i.fontStyle,
      i.fontWeight,
      (i.fontSize || 12) + "px",
      i.fontFamily || "sans-serif"
    ].join(" ");
    i.font = o;
    var s = r.getBoundingRect();
    return this._textX += s.width, t.add(r), r;
  }, n.internalField = function() {
    mE = {
      g: function(e, t) {
        var r = new mt();
        return Ia(t, r), oa(e, r, this._defsUsePending, !1, !1), r;
      },
      rect: function(e, t) {
        var r = new Qt();
        return Ia(t, r), oa(e, r, this._defsUsePending, !1, !1), r.setShape({
          x: parseFloat(e.getAttribute("x") || "0"),
          y: parseFloat(e.getAttribute("y") || "0"),
          width: parseFloat(e.getAttribute("width") || "0"),
          height: parseFloat(e.getAttribute("height") || "0")
        }), r.silent = !0, r;
      },
      circle: function(e, t) {
        var r = new Ml();
        return Ia(t, r), oa(e, r, this._defsUsePending, !1, !1), r.setShape({
          cx: parseFloat(e.getAttribute("cx") || "0"),
          cy: parseFloat(e.getAttribute("cy") || "0"),
          r: parseFloat(e.getAttribute("r") || "0")
        }), r.silent = !0, r;
      },
      line: function(e, t) {
        var r = new Dr();
        return Ia(t, r), oa(e, r, this._defsUsePending, !1, !1), r.setShape({
          x1: parseFloat(e.getAttribute("x1") || "0"),
          y1: parseFloat(e.getAttribute("y1") || "0"),
          x2: parseFloat(e.getAttribute("x2") || "0"),
          y2: parseFloat(e.getAttribute("y2") || "0")
        }), r.silent = !0, r;
      },
      ellipse: function(e, t) {
        var r = new iw();
        return Ia(t, r), oa(e, r, this._defsUsePending, !1, !1), r.setShape({
          cx: parseFloat(e.getAttribute("cx") || "0"),
          cy: parseFloat(e.getAttribute("cy") || "0"),
          rx: parseFloat(e.getAttribute("rx") || "0"),
          ry: parseFloat(e.getAttribute("ry") || "0")
        }), r.silent = !0, r;
      },
      polygon: function(e, t) {
        var r = e.getAttribute("points"), i;
        r && (i = GB(r));
        var a = new Vi({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return Ia(t, a), oa(e, a, this._defsUsePending, !1, !1), a;
      },
      polyline: function(e, t) {
        var r = e.getAttribute("points"), i;
        r && (i = GB(r));
        var a = new Hi({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return Ia(t, a), oa(e, a, this._defsUsePending, !1, !1), a;
      },
      image: function(e, t) {
        var r = new Ur();
        return Ia(t, r), oa(e, r, this._defsUsePending, !1, !1), r.setStyle({
          image: e.getAttribute("xlink:href") || e.getAttribute("href"),
          x: +e.getAttribute("x"),
          y: +e.getAttribute("y"),
          width: +e.getAttribute("width"),
          height: +e.getAttribute("height")
        }), r.silent = !0, r;
      },
      text: function(e, t) {
        var r = e.getAttribute("x") || "0", i = e.getAttribute("y") || "0", a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0";
        this._textX = parseFloat(r) + parseFloat(a), this._textY = parseFloat(i) + parseFloat(o);
        var s = new mt();
        return Ia(t, s), oa(e, s, this._defsUsePending, !1, !0), s;
      },
      tspan: function(e, t) {
        var r = e.getAttribute("x"), i = e.getAttribute("y");
        r != null && (this._textX = parseFloat(r)), i != null && (this._textY = parseFloat(i));
        var a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0", s = new mt();
        return Ia(t, s), oa(e, s, this._defsUsePending, !1, !0), this._textX += parseFloat(a), this._textY += parseFloat(o), s;
      },
      path: function(e, t) {
        var r = e.getAttribute("d") || "", i = cU(r);
        return Ia(t, i), oa(e, i, this._defsUsePending, !1, !1), i.silent = !0, i;
      }
    };
  }(), n;
}(), FB = {
  lineargradient: function(n) {
    var e = parseInt(n.getAttribute("x1") || "0", 10), t = parseInt(n.getAttribute("y1") || "0", 10), r = parseInt(n.getAttribute("x2") || "10", 10), i = parseInt(n.getAttribute("y2") || "0", 10), a = new Ug(e, t, r, i);
    return VB(n, a), HB(n, a), a;
  },
  radialgradient: function(n) {
    var e = parseInt(n.getAttribute("cx") || "0", 10), t = parseInt(n.getAttribute("cy") || "0", 10), r = parseInt(n.getAttribute("r") || "0", 10), i = new hU(e, t, r);
    return VB(n, i), HB(n, i), i;
  }
};
function VB(n, e) {
  var t = n.getAttribute("gradientUnits");
  t === "userSpaceOnUse" && (e.global = !0);
}
function HB(n, e) {
  for (var t = n.firstChild; t; ) {
    if (t.nodeType === 1 && t.nodeName.toLocaleLowerCase() === "stop") {
      var r = t.getAttribute("offset"), i = void 0;
      r && r.indexOf("%") > 0 ? i = parseInt(r, 10) / 100 : r ? i = parseFloat(r) : i = 0;
      var a = {};
      bY(t, a, a);
      var o = a.stopColor || t.getAttribute("stop-color") || "#000000";
      e.colorStops.push({
        offset: i,
        color: o
      });
    }
    t = t.nextSibling;
  }
}
function Ia(n, e) {
  n && n.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), dt(e.__inheritedStyle, n.__inheritedStyle));
}
function GB(n) {
  for (var e = Cw(n), t = [], r = 0; r < e.length; r += 2) {
    var i = parseFloat(e[r]), a = parseFloat(e[r + 1]);
    t.push([i, a]);
  }
  return t;
}
function oa(n, e, t, r, i) {
  var a = e, o = a.__inheritedStyle = a.__inheritedStyle || {}, s = {};
  n.nodeType === 1 && (YBe(n, e), bY(n, o, s), r || KBe(n, o, s)), a.style = a.style || {}, o.fill != null && (a.style.fill = UB(a, "fill", o.fill, t)), o.stroke != null && (a.style.stroke = UB(a, "stroke", o.stroke, t)), $([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(l) {
    o[l] != null && (a.style[l] = parseFloat(o[l]));
  }), $([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(l) {
    o[l] != null && (a.style[l] = o[l]);
  }), i && (a.__selfStyle = s), o.lineDash && (a.style.lineDash = De(Cw(o.lineDash), function(l) {
    return parseFloat(l);
  })), (o.visibility === "hidden" || o.visibility === "collapse") && (a.invisible = !0), o.display === "none" && (a.ignore = !0);
}
function HBe(n, e) {
  var t = e.__selfStyle;
  if (t) {
    var r = t.textBaseline, i = r;
    !r || r === "auto" || r === "baseline" ? i = "alphabetic" : r === "before-edge" || r === "text-before-edge" ? i = "top" : r === "after-edge" || r === "text-after-edge" ? i = "bottom" : (r === "central" || r === "mathematical") && (i = "middle"), n.style.textBaseline = i;
  }
  var a = e.__inheritedStyle;
  if (a) {
    var o = a.textAlign, s = o;
    o && (o === "middle" && (s = "center"), n.style.textAlign = s);
  }
}
var GBe = /^url\(\s*#(.*?)\)/;
function UB(n, e, t, r) {
  var i = t && t.match(GBe);
  if (i) {
    var a = yo(i[1]);
    r.push([n, e, a]);
    return;
  }
  return t === "none" && (t = null), t;
}
function UBe(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    r[0].style[r[1]] = n[r[2]];
  }
}
var WBe = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function Cw(n) {
  return n.match(WBe) || [];
}
var qBe = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, gE = Math.PI / 180;
function YBe(n, e) {
  var t = n.getAttribute("transform");
  if (t) {
    t = t.replace(/,/g, " ");
    var r = [], i = null;
    t.replace(qBe, function(d, f, p) {
      return r.push(f, p), "";
    });
    for (var a = r.length - 1; a > 0; a -= 2) {
      var o = r[a], s = r[a - 1], l = Cw(o);
      switch (i = i || ya(), s) {
        case "translate":
          ws(i, i, [parseFloat(l[0]), parseFloat(l[1] || "0")]);
          break;
        case "scale":
          kD(i, i, [parseFloat(l[0]), parseFloat(l[1] || l[0])]);
          break;
        case "rotate":
          Zd(i, i, -parseFloat(l[0]) * gE, [
            parseFloat(l[1] || "0"),
            parseFloat(l[2] || "0")
          ]);
          break;
        case "skewX":
          var u = Math.tan(parseFloat(l[0]) * gE);
          cl(i, [1, 0, u, 1, 0, 0], i);
          break;
        case "skewY":
          var c = Math.tan(parseFloat(l[0]) * gE);
          cl(i, [1, c, 0, 1, 0, 0], i);
          break;
        case "matrix":
          i[0] = parseFloat(l[0]), i[1] = parseFloat(l[1]), i[2] = parseFloat(l[2]), i[3] = parseFloat(l[3]), i[4] = parseFloat(l[4]), i[5] = parseFloat(l[5]);
          break;
      }
    }
    e.setLocalTransform(i);
  }
}
var WB = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function bY(n, e, t) {
  var r = n.getAttribute("style");
  if (r) {
    WB.lastIndex = 0;
    for (var i; (i = WB.exec(r)) != null; ) {
      var a = i[1], o = Je(w_, a) ? w_[a] : null;
      o && (e[o] = i[2]);
      var s = Je(S_, a) ? S_[a] : null;
      s && (t[s] = i[2]);
    }
  }
}
function KBe(n, e, t) {
  for (var r = 0; r < $B.length; r++) {
    var i = $B[r], a = n.getAttribute(i);
    a != null && (e[w_[i]] = a);
  }
  for (var r = 0; r < zB.length; r++) {
    var i = zB[r], a = n.getAttribute(i);
    a != null && (t[S_[i]] = a);
  }
}
function _Y(n, e) {
  var t = e.width / n.width, r = e.height / n.height, i = Math.min(t, r);
  return {
    scale: i,
    x: -(n.x + n.width / 2) * i + (e.x + e.width / 2),
    y: -(n.y + n.height / 2) * i + (e.y + e.height / 2)
  };
}
function XBe(n, e) {
  var t = new VBe();
  return t.parse(n, e);
}
var ZBe = tt([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  // <text> <tspan> are also enabled because some SVG might paint text itself,
  // but still need to trigger events or tooltip.
  "text",
  "tspan",
  // <g> is also enabled because this case: if multiple tags share one name
  // and need label displayed, every tags will display the name, which is not
  // expected. So we can put them into a <g name="xxx">. Thereby only one label
  // displayed and located based on the bounding rect of the <g>.
  "g"
]), JBe = (
  /** @class */
  function() {
    function n(e, t) {
      this.type = "geoSVG", this._usedGraphicMap = tt(), this._freedGraphics = [], this._mapName = e, this._parsedXML = yY(t);
    }
    return n.prototype.load = function() {
      var e = this._firstGraphic;
      if (!e) {
        e = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(e), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var t = e4e(e.named), r = t.regions, i = t.regionsMap;
        this._regions = r, this._regionsMap = i;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, n.prototype._buildGraphic = function(e) {
      var t, r;
      try {
        t = e && XBe(e, {
          ignoreViewBox: !0,
          ignoreRootClip: !0
        }) || {}, r = t.root, ct(r != null);
      } catch (m) {
        throw new Error(`Invalid svg format
` + m.message);
      }
      var i = new mt();
      i.add(r), i.isGeoSVGGraphicRoot = !0;
      var a = t.width, o = t.height, s = t.viewBoxRect, l = this._boundingRect;
      if (!l) {
        var u = void 0, c = void 0, d = void 0, f = void 0;
        if (a != null ? (u = 0, d = a) : s && (u = s.x, d = s.width), o != null ? (c = 0, f = o) : s && (c = s.y, f = s.height), u == null || c == null) {
          var p = r.getBoundingRect();
          u == null && (u = p.x, d = p.width), c == null && (c = p.y, f = p.height);
        }
        l = this._boundingRect = new Ot(u, c, d, f);
      }
      if (s) {
        var h = _Y(s, l);
        r.scaleX = r.scaleY = h.scale, r.x = h.x, r.y = h.y;
      }
      i.setClipPath(new Qt({
        shape: l.plain()
      }));
      var v = [];
      return $(t.named, function(m) {
        ZBe.get(m.svgNodeTagLower) != null && (v.push(m), QBe(m.el));
      }), {
        root: i,
        boundingRect: l,
        named: v
      };
    }, n.prototype.useGraphic = function(e) {
      var t = this._usedGraphicMap, r = t.get(e);
      return r || (r = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), t.set(e, r), r);
    }, n.prototype.freeGraphic = function(e) {
      var t = this._usedGraphicMap, r = t.get(e);
      r && (t.removeKey(e), this._freedGraphics.push(r));
    }, n;
  }()
);
function QBe(n) {
  n.silent = !1, n.isGroup && n.traverse(function(e) {
    e.silent = !1;
  });
}
function e4e(n) {
  var e = [], t = tt();
  return $(n, function(r) {
    if (r.namedFrom == null) {
      var i = new Y3e(r.name, r.el);
      e.push(i), t.set(r.name, i);
    }
  }), {
    regions: e,
    regionsMap: t
  };
}
var Wk = [126, 25], qB = "南海诸岛", Tc = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var wc = 0; wc < Tc.length; wc++)
  for (var Lf = 0; Lf < Tc[wc].length; Lf++)
    Tc[wc][Lf][0] /= 10.5, Tc[wc][Lf][1] /= -10.5 / 0.75, Tc[wc][Lf][0] += Wk[0], Tc[wc][Lf][1] += Wk[1];
function t4e(n, e) {
  if (n === "china") {
    for (var t = 0; t < e.length; t++)
      if (e[t].name === qB)
        return;
    e.push(new mq(qB, De(Tc, function(r) {
      return {
        type: "polygon",
        exterior: r
      };
    }), Wk));
  }
}
var n4e = {
  南海诸岛: [32, 80],
  // 全国
  广东: [0, -10],
  香港: [10, 5],
  澳门: [-10, 10],
  // '北京': [-10, 0],
  天津: [5, 5]
};
function r4e(n, e) {
  if (n === "china") {
    var t = n4e[e.name];
    if (t) {
      var r = e.getCenter();
      r[0] += t[0] / 10.5, r[1] += -t[1] / (10.5 / 0.75), e.setCenter(r);
    }
  }
}
var i4e = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function a4e(n, e) {
  n === "china" && e.name === "台湾" && e.geometries.push({
    type: "polygon",
    exterior: i4e[0]
  });
}
var o4e = "name", s4e = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.type = "geoJSON", this._parsedMap = tt(), this._mapName = e, this._specialAreas = r, this._geoJSON = u4e(t);
    }
    return n.prototype.load = function(e, t) {
      t = t || o4e;
      var r = this._parsedMap.get(t);
      if (!r) {
        var i = this._parseToRegions(t);
        r = this._parsedMap.set(t, {
          regions: i,
          boundingRect: l4e(i)
        });
      }
      var a = tt(), o = [];
      return $(r.regions, function(s) {
        var l = s.name;
        e && Je(e, l) && (s = s.cloneShallow(l = e[l])), o.push(s), a.set(l, s);
      }), {
        regions: o,
        boundingRect: r.boundingRect || new Ot(0, 0, 0, 0),
        regionsMap: a
      };
    }, n.prototype._parseToRegions = function(e) {
      var t = this._mapName, r = this._geoJSON, i;
      try {
        i = r ? X3e(r, e) : [];
      } catch (a) {
        throw new Error(`Invalid geoJson format
` + a.message);
      }
      return t4e(t, i), $(i, function(a) {
        var o = a.name;
        r4e(t, a), a4e(t, a);
        var s = this._specialAreas && this._specialAreas[o];
        s && a.transformTo(s.left, s.top, s.width, s.height);
      }, this), i;
    }, n.prototype.getMapForUser = function() {
      return {
        // For backward compatibility, use geoJson
        // PENDING: it has been returning them without clone.
        // do we need to avoid outsite modification?
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, n;
  }()
);
function l4e(n) {
  for (var e, t = 0; t < n.length; t++) {
    var r = n[t].getBoundingRect();
    e = e || r.clone(), e.union(r);
  }
  return e;
}
function u4e(n) {
  return We(n) ? typeof JSON < "u" && JSON.parse ? JSON.parse(n) : new Function("return (" + n + ");")() : n;
}
var fv = tt();
const Tl = {
  /**
   * Compatible with previous `echarts.registerMap`.
   *
   * @usage
   * ```js
   *
   * echarts.registerMap('USA', geoJson, specialAreas);
   *
   * echarts.registerMap('USA', {
   *     geoJson: geoJson,
   *     specialAreas: {...}
   * });
   * echarts.registerMap('USA', {
   *     geoJSON: geoJson,
   *     specialAreas: {...}
   * });
   *
   * echarts.registerMap('airport', {
   *     svg: svg
   * }
   * ```
   *
   * Note:
   * Do not support that register multiple geoJSON or SVG
   * one map name. Because different geoJSON and SVG have
   * different unit. It's not easy to make sure how those
   * units are mapping/normalize.
   * If intending to use multiple geoJSON or SVG, we can
   * use multiple geo coordinate system.
   */
  registerMap: function(n, e, t) {
    if (e.svg) {
      var r = new JBe(n, e.svg);
      fv.set(n, r);
    } else {
      var i = e.geoJson || e.geoJSON;
      i && !e.features ? t = e.specialAreas : i = e;
      var r = new s4e(n, i, t);
      fv.set(n, r);
    }
  },
  getGeoResource: function(n) {
    return fv.get(n);
  },
  /**
   * Only for exporting to users.
   * **MUST NOT** used internally.
   */
  getMapForUser: function(n) {
    var e = fv.get(n);
    return e && e.type === "geoJSON" && e.getMapForUser();
  },
  load: function(n, e, t) {
    var r = fv.get(n);
    if (!r) {
      process.env.NODE_ENV !== "production" && console.error("Map " + n + " not exists. The GeoJSON of the map must be provided.");
      return;
    }
    return r.load(e, t);
  }
};
var LO = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], c4e = tt(LO), d4e = tt(LO.concat(["g"])), f4e = tt(LO.concat(["g"])), xY = en();
function $0(n) {
  var e = n.getItemStyle(), t = n.get("areaColor");
  return t != null && (e.fill = t), e;
}
function YB(n) {
  var e = n.style;
  e && (e.stroke = e.stroke || e.fill, e.fill = null);
}
var wY = (
  /** @class */
  function() {
    function n(e) {
      var t = new mt();
      this.uid = ph("ec_map_draw"), this._controller = new ry(e.getZr()), this._controllerHost = {
        target: t
      }, this.group = t, t.add(this._regionsGroup = new mt()), t.add(this._svgGroup = new mt());
    }
    return n.prototype.draw = function(e, t, r, i, a) {
      var o = e.mainType === "geo", s = e.getData && e.getData();
      o && t.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(g) {
        !s && g.getHostGeoModel() === e && (s = g.getData());
      });
      var l = e.coordinateSystem, u = this._regionsGroup, c = this.group, d = l.getTransformInfo(), f = d.raw, p = d.roam, h = !u.childAt(0) || a;
      h ? (c.x = p.x, c.y = p.y, c.scaleX = p.scaleX, c.scaleY = p.scaleY, c.dirty()) : ln(c, p, e);
      var v = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, m = {
        api: r,
        geo: l,
        mapOrGeoModel: e,
        data: s,
        isVisualEncodedByVisualMap: v,
        isGeo: o,
        transformInfoRaw: f
      };
      l.resourceType === "geoJSON" ? this._buildGeoJSON(m) : l.resourceType === "geoSVG" && this._buildSVG(m), this._updateController(e, t, r), this._updateMapSelectHandler(e, u, r, i);
    }, n.prototype._buildGeoJSON = function(e) {
      var t = this._regionsGroupByName = tt(), r = tt(), i = this._regionsGroup, a = e.transformInfoRaw, o = e.mapOrGeoModel, s = e.data, l = e.geo.projection, u = l && l.stream;
      function c(p, h) {
        return h && (p = h(p)), p && [p[0] * a.scaleX + a.x, p[1] * a.scaleY + a.y];
      }
      function d(p) {
        for (var h = [], v = !u && l && l.project, m = 0; m < p.length; ++m) {
          var g = c(p[m], v);
          g && h.push(g);
        }
        return h;
      }
      function f(p) {
        return {
          shape: {
            points: d(p)
          }
        };
      }
      i.removeAll(), $(e.geo.regions, function(p) {
        var h = p.name, v = t.get(h), m = r.get(h) || {}, g = m.dataIdx, y = m.regionModel;
        if (!v) {
          v = t.set(h, new mt()), i.add(v), g = s ? s.indexOfName(h) : null, y = e.isGeo ? o.getRegionModel(h) : s ? s.getItemModel(g) : null;
          var b = y.get("silent", !0);
          b != null && (v.silent = b), r.set(h, {
            dataIdx: g,
            regionModel: y
          });
        }
        var _ = [], x = [];
        $(p.geometries, function(C) {
          if (C.type === "polygon") {
            var k = [C.exterior].concat(C.interiors || []);
            u && (k = e4(k, u)), $(k, function(D) {
              _.push(new Vi(f(D)));
            });
          } else {
            var M = C.points;
            u && (M = e4(M, u, !0)), $(M, function(D) {
              x.push(new Hi(f(D)));
            });
          }
        });
        var w = c(p.getCenter(), l && l.project);
        function S(C, k) {
          if (C.length) {
            var M = new HD({
              culling: !0,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: C
              }
            });
            v.add(M), KB(e, M, g, y), XB(e, M, h, y, o, g, w), k && (YB(M), $(M.states, YB));
          }
        }
        S(_), S(x, !0);
      }), t.each(function(p, h) {
        var v = r.get(h), m = v.dataIdx, g = v.regionModel;
        ZB(e, p, h, g, o, m), JB(e, p, h, g, o), QB(e, p, h, g, o);
      }, this);
    }, n.prototype._buildSVG = function(e) {
      var t = e.geo.map, r = e.transformInfoRaw;
      this._svgGroup.x = r.x, this._svgGroup.y = r.y, this._svgGroup.scaleX = r.scaleX, this._svgGroup.scaleY = r.scaleY, this._svgResourceChanged(t) && (this._freeSVG(), this._useSVG(t));
      var i = this._svgDispatcherMap = tt(), a = !1;
      $(this._svgGraphicRecord.named, function(o) {
        var s = o.name, l = e.mapOrGeoModel, u = e.data, c = o.svgNodeTagLower, d = o.el, f = u ? u.indexOfName(s) : null, p = l.getRegionModel(s);
        c4e.get(c) != null && d instanceof no && KB(e, d, f, p), d instanceof no && (d.culling = !0);
        var h = p.get("silent", !0);
        if (h != null && (d.silent = h), d.z2EmphasisLift = 0, !o.namedFrom && (f4e.get(c) != null && XB(e, d, s, p, l, f, null), ZB(e, d, s, p, l, f), JB(e, d, s, p, l), d4e.get(c) != null)) {
          var v = QB(e, d, s, p, l);
          v === "self" && (a = !0);
          var m = i.get(s) || i.set(s, []);
          m.push(d);
        }
      }, this), this._enableBlurEntireSVG(a, e);
    }, n.prototype._enableBlurEntireSVG = function(e, t) {
      if (e && t.isGeo) {
        var r = t.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), i = r.opacity;
        this._svgGraphicRecord.root.traverse(function(a) {
          if (!a.isGroup) {
            Nd(a);
            var o = a.ensureState("blur").style || {};
            o.opacity == null && i != null && (o.opacity = i), a.ensureState("emphasis");
          }
        });
      }
    }, n.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, n.prototype.findHighDownDispatchers = function(e, t) {
      if (e == null)
        return [];
      var r = t.coordinateSystem;
      if (r.resourceType === "geoJSON") {
        var i = this._regionsGroupByName;
        if (i) {
          var a = i.get(e);
          return a ? [a] : [];
        }
      } else if (r.resourceType === "geoSVG")
        return this._svgDispatcherMap && this._svgDispatcherMap.get(e) || [];
    }, n.prototype._svgResourceChanged = function(e) {
      return this._svgMapName !== e;
    }, n.prototype._useSVG = function(e) {
      var t = Tl.getGeoResource(e);
      if (t && t.type === "geoSVG") {
        var r = t.useGraphic(this.uid);
        this._svgGroup.add(r.root), this._svgGraphicRecord = r, this._svgMapName = e;
      }
    }, n.prototype._freeSVG = function() {
      var e = this._svgMapName;
      if (e != null) {
        var t = Tl.getGeoResource(e);
        t && t.type === "geoSVG" && t.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, n.prototype._updateController = function(e, t, r) {
      var i = e.coordinateSystem, a = this._controller, o = this._controllerHost;
      o.zoomLimit = e.get("scaleLimit"), o.zoom = i.getZoom(), a.enable(e.get("roam") || !1);
      var s = e.mainType;
      function l() {
        var u = {
          type: "geoRoam",
          componentType: s
        };
        return u[s + "Id"] = e.id, u;
      }
      a.off("pan").on("pan", function(u) {
        this._mouseDownFlag = !1, OO(o, u.dx, u.dy), r.dispatchAction(xe(l(), {
          dx: u.dx,
          dy: u.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), a.off("zoom").on("zoom", function(u) {
        this._mouseDownFlag = !1, IO(o, u.scale, u.originX, u.originY), r.dispatchAction(xe(l(), {
          totalZoom: o.zoom,
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY,
          animation: {
            duration: 0
          }
        }));
      }, this), a.setPointerChecker(function(u, c, d) {
        return i.containPoint([c, d]) && !Tw(u, r, e);
      });
    }, n.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(e) {
        var t = e.getTextContent();
        t && (t.ignore = xY(t).ignore);
      });
    }, n.prototype._updateMapSelectHandler = function(e, t, r, i) {
      var a = this;
      t.off("mousedown"), t.off("click"), e.get("selectedMode") && (t.on("mousedown", function() {
        a._mouseDownFlag = !0;
      }), t.on("click", function(o) {
        a._mouseDownFlag && (a._mouseDownFlag = !1);
      }));
    }, n;
  }()
);
function KB(n, e, t, r) {
  var i = r.getModel("itemStyle"), a = r.getModel(["emphasis", "itemStyle"]), o = r.getModel(["blur", "itemStyle"]), s = r.getModel(["select", "itemStyle"]), l = $0(i), u = $0(a), c = $0(s), d = $0(o), f = n.data;
  if (f) {
    var p = f.getItemVisual(t, "style"), h = f.getItemVisual(t, "decal");
    n.isVisualEncodedByVisualMap && p.fill && (l.fill = p.fill), h && (l.decal = Hp(h, n.api));
  }
  e.setStyle(l), e.style.strokeNoScale = !0, e.ensureState("emphasis").style = u, e.ensureState("select").style = c, e.ensureState("blur").style = d, Nd(e);
}
function XB(n, e, t, r, i, a, o) {
  var s = n.data, l = n.isGeo, u = s && isNaN(s.get(s.mapDimension("value"), a)), c = s && s.getItemLayout(a);
  if (l || u || c && c.showLabel) {
    var d = l ? t : a, f = void 0;
    (!s || a >= 0) && (f = i);
    var p = o ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    ei(e, Nr(r), {
      labelFetcher: f,
      labelDataIndex: d,
      defaultText: t
    }, p);
    var h = e.getTextContent();
    if (h && (xY(h).ignore = h.ignore, e.textConfig && o)) {
      var v = e.getBoundingRect().clone();
      e.textConfig.layoutRect = v, e.textConfig.position = [(o[0] - v.x) / v.width * 100 + "%", (o[1] - v.y) / v.height * 100 + "%"];
    }
    e.disableLabelAnimation = !0;
  } else
    e.removeTextContent(), e.removeTextConfig(), e.disableLabelAnimation = null;
}
function ZB(n, e, t, r, i, a) {
  n.data ? n.data.setItemGraphicEl(a, e) : yt(e).eventData = {
    componentType: "geo",
    componentIndex: i.componentIndex,
    geoIndex: i.componentIndex,
    name: t,
    region: r && r.option || {}
  };
}
function JB(n, e, t, r, i) {
  n.data || Jd({
    el: e,
    componentModel: i,
    itemName: t,
    // @ts-ignore FIXME:TS fix the "compatible with each other"?
    itemTooltipOption: r.get("tooltip")
  });
}
function QB(n, e, t, r, i) {
  e.highDownSilentOnTouch = !!i.get("selectedMode");
  var a = r.getModel("emphasis"), o = a.get("focus");
  return er(e, o, a.get("blurScope"), a.get("disabled")), n.isGeo && oLe(e, i, t), o;
}
function e4(n, e, t) {
  var r = [], i;
  function a() {
    i = [];
  }
  function o() {
    i.length && (r.push(i), i = []);
  }
  var s = e({
    polygonStart: a,
    polygonEnd: o,
    lineStart: a,
    lineEnd: o,
    point: function(l, u) {
      isFinite(l) && isFinite(u) && i.push([l, u]);
    },
    sphere: function() {
    }
  });
  return !t && s.polygonStart(), $(n, function(l) {
    s.lineStart();
    for (var u = 0; u < l.length; u++)
      s.point(l[u][0], l[u][1]);
    s.lineEnd();
  }), !t && s.polygonEnd(), r;
}
var p4e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) {
        var o = this.group;
        if (o.removeAll(), !t.getHostGeoModel()) {
          if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === t.id) {
            var s = this._mapDraw;
            s && o.add(s.group);
          } else if (t.needsDrawMap) {
            var s = this._mapDraw || new wY(i);
            o.add(s.group), s.draw(t, r, i, this, a), this._mapDraw = s;
          } else
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          t.get("showLegendSymbol") && r.getComponent("legend") && this._renderSymbols(t, r, i);
        }
      }
    }, e.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, e.prototype._renderSymbols = function(t, r, i) {
      var a = t.originalData, o = this.group;
      a.each(a.mapDimension("value"), function(s, l) {
        if (!isNaN(s)) {
          var u = a.getItemLayout(l);
          if (!(!u || !u.point)) {
            var c = u.point, d = u.offset, f = new Ml({
              style: {
                // Because the special of map draw.
                // Which needs statistic of multiple series and draw on one map.
                // And each series also need a symbol with legend color
                //
                // Layout and visual are put one the different data
                // TODO
                fill: t.getData().getVisual("style").fill
              },
              shape: {
                cx: c[0] + d * 9,
                cy: c[1],
                r: 3
              },
              silent: !0,
              // Do not overlap the first series, on which labels are displayed.
              z2: 8 + (d ? 0 : ch + 1)
            });
            if (!d) {
              var p = t.mainSeries.getData(), h = a.getName(l), v = p.indexOfName(h), m = a.getItemModel(l), g = m.getModel("label"), y = p.getItemGraphicEl(v);
              ei(f, Nr(m), {
                labelFetcher: {
                  getFormattedLabel: function(b, _) {
                    return t.getFormattedLabel(v, _);
                  }
                },
                defaultText: h
              }), f.disableLabelAnimation = !0, g.get("position") || f.setTextConfig({
                position: "bottom"
              }), y.onHoverStateChange = function(b) {
                e_(f, b);
              };
            }
            o.add(f);
          }
        }
      });
    }, e.type = "map", e;
  }(Tn)
), h4e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.needsDrawMap = !1, t.seriesGroup = [], t.getTooltipPosition = function(r) {
        if (r != null) {
          var i = this.getData().getName(r), a = this.coordinateSystem, o = a.getRegion(i);
          return o && a.dataToPoint(o.getCenter());
        }
      }, t;
    }
    return e.prototype.getInitialData = function(t) {
      for (var r = wh(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Tt(QD, this)
      }), i = tt(), a = [], o = 0, s = r.count(); o < s; o++) {
        var l = r.getName(o);
        i.set(l, o);
      }
      var u = Tl.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return $(u.regions, function(c) {
        var d = c.name, f = i.get(d), p = c.properties && c.properties.echartsStyle, h;
        f == null ? (h = {
          name: d
        }, a.push(h)) : h = r.getRawDataItem(f), p && At(h, p);
      }), r.appendData(a), r;
    }, e.prototype.getHostGeoModel = function() {
      var t = this.option.geoIndex;
      return t != null ? this.ecModel.getComponent("geo", t) : null;
    }, e.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, e.prototype.getRawValue = function(t) {
      var r = this.getData();
      return r.get(r.mapDimension("value"), t);
    }, e.prototype.getRegionModel = function(t) {
      var r = this.getData();
      return r.getItemModel(r.indexOfName(t));
    }, e.prototype.formatTooltip = function(t, r, i) {
      for (var a = this.getData(), o = this.getRawValue(t), s = a.getName(t), l = this.seriesGroup, u = [], c = 0; c < l.length; c++) {
        var d = l[c].originalData.indexOfName(s), f = a.mapDimension("value");
        isNaN(l[c].originalData.get(f, d)) || u.push(l[c].name);
      }
      return Rr("section", {
        header: u.join(", "),
        noHeader: !u.length,
        blocks: [Rr("nameValue", {
          name: s,
          value: o
        })]
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.getLegendIcon = function(t) {
      var r = t.icon || "roundRect", i = yr(r, 0, 0, t.itemWidth, t.itemHeight, t.itemStyle.fill);
      return i.setStyle(t.itemStyle), i.style.stroke = "none", r.indexOf("empty") > -1 && (i.style.stroke = i.style.fill, i.style.fill = "#fff", i.style.lineWidth = 2), i;
    }, e.type = "series.map", e.dependencies = ["geo"], e.layoutMode = "box", e.defaultOption = {
      // 一级层叠
      // zlevel: 0,
      // 二级层叠
      z: 2,
      coordinateSystem: "geo",
      // map should be explicitly specified since ec3.
      map: "",
      // If `geoIndex` is not specified, a exclusive geo will be
      // created. Otherwise use the specified geo component, and
      // `map` and `mapType` are ignored.
      // geoIndex: 0,
      // 'center' | 'left' | 'right' | 'x%' | {number}
      left: "center",
      // 'center' | 'top' | 'bottom' | 'x%' | {number}
      top: "center",
      // right
      // bottom
      // width:
      // height
      // Aspect is width / height. Inited to be geoJson bbox aspect
      // This parameter is used for scale this aspect
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient.
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      showLegendSymbol: !0,
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ],
      // higher priority than center and zoom
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: !0,
      label: {
        show: !1,
        color: "#000"
      },
      // scaleLimit: null,
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }, e;
  }(Rn)
);
function v4e(n, e) {
  var t = {};
  return $(n, function(r) {
    r.each(r.mapDimension("value"), function(i, a) {
      var o = "ec-" + r.getName(a);
      t[o] = t[o] || [], isNaN(i) || t[o].push(i);
    });
  }), n[0].map(n[0].mapDimension("value"), function(r, i) {
    for (var a = "ec-" + n[0].getName(i), o = 0, s = 1 / 0, l = -1 / 0, u = t[a].length, c = 0; c < u; c++)
      s = Math.min(s, t[a][c]), l = Math.max(l, t[a][c]), o += t[a][c];
    var d;
    return e === "min" ? d = s : e === "max" ? d = l : e === "average" ? d = o / u : d = o, u === 0 ? NaN : d;
  });
}
function m4e(n) {
  var e = {};
  n.eachSeriesByType("map", function(t) {
    var r = t.getHostGeoModel(), i = r ? "o" + r.id : "i" + t.getMapType();
    (e[i] = e[i] || []).push(t);
  }), $(e, function(t, r) {
    for (var i = v4e(De(t, function(o) {
      return o.getData();
    }), t[0].get("mapValueCalculation")), a = 0; a < t.length; a++)
      t[a].originalData = t[a].getData();
    for (var a = 0; a < t.length; a++)
      t[a].seriesGroup = t, t[a].needsDrawMap = a === 0 && !t[a].getHostGeoModel(), t[a].setData(i.cloneShallow()), t[a].mainSeries = t[0];
  });
}
function g4e(n) {
  var e = {};
  n.eachSeriesByType("map", function(t) {
    var r = t.getMapType();
    if (!(t.getHostGeoModel() || e[r])) {
      var i = {};
      $(t.seriesGroup, function(o) {
        var s = o.coordinateSystem, l = o.originalData;
        o.get("showLegendSymbol") && n.getComponent("legend") && l.each(l.mapDimension("value"), function(u, c) {
          var d = l.getName(c), f = s.getRegion(d);
          if (!(!f || isNaN(u))) {
            var p = i[d] || 0, h = s.dataToPoint(f.getCenter());
            i[d] = p + 1, l.setItemLayout(c, {
              point: h,
              offset: p
            });
          }
        });
      });
      var a = t.getData();
      a.each(function(o) {
        var s = a.getName(o), l = a.getItemLayout(o) || {};
        l.showLabel = !i[s], a.setItemLayout(o, l);
      }), e[r] = !0;
    }
  });
}
var t4 = Zr, iy = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this) || this;
      return r.type = "view", r.dimensions = ["x", "y"], r._roamTransformable = new rl(), r._rawTransformable = new rl(), r.name = t, r;
    }
    return e.prototype.setBoundingRect = function(t, r, i, a) {
      return this._rect = new Ot(t, r, i, a), this._rect;
    }, e.prototype.getBoundingRect = function() {
      return this._rect;
    }, e.prototype.setViewRect = function(t, r, i, a) {
      this._transformTo(t, r, i, a), this._viewRect = new Ot(t, r, i, a);
    }, e.prototype._transformTo = function(t, r, i, a) {
      var o = this.getBoundingRect(), s = this._rawTransformable;
      s.transform = o.calculateTransform(new Ot(t, r, i, a));
      var l = s.parent;
      s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
    }, e.prototype.setCenter = function(t, r) {
      t && (this._center = [ze(t[0], r.getWidth()), ze(t[1], r.getHeight())], this._updateCenterAndZoom());
    }, e.prototype.setZoom = function(t) {
      t = t || 1;
      var r = this.zoomLimit;
      r && (r.max != null && (t = Math.min(r.max, t)), r.min != null && (t = Math.max(r.min, t))), this._zoom = t, this._updateCenterAndZoom();
    }, e.prototype.getDefaultCenter = function() {
      var t = this.getBoundingRect(), r = t.x + t.width / 2, i = t.y + t.height / 2;
      return [r, i];
    }, e.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, e.prototype.getZoom = function() {
      return this._zoom || 1;
    }, e.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, e.prototype._updateCenterAndZoom = function() {
      var t = this._rawTransformable.getLocalTransform(), r = this._roamTransformable, i = this.getDefaultCenter(), a = this.getCenter(), o = this.getZoom();
      a = Zr([], a, t), i = Zr([], i, t), r.originX = a[0], r.originY = a[1], r.x = i[0] - a[0], r.y = i[1] - a[1], r.scaleX = r.scaleY = o, this._updateTransform();
    }, e.prototype._updateTransform = function() {
      var t = this._roamTransformable, r = this._rawTransformable;
      r.parent = t, t.updateTransform(), r.updateTransform(), CD(this.transform || (this.transform = []), r.transform || ya()), this._rawTransform = r.getLocalTransform(), this.invTransform = this.invTransform || [], lh(this.invTransform, this.transform), this.decomposeTransform();
    }, e.prototype.getTransformInfo = function() {
      var t = this._rawTransformable, r = this._roamTransformable, i = new rl();
      return i.transform = r.transform, i.decomposeTransform(), {
        roam: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        },
        raw: {
          x: t.x,
          y: t.y,
          scaleX: t.scaleX,
          scaleY: t.scaleY
        }
      };
    }, e.prototype.getViewRect = function() {
      return this._viewRect;
    }, e.prototype.getViewRectAfterRoam = function() {
      var t = this.getBoundingRect().clone();
      return t.applyTransform(this.transform), t;
    }, e.prototype.dataToPoint = function(t, r, i) {
      var a = r ? this._rawTransform : this.transform;
      return i = i || [], a ? t4(i, t, a) : Si(i, t);
    }, e.prototype.pointToData = function(t) {
      var r = this.invTransform;
      return r ? t4([], t, r) : [t[0], t[1]];
    }, e.prototype.convertToPixel = function(t, r, i) {
      var a = n4(r);
      return a === this ? a.dataToPoint(i) : null;
    }, e.prototype.convertFromPixel = function(t, r, i) {
      var a = n4(r);
      return a === this ? a.pointToData(i) : null;
    }, e.prototype.containPoint = function(t) {
      return this.getViewRectAfterRoam().contain(t[0], t[1]);
    }, e.dimensions = ["x", "y"], e;
  }(rl)
);
function n4(n) {
  var e = n.seriesModel;
  return e ? e.coordinateSystem : null;
}
var y4e = {
  geoJSON: {
    aspectScale: 0.75,
    invertLongitute: !0
  },
  geoSVG: {
    aspectScale: 1,
    invertLongitute: !1
  }
}, SY = ["lng", "lat"], qk = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i) {
      var a = n.call(this, t) || this;
      a.dimensions = SY, a.type = "geo", a._nameCoordMap = tt(), a.map = r;
      var o = i.projection, s = Tl.load(r, i.nameMap, i.nameProperty), l = Tl.getGeoResource(r), u = a.resourceType = l ? l.type : null, c = a.regions = s.regions, d = y4e[l.type];
      a._regionsMap = s.regionsMap, a.regions = s.regions, process.env.NODE_ENV !== "production" && o && (u === "geoSVG" && (process.env.NODE_ENV !== "production" && Jn("Map " + r + " with SVG source can't use projection. Only GeoJSON source supports projection."), o = null), o.project && o.unproject || (process.env.NODE_ENV !== "production" && Jn("project and unproject must be both provided in the projeciton."), o = null)), a.projection = o;
      var f;
      if (o)
        for (var p = 0; p < c.length; p++) {
          var h = c[p].getBoundingRect(o);
          f = f || h.clone(), f.union(h);
        }
      else
        f = s.boundingRect;
      return a.setBoundingRect(f.x, f.y, f.width, f.height), a.aspectScale = o ? 1 : bt(i.aspectScale, d.aspectScale), a._invertLongitute = o ? !1 : d.invertLongitute, a;
    }
    return e.prototype._transformTo = function(t, r, i, a) {
      var o = this.getBoundingRect(), s = this._invertLongitute;
      o = o.clone(), s && (o.y = -o.y - o.height);
      var l = this._rawTransformable;
      l.transform = o.calculateTransform(new Ot(t, r, i, a));
      var u = l.parent;
      l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform();
    }, e.prototype.getRegion = function(t) {
      return this._regionsMap.get(t);
    }, e.prototype.getRegionByCoord = function(t) {
      for (var r = this.regions, i = 0; i < r.length; i++) {
        var a = r[i];
        if (a.type === "geoJSON" && a.contain(t))
          return r[i];
      }
    }, e.prototype.addGeoCoord = function(t, r) {
      this._nameCoordMap.set(t, r);
    }, e.prototype.getGeoCoord = function(t) {
      var r = this._regionsMap.get(t);
      return this._nameCoordMap.get(t) || r && r.getCenter();
    }, e.prototype.dataToPoint = function(t, r, i) {
      if (We(t) && (t = this.getGeoCoord(t)), t) {
        var a = this.projection;
        return a && (t = a.project(t)), t && this.projectedToPoint(t, r, i);
      }
    }, e.prototype.pointToData = function(t) {
      var r = this.projection;
      return r && (t = r.unproject(t)), t && this.pointToProjected(t);
    }, e.prototype.pointToProjected = function(t) {
      return n.prototype.pointToData.call(this, t);
    }, e.prototype.projectedToPoint = function(t, r, i) {
      return n.prototype.dataToPoint.call(this, t, r, i);
    }, e.prototype.convertToPixel = function(t, r, i) {
      var a = r4(r);
      return a === this ? a.dataToPoint(i) : null;
    }, e.prototype.convertFromPixel = function(t, r, i) {
      var a = r4(r);
      return a === this ? a.pointToData(i) : null;
    }, e;
  }(iy)
);
_r(qk, iy);
function r4(n) {
  var e = n.geoModel, t = n.seriesModel;
  return e ? e.coordinateSystem : t ? t.coordinateSystem || (t.getReferringComponents("geo", gr).models[0] || {}).coordinateSystem : null;
}
function i4(n, e) {
  var t = n.get("boundingCoords");
  if (t != null) {
    var r = t[0], i = t[1];
    if (!(isFinite(r[0]) && isFinite(r[1]) && isFinite(i[0]) && isFinite(i[1])))
      process.env.NODE_ENV !== "production" && console.error("Invalid boundingCoords");
    else {
      var a = this.projection;
      if (a) {
        var o = r[0], s = r[1], l = i[0], u = i[1];
        r = [1 / 0, 1 / 0], i = [-1 / 0, -1 / 0];
        var c = function(w, S, C, k) {
          for (var M = C - w, D = k - S, N = 0; N <= 100; N++) {
            var R = N / 100, j = a.project([w + M * R, S + D * R]);
            fu(r, r, j), pu(i, i, j);
          }
        };
        c(o, s, l, s), c(l, s, l, u), c(l, u, o, u), c(o, u, l, s);
      }
      this.setBoundingRect(r[0], r[1], i[0] - r[0], i[1] - r[1]);
    }
  }
  var d = this.getBoundingRect(), f = n.get("layoutCenter"), p = n.get("layoutSize"), h = e.getWidth(), v = e.getHeight(), m = d.width / d.height * this.aspectScale, g = !1, y, b;
  f && p && (y = [ze(f[0], h), ze(f[1], v)], b = ze(p, Math.min(h, v)), !isNaN(y[0]) && !isNaN(y[1]) && !isNaN(b) ? g = !0 : process.env.NODE_ENV !== "production" && console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead."));
  var _;
  if (g)
    _ = {}, m > 1 ? (_.width = b, _.height = b / m) : (_.height = b, _.width = b * m), _.y = y[1] - _.height / 2, _.x = y[0] - _.width / 2;
  else {
    var x = n.getBoxLayoutParams();
    x.aspect = m, _ = Er(x, {
      width: h,
      height: v
    });
  }
  this.setViewRect(_.x, _.y, _.width, _.height), this.setCenter(n.get("center"), e), this.setZoom(n.get("zoom"));
}
function b4e(n, e) {
  $(e.get("geoCoord"), function(t, r) {
    n.addGeoCoord(r, t);
  });
}
var _4e = (
  /** @class */
  function() {
    function n() {
      this.dimensions = SY;
    }
    return n.prototype.create = function(e, t) {
      var r = [];
      function i(o) {
        return {
          nameProperty: o.get("nameProperty"),
          aspectScale: o.get("aspectScale"),
          projection: o.get("projection")
        };
      }
      e.eachComponent("geo", function(o, s) {
        var l = o.get("map"), u = new qk(l + s, l, xe({
          nameMap: o.get("nameMap")
        }, i(o)));
        u.zoomLimit = o.get("scaleLimit"), r.push(u), o.coordinateSystem = u, u.model = o, u.resize = i4, u.resize(o, t);
      }), e.eachSeries(function(o) {
        var s = o.get("coordinateSystem");
        if (s === "geo") {
          var l = o.get("geoIndex") || 0;
          o.coordinateSystem = r[l];
        }
      });
      var a = {};
      return e.eachSeriesByType("map", function(o) {
        if (!o.getHostGeoModel()) {
          var s = o.getMapType();
          a[s] = a[s] || [], a[s].push(o);
        }
      }), $(a, function(o, s) {
        var l = De(o, function(c) {
          return c.get("nameMap");
        }), u = new qk(s, s, xe({
          nameMap: wD(l)
        }, i(o[0])));
        u.zoomLimit = mr.apply(null, De(o, function(c) {
          return c.get("scaleLimit");
        })), r.push(u), u.resize = i4, u.resize(o[0], t), $(o, function(c) {
          c.coordinateSystem = u, b4e(u, c);
        });
      }), r;
    }, n.prototype.getFilledRegions = function(e, t, r, i) {
      for (var a = (e || []).slice(), o = tt(), s = 0; s < a.length; s++)
        o.set(a[s].name, a[s]);
      var l = Tl.load(t, r, i);
      return $(l.regions, function(u) {
        var c = u.name, d = o.get(c), f = u.properties && u.properties.echartsStyle;
        d || (d = {
          name: c
        }, a.push(d)), f && At(d, f);
      }), a;
    }, n;
  }()
), EY = new _4e(), x4e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r, i) {
      var a = Tl.getGeoResource(t.map);
      if (a && a.type === "geoJSON") {
        var o = t.itemStyle = t.itemStyle || {};
        "color" in o || (o.color = "#eee");
      }
      this.mergeDefaultAndTheme(t, i), Od(t, "label", ["show"]);
    }, e.prototype.optionUpdated = function() {
      var t = this, r = this.option;
      r.regions = EY.getFilledRegions(r.regions, r.map, r.nameMap, r.nameProperty);
      var i = {};
      this._optionModelMap = xs(r.regions || [], function(a, o) {
        var s = o.name;
        return s && (a.set(s, new yn(o, t, t.ecModel)), o.selected && (i[s] = !0)), a;
      }, tt()), r.selectedMap || (r.selectedMap = i);
    }, e.prototype.getRegionModel = function(t) {
      return this._optionModelMap.get(t) || new yn(null, this, this.ecModel);
    }, e.prototype.getFormattedLabel = function(t, r) {
      var i = this.getRegionModel(t), a = r === "normal" ? i.get(["label", "formatter"]) : i.get(["emphasis", "label", "formatter"]), o = {
        name: t
      };
      if (at(a))
        return o.status = r, a(o);
      if (We(a))
        return a.replace("{a}", t ?? "");
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.select = function(t) {
      var r = this.option, i = r.selectedMode;
      if (i) {
        i !== "multiple" && (r.selectedMap = null);
        var a = r.selectedMap || (r.selectedMap = {});
        a[t] = !0;
      }
    }, e.prototype.unSelect = function(t) {
      var r = this.option.selectedMap;
      r && (r[t] = !1);
    }, e.prototype.toggleSelected = function(t) {
      this[this.isSelected(t) ? "unSelect" : "select"](t);
    }, e.prototype.isSelected = function(t) {
      var r = this.option.selectedMap;
      return !!(r && r[t]);
    }, e.type = "geo", e.layoutMode = "box", e.defaultOption = {
      // zlevel: 0,
      z: 0,
      show: !0,
      left: "center",
      top: "center",
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // /// Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      silent: !1,
      // Map type
      map: "",
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ]
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      // selectedMode: false
      label: {
        show: !1,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
        // Default color:
        // + geoJSON: #eee
        // + geoSVG: null (use SVG original `fill`)
        // color: '#eee'
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
      // tooltip: {
      //     show: false
      // }
    }, e;
  }(Ut)
);
function a4(n, e) {
  return n.pointToProjected ? n.pointToProjected(e) : n.pointToData(e);
}
function NO(n, e, t, r) {
  var i = n.getZoom(), a = n.getCenter(), o = e.zoom, s = n.projectedToPoint ? n.projectedToPoint(a) : n.dataToPoint(a);
  if (e.dx != null && e.dy != null && (s[0] -= e.dx, s[1] -= e.dy, n.setCenter(a4(n, s), r)), o != null) {
    if (t) {
      var l = t.min || 0, u = t.max || 1 / 0;
      o = Math.max(Math.min(i * o, u), l) / i;
    }
    n.scaleX *= o, n.scaleY *= o;
    var c = (e.originX - n.x) * (o - 1), d = (e.originY - n.y) * (o - 1);
    n.x -= c, n.y -= d, n.updateTransform(), n.setCenter(a4(n, s), r), n.setZoom(o * i);
  }
  return {
    center: n.getCenter(),
    zoom: n.getZoom()
  };
}
var w4e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.focusBlurEnabled = !0, t;
    }
    return e.prototype.init = function(t, r) {
      this._api = r;
    }, e.prototype.render = function(t, r, i, a) {
      if (this._model = t, !t.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new wY(i));
      var o = this._mapDraw;
      o.draw(t, r, i, this, a), o.group.on("click", this._handleRegionClick, this), o.group.silent = t.get("silent"), this.group.add(o.group), this.updateSelectStatus(t, r, i);
    }, e.prototype._handleRegionClick = function(t) {
      var r;
      qc(t.target, function(i) {
        return (r = yt(i).eventData) != null;
      }, !0), r && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: r.name
      });
    }, e.prototype.updateSelectStatus = function(t, r, i) {
      var a = this;
      this._mapDraw.group.traverse(function(o) {
        var s = yt(o).eventData;
        if (s)
          return a._model.isSelected(s.name) ? i.enterSelect(o) : i.leaveSelect(o), !0;
      });
    }, e.prototype.findHighDownDispatchers = function(t) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(t, this._model);
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, e.type = "geo", e;
  }(Yn)
);
function S4e(n, e, t) {
  Tl.registerMap(n, e, t);
}
function TY(n) {
  n.registerCoordinateSystem("geo", EY), n.registerComponentModel(x4e), n.registerComponentView(w4e), n.registerImpl("registerMap", S4e), n.registerImpl("getMap", function(t) {
    return Tl.getMapForUser(t);
  });
  function e(t, r) {
    r.update = "geo:updateSelectStatus", n.registerAction(r, function(i, a) {
      var o = {}, s = [];
      return a.eachComponent({
        mainType: "geo",
        query: i
      }, function(l) {
        l[t](i.name);
        var u = l.coordinateSystem;
        $(u.regions, function(d) {
          o[d.name] = l.isSelected(d.name) || !1;
        });
        var c = [];
        $(o, function(d, f) {
          o[f] && c.push(f);
        }), s.push({
          geoIndex: l.componentIndex,
          // Use singular, the same naming convention as the event `selectchanged`.
          name: c
        });
      }), {
        selected: o,
        allSelected: s,
        name: i.name
      };
    });
  }
  e("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  }), e("select", {
    type: "geoSelect",
    event: "geoselected"
  }), e("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  }), n.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(t, r, i) {
    var a = t.componentType || "series";
    r.eachComponent({
      mainType: a,
      query: t
    }, function(o) {
      var s = o.coordinateSystem;
      if (s.type === "geo") {
        var l = NO(s, t, o.get("scaleLimit"), i);
        o.setCenter && o.setCenter(l.center), o.setZoom && o.setZoom(l.zoom), a === "series" && $(o.seriesGroup, function(u) {
          u.setCenter(l.center), u.setZoom(l.zoom);
        });
      }
    });
  });
}
function E4e(n) {
  $t(TY), n.registerChartView(p4e), n.registerSeriesModel(h4e), n.registerLayout(g4e), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, m4e), kW("map", n.registerAction);
}
function T4e(n) {
  var e = n;
  e.hierNode = {
    defaultAncestor: null,
    ancestor: e,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  for (var t = [e], r, i; r = t.pop(); )
    if (i = r.children, r.isExpand && i.length)
      for (var a = i.length, o = a - 1; o >= 0; o--) {
        var s = i[o];
        s.hierNode = {
          defaultAncestor: null,
          ancestor: s,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: o,
          thread: null
        }, t.push(s);
      }
}
function C4e(n, e) {
  var t = n.isExpand ? n.children : [], r = n.parentNode.children, i = n.hierNode.i ? r[n.hierNode.i - 1] : null;
  if (t.length) {
    M4e(n);
    var a = (t[0].hierNode.prelim + t[t.length - 1].hierNode.prelim) / 2;
    i ? (n.hierNode.prelim = i.hierNode.prelim + e(n, i), n.hierNode.modifier = n.hierNode.prelim - a) : n.hierNode.prelim = a;
  } else i && (n.hierNode.prelim = i.hierNode.prelim + e(n, i));
  n.parentNode.hierNode.defaultAncestor = D4e(n, i, n.parentNode.hierNode.defaultAncestor || r[0], e);
}
function k4e(n) {
  var e = n.hierNode.prelim + n.parentNode.hierNode.modifier;
  n.setLayout({
    x: e
  }, !0), n.hierNode.modifier += n.parentNode.hierNode.modifier;
}
function o4(n) {
  return arguments.length ? n : L4e;
}
function Rv(n, e) {
  return n -= Math.PI / 2, {
    x: e * Math.cos(n),
    y: e * Math.sin(n)
  };
}
function A4e(n, e) {
  return Er(n.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function M4e(n) {
  for (var e = n.children, t = e.length, r = 0, i = 0; --t >= 0; ) {
    var a = e[t];
    a.hierNode.prelim += r, a.hierNode.modifier += r, i += a.hierNode.change, r += a.hierNode.shift + i;
  }
}
function D4e(n, e, t, r) {
  if (e) {
    for (var i = n, a = n, o = a.parentNode.children[0], s = e, l = i.hierNode.modifier, u = a.hierNode.modifier, c = o.hierNode.modifier, d = s.hierNode.modifier; s = yE(s), a = bE(a), s && a; ) {
      i = yE(i), o = bE(o), i.hierNode.ancestor = n;
      var f = s.hierNode.prelim + d - a.hierNode.prelim - u + r(s, a);
      f > 0 && (I4e(O4e(s, n, t), n, f), u += f, l += f), d += s.hierNode.modifier, u += a.hierNode.modifier, l += i.hierNode.modifier, c += o.hierNode.modifier;
    }
    s && !yE(i) && (i.hierNode.thread = s, i.hierNode.modifier += d - l), a && !bE(o) && (o.hierNode.thread = a, o.hierNode.modifier += u - c, t = n);
  }
  return t;
}
function yE(n) {
  var e = n.children;
  return e.length && n.isExpand ? e[e.length - 1] : n.hierNode.thread;
}
function bE(n) {
  var e = n.children;
  return e.length && n.isExpand ? e[0] : n.hierNode.thread;
}
function O4e(n, e, t) {
  return n.hierNode.ancestor.parentNode === e.parentNode ? n.hierNode.ancestor : t;
}
function I4e(n, e, t) {
  var r = t / (e.hierNode.i - n.hierNode.i);
  e.hierNode.change -= r, e.hierNode.shift += t, e.hierNode.modifier += t, e.hierNode.prelim += t, n.hierNode.change += r;
}
function L4e(n, e) {
  return n.parentNode === e.parentNode ? 1 : 2;
}
var N4e = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.parentPoint = [], this.childPoints = [];
    }
    return n;
  }()
), R4e = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new N4e();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.childPoints, a = i.length, o = r.parentPoint, s = i[0], l = i[a - 1];
      if (a === 1) {
        t.moveTo(o[0], o[1]), t.lineTo(s[0], s[1]);
        return;
      }
      var u = r.orient, c = u === "TB" || u === "BT" ? 0 : 1, d = 1 - c, f = ze(r.forkPosition, 1), p = [];
      p[c] = o[c], p[d] = o[d] + (l[d] - o[d]) * f, t.moveTo(o[0], o[1]), t.lineTo(p[0], p[1]), t.moveTo(s[0], s[1]), p[c] = s[c], t.lineTo(p[0], p[1]), p[c] = l[c], t.lineTo(p[0], p[1]), t.lineTo(l[0], l[1]);
      for (var h = 1; h < a - 1; h++) {
        var v = i[h];
        t.moveTo(v[0], v[1]), p[c] = v[c], t.lineTo(p[0], p[1]);
      }
    }, e;
  }(Ht)
), P4e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._mainGroup = new mt(), t;
    }
    return e.prototype.init = function(t, r) {
      this._controller = new ry(r.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, e.prototype.render = function(t, r, i) {
      var a = t.getData(), o = t.layoutInfo, s = this._mainGroup, l = t.get("layout");
      l === "radial" ? (s.x = o.x + o.width / 2, s.y = o.y + o.height / 2) : (s.x = o.x, s.y = o.y), this._updateViewCoordSys(t, i), this._updateController(t, r, i);
      var u = this._data;
      a.diff(u).add(function(c) {
        s4(a, c) && l4(a, c, null, s, t);
      }).update(function(c, d) {
        var f = u.getItemGraphicEl(d);
        if (!s4(a, c)) {
          f && c4(u, d, f, s, t);
          return;
        }
        l4(a, c, f, s, t);
      }).remove(function(c) {
        var d = u.getItemGraphicEl(c);
        d && c4(u, c, d, s, t);
      }).execute(), this._nodeScaleRatio = t.get("nodeScaleRatio"), this._updateNodeAndLinkScale(t), t.get("expandAndCollapse") === !0 && a.eachItemGraphicEl(function(c, d) {
        c.off("click").on("click", function() {
          i.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: t.id,
            dataIndex: d
          });
        });
      }), this._data = a;
    }, e.prototype._updateViewCoordSys = function(t, r) {
      var i = t.getData(), a = [];
      i.each(function(d) {
        var f = i.getItemLayout(d);
        f && !isNaN(f.x) && !isNaN(f.y) && a.push([+f.x, +f.y]);
      });
      var o = [], s = [];
      tw(a, o, s);
      var l = this._min, u = this._max;
      s[0] - o[0] === 0 && (o[0] = l ? l[0] : o[0] - 1, s[0] = u ? u[0] : s[0] + 1), s[1] - o[1] === 0 && (o[1] = l ? l[1] : o[1] - 1, s[1] = u ? u[1] : s[1] + 1);
      var c = t.coordinateSystem = new iy();
      c.zoomLimit = t.get("scaleLimit"), c.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]), c.setCenter(t.get("center"), r), c.setZoom(t.get("zoom")), this.group.attr({
        x: c.x,
        y: c.y,
        scaleX: c.scaleX,
        scaleY: c.scaleY
      }), this._min = o, this._max = s;
    }, e.prototype._updateController = function(t, r, i) {
      var a = this, o = this._controller, s = this._controllerHost, l = this.group;
      o.setPointerChecker(function(u, c, d) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(c, d) && !Tw(u, i, t);
      }), o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
        OO(s, u.dx, u.dy), i.dispatchAction({
          seriesId: t.id,
          type: "treeRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        IO(s, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: t.id,
          type: "treeRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(t), i.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function(t) {
      var r = t.getData(), i = this._getNodeGlobalScale(t);
      r.eachItemGraphicEl(function(a, o) {
        a.setSymbolScale(i);
      });
    }, e.prototype._getNodeGlobalScale = function(t) {
      var r = t.coordinateSystem;
      if (r.type !== "view")
        return 1;
      var i = this._nodeScaleRatio, a = r.scaleX || 1, o = r.getZoom(), s = (o - 1) * i + 1;
      return s / a;
    }, e.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, e.type = "tree", e;
  }(Tn)
);
function s4(n, e) {
  var t = n.getItemLayout(e);
  return t && !isNaN(t.x) && !isNaN(t.y);
}
function l4(n, e, t, r, i) {
  var a = !t, o = n.tree.getNodeByDataIndex(e), s = o.getModel(), l = o.getVisual("style").fill, u = o.isExpand === !1 && o.children.length !== 0 ? l : "#fff", c = n.tree.root, d = o.parentNode === c ? o : o.parentNode || o, f = n.getItemGraphicEl(d.dataIndex), p = d.getLayout(), h = f ? {
    x: f.__oldX,
    y: f.__oldY,
    rawX: f.__radialOldRawX,
    rawY: f.__radialOldRawY
  } : p, v = o.getLayout();
  a ? (t = new Zg(n, e, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), t.x = h.x, t.y = h.y) : t.updateData(n, e, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), t.__radialOldRawX = t.__radialRawX, t.__radialOldRawY = t.__radialRawY, t.__radialRawX = v.rawX, t.__radialRawY = v.rawY, r.add(t), n.setItemGraphicEl(e, t), t.__oldX = t.x, t.__oldY = t.y, ln(t, {
    x: v.x,
    y: v.y
  }, i);
  var m = t.getSymbolPath();
  if (i.get("layout") === "radial") {
    var g = c.children[0], y = g.getLayout(), b = g.children.length, _ = void 0, x = void 0;
    if (v.x === y.x && o.isExpand === !0 && g.children.length) {
      var w = {
        x: (g.children[0].getLayout().x + g.children[b - 1].getLayout().x) / 2,
        y: (g.children[0].getLayout().y + g.children[b - 1].getLayout().y) / 2
      };
      _ = Math.atan2(w.y - y.y, w.x - y.x), _ < 0 && (_ = Math.PI * 2 + _), x = w.x < y.x, x && (_ = _ - Math.PI);
    } else
      _ = Math.atan2(v.y - y.y, v.x - y.x), _ < 0 && (_ = Math.PI * 2 + _), o.children.length === 0 || o.children.length !== 0 && o.isExpand === !1 ? (x = v.x < y.x, x && (_ = _ - Math.PI)) : (x = v.x > y.x, x || (_ = _ - Math.PI));
    var S = x ? "left" : "right", C = s.getModel("label"), k = C.get("rotate"), M = k * (Math.PI / 180), D = m.getTextContent();
    D && (m.setTextConfig({
      position: C.get("position") || S,
      rotation: k == null ? -_ : M,
      origin: "center"
    }), D.setStyle("verticalAlign", "middle"));
  }
  var N = s.get(["emphasis", "focus"]), R = N === "relative" ? Km(o.getAncestorsIndices(), o.getDescendantIndices()) : N === "ancestor" ? o.getAncestorsIndices() : N === "descendant" ? o.getDescendantIndices() : null;
  R && (yt(t).focus = R), j4e(i, o, c, t, h, p, v, r), t.__edge && (t.onHoverStateChange = function(j) {
    if (j !== "blur") {
      var z = o.parentNode && n.getItemGraphicEl(o.parentNode.dataIndex);
      z && z.hoverState === Vg || e_(t.__edge, j);
    }
  });
}
function j4e(n, e, t, r, i, a, o, s) {
  var l = e.getModel(), u = n.get("edgeShape"), c = n.get("layout"), d = n.getOrient(), f = n.get(["lineStyle", "curveness"]), p = n.get("edgeForkPosition"), h = l.getModel("lineStyle").getLineStyle(), v = r.__edge;
  if (u === "curve")
    e.parentNode && e.parentNode !== t && (v || (v = r.__edge = new Gg({
      shape: Yk(c, d, f, i, i)
    })), ln(v, {
      shape: Yk(c, d, f, a, o)
    }, n));
  else if (u === "polyline") {
    if (c === "orthogonal") {
      if (e !== t && e.children && e.children.length !== 0 && e.isExpand === !0) {
        for (var m = e.children, g = [], y = 0; y < m.length; y++) {
          var b = m[y].getLayout();
          g.push([b.x, b.y]);
        }
        v || (v = r.__edge = new R4e({
          shape: {
            parentPoint: [o.x, o.y],
            childPoints: [[o.x, o.y]],
            orient: d,
            forkPosition: p
          }
        })), ln(v, {
          shape: {
            parentPoint: [o.x, o.y],
            childPoints: g
          }
        }, n);
      }
    } else if (process.env.NODE_ENV !== "production")
      throw new Error("The polyline edgeShape can only be used in orthogonal layout");
  }
  v && !(u === "polyline" && !e.isExpand) && (v.useStyle(dt({
    strokeNoScale: !0,
    fill: null
  }, h)), Qr(v, l, "lineStyle"), Nd(v), s.add(v));
}
function u4(n, e, t, r, i) {
  var a = e.tree.root, o = CY(a, n), s = o.source, l = o.sourceLayout, u = e.getItemGraphicEl(n.dataIndex);
  if (u) {
    var c = e.getItemGraphicEl(s.dataIndex), d = c.__edge, f = u.__edge || (s.isExpand === !1 || s.children.length === 1 ? d : void 0), p = r.get("edgeShape"), h = r.get("layout"), v = r.get("orient"), m = r.get(["lineStyle", "curveness"]);
    f && (p === "curve" ? Pu(f, {
      shape: Yk(h, v, m, l, l),
      style: {
        opacity: 0
      }
    }, r, {
      cb: function() {
        t.remove(f);
      },
      removeOpt: i
    }) : p === "polyline" && r.get("layout") === "orthogonal" && Pu(f, {
      shape: {
        parentPoint: [l.x, l.y],
        childPoints: [[l.x, l.y]]
      },
      style: {
        opacity: 0
      }
    }, r, {
      cb: function() {
        t.remove(f);
      },
      removeOpt: i
    }));
  }
}
function CY(n, e) {
  for (var t = e.parentNode === n ? e : e.parentNode || e, r; r = t.getLayout(), r == null; )
    t = t.parentNode === n ? t : t.parentNode || t;
  return {
    source: t,
    sourceLayout: r
  };
}
function c4(n, e, t, r, i) {
  var a = n.tree.getNodeByDataIndex(e), o = n.tree.root, s = CY(o, a).sourceLayout, l = {
    duration: i.get("animationDurationUpdate"),
    easing: i.get("animationEasingUpdate")
  };
  Pu(t, {
    x: s.x + 1,
    y: s.y + 1
  }, i, {
    cb: function() {
      r.remove(t), n.setItemGraphicEl(e, null);
    },
    removeOpt: l
  }), t.fadeOut(null, n.hostModel, {
    fadeLabel: !0,
    animation: l
  }), a.children.forEach(function(u) {
    u4(u, n, r, i, l);
  }), u4(a, n, r, i, l);
}
function Yk(n, e, t, r, i) {
  var a, o, s, l, u, c, d, f;
  if (n === "radial") {
    u = r.rawX, d = r.rawY, c = i.rawX, f = i.rawY;
    var p = Rv(u, d), h = Rv(u, d + (f - d) * t), v = Rv(c, f + (d - f) * t), m = Rv(c, f);
    return {
      x1: p.x || 0,
      y1: p.y || 0,
      x2: m.x || 0,
      y2: m.y || 0,
      cpx1: h.x || 0,
      cpy1: h.y || 0,
      cpx2: v.x || 0,
      cpy2: v.y || 0
    };
  } else
    u = r.x, d = r.y, c = i.x, f = i.y, (e === "LR" || e === "RL") && (a = u + (c - u) * t, o = d, s = c + (u - c) * t, l = f), (e === "TB" || e === "BT") && (a = u, o = d + (f - d) * t, s = c, l = f + (d - f) * t);
  return {
    x1: u,
    y1: d,
    x2: c,
    y2: f,
    cpx1: a,
    cpy1: o,
    cpx2: s,
    cpy2: l
  };
}
var Ja = en();
function kY(n) {
  var e = n.mainData, t = n.datas;
  t || (t = {
    main: e
  }, n.datasAttr = {
    main: "data"
  }), n.datas = n.mainData = null, AY(e, t, n), $(t, function(r) {
    $(e.TRANSFERABLE_METHODS, function(i) {
      r.wrapMethod(i, Tt(B4e, n));
    });
  }), e.wrapMethod("cloneShallow", Tt(z4e, n)), $(e.CHANGABLE_METHODS, function(r) {
    e.wrapMethod(r, Tt($4e, n));
  }), ct(t[e.dataType] === e);
}
function B4e(n, e) {
  if (H4e(this)) {
    var t = xe({}, Ja(this).datas);
    t[this.dataType] = e, AY(e, t, n);
  } else
    RO(e, this.dataType, Ja(this).mainData, n);
  return e;
}
function $4e(n, e) {
  return n.struct && n.struct.update(), e;
}
function z4e(n, e) {
  return $(Ja(e).datas, function(t, r) {
    t !== e && RO(t.cloneShallow(), r, e, n);
  }), e;
}
function F4e(n) {
  var e = Ja(this).mainData;
  return n == null || e == null ? e : Ja(e).datas[n];
}
function V4e() {
  var n = Ja(this).mainData;
  return n == null ? [{
    data: n
  }] : De(Yt(Ja(n).datas), function(e) {
    return {
      type: e,
      data: Ja(n).datas[e]
    };
  });
}
function H4e(n) {
  return Ja(n).mainData === n;
}
function AY(n, e, t) {
  Ja(n).datas = {}, $(e, function(r, i) {
    RO(r, i, n, t);
  });
}
function RO(n, e, t, r) {
  Ja(t).datas[e] = n, Ja(n).mainData = t, n.dataType = e, r.struct && (n[r.structAttr] = r.struct, r.struct[r.datasAttr[e]] = n), n.getLinkedData = F4e, n.getLinkedDataAll = V4e;
}
var G4e = (
  /** @class */
  function() {
    function n(e, t) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = e || "", this.hostTree = t;
    }
    return n.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, n.prototype.eachNode = function(e, t, r) {
      at(e) && (r = t, t = e, e = null), e = e || {}, We(e) && (e = {
        order: e
      });
      var i = e.order || "preorder", a = this[e.attr || "children"], o;
      i === "preorder" && (o = t.call(r, this));
      for (var s = 0; !o && s < a.length; s++)
        a[s].eachNode(e, t, r);
      i === "postorder" && t.call(r, this);
    }, n.prototype.updateDepthAndHeight = function(e) {
      var t = 0;
      this.depth = e;
      for (var r = 0; r < this.children.length; r++) {
        var i = this.children[r];
        i.updateDepthAndHeight(e + 1), i.height > t && (t = i.height);
      }
      this.height = t + 1;
    }, n.prototype.getNodeById = function(e) {
      if (this.getId() === e)
        return this;
      for (var t = 0, r = this.children, i = r.length; t < i; t++) {
        var a = r[t].getNodeById(e);
        if (a)
          return a;
      }
    }, n.prototype.contains = function(e) {
      if (e === this)
        return !0;
      for (var t = 0, r = this.children, i = r.length; t < i; t++) {
        var a = r[t].contains(e);
        if (a)
          return a;
      }
    }, n.prototype.getAncestors = function(e) {
      for (var t = [], r = e ? this : this.parentNode; r; )
        t.push(r), r = r.parentNode;
      return t.reverse(), t;
    }, n.prototype.getAncestorsIndices = function() {
      for (var e = [], t = this; t; )
        e.push(t.dataIndex), t = t.parentNode;
      return e.reverse(), e;
    }, n.prototype.getDescendantIndices = function() {
      var e = [];
      return this.eachNode(function(t) {
        e.push(t.dataIndex);
      }), e;
    }, n.prototype.getValue = function(e) {
      var t = this.hostTree.data;
      return t.getStore().get(t.getDimensionIndex(e || "value"), this.dataIndex);
    }, n.prototype.setLayout = function(e, t) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, e, t);
    }, n.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, n.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostTree, r = t.data.getItemModel(this.dataIndex);
        return r.getModel(e);
      }
    }, n.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, n.prototype.setVisual = function(e, t) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, e, t);
    }, n.prototype.getVisual = function(e) {
      return this.hostTree.data.getItemVisual(this.dataIndex, e);
    }, n.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, n.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, n.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var e = this.parentNode.children, t = 0; t < e.length; ++t)
          if (e[t] === this)
            return t;
        return -1;
      }
      return -1;
    }, n.prototype.isAncestorOf = function(e) {
      for (var t = e.parentNode; t; ) {
        if (t === this)
          return !0;
        t = t.parentNode;
      }
      return !1;
    }, n.prototype.isDescendantOf = function(e) {
      return e !== this && e.isAncestorOf(this);
    }, n;
  }()
), PO = (
  /** @class */
  function() {
    function n(e) {
      this.type = "tree", this._nodes = [], this.hostModel = e;
    }
    return n.prototype.eachNode = function(e, t, r) {
      this.root.eachNode(e, t, r);
    }, n.prototype.getNodeByDataIndex = function(e) {
      var t = this.data.getRawIndex(e);
      return this._nodes[t];
    }, n.prototype.getNodeById = function(e) {
      return this.root.getNodeById(e);
    }, n.prototype.update = function() {
      for (var e = this.data, t = this._nodes, r = 0, i = t.length; r < i; r++)
        t[r].dataIndex = -1;
      for (var r = 0, i = e.count(); r < i; r++)
        t[e.getRawIndex(r)].dataIndex = r;
    }, n.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, n.createTree = function(e, t, r) {
      var i = new n(t), a = [], o = 1;
      s(e);
      function s(c, d) {
        var f = c.value;
        o = Math.max(o, Me(f) ? f.length : 1), a.push(c);
        var p = new G4e(wr(c.name, ""), i);
        d ? U4e(p, d) : i.root = p, i._nodes.push(p);
        var h = c.children;
        if (h)
          for (var v = 0; v < h.length; v++)
            s(h[v], p);
      }
      i.root.updateDepthAndHeight(0);
      var l = Kg(a, {
        coordDimensions: ["value"],
        dimensionsCount: o
      }).dimensions, u = new Oi(l, t);
      return u.initData(a), r && r(u), kY({
        mainData: u,
        struct: i,
        structAttr: "tree"
      }), i.update(), i;
    }, n;
  }()
);
function U4e(n, e) {
  var t = e.children;
  n.parentNode !== e && (t.push(n), n.parentNode = e);
}
function pg(n, e, t) {
  if (n && Pt(e, n.type) >= 0) {
    var r = t.getData().tree.root, i = n.targetNode;
    if (We(i) && (i = r.getNodeById(i)), i && r.contains(i))
      return {
        node: i
      };
    var a = n.targetNodeId;
    if (a != null && (i = r.getNodeById(a)))
      return {
        node: i
      };
  }
}
function MY(n) {
  for (var e = []; n; )
    n = n.parentNode, n && e.push(n);
  return e.reverse();
}
function jO(n, e) {
  var t = MY(n);
  return Pt(t, e) >= 0;
}
function kw(n, e) {
  for (var t = []; n; ) {
    var r = n.dataIndex;
    t.push({
      name: n.name,
      dataIndex: r,
      value: e.getRawValue(r)
    }), n = n.parentNode;
  }
  return t.reverse(), t;
}
var W4e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.hasSymbolVisual = !0, t.ignoreStyleOnData = !0, t;
    }
    return e.prototype.getInitialData = function(t) {
      var r = {
        name: t.name,
        children: t.data
      }, i = t.leaves || {}, a = new yn(i, this, this.ecModel), o = PO.createTree(r, this, s);
      function s(d) {
        d.wrapMethod("getItemModel", function(f, p) {
          var h = o.getNodeByDataIndex(p);
          return h && h.children.length && h.isExpand || (f.parentModel = a), f;
        });
      }
      var l = 0;
      o.eachNode("preorder", function(d) {
        d.depth > l && (l = d.depth);
      });
      var u = t.expandAndCollapse, c = u && t.initialTreeDepth >= 0 ? t.initialTreeDepth : l;
      return o.root.eachNode("preorder", function(d) {
        var f = d.hostTree.data.getRawDataItem(d.dataIndex);
        d.isExpand = f && f.collapsed != null ? !f.collapsed : d.depth <= c;
      }), o.data;
    }, e.prototype.getOrient = function() {
      var t = this.get("orient");
      return t === "horizontal" ? t = "LR" : t === "vertical" && (t = "TB"), t;
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.formatTooltip = function(t, r, i) {
      for (var a = this.getData().tree, o = a.root.children[0], s = a.getNodeByDataIndex(t), l = s.getValue(), u = s.name; s && s !== o; )
        u = s.parentNode.name + "." + u, s = s.parentNode;
      return Rr("nameValue", {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null
      });
    }, e.prototype.getDataParams = function(t) {
      var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
      return r.treeAncestors = kw(i, this), r.collapsed = !i.isExpand, r;
    }, e.type = "series.tree", e.layoutMode = "box", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // the position of the whole view
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
      layout: "orthogonal",
      // value can be 'polyline'
      edgeShape: "curve",
      edgeForkPosition: "50%",
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.4,
      // Default on center of graph
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: !0,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        // borderColor: '#c23531',
        borderWidth: 1.5
      },
      label: {
        show: !0
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, e;
  }(Rn)
);
function q4e(n, e, t) {
  for (var r = [n], i = [], a; a = r.pop(); )
    if (i.push(a), a.isExpand) {
      var o = a.children;
      if (o.length)
        for (var s = 0; s < o.length; s++)
          r.push(o[s]);
    }
  for (; a = i.pop(); )
    e(a, t);
}
function pv(n, e) {
  for (var t = [n], r; r = t.pop(); )
    if (e(r), r.isExpand) {
      var i = r.children;
      if (i.length)
        for (var a = i.length - 1; a >= 0; a--)
          t.push(i[a]);
    }
}
function Y4e(n, e) {
  n.eachSeriesByType("tree", function(t) {
    K4e(t, e);
  });
}
function K4e(n, e) {
  var t = A4e(n, e);
  n.layoutInfo = t;
  var r = n.get("layout"), i = 0, a = 0, o = null;
  r === "radial" ? (i = 2 * Math.PI, a = Math.min(t.height, t.width) / 2, o = o4(function(b, _) {
    return (b.parentNode === _.parentNode ? 1 : 2) / b.depth;
  })) : (i = t.width, a = t.height, o = o4());
  var s = n.getData().tree.root, l = s.children[0];
  if (l) {
    T4e(s), q4e(l, C4e, o), s.hierNode.modifier = -l.hierNode.prelim, pv(l, k4e);
    var u = l, c = l, d = l;
    pv(l, function(b) {
      var _ = b.getLayout().x;
      _ < u.getLayout().x && (u = b), _ > c.getLayout().x && (c = b), b.depth > d.depth && (d = b);
    });
    var f = u === c ? 1 : o(u, c) / 2, p = f - u.getLayout().x, h = 0, v = 0, m = 0, g = 0;
    if (r === "radial")
      h = i / (c.getLayout().x + f + p), v = a / (d.depth - 1 || 1), pv(l, function(b) {
        m = (b.getLayout().x + p) * h, g = (b.depth - 1) * v;
        var _ = Rv(m, g);
        b.setLayout({
          x: _.x,
          y: _.y,
          rawX: m,
          rawY: g
        }, !0);
      });
    else {
      var y = n.getOrient();
      y === "RL" || y === "LR" ? (v = a / (c.getLayout().x + f + p), h = i / (d.depth - 1 || 1), pv(l, function(b) {
        g = (b.getLayout().x + p) * v, m = y === "LR" ? (b.depth - 1) * h : i - (b.depth - 1) * h, b.setLayout({
          x: m,
          y: g
        }, !0);
      })) : (y === "TB" || y === "BT") && (h = i / (c.getLayout().x + f + p), v = a / (d.depth - 1 || 1), pv(l, function(b) {
        m = (b.getLayout().x + p) * h, g = y === "TB" ? (b.depth - 1) * v : a - (b.depth - 1) * v, b.setLayout({
          x: m,
          y: g
        }, !0);
      }));
    }
  }
}
function X4e(n) {
  n.eachSeriesByType("tree", function(e) {
    var t = e.getData(), r = t.tree;
    r.eachNode(function(i) {
      var a = i.getModel(), o = a.getModel("itemStyle").getItemStyle(), s = t.ensureUniqueItemVisual(i.dataIndex, "style");
      xe(s, o);
    });
  });
}
function Z4e(n) {
  n.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(e, t) {
    t.eachComponent({
      mainType: "series",
      subType: "tree",
      query: e
    }, function(r) {
      var i = e.dataIndex, a = r.getData().tree, o = a.getNodeByDataIndex(i);
      o.isExpand = !o.isExpand;
    });
  }), n.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    // Here we set 'none' instead of 'update', because roam action
    // just need to update the transform matrix without having to recalculate
    // the layout. So don't need to go through the whole update process, such
    // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
    update: "none"
  }, function(e, t, r) {
    t.eachComponent({
      mainType: "series",
      subType: "tree",
      query: e
    }, function(i) {
      var a = i.coordinateSystem, o = NO(a, e, void 0, r);
      i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom);
    });
  });
}
function J4e(n) {
  n.registerChartView(P4e), n.registerSeriesModel(W4e), n.registerLayout(Y4e), n.registerVisual(X4e), Z4e(n);
}
var d4 = ["treemapZoomToNode", "treemapRender", "treemapMove"];
function Q4e(n) {
  for (var e = 0; e < d4.length; e++)
    n.registerAction({
      type: d4[e],
      update: "updateView"
    }, dr);
  n.registerAction({
    type: "treemapRootToNode",
    update: "updateView"
  }, function(t, r) {
    r.eachComponent({
      mainType: "series",
      subType: "treemap",
      query: t
    }, i);
    function i(a, o) {
      var s = ["treemapZoomToNode", "treemapRootToNode"], l = pg(t, s, a);
      if (l) {
        var u = a.getViewRoot();
        u && (t.direction = jO(u, l.node) ? "rollUp" : "drillDown"), a.resetViewRoot(l.node);
      }
    }
  });
}
function DY(n) {
  var e = n.getData(), t = e.tree, r = {};
  t.eachNode(function(i) {
    for (var a = i; a && a.depth > 1; )
      a = a.parentNode;
    var o = wk(n.ecModel, a.name || a.dataIndex + "", r);
    i.setVisual("decal", o);
  });
}
var e$e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.preventUsingHoverLayer = !0, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      var i = {
        name: t.name,
        children: t.data
      };
      OY(i);
      var a = t.levels || [], o = this.designatedVisualItemStyle = {}, s = new yn({
        itemStyle: o
      }, this, r);
      a = t.levels = t$e(a, r);
      var l = De(a || [], function(d) {
        return new yn(d, s, r);
      }, this), u = PO.createTree(i, this, c);
      function c(d) {
        d.wrapMethod("getItemModel", function(f, p) {
          var h = u.getNodeByDataIndex(p), v = h ? l[h.depth] : null;
          return f.parentModel = v || s, f;
        });
      }
      return u.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.formatTooltip = function(t, r, i) {
      var a = this.getData(), o = this.getRawValue(t), s = a.getName(t);
      return Rr("nameValue", {
        name: s,
        value: o
      });
    }, e.prototype.getDataParams = function(t) {
      var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
      return r.treeAncestors = kw(i, this), r.treePathInfo = r.treeAncestors, r;
    }, e.prototype.setLayoutInfo = function(t) {
      this.layoutInfo = this.layoutInfo || {}, xe(this.layoutInfo, t);
    }, e.prototype.mapIdToIndex = function(t) {
      var r = this._idIndexMap;
      r || (r = this._idIndexMap = tt(), this._idIndexMapCount = 0);
      var i = r.get(t);
      return i == null && r.set(t, i = this._idIndexMapCount++), i;
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(t) {
      t ? this._viewRoot = t : t = this._viewRoot;
      var r = this.getRawData().tree.root;
      (!t || t !== r && !r.contains(t)) && (this._viewRoot = r);
    }, e.prototype.enableAriaDecal = function() {
      DY(this);
    }, e.type = "series.treemap", e.layoutMode = "box", e.defaultOption = {
      // Disable progressive rendering
      progressive: 0,
      // size: ['80%', '80%'],            // deprecated, compatible with ec2.
      left: "center",
      top: "middle",
      width: "80%",
      height: "80%",
      sort: !0,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "▶",
      // to align specialized icon. ▷▶❒❐▼✚
      zoomToNodeRatio: 0.32 * 0.32,
      scaleLimit: null,
      roam: !0,
      nodeClick: "zoomToNode",
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: !0,
        height: 22,
        left: "center",
        top: "bottom",
        // right
        // bottom
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          textStyle: {
            color: "#fff"
          }
        },
        emphasis: {
          itemStyle: {
            color: "rgba(0,0,0,0.9)"
            // '#5793f3',
          }
        }
      },
      label: {
        show: !0,
        // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
        distance: 0,
        padding: 5,
        position: "inside",
        // formatter: null,
        color: "#fff",
        overflow: "truncate"
        // align
        // verticalAlign
      },
      upperLabel: {
        show: !1,
        position: [0, "50%"],
        height: 20,
        // formatter: null,
        // color: '#fff',
        overflow: "truncate",
        // align: null,
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
        // If specified, borderColor will be ineffective, and the
        // border color is evaluated by color of current node and
        // borderColorSaturation.
      },
      emphasis: {
        upperLabel: {
          show: !0,
          position: [0, "50%"],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      // level[n].color (if necessary).
      // + Specify color list of each level. level[0].color would be global
      // color list if not specified. (see method `setDefault`).
      // + But set as a empty array to forbid fetch color from global palette
      // when using nodeModel.get('color'), otherwise nodes on deep level
      // will always has color palette set and are not able to inherit color
      // from parent node.
      // + TreemapSeries.color can not be set as 'none', otherwise effect
      // legend color fetching (see seriesColor.js).
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      // be rendered. Only works when sort is 'asc' or 'desc'.
      childrenVisibleMin: null,
      // grandchildren will not show.
      // Why grandchildren? If not grandchildren but children,
      // some siblings show children and some not,
      // the appearance may be mess and not consistent,
      levels: []
      // Each item: {
      //     visibleMin, itemStyle, visualDimension, label
      // }
    }, e;
  }(Rn)
);
function OY(n) {
  var e = 0;
  $(n.children, function(r) {
    OY(r);
    var i = r.value;
    Me(i) && (i = i[0]), e += i;
  });
  var t = n.value;
  Me(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), Me(n.value) ? n.value[0] = t : n.value = t;
}
function t$e(n, e) {
  var t = wn(e.get("color")), r = wn(e.get(["aria", "decal", "decals"]));
  if (t) {
    n = n || [];
    var i, a;
    $(n, function(s) {
      var l = new yn(s), u = l.get("color"), c = l.get("decal");
      (l.get(["itemStyle", "color"]) || u && u !== "none") && (i = !0), (l.get(["itemStyle", "decal"]) || c && c !== "none") && (a = !0);
    });
    var o = n[0] || (n[0] = {});
    return i || (o.color = t.slice()), !a && r && (o.decal = r.slice()), n;
  }
}
var n$e = 8, f4 = 8, _E = 5, r$e = (
  /** @class */
  function() {
    function n(e) {
      this.group = new mt(), e.add(this.group);
    }
    return n.prototype.render = function(e, t, r, i) {
      var a = e.getModel("breadcrumb"), o = this.group;
      if (o.removeAll(), !(!a.get("show") || !r)) {
        var s = a.getModel("itemStyle"), l = a.getModel("emphasis"), u = s.getModel("textStyle"), c = l.getModel(["itemStyle", "textStyle"]), d = {
          pos: {
            left: a.get("left"),
            right: a.get("right"),
            top: a.get("top"),
            bottom: a.get("bottom")
          },
          box: {
            width: t.getWidth(),
            height: t.getHeight()
          },
          emptyItemWidth: a.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(r, d, u), this._renderContent(e, d, s, l, u, c, i), hw(o, d.pos, d.box);
      }
    }, n.prototype._prepare = function(e, t, r) {
      for (var i = e; i; i = i.parentNode) {
        var a = wr(i.getModel().get("name"), ""), o = r.getTextRect(a), s = Math.max(o.width + n$e * 2, t.emptyItemWidth);
        t.totalWidth += s + f4, t.renderList.push({
          node: i,
          text: a,
          width: s
        });
      }
    }, n.prototype._renderContent = function(e, t, r, i, a, o, s) {
      for (var l = 0, u = t.emptyItemWidth, c = e.get(["breadcrumb", "height"]), d = lNe(t.pos, t.box), f = t.totalWidth, p = t.renderList, h = i.getModel("itemStyle").getItemStyle(), v = p.length - 1; v >= 0; v--) {
        var m = p[v], g = m.node, y = m.width, b = m.text;
        f > d.width && (f -= y - u, y = u, b = null);
        var _ = new Vi({
          shape: {
            points: i$e(l, 0, y, c, v === p.length - 1, v === 0)
          },
          style: dt(r.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new nn({
            style: Ln(a, {
              text: b
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: ch * 1e4,
          onclick: Tt(s, g)
        });
        _.disableLabelAnimation = !0, _.getTextContent().ensureState("emphasis").style = Ln(o, {
          text: b
        }), _.ensureState("emphasis").style = h, er(_, i.get("focus"), i.get("blurScope"), i.get("disabled")), this.group.add(_), a$e(_, e, g), l += y + f4;
      }
    }, n.prototype.remove = function() {
      this.group.removeAll();
    }, n;
  }()
);
function i$e(n, e, t, r, i, a) {
  var o = [[i ? n : n - _E, e], [n + t, e], [n + t, e + r], [i ? n : n - _E, e + r]];
  return !a && o.splice(2, 0, [n + t + _E, e + r / 2]), !i && o.push([n, e + r / 2]), o;
}
function a$e(n, e, t) {
  yt(n).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: e.componentIndex,
    seriesIndex: e.seriesIndex,
    seriesName: e.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: t && t.dataIndex,
      name: t && t.name
    },
    treePathInfo: t && kw(t, e)
  };
}
var o$e = (
  /** @class */
  function() {
    function n() {
      this._storage = [], this._elExistsMap = {};
    }
    return n.prototype.add = function(e, t, r, i, a) {
      return this._elExistsMap[e.id] ? !1 : (this._elExistsMap[e.id] = !0, this._storage.push({
        el: e,
        target: t,
        duration: r,
        delay: i,
        easing: a
      }), !0);
    }, n.prototype.finished = function(e) {
      return this._finishedCallback = e, this;
    }, n.prototype.start = function() {
      for (var e = this, t = this._storage.length, r = function() {
        t--, t <= 0 && (e._storage.length = 0, e._elExistsMap = {}, e._finishedCallback && e._finishedCallback());
      }, i = 0, a = this._storage.length; i < a; i++) {
        var o = this._storage[i];
        o.el.animateTo(o.target, {
          duration: o.duration,
          delay: o.delay,
          easing: o.easing,
          setToFinal: !0,
          done: r,
          aborted: r
        });
      }
      return this;
    }, n;
  }()
);
function s$e() {
  return new o$e();
}
var Kk = mt, p4 = Qt, h4 = 3, v4 = "label", m4 = "upperLabel", l$e = ch * 10, u$e = ch * 2, c$e = ch * 3, Cc = Ld([
  ["fill", "color"],
  // `borderColor` and `borderWidth` has been occupied,
  // so use `stroke` to indicate the stroke of the rect.
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
]), g4 = function(n) {
  var e = Cc(n);
  return e.stroke = e.fill = e.lineWidth = null, e;
}, E_ = en(), d$e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._state = "ready", t._storage = hv(), t;
    }
    return e.prototype.render = function(t, r, i, a) {
      var o = r.findComponents({
        mainType: "series",
        subType: "treemap",
        query: a
      });
      if (!(Pt(o, t) < 0)) {
        this.seriesModel = t, this.api = i, this.ecModel = r;
        var s = ["treemapZoomToNode", "treemapRootToNode"], l = pg(a, s, t), u = a && a.type, c = t.layoutInfo, d = !this._oldTree, f = this._storage, p = u === "treemapRootToNode" && l && f ? {
          rootNodeGroup: f.nodeGroup[l.node.getRawIndex()],
          direction: a.direction
        } : null, h = this._giveContainerGroup(c), v = t.get("animation"), m = this._doRender(h, t, p);
        v && !d && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(h, m, t, p) : m.renderFinally(), this._resetController(i), this._renderBreadcrumb(t, i, l);
      }
    }, e.prototype._giveContainerGroup = function(t) {
      var r = this._containerGroup;
      return r || (r = this._containerGroup = new Kk(), this._initEvents(r), this.group.add(r)), r.x = t.x, r.y = t.y, r;
    }, e.prototype._doRender = function(t, r, i) {
      var a = r.getData().tree, o = this._oldTree, s = hv(), l = hv(), u = this._storage, c = [];
      function d(y, b, _, x) {
        return f$e(r, l, u, i, s, c, y, b, _, x);
      }
      v(a.root ? [a.root] : [], o && o.root ? [o.root] : [], t, a === o || !o, 0);
      var f = m(u);
      if (this._oldTree = a, this._storage = l, this._controllerHost) {
        var p = this.seriesModel.layoutInfo, h = a.root.getLayout();
        h.width === p.width && h.height === p.height && (this._controllerHost.zoom = 1);
      }
      return {
        lastsForAnimation: s,
        willDeleteEls: f,
        renderFinally: g
      };
      function v(y, b, _, x, w) {
        x ? (b = y, $(y, function(k, M) {
          !k.isRemoved() && C(M, M);
        })) : new Sl(b, y, S, S).add(C).update(C).remove(Tt(C, null)).execute();
        function S(k) {
          return k.getId();
        }
        function C(k, M) {
          var D = k != null ? y[k] : null, N = M != null ? b[M] : null, R = d(D, N, _, w);
          R && v(D && D.viewChildren || [], N && N.viewChildren || [], R, x, w + 1);
        }
      }
      function m(y) {
        var b = hv();
        return y && $(y, function(_, x) {
          var w = b[x];
          $(_, function(S) {
            S && (w.push(S), E_(S).willDelete = !0);
          });
        }), b;
      }
      function g() {
        $(f, function(y) {
          $(y, function(b) {
            b.parent && b.parent.remove(b);
          });
        }), $(c, function(y) {
          y.invisible = !0, y.dirty();
        });
      }
    }, e.prototype._doAnimation = function(t, r, i, a) {
      var o = i.get("animationDurationUpdate"), s = i.get("animationEasing"), l = (at(o) ? 0 : o) || 0, u = (at(s) ? null : s) || "cubicOut", c = s$e();
      $(r.willDeleteEls, function(d, f) {
        $(d, function(p, h) {
          if (!p.invisible) {
            var v = p.parent, m, g = E_(v);
            if (a && a.direction === "drillDown")
              m = v === a.rootNodeGroup ? {
                shape: {
                  x: 0,
                  y: 0,
                  width: g.nodeWidth,
                  height: g.nodeHeight
                },
                style: {
                  opacity: 0
                }
              } : {
                style: {
                  opacity: 0
                }
              };
            else {
              var y = 0, b = 0;
              g.willDelete || (y = g.nodeWidth / 2, b = g.nodeHeight / 2), m = f === "nodeGroup" ? {
                x: y,
                y: b,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: y,
                  y: b,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            m && c.add(p, m, l, 0, u);
          }
        });
      }), $(this._storage, function(d, f) {
        $(d, function(p, h) {
          var v = r.lastsForAnimation[f][h], m = {};
          v && (p instanceof mt ? v.oldX != null && (m.x = p.x, m.y = p.y, p.x = v.oldX, p.y = v.oldY) : (v.oldShape && (m.shape = xe({}, p.shape), p.setShape(v.oldShape)), v.fadein ? (p.setStyle("opacity", 0), m.style = {
            opacity: 1
          }) : p.style.opacity !== 1 && (m.style = {
            opacity: 1
          })), c.add(p, m, l, 0, u));
        });
      }, this), this._state = "animating", c.finished(Ze(function() {
        this._state = "ready", r.renderFinally();
      }, this)).start();
    }, e.prototype._resetController = function(t) {
      var r = this._controller, i = this._controllerHost;
      i || (this._controllerHost = {
        target: this.group
      }, i = this._controllerHost), r || (r = this._controller = new ry(t.getZr()), r.enable(this.seriesModel.get("roam")), i.zoomLimit = this.seriesModel.get("scaleLimit"), i.zoom = this.seriesModel.get("zoom"), r.on("pan", Ze(this._onPan, this)), r.on("zoom", Ze(this._onZoom, this)));
      var a = new Ot(0, 0, t.getWidth(), t.getHeight());
      r.setPointerChecker(function(o, s, l) {
        return a.contain(s, l);
      });
    }, e.prototype._clearController = function() {
      var t = this._controller;
      this._controllerHost = null, t && (t.dispose(), t = null);
    }, e.prototype._onPan = function(t) {
      if (this._state !== "animating" && (Math.abs(t.dx) > h4 || Math.abs(t.dy) > h4)) {
        var r = this.seriesModel.getData().tree.root;
        if (!r)
          return;
        var i = r.getLayout();
        if (!i)
          return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: i.x + t.dx,
            y: i.y + t.dy,
            width: i.width,
            height: i.height
          }
        });
      }
    }, e.prototype._onZoom = function(t) {
      var r = t.originX, i = t.originY, a = t.scale;
      if (this._state !== "animating") {
        var o = this.seriesModel.getData().tree.root;
        if (!o)
          return;
        var s = o.getLayout();
        if (!s)
          return;
        var l = new Ot(s.x, s.y, s.width, s.height), u = null, c = this._controllerHost;
        u = c.zoomLimit;
        var d = c.zoom = c.zoom || 1;
        if (d *= a, u) {
          var f = u.min || 0, p = u.max || 1 / 0;
          d = Math.max(Math.min(p, d), f);
        }
        var h = d / c.zoom;
        c.zoom = d;
        var v = this.seriesModel.layoutInfo;
        r -= v.x, i -= v.y;
        var m = ya();
        ws(m, m, [-r, -i]), kD(m, m, [h, h]), ws(m, m, [r, i]), l.applyTransform(m), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: l.x,
            y: l.y,
            width: l.width,
            height: l.height
          }
        });
      }
    }, e.prototype._initEvents = function(t) {
      var r = this;
      t.on("click", function(i) {
        if (r._state === "ready") {
          var a = r.seriesModel.get("nodeClick", !0);
          if (a) {
            var o = r.findTarget(i.offsetX, i.offsetY);
            if (o) {
              var s = o.node;
              if (s.getLayout().isLeafRoot)
                r._rootToNode(o);
              else if (a === "zoomToNode")
                r._zoomToNode(o);
              else if (a === "link") {
                var l = s.hostTree.data.getItemModel(s.dataIndex), u = l.get("link", !0), c = l.get("target", !0) || "blank";
                u && o_(u, c);
              }
            }
          }
        }
      }, this);
    }, e.prototype._renderBreadcrumb = function(t, r, i) {
      var a = this;
      i || (i = t.get("leafDepth", !0) != null ? {
        node: t.getViewRoot()
      } : this.findTarget(r.getWidth() / 2, r.getHeight() / 2), i || (i = {
        node: t.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new r$e(this.group))).render(t, r, i.node, function(o) {
        a._state !== "animating" && (jO(t.getViewRoot(), o) ? a._rootToNode({
          node: o
        }) : a._zoomToNode({
          node: o
        }));
      });
    }, e.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = hv(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, e.prototype.dispose = function() {
      this._clearController();
    }, e.prototype._zoomToNode = function(t) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t.node
      });
    }, e.prototype._rootToNode = function(t) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t.node
      });
    }, e.prototype.findTarget = function(t, r) {
      var i, a = this.seriesModel.getViewRoot();
      return a.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(o) {
        var s = this._storage.background[o.getRawIndex()];
        if (s) {
          var l = s.transformCoordToLocal(t, r), u = s.shape;
          if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height)
            i = {
              node: o,
              offsetX: l[0],
              offsetY: l[1]
            };
          else
            return !1;
        }
      }, this), i;
    }, e.type = "treemap", e;
  }(Tn)
);
function hv() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function f$e(n, e, t, r, i, a, o, s, l, u) {
  if (!o)
    return;
  var c = o.getLayout(), d = n.getData(), f = o.getModel();
  if (d.setItemGraphicEl(o.dataIndex, null), !c || !c.isInView)
    return;
  var p = c.width, h = c.height, v = c.borderWidth, m = c.invisible, g = o.getRawIndex(), y = s && s.getRawIndex(), b = o.viewChildren, _ = c.upperHeight, x = b && b.length, w = f.getModel("itemStyle"), S = f.getModel(["emphasis", "itemStyle"]), C = f.getModel(["blur", "itemStyle"]), k = f.getModel(["select", "itemStyle"]), M = w.get("borderRadius") || 0, D = pe("nodeGroup", Kk);
  if (!D)
    return;
  if (l.add(D), D.x = c.x || 0, D.y = c.y || 0, D.markRedraw(), E_(D).nodeWidth = p, E_(D).nodeHeight = h, c.isAboveViewRoot)
    return D;
  var N = pe("background", p4, u, u$e);
  N && ne(D, N, x && c.upperLabelHeight);
  var R = f.getModel("emphasis"), j = R.get("focus"), z = R.get("blurScope"), F = R.get("disabled"), B = j === "ancestor" ? o.getAncestorsIndices() : j === "descendant" ? o.getDescendantIndices() : j;
  if (x)
    Ru(D) && Uc(D, !1), N && (Uc(N, !F), d.setItemGraphicEl(o.dataIndex, N), pk(N, B, z));
  else {
    var H = pe("content", p4, u, c$e);
    H && J(D, H), N.disableMorphing = !0, N && Ru(N) && Uc(N, !1), Uc(D, !F), d.setItemGraphicEl(o.dataIndex, D);
    var Y = f.getShallow("cursor");
    Y && H.attr("cursor", Y), pk(D, B, z);
  }
  return D;
  function ne(Ee, ce, Pe) {
    var Ae = yt(ce);
    if (Ae.dataIndex = o.dataIndex, Ae.seriesIndex = n.seriesIndex, ce.setShape({
      x: 0,
      y: 0,
      width: p,
      height: h,
      r: M
    }), m)
      X(ce);
    else {
      ce.invisible = !1;
      var fe = o.getVisual("style"), oe = fe.stroke, he = g4(w);
      he.fill = oe;
      var Oe = Cc(S);
      Oe.fill = S.get("borderColor");
      var Te = Cc(C);
      Te.fill = C.get("borderColor");
      var Ge = Cc(k);
      if (Ge.fill = k.get("borderColor"), Pe) {
        var je = p - 2 * v;
        ie(
          // PENDING: convert ZRColor to ColorString for text.
          ce,
          oe,
          fe.opacity,
          {
            x: v,
            y: 0,
            width: je,
            height: _
          }
        );
      } else
        ce.removeTextContent();
      ce.setStyle(he), ce.ensureState("emphasis").style = Oe, ce.ensureState("blur").style = Te, ce.ensureState("select").style = Ge, Nd(ce);
    }
    Ee.add(ce);
  }
  function J(Ee, ce) {
    var Pe = yt(ce);
    Pe.dataIndex = o.dataIndex, Pe.seriesIndex = n.seriesIndex;
    var Ae = Math.max(p - 2 * v, 0), fe = Math.max(h - 2 * v, 0);
    if (ce.culling = !0, ce.setShape({
      x: v,
      y: v,
      width: Ae,
      height: fe,
      r: M
    }), m)
      X(ce);
    else {
      ce.invisible = !1;
      var oe = o.getVisual("style"), he = oe.fill, Oe = g4(w);
      Oe.fill = he, Oe.decal = oe.decal;
      var Te = Cc(S), Ge = Cc(C), je = Cc(k);
      ie(ce, he, oe.opacity, null), ce.setStyle(Oe), ce.ensureState("emphasis").style = Te, ce.ensureState("blur").style = Ge, ce.ensureState("select").style = je, Nd(ce);
    }
    Ee.add(ce);
  }
  function X(Ee) {
    !Ee.invisible && a.push(Ee);
  }
  function ie(Ee, ce, Pe, Ae) {
    var fe = f.getModel(Ae ? m4 : v4), oe = wr(f.get("name"), null), he = fe.getShallow("show");
    ei(Ee, Nr(f, Ae ? m4 : v4), {
      defaultText: he ? oe : null,
      inheritColor: ce,
      defaultOpacity: Pe,
      labelFetcher: n,
      labelDataIndex: o.dataIndex
    });
    var Oe = Ee.getTextContent();
    if (Oe) {
      var Te = Oe.style, Ge = ED(Te.padding || 0);
      Ae && (Ee.setTextConfig({
        layoutRect: Ae
      }), Oe.disableLabelLayout = !0), Oe.beforeUpdate = function() {
        var Qe = Math.max((Ae ? Ae.width : Ee.shape.width) - Ge[1] - Ge[3], 0), ot = Math.max((Ae ? Ae.height : Ee.shape.height) - Ge[0] - Ge[2], 0);
        (Te.width !== Qe || Te.height !== ot) && Oe.setStyle({
          width: Qe,
          height: ot
        });
      }, Te.truncateMinChar = 2, Te.lineOverflow = "truncate", ye(Te, Ae, c);
      var je = Oe.getState("emphasis");
      ye(je ? je.style : null, Ae, c);
    }
  }
  function ye(Ee, ce, Pe) {
    var Ae = Ee ? Ee.text : null;
    if (!ce && Pe.isLeafRoot && Ae != null) {
      var fe = n.get("drillDownIcon", !0);
      Ee.text = fe ? fe + " " + Ae : Ae;
    }
  }
  function pe(Ee, ce, Pe, Ae) {
    var fe = y != null && t[Ee][y], oe = i[Ee];
    return fe ? (t[Ee][y] = null, Be(oe, fe)) : m || (fe = new ce(), fe instanceof no && (fe.z2 = p$e(Pe, Ae)), Ce(oe, fe)), e[Ee][g] = fe;
  }
  function Be(Ee, ce) {
    var Pe = Ee[g] = {};
    ce instanceof Kk ? (Pe.oldX = ce.x, Pe.oldY = ce.y) : Pe.oldShape = xe({}, ce.shape);
  }
  function Ce(Ee, ce) {
    var Pe = Ee[g] = {}, Ae = o.parentNode, fe = ce instanceof mt;
    if (Ae && (!r || r.direction === "drillDown")) {
      var oe = 0, he = 0, Oe = i.background[Ae.getRawIndex()];
      !r && Oe && Oe.oldShape && (oe = Oe.oldShape.width, he = Oe.oldShape.height), fe ? (Pe.oldX = 0, Pe.oldY = he) : Pe.oldShape = {
        x: oe,
        y: he,
        width: 0,
        height: 0
      };
    }
    Pe.fadein = !fe;
  }
}
function p$e(n, e) {
  return n * l$e + e;
}
var hg = $, h$e = ut, T_ = -1, Lr = (
  /** @class */
  function() {
    function n(e) {
      var t = e.mappingMethod, r = e.type, i = this.option = ht(e);
      this.type = r, this.mappingMethod = t, this._normalizeData = g$e[t];
      var a = n.visualHandlers[r];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[t], t === "piecewise" ? (xE(i), v$e(i)) : t === "category" ? i.categories ? m$e(i) : xE(i, !0) : (ct(t !== "linear" || i.dataExtent), xE(i));
    }
    return n.prototype.mapValueToVisual = function(e) {
      var t = this._normalizeData(e);
      return this._normalizedToVisual(t, e);
    }, n.prototype.getNormalizer = function() {
      return Ze(this._normalizeData, this);
    }, n.listVisualTypes = function() {
      return Yt(n.visualHandlers);
    }, n.isValidType = function(e) {
      return n.visualHandlers.hasOwnProperty(e);
    }, n.eachVisual = function(e, t, r) {
      ut(e) ? $(e, t, r) : t.call(r, e);
    }, n.mapVisual = function(e, t, r) {
      var i, a = Me(e) ? [] : ut(e) ? {} : (i = !0, null);
      return n.eachVisual(e, function(o, s) {
        var l = t.call(r, o, s);
        i ? a = l : a[s] = l;
      }), a;
    }, n.retrieveVisuals = function(e) {
      var t = {}, r;
      return e && hg(n.visualHandlers, function(i, a) {
        e.hasOwnProperty(a) && (t[a] = e[a], r = !0);
      }), r ? t : null;
    }, n.prepareVisualTypes = function(e) {
      if (Me(e))
        e = e.slice();
      else if (h$e(e)) {
        var t = [];
        hg(e, function(r, i) {
          t.push(i);
        }), e = t;
      } else
        return [];
      return e.sort(function(r, i) {
        return i === "color" && r !== "color" && r.indexOf("color") === 0 ? 1 : -1;
      }), e;
    }, n.dependsOn = function(e, t) {
      return t === "color" ? !!(e && e.indexOf(t) === 0) : e === t;
    }, n.findPieceIndex = function(e, t, r) {
      for (var i, a = 1 / 0, o = 0, s = t.length; o < s; o++) {
        var l = t[o].value;
        if (l != null) {
          if (l === e || We(l) && l === e + "")
            return o;
          r && f(l, o);
        }
      }
      for (var o = 0, s = t.length; o < s; o++) {
        var u = t[o], c = u.interval, d = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (F0(d[1], e, c[1]))
              return o;
          } else if (c[1] === 1 / 0) {
            if (F0(d[0], c[0], e))
              return o;
          } else if (F0(d[0], c[0], e) && F0(d[1], e, c[1]))
            return o;
          r && f(c[0], o), r && f(c[1], o);
        }
      }
      if (r)
        return e === 1 / 0 ? t.length - 1 : e === -1 / 0 ? 0 : i;
      function f(p, h) {
        var v = Math.abs(p - e);
        v < a && (a = v, i = h);
      }
    }, n.visualHandlers = {
      color: {
        applyVisual: vv("color"),
        getColorMapper: function() {
          var e = this.option;
          return Ze(e.mappingMethod === "category" ? function(t, r) {
            return !r && (t = this._normalizeData(t)), Pv.call(this, t);
          } : function(t, r, i) {
            var a = !!i;
            return !r && (t = this._normalizeData(t)), i = QS(t, e.parsedVisual, i), a ? i : dl(i, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(e) {
            return dl(QS(e, this.option.parsedVisual), "rgba");
          },
          category: Pv,
          piecewise: function(e, t) {
            var r = Zk.call(this, t);
            return r == null && (r = dl(QS(e, this.option.parsedVisual), "rgba")), r;
          },
          fixed: kc
        }
      },
      colorHue: z0(function(e, t) {
        return sm(e, t);
      }),
      colorSaturation: z0(function(e, t) {
        return sm(e, null, t);
      }),
      colorLightness: z0(function(e, t) {
        return sm(e, null, null, t);
      }),
      colorAlpha: z0(function(e, t) {
        return Yb(e, t);
      }),
      decal: {
        applyVisual: vv("decal"),
        _normalizedToVisual: {
          linear: null,
          category: Pv,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: vv("opacity"),
        _normalizedToVisual: Xk([0, 1])
      },
      liftZ: {
        applyVisual: vv("liftZ"),
        _normalizedToVisual: {
          linear: kc,
          category: kc,
          piecewise: kc,
          fixed: kc
        }
      },
      symbol: {
        applyVisual: function(e, t, r) {
          var i = this.mapValueToVisual(e);
          r("symbol", i);
        },
        _normalizedToVisual: {
          linear: y4,
          category: Pv,
          piecewise: function(e, t) {
            var r = Zk.call(this, t);
            return r == null && (r = y4.call(this, e)), r;
          },
          fixed: kc
        }
      },
      symbolSize: {
        applyVisual: vv("symbolSize"),
        _normalizedToVisual: Xk([0, 1])
      }
    }, n;
  }()
);
function v$e(n) {
  var e = n.pieceList;
  n.hasSpecialVisual = !1, $(e, function(t, r) {
    t.originIndex = r, t.visual != null && (n.hasSpecialVisual = !0);
  });
}
function m$e(n) {
  var e = n.categories, t = n.categoryMap = {}, r = n.visual;
  if (hg(e, function(o, s) {
    t[o] = s;
  }), !Me(r)) {
    var i = [];
    ut(r) ? hg(r, function(o, s) {
      var l = t[s];
      i[l ?? T_] = o;
    }) : i[T_] = r, r = IY(n, i);
  }
  for (var a = e.length - 1; a >= 0; a--)
    r[a] == null && (delete t[e[a]], e.pop());
}
function xE(n, e) {
  var t = n.visual, r = [];
  ut(t) ? hg(t, function(a) {
    r.push(a);
  }) : t != null && r.push(t);
  var i = {
    color: 1,
    symbol: 1
  };
  !e && r.length === 1 && !i.hasOwnProperty(n.type) && (r[1] = r[0]), IY(n, r);
}
function z0(n) {
  return {
    applyVisual: function(e, t, r) {
      var i = this.mapValueToVisual(e);
      r("color", n(t("color"), i));
    },
    _normalizedToVisual: Xk([0, 1])
  };
}
function y4(n) {
  var e = this.option.visual;
  return e[Math.round(mn(n, [0, 1], [0, e.length - 1], !0))] || {};
}
function vv(n) {
  return function(e, t, r) {
    r(n, this.mapValueToVisual(e));
  };
}
function Pv(n) {
  var e = this.option.visual;
  return e[this.option.loop && n !== T_ ? n % e.length : n];
}
function kc() {
  return this.option.visual[0];
}
function Xk(n) {
  return {
    linear: function(e) {
      return mn(e, n, this.option.visual, !0);
    },
    category: Pv,
    piecewise: function(e, t) {
      var r = Zk.call(this, t);
      return r == null && (r = mn(e, n, this.option.visual, !0)), r;
    },
    fixed: kc
  };
}
function Zk(n) {
  var e = this.option, t = e.pieceList;
  if (e.hasSpecialVisual) {
    var r = Lr.findPieceIndex(n, t), i = t[r];
    if (i && i.visual)
      return i.visual[this.type];
  }
}
function IY(n, e) {
  return n.visual = e, n.type === "color" && (n.parsedVisual = De(e, function(t) {
    var r = ba(t);
    return !r && process.env.NODE_ENV !== "production" && Jn("'" + t + "' is an illegal color, fallback to '#000000'", !0), r || [0, 0, 0, 1];
  })), e;
}
var g$e = {
  linear: function(n) {
    return mn(n, this.option.dataExtent, [0, 1], !0);
  },
  piecewise: function(n) {
    var e = this.option.pieceList, t = Lr.findPieceIndex(n, e, !0);
    if (t != null)
      return mn(t, [0, e.length - 1], [0, 1], !0);
  },
  category: function(n) {
    var e = this.option.categories ? this.option.categoryMap[n] : n;
    return e ?? T_;
  },
  fixed: dr
};
function F0(n, e, t) {
  return n ? e <= t : e < t;
}
var y$e = "itemStyle", LY = en();
const b$e = {
  seriesType: "treemap",
  reset: function(n) {
    var e = n.getData().tree, t = e.root;
    t.isRemoved() || NY(
      t,
      // Visual should calculate from tree root but not view root.
      {},
      n.getViewRoot().getAncestors(),
      n
    );
  }
};
function NY(n, e, t, r) {
  var i = n.getModel(), a = n.getLayout(), o = n.hostTree.data;
  if (!(!a || a.invisible || !a.isInView)) {
    var s = i.getModel(y$e), l = _$e(s, e, r), u = o.ensureUniqueItemVisual(n.dataIndex, "style"), c = s.get("borderColor"), d = s.get("borderColorSaturation"), f;
    d != null && (f = b4(l), c = x$e(d, f)), u.stroke = c;
    var p = n.viewChildren;
    if (!p || !p.length)
      f = b4(l), u.fill = f;
    else {
      var h = w$e(n, i, a, s, l, p);
      $(p, function(v, m) {
        if (v.depth >= t.length || v === t[v.depth]) {
          var g = S$e(i, l, v, m, h, r);
          NY(v, g, t, r);
        }
      });
    }
  }
}
function _$e(n, e, t) {
  var r = xe({}, e), i = t.designatedVisualItemStyle;
  return $(["color", "colorAlpha", "colorSaturation"], function(a) {
    i[a] = e[a];
    var o = n.get(a);
    i[a] = null, o != null && (r[a] = o);
  }), r;
}
function b4(n) {
  var e = wE(n, "color");
  if (e) {
    var t = wE(n, "colorAlpha"), r = wE(n, "colorSaturation");
    return r && (e = sm(e, null, null, r)), t && (e = Yb(e, t)), e;
  }
}
function x$e(n, e) {
  return e != null ? sm(e, null, null, n) : null;
}
function wE(n, e) {
  var t = n[e];
  if (t != null && t !== "none")
    return t;
}
function w$e(n, e, t, r, i, a) {
  if (!(!a || !a.length)) {
    var o = SE(e, "color") || i.color != null && i.color !== "none" && (SE(e, "colorAlpha") || SE(e, "colorSaturation"));
    if (o) {
      var s = e.get("visualMin"), l = e.get("visualMax"), u = t.dataExtent.slice();
      s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l);
      var c = e.get("colorMappingBy"), d = {
        type: o.name,
        dataExtent: u,
        visual: o.range
      };
      d.type === "color" && (c === "index" || c === "id") ? (d.mappingMethod = "category", d.loop = !0) : d.mappingMethod = "linear";
      var f = new Lr(d);
      return LY(f).drColorMappingBy = c, f;
    }
  }
}
function SE(n, e) {
  var t = n.get(e);
  return Me(t) && t.length ? {
    name: e,
    range: t
  } : null;
}
function S$e(n, e, t, r, i, a) {
  var o = xe({}, e);
  if (i) {
    var s = i.type, l = s === "color" && LY(i).drColorMappingBy, u = l === "index" ? r : l === "id" ? a.mapIdToIndex(t.getId()) : t.getValue(n.get("visualDimension"));
    o[s] = i.mapValueToVisual(u);
  }
  return o;
}
var vg = Math.max, C_ = Math.min, _4 = mr, BO = $, RY = ["itemStyle", "borderWidth"], E$e = ["itemStyle", "gapWidth"], T$e = ["upperLabel", "show"], C$e = ["upperLabel", "height"];
const k$e = {
  seriesType: "treemap",
  reset: function(n, e, t, r) {
    var i = t.getWidth(), a = t.getHeight(), o = n.option, s = Er(n.getBoxLayoutParams(), {
      width: t.getWidth(),
      height: t.getHeight()
    }), l = o.size || [], u = ze(_4(s.width, l[0]), i), c = ze(_4(s.height, l[1]), a), d = r && r.type, f = ["treemapZoomToNode", "treemapRootToNode"], p = pg(r, f, n), h = d === "treemapRender" || d === "treemapMove" ? r.rootRect : null, v = n.getViewRoot(), m = MY(v);
    if (d !== "treemapMove") {
      var g = d === "treemapZoomToNode" ? L$e(n, p, v, u, c) : h ? [h.width, h.height] : [u, c], y = o.sort;
      y && y !== "asc" && y !== "desc" && (y = "desc");
      var b = {
        squareRatio: o.squareRatio,
        sort: y,
        leafDepth: o.leafDepth
      };
      v.hostTree.clearLayouts();
      var _ = {
        x: 0,
        y: 0,
        width: g[0],
        height: g[1],
        area: g[0] * g[1]
      };
      v.setLayout(_), PY(v, b, !1, 0), _ = v.getLayout(), BO(m, function(w, S) {
        var C = (m[S + 1] || v).getValue();
        w.setLayout(xe({
          dataExtent: [C, C],
          borderWidth: 0,
          upperHeight: 0
        }, _));
      });
    }
    var x = n.getData().tree.root;
    x.setLayout(N$e(s, h, p), !0), n.setLayoutInfo(s), jY(
      x,
      // Transform to base element coordinate system.
      new Ot(-s.x, -s.y, i, a),
      m,
      v,
      0
    );
  }
};
function PY(n, e, t, r) {
  var i, a;
  if (!n.isRemoved()) {
    var o = n.getLayout();
    i = o.width, a = o.height;
    var s = n.getModel(), l = s.get(RY), u = s.get(E$e) / 2, c = BY(s), d = Math.max(l, c), f = l - u, p = d - u;
    n.setLayout({
      borderWidth: l,
      upperHeight: d,
      upperLabelHeight: c
    }, !0), i = vg(i - 2 * f, 0), a = vg(a - f - p, 0);
    var h = i * a, v = A$e(n, s, h, e, t, r);
    if (v.length) {
      var m = {
        x: f,
        y: p,
        width: i,
        height: a
      }, g = C_(i, a), y = 1 / 0, b = [];
      b.area = 0;
      for (var _ = 0, x = v.length; _ < x; ) {
        var w = v[_];
        b.push(w), b.area += w.getLayout().area;
        var S = I$e(b, g, e.squareRatio);
        S <= y ? (_++, y = S) : (b.area -= b.pop().getLayout().area, x4(b, g, m, u, !1), g = C_(m.width, m.height), b.length = b.area = 0, y = 1 / 0);
      }
      if (b.length && x4(b, g, m, u, !0), !t) {
        var C = s.get("childrenVisibleMin");
        C != null && h < C && (t = !0);
      }
      for (var _ = 0, x = v.length; _ < x; _++)
        PY(v[_], e, t, r + 1);
    }
  }
}
function A$e(n, e, t, r, i, a) {
  var o = n.children || [], s = r.sort;
  s !== "asc" && s !== "desc" && (s = null);
  var l = r.leafDepth != null && r.leafDepth <= a;
  if (i && !l)
    return n.viewChildren = [];
  o = vn(o, function(p) {
    return !p.isRemoved();
  }), D$e(o, s);
  var u = O$e(e, o, s);
  if (u.sum === 0)
    return n.viewChildren = [];
  if (u.sum = M$e(e, t, u.sum, s, o), u.sum === 0)
    return n.viewChildren = [];
  for (var c = 0, d = o.length; c < d; c++) {
    var f = o[c].getValue() / u.sum * t;
    o[c].setLayout({
      area: f
    });
  }
  return l && (o.length && n.setLayout({
    isLeafRoot: !0
  }, !0), o.length = 0), n.viewChildren = o, n.setLayout({
    dataExtent: u.dataExtent
  }, !0), o;
}
function M$e(n, e, t, r, i) {
  if (!r)
    return t;
  for (var a = n.get("visibleMin"), o = i.length, s = o, l = o - 1; l >= 0; l--) {
    var u = i[r === "asc" ? o - l - 1 : l].getValue();
    u / t * e < a && (s = l, t -= u);
  }
  return r === "asc" ? i.splice(0, o - s) : i.splice(s, o - s), t;
}
function D$e(n, e) {
  return e && n.sort(function(t, r) {
    var i = e === "asc" ? t.getValue() - r.getValue() : r.getValue() - t.getValue();
    return i === 0 ? e === "asc" ? t.dataIndex - r.dataIndex : r.dataIndex - t.dataIndex : i;
  }), n;
}
function O$e(n, e, t) {
  for (var r = 0, i = 0, a = e.length; i < a; i++)
    r += e[i].getValue();
  var o = n.get("visualDimension"), s;
  return !e || !e.length ? s = [NaN, NaN] : o === "value" && t ? (s = [e[e.length - 1].getValue(), e[0].getValue()], t === "asc" && s.reverse()) : (s = [1 / 0, -1 / 0], BO(e, function(l) {
    var u = l.getValue(o);
    u < s[0] && (s[0] = u), u > s[1] && (s[1] = u);
  })), {
    sum: r,
    dataExtent: s
  };
}
function I$e(n, e, t) {
  for (var r = 0, i = 1 / 0, a = 0, o = void 0, s = n.length; a < s; a++)
    o = n[a].getLayout().area, o && (o < i && (i = o), o > r && (r = o));
  var l = n.area * n.area, u = e * e * t;
  return l ? vg(u * r / l, l / (u * i)) : 1 / 0;
}
function x4(n, e, t, r, i) {
  var a = e === t.width ? 0 : 1, o = 1 - a, s = ["x", "y"], l = ["width", "height"], u = t[s[a]], c = e ? n.area / e : 0;
  (i || c > t[l[o]]) && (c = t[l[o]]);
  for (var d = 0, f = n.length; d < f; d++) {
    var p = n[d], h = {}, v = c ? p.getLayout().area / c : 0, m = h[l[o]] = vg(c - 2 * r, 0), g = t[s[a]] + t[l[a]] - u, y = d === f - 1 || g < v ? g : v, b = h[l[a]] = vg(y - 2 * r, 0);
    h[s[o]] = t[s[o]] + C_(r, m / 2), h[s[a]] = u + C_(r, b / 2), u += y, p.setLayout(h, !0);
  }
  t[s[o]] += c, t[l[o]] -= c;
}
function L$e(n, e, t, r, i) {
  var a = (e || {}).node, o = [r, i];
  if (!a || a === t)
    return o;
  for (var s, l = r * i, u = l * n.option.zoomToNodeRatio; s = a.parentNode; ) {
    for (var c = 0, d = s.children, f = 0, p = d.length; f < p; f++)
      c += d[f].getValue();
    var h = a.getValue();
    if (h === 0)
      return o;
    u *= c / h;
    var v = s.getModel(), m = v.get(RY), g = Math.max(m, BY(v));
    u += 4 * m * m + (3 * m + g) * Math.pow(u, 0.5), u > I3 && (u = I3), a = s;
  }
  u < l && (u = l);
  var y = Math.pow(u / l, 0.5);
  return [r * y, i * y];
}
function N$e(n, e, t) {
  if (e)
    return {
      x: e.x,
      y: e.y
    };
  var r = {
    x: 0,
    y: 0
  };
  if (!t)
    return r;
  var i = t.node, a = i.getLayout();
  if (!a)
    return r;
  for (var o = [a.width / 2, a.height / 2], s = i; s; ) {
    var l = s.getLayout();
    o[0] += l.x, o[1] += l.y, s = s.parentNode;
  }
  return {
    x: n.width / 2 - o[0],
    y: n.height / 2 - o[1]
  };
}
function jY(n, e, t, r, i) {
  var a = n.getLayout(), o = t[i], s = o && o === n;
  if (!(o && !s || i === t.length && n !== r)) {
    n.setLayout({
      // isInView means: viewRoot sub tree + viewAbovePath
      isInView: !0,
      // invisible only means: outside view clip so that the node can not
      // see but still layout for animation preparation but not render.
      invisible: !s && !e.intersect(a),
      isAboveViewRoot: s
    }, !0);
    var l = new Ot(e.x - a.x, e.y - a.y, e.width, e.height);
    BO(n.viewChildren || [], function(u) {
      jY(u, l, t, r, i + 1);
    });
  }
}
function BY(n) {
  return n.get(T$e) ? n.get(C$e) : 0;
}
function R$e(n) {
  n.registerSeriesModel(e$e), n.registerChartView(d$e), n.registerVisual(b$e), n.registerLayout(k$e), Q4e(n);
}
function P$e(n) {
  var e = n.findComponents({
    mainType: "legend"
  });
  !e || !e.length || n.eachSeriesByType("graph", function(t) {
    var r = t.getCategoriesData(), i = t.getGraph(), a = i.data, o = r.mapArray(r.getName);
    a.filterSelf(function(s) {
      var l = a.getItemModel(s), u = l.getShallow("category");
      if (u != null) {
        sn(u) && (u = o[u]);
        for (var c = 0; c < e.length; c++)
          if (!e[c].isSelected(u))
            return !1;
      }
      return !0;
    });
  });
}
function j$e(n) {
  var e = {};
  n.eachSeriesByType("graph", function(t) {
    var r = t.getCategoriesData(), i = t.getData(), a = {};
    r.each(function(o) {
      var s = r.getName(o);
      a["ec-" + s] = o;
      var l = r.getItemModel(o), u = l.getModel("itemStyle").getItemStyle();
      u.fill || (u.fill = t.getColorFromPalette(s, e)), r.setItemVisual(o, "style", u);
      for (var c = ["symbol", "symbolSize", "symbolKeepAspect"], d = 0; d < c.length; d++) {
        var f = l.getShallow(c[d], !0);
        f != null && r.setItemVisual(o, c[d], f);
      }
    }), r.count() && i.each(function(o) {
      var s = i.getItemModel(o), l = s.getShallow("category");
      if (l != null) {
        We(l) && (l = a["ec-" + l]);
        var u = r.getItemVisual(l, "style"), c = i.ensureUniqueItemVisual(o, "style");
        xe(c, u);
        for (var d = ["symbol", "symbolSize", "symbolKeepAspect"], f = 0; f < d.length; f++)
          i.setItemVisual(o, d[f], r.getItemVisual(l, d[f]));
      }
    });
  });
}
function V0(n) {
  return n instanceof Array || (n = [n, n]), n;
}
function B$e(n) {
  n.eachSeriesByType("graph", function(e) {
    var t = e.getGraph(), r = e.getEdgeData(), i = V0(e.get("edgeSymbol")), a = V0(e.get("edgeSymbolSize"));
    r.setVisual("fromSymbol", i && i[0]), r.setVisual("toSymbol", i && i[1]), r.setVisual("fromSymbolSize", a && a[0]), r.setVisual("toSymbolSize", a && a[1]), r.setVisual("style", e.getModel("lineStyle").getLineStyle()), r.each(function(o) {
      var s = r.getItemModel(o), l = t.getEdgeByIndex(o), u = V0(s.getShallow("symbol", !0)), c = V0(s.getShallow("symbolSize", !0)), d = s.getModel("lineStyle").getLineStyle(), f = r.ensureUniqueItemVisual(o, "style");
      switch (xe(f, d), f.stroke) {
        case "source": {
          var p = l.node1.getVisual("style");
          f.stroke = p && p.fill;
          break;
        }
        case "target": {
          var p = l.node2.getVisual("style");
          f.stroke = p && p.fill;
          break;
        }
      }
      u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), c[0] && l.setVisual("fromSymbolSize", c[0]), c[1] && l.setVisual("toSymbolSize", c[1]);
    });
  });
}
var Jk = "-->", Aw = function(n) {
  return n.get("autoCurveness") || null;
}, $Y = function(n, e) {
  var t = Aw(n), r = 20, i = [];
  if (sn(t))
    r = t;
  else if (Me(t)) {
    n.__curvenessList = t;
    return;
  }
  e > r && (r = e);
  var a = r % 2 ? r + 2 : r + 3;
  i = [];
  for (var o = 0; o < a; o++)
    i.push((o % 2 ? o + 1 : o) / 10 * (o % 2 ? -1 : 1));
  n.__curvenessList = i;
}, mg = function(n, e, t) {
  var r = [n.id, n.dataIndex].join("."), i = [e.id, e.dataIndex].join(".");
  return [t.uid, r, i].join(Jk);
}, zY = function(n) {
  var e = n.split(Jk);
  return [e[0], e[2], e[1]].join(Jk);
}, $$e = function(n, e) {
  var t = mg(n.node1, n.node2, e);
  return e.__edgeMap[t];
}, z$e = function(n, e) {
  var t = Qk(mg(n.node1, n.node2, e), e), r = Qk(mg(n.node2, n.node1, e), e);
  return t + r;
}, Qk = function(n, e) {
  var t = e.__edgeMap;
  return t[n] ? t[n].length : 0;
};
function F$e(n) {
  Aw(n) && (n.__curvenessList = [], n.__edgeMap = {}, $Y(n));
}
function V$e(n, e, t, r) {
  if (Aw(t)) {
    var i = mg(n, e, t), a = t.__edgeMap, o = a[zY(i)];
    a[i] && !o ? a[i].isForward = !0 : o && a[i] && (o.isForward = !0, a[i].isForward = !1), a[i] = a[i] || [], a[i].push(r);
  }
}
function $O(n, e, t, r) {
  var i = Aw(e), a = Me(i);
  if (!i)
    return null;
  var o = $$e(n, e);
  if (!o)
    return null;
  for (var s = -1, l = 0; l < o.length; l++)
    if (o[l] === t) {
      s = l;
      break;
    }
  var u = z$e(n, e);
  $Y(e, u), n.lineStyle = n.lineStyle || {};
  var c = mg(n.node1, n.node2, e), d = e.__curvenessList, f = a || u % 2 ? 0 : 1;
  if (o.isForward)
    return d[f + s];
  var p = zY(c), h = Qk(p, e), v = d[s + h + f];
  return r ? a ? i && i[0] === 0 ? (h + f) % 2 ? v : -v : ((h % 2 ? 0 : 1) + f) % 2 ? v : -v : (h + f) % 2 ? v : -v : d[s + h + f];
}
function FY(n) {
  var e = n.coordinateSystem;
  if (!(e && e.type !== "view")) {
    var t = n.getGraph();
    t.eachNode(function(r) {
      var i = r.getModel();
      r.setLayout([+i.get("x"), +i.get("y")]);
    }), zO(t, n);
  }
}
function zO(n, e) {
  n.eachEdge(function(t, r) {
    var i = Za(t.getModel().get(["lineStyle", "curveness"]), -$O(t, e, r, !0), 0), a = ul(t.node1.getLayout()), o = ul(t.node2.getLayout()), s = [a, o];
    +i && s.push([(a[0] + o[0]) / 2 - (a[1] - o[1]) * i, (a[1] + o[1]) / 2 - (o[0] - a[0]) * i]), t.setLayout(s);
  });
}
function H$e(n, e) {
  n.eachSeriesByType("graph", function(t) {
    var r = t.get("layout"), i = t.coordinateSystem;
    if (i && i.type !== "view") {
      var a = t.getData(), o = [];
      $(i.dimensions, function(f) {
        o = o.concat(a.mapDimensionsAll(f));
      });
      for (var s = 0; s < a.count(); s++) {
        for (var l = [], u = !1, c = 0; c < o.length; c++) {
          var d = a.get(o[c], s);
          isNaN(d) || (u = !0), l.push(d);
        }
        u ? a.setItemLayout(s, i.dataToPoint(l)) : a.setItemLayout(s, [NaN, NaN]);
      }
      zO(a.graph, t);
    } else (!r || r === "none") && FY(t);
  });
}
function jv(n) {
  var e = n.coordinateSystem;
  if (e.type !== "view")
    return 1;
  var t = n.option.nodeScaleRatio, r = e.scaleX, i = e.getZoom(), a = (i - 1) * t + 1;
  return a / r;
}
function Bv(n) {
  var e = n.getVisual("symbolSize");
  return e instanceof Array && (e = (e[0] + e[1]) / 2), +e;
}
var w4 = Math.PI, EE = [];
function FO(n, e, t, r) {
  var i = n.coordinateSystem;
  if (!(i && i.type !== "view")) {
    var a = i.getBoundingRect(), o = n.getData(), s = o.graph, l = a.width / 2 + a.x, u = a.height / 2 + a.y, c = Math.min(a.width, a.height) / 2, d = o.count();
    if (o.setLayout({
      cx: l,
      cy: u
    }), !!d) {
      if (t) {
        var f = i.pointToData(r), p = f[0], h = f[1], v = [p - l, h - u];
        sh(v, v), y1(v, v, c), t.setLayout([l + v[0], u + v[1]], !0);
        var m = n.get(["circular", "rotateLabel"]);
        VY(t, m, l, u);
      }
      G$e[e](n, s, o, c, l, u, d), s.eachEdge(function(g, y) {
        var b = Za(g.getModel().get(["lineStyle", "curveness"]), $O(g, n, y), 0), _ = ul(g.node1.getLayout()), x = ul(g.node2.getLayout()), w, S = (_[0] + x[0]) / 2, C = (_[1] + x[1]) / 2;
        +b && (b *= 3, w = [l * b + S * (1 - b), u * b + C * (1 - b)]), g.setLayout([_, x, w]);
      });
    }
  }
}
var G$e = {
  value: function(n, e, t, r, i, a, o) {
    var s = 0, l = t.getSum("value"), u = Math.PI * 2 / (l || o);
    e.eachNode(function(c) {
      var d = c.getValue("value"), f = u * (l ? d : 1) / 2;
      s += f, c.setLayout([r * Math.cos(s) + i, r * Math.sin(s) + a]), s += f;
    });
  },
  symbolSize: function(n, e, t, r, i, a, o) {
    var s = 0;
    EE.length = o;
    var l = jv(n);
    e.eachNode(function(d) {
      var f = Bv(d);
      isNaN(f) && (f = 2), f < 0 && (f = 0), f *= l;
      var p = Math.asin(f / 2 / r);
      isNaN(p) && (p = w4 / 2), EE[d.dataIndex] = p, s += p * 2;
    });
    var u = (2 * w4 - s) / o / 2, c = 0;
    e.eachNode(function(d) {
      var f = u + EE[d.dataIndex];
      c += f, (!d.getLayout() || !d.getLayout().fixed) && d.setLayout([r * Math.cos(c) + i, r * Math.sin(c) + a]), c += f;
    });
  }
};
function VY(n, e, t, r) {
  var i = n.getGraphicEl();
  if (i) {
    var a = n.getModel(), o = a.get(["label", "rotate"]) || 0, s = i.getSymbolPath();
    if (e) {
      var l = n.getLayout(), u = Math.atan2(l[1] - r, l[0] - t);
      u < 0 && (u = Math.PI * 2 + u);
      var c = l[0] < t;
      c && (u = u - Math.PI);
      var d = c ? "left" : "right";
      s.setTextConfig({
        rotation: -u,
        position: d,
        origin: "center"
      });
      var f = s.ensureState("emphasis");
      xe(f.textConfig || (f.textConfig = {}), {
        position: d
      });
    } else
      s.setTextConfig({
        rotation: o *= Math.PI / 180
      });
  }
}
function U$e(n) {
  n.eachSeriesByType("graph", function(e) {
    e.get("layout") === "circular" && FO(e, "symbolSize");
  });
}
var Nf = jC;
function W$e(n, e, t) {
  for (var r = n, i = e, a = t.rect, o = a.width, s = a.height, l = [a.x + o / 2, a.y + s / 2], u = t.gravity == null ? 0.1 : t.gravity, c = 0; c < r.length; c++) {
    var d = r[c];
    d.p || (d.p = Xd(o * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), d.pp = ul(d.p), d.edges = null;
  }
  var f = t.friction == null ? 0.6 : t.friction, p = f, h, v;
  return {
    warmUp: function() {
      p = f * 0.8;
    },
    setFixed: function(m) {
      r[m].fixed = !0;
    },
    setUnfixed: function(m) {
      r[m].fixed = !1;
    },
    /**
     * Before step hook
     */
    beforeStep: function(m) {
      h = m;
    },
    /**
     * After step hook
     */
    afterStep: function(m) {
      v = m;
    },
    /**
     * Some formulas were originally copied from "d3.js"
     * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
     * with some modifications made for this project.
     * See the license statement at the head of this file.
     */
    step: function(m) {
      h && h(r, i);
      for (var g = [], y = r.length, b = 0; b < i.length; b++) {
        var _ = i[b];
        if (!_.ignoreForceLayout) {
          var x = _.n1, w = _.n2;
          Hc(g, w.p, x.p);
          var S = BC(g) - _.d, C = w.w / (x.w + w.w);
          isNaN(C) && (C = 0), sh(g, g), !x.fixed && Nf(x.p, x.p, g, C * S * p), !w.fixed && Nf(w.p, w.p, g, -(1 - C) * S * p);
        }
      }
      for (var b = 0; b < y; b++) {
        var k = r[b];
        k.fixed || (Hc(g, l, k.p), Nf(k.p, k.p, g, u * p));
      }
      for (var b = 0; b < y; b++)
        for (var x = r[b], M = b + 1; M < y; M++) {
          var w = r[M];
          Hc(g, w.p, x.p);
          var S = BC(g);
          S === 0 && (vDe(g, Math.random() - 0.5, Math.random() - 0.5), S = 1);
          var D = (x.rep + w.rep) / S / S;
          !x.fixed && Nf(x.pp, x.pp, g, D), !w.fixed && Nf(w.pp, w.pp, g, -D);
        }
      for (var N = [], b = 0; b < y; b++) {
        var k = r[b];
        k.fixed || (Hc(N, k.p, k.pp), Nf(k.p, k.p, N, p), Si(k.pp, k.p));
      }
      p = p * 0.992;
      var R = p < 0.01;
      v && v(r, i, R), m && m(R);
    }
  };
}
function q$e(n) {
  n.eachSeriesByType("graph", function(e) {
    var t = e.coordinateSystem;
    if (!(t && t.type !== "view"))
      if (e.get("layout") === "force") {
        var r = e.preservedPoints || {}, i = e.getGraph(), a = i.data, o = i.edgeData, s = e.getModel("force"), l = s.get("initLayout");
        e.preservedPoints ? a.each(function(b) {
          var _ = a.getId(b);
          a.setItemLayout(b, r[_] || [NaN, NaN]);
        }) : !l || l === "none" ? FY(e) : l === "circular" && FO(e, "value");
        var u = a.getDataExtent("value"), c = o.getDataExtent("value"), d = s.get("repulsion"), f = s.get("edgeLength"), p = Me(d) ? d : [d, d], h = Me(f) ? f : [f, f];
        h = [h[1], h[0]];
        var v = a.mapArray("value", function(b, _) {
          var x = a.getItemLayout(_), w = mn(b, u, p);
          return isNaN(w) && (w = (p[0] + p[1]) / 2), {
            w,
            rep: w,
            fixed: a.getItemModel(_).get("fixed"),
            p: !x || isNaN(x[0]) || isNaN(x[1]) ? null : x
          };
        }), m = o.mapArray("value", function(b, _) {
          var x = i.getEdgeByIndex(_), w = mn(b, c, h);
          isNaN(w) && (w = (h[0] + h[1]) / 2);
          var S = x.getModel(), C = Za(x.getModel().get(["lineStyle", "curveness"]), -$O(x, e, _, !0), 0);
          return {
            n1: v[x.node1.dataIndex],
            n2: v[x.node2.dataIndex],
            d: w,
            curveness: C,
            ignoreForceLayout: S.get("ignoreForceLayout")
          };
        }), g = t.getBoundingRect(), y = W$e(v, m, {
          rect: g,
          gravity: s.get("gravity"),
          friction: s.get("friction")
        });
        y.beforeStep(function(b, _) {
          for (var x = 0, w = b.length; x < w; x++)
            b[x].fixed && Si(b[x].p, i.getNodeByIndex(x).getLayout());
        }), y.afterStep(function(b, _, x) {
          for (var w = 0, S = b.length; w < S; w++)
            b[w].fixed || i.getNodeByIndex(w).setLayout(b[w].p), r[a.getId(w)] = b[w].p;
          for (var w = 0, S = _.length; w < S; w++) {
            var C = _[w], k = i.getEdgeByIndex(w), M = C.n1.p, D = C.n2.p, N = k.getLayout();
            N = N ? N.slice() : [], N[0] = N[0] || [], N[1] = N[1] || [], Si(N[0], M), Si(N[1], D), +C.curveness && (N[2] = [(M[0] + D[0]) / 2 - (M[1] - D[1]) * C.curveness, (M[1] + D[1]) / 2 - (D[0] - M[0]) * C.curveness]), k.setLayout(N);
          }
        }), e.forceLayout = y, e.preservedPoints = r, y.step();
      } else
        e.forceLayout = null;
  });
}
function Y$e(n, e, t) {
  var r = xe(n.getBoxLayoutParams(), {
    aspect: t
  });
  return Er(r, {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function K$e(n, e) {
  var t = [];
  return n.eachSeriesByType("graph", function(r) {
    var i = r.get("coordinateSystem");
    if (!i || i === "view") {
      var a = r.getData(), o = a.mapArray(function(m) {
        var g = a.getItemModel(m);
        return [+g.get("x"), +g.get("y")];
      }), s = [], l = [];
      tw(o, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
      var u = (l[0] - s[0]) / (l[1] - s[1]), c = Y$e(r, e, u);
      isNaN(u) && (s = [c.x, c.y], l = [c.x + c.width, c.y + c.height]);
      var d = l[0] - s[0], f = l[1] - s[1], p = c.width, h = c.height, v = r.coordinateSystem = new iy();
      v.zoomLimit = r.get("scaleLimit"), v.setBoundingRect(s[0], s[1], d, f), v.setViewRect(c.x, c.y, p, h), v.setCenter(r.get("center"), e), v.setZoom(r.get("zoom")), t.push(v);
    }
  }), t;
}
var S4 = Dr.prototype, TE = Gg.prototype, HY = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return n;
  }()
);
(function(n) {
  le(e, n);
  function e() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return e;
})(HY);
function CE(n) {
  return isNaN(+n.cpx1) || isNaN(+n.cpy1);
}
var X$e = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "ec-line", r;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new HY();
    }, e.prototype.buildPath = function(t, r) {
      CE(r) ? S4.buildPath.call(this, t, r) : TE.buildPath.call(this, t, r);
    }, e.prototype.pointAt = function(t) {
      return CE(this.shape) ? S4.pointAt.call(this, t) : TE.pointAt.call(this, t);
    }, e.prototype.tangentAt = function(t) {
      var r = this.shape, i = CE(r) ? [r.x2 - r.x1, r.y2 - r.y1] : TE.tangentAt.call(this, t);
      return sh(i, i);
    }, e;
  }(Ht)
), kE = ["fromSymbol", "toSymbol"];
function E4(n) {
  return "_" + n + "Type";
}
function T4(n, e, t) {
  var r = e.getItemVisual(t, n);
  if (!r || r === "none")
    return r;
  var i = e.getItemVisual(t, n + "Size"), a = e.getItemVisual(t, n + "Rotate"), o = e.getItemVisual(t, n + "Offset"), s = e.getItemVisual(t, n + "KeepAspect"), l = _h(i), u = ef(o || 0, l);
  return r + l + u + (a || "") + (s || "");
}
function C4(n, e, t) {
  var r = e.getItemVisual(t, n);
  if (!(!r || r === "none")) {
    var i = e.getItemVisual(t, n + "Size"), a = e.getItemVisual(t, n + "Rotate"), o = e.getItemVisual(t, n + "Offset"), s = e.getItemVisual(t, n + "KeepAspect"), l = _h(i), u = ef(o || 0, l), c = yr(r, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
    return c.__specifiedRotation = a == null || isNaN(a) ? void 0 : +a * Math.PI / 180 || 0, c.name = n, c;
  }
}
function Z$e(n) {
  var e = new X$e({
    name: "line",
    subPixelOptimize: !0
  });
  return eA(e.shape, n), e;
}
function eA(n, e) {
  n.x1 = e[0][0], n.y1 = e[0][1], n.x2 = e[1][0], n.y2 = e[1][1], n.percent = 1;
  var t = e[2];
  t ? (n.cpx1 = t[0], n.cpy1 = t[1]) : (n.cpx1 = NaN, n.cpy1 = NaN);
}
var VO = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i) {
      var a = n.call(this) || this;
      return a._createLine(t, r, i), a;
    }
    return e.prototype._createLine = function(t, r, i) {
      var a = t.hostModel, o = t.getItemLayout(r), s = Z$e(o);
      s.shape.percent = 0, Gn(s, {
        shape: {
          percent: 1
        }
      }, a, r), this.add(s), $(kE, function(l) {
        var u = C4(l, t, r);
        this.add(u), this[E4(l)] = T4(l, t, r);
      }, this), this._updateCommonStl(t, r, i);
    }, e.prototype.updateData = function(t, r, i) {
      var a = t.hostModel, o = this.childOfName("line"), s = t.getItemLayout(r), l = {
        shape: {}
      };
      eA(l.shape, s), ln(o, l, a, r), $(kE, function(u) {
        var c = T4(u, t, r), d = E4(u);
        if (this[d] !== c) {
          this.remove(this.childOfName(u));
          var f = C4(u, t, r);
          this.add(f);
        }
        this[d] = c;
      }, this), this._updateCommonStl(t, r, i);
    }, e.prototype.getLinePath = function() {
      return this.childAt(0);
    }, e.prototype._updateCommonStl = function(t, r, i) {
      var a = t.hostModel, o = this.childOfName("line"), s = i && i.emphasisLineStyle, l = i && i.blurLineStyle, u = i && i.selectLineStyle, c = i && i.labelStatesModels, d = i && i.emphasisDisabled, f = i && i.focus, p = i && i.blurScope;
      if (!i || t.hasItemOption) {
        var h = t.getItemModel(r), v = h.getModel("emphasis");
        s = v.getModel("lineStyle").getLineStyle(), l = h.getModel(["blur", "lineStyle"]).getLineStyle(), u = h.getModel(["select", "lineStyle"]).getLineStyle(), d = v.get("disabled"), f = v.get("focus"), p = v.get("blurScope"), c = Nr(h);
      }
      var m = t.getItemVisual(r, "style"), g = m.stroke;
      o.useStyle(m), o.style.fill = null, o.style.strokeNoScale = !0, o.ensureState("emphasis").style = s, o.ensureState("blur").style = l, o.ensureState("select").style = u, $(kE, function(w) {
        var S = this.childOfName(w);
        if (S) {
          S.setColor(g), S.style.opacity = m.opacity;
          for (var C = 0; C < zi.length; C++) {
            var k = zi[C], M = o.getState(k);
            if (M) {
              var D = M.style || {}, N = S.ensureState(k), R = N.style || (N.style = {});
              D.stroke != null && (R[S.__isEmptyBrush ? "stroke" : "fill"] = D.stroke), D.opacity != null && (R.opacity = D.opacity);
            }
          }
          S.markRedraw();
        }
      }, this);
      var y = a.getRawValue(r);
      ei(this, c, {
        labelDataIndex: r,
        labelFetcher: {
          getFormattedLabel: function(w, S) {
            return a.getFormattedLabel(w, S, t.dataType);
          }
        },
        inheritColor: g || "#000",
        defaultOpacity: m.opacity,
        defaultText: (y == null ? t.getName(r) : isFinite(y) ? ir(y) : y) + ""
      });
      var b = this.getTextContent();
      if (b) {
        var _ = c.normal;
        b.__align = b.style.align, b.__verticalAlign = b.style.verticalAlign, b.__position = _.get("position") || "middle";
        var x = _.get("distance");
        Me(x) || (x = [x, x]), b.__labelDistance = x;
      }
      this.setTextConfig({
        position: null,
        local: !0,
        inside: !1
        // Can't be inside for stroke element.
      }), er(this, f, p, d);
    }, e.prototype.highlight = function() {
      xl(this);
    }, e.prototype.downplay = function() {
      wl(this);
    }, e.prototype.updateLayout = function(t, r) {
      this.setLinePoints(t.getItemLayout(r));
    }, e.prototype.setLinePoints = function(t) {
      var r = this.childOfName("line");
      eA(r.shape, t), r.dirty();
    }, e.prototype.beforeUpdate = function() {
      var t = this, r = t.childOfName("fromSymbol"), i = t.childOfName("toSymbol"), a = t.getTextContent();
      if (!r && !i && (!a || a.ignore))
        return;
      for (var o = 1, s = this.parent; s; )
        s.scaleX && (o /= s.scaleX), s = s.parent;
      var l = t.childOfName("line");
      if (!this.__dirty && !l.__dirty)
        return;
      var u = l.shape.percent, c = l.pointAt(0), d = l.pointAt(u), f = Hc([], d, c);
      sh(f, f);
      function p(M, D) {
        var N = M.__specifiedRotation;
        if (N == null) {
          var R = l.tangentAt(D);
          M.attr("rotation", (D === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(R[1], R[0]));
        } else
          M.attr("rotation", N);
      }
      if (r && (r.setPosition(c), p(r, 0), r.scaleX = r.scaleY = o * u, r.markRedraw()), i && (i.setPosition(d), p(i, 1), i.scaleX = i.scaleY = o * u, i.markRedraw()), a && !a.ignore) {
        a.x = a.y = 0, a.originX = a.originY = 0;
        var h = void 0, v = void 0, m = a.__labelDistance, g = m[0] * o, y = m[1] * o, b = u / 2, _ = l.tangentAt(b), x = [_[1], -_[0]], w = l.pointAt(b);
        x[1] > 0 && (x[0] = -x[0], x[1] = -x[1]);
        var S = _[0] < 0 ? -1 : 1;
        if (a.__position !== "start" && a.__position !== "end") {
          var C = -Math.atan2(_[1], _[0]);
          d[0] < c[0] && (C = Math.PI + C), a.rotation = C;
        }
        var k = void 0;
        switch (a.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            k = -y, v = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            k = y, v = "top";
            break;
          default:
            k = 0, v = "middle";
        }
        switch (a.__position) {
          case "end":
            a.x = f[0] * g + d[0], a.y = f[1] * y + d[1], h = f[0] > 0.8 ? "left" : f[0] < -0.8 ? "right" : "center", v = f[1] > 0.8 ? "top" : f[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            a.x = -f[0] * g + c[0], a.y = -f[1] * y + c[1], h = f[0] > 0.8 ? "right" : f[0] < -0.8 ? "left" : "center", v = f[1] > 0.8 ? "bottom" : f[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            a.x = g * S + c[0], a.y = c[1] + k, h = _[0] < 0 ? "right" : "left", a.originX = -g * S, a.originY = -k;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            a.x = w[0], a.y = w[1] + k, h = "center", a.originY = -k;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            a.x = -g * S + d[0], a.y = d[1] + k, h = _[0] >= 0 ? "right" : "left", a.originX = g * S, a.originY = -k;
            break;
        }
        a.scaleX = a.scaleY = o, a.setStyle({
          // Use the user specified text align and baseline first
          verticalAlign: a.__verticalAlign || v,
          align: a.__align || h
        });
      }
    }, e;
  }(mt)
), HO = (
  /** @class */
  function() {
    function n(e) {
      this.group = new mt(), this._LineCtor = e || VO;
    }
    return n.prototype.updateData = function(e) {
      var t = this;
      this._progressiveEls = null;
      var r = this, i = r.group, a = r._lineData;
      r._lineData = e, a || i.removeAll();
      var o = k4(e);
      e.diff(a).add(function(s) {
        t._doAdd(e, s, o);
      }).update(function(s, l) {
        t._doUpdate(a, e, l, s, o);
      }).remove(function(s) {
        i.remove(a.getItemGraphicEl(s));
      }).execute();
    }, n.prototype.updateLayout = function() {
      var e = this._lineData;
      e && e.eachItemGraphicEl(function(t, r) {
        t.updateLayout(e, r);
      }, this);
    }, n.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = k4(e), this._lineData = null, this.group.removeAll();
    }, n.prototype.incrementalUpdate = function(e, t) {
      this._progressiveEls = [];
      function r(s) {
        !s.isGroup && !J$e(s) && (s.incremental = !0, s.ensureState("emphasis").hoverLayer = !0);
      }
      for (var i = e.start; i < e.end; i++) {
        var a = t.getItemLayout(i);
        if (AE(a)) {
          var o = new this._LineCtor(t, i, this._seriesScope);
          o.traverse(r), this.group.add(o), t.setItemGraphicEl(i, o), this._progressiveEls.push(o);
        }
      }
    }, n.prototype.remove = function() {
      this.group.removeAll();
    }, n.prototype.eachRendered = function(e) {
      Yu(this._progressiveEls || this.group, e);
    }, n.prototype._doAdd = function(e, t, r) {
      var i = e.getItemLayout(t);
      if (AE(i)) {
        var a = new this._LineCtor(e, t, r);
        e.setItemGraphicEl(t, a), this.group.add(a);
      }
    }, n.prototype._doUpdate = function(e, t, r, i, a) {
      var o = e.getItemGraphicEl(r);
      if (!AE(t.getItemLayout(i))) {
        this.group.remove(o);
        return;
      }
      o ? o.updateData(t, i, a) : o = new this._LineCtor(t, i, a), t.setItemGraphicEl(i, o), this.group.add(o);
    }, n;
  }()
);
function J$e(n) {
  return n.animators && n.animators.length > 0;
}
function k4(n) {
  var e = n.hostModel, t = e.getModel("emphasis");
  return {
    lineStyle: e.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: t.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: e.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: e.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: t.get("disabled"),
    blurScope: t.get("blurScope"),
    focus: t.get("focus"),
    labelStatesModels: Nr(e)
  };
}
function A4(n) {
  return isNaN(n[0]) || isNaN(n[1]);
}
function AE(n) {
  return n && !A4(n[0]) && !A4(n[1]);
}
var ME = [], DE = [], OE = [], Rf = Br, IE = cd, M4 = Math.abs;
function D4(n, e, t) {
  for (var r = n[0], i = n[1], a = n[2], o = 1 / 0, s, l = t * t, u = 0.1, c = 0.1; c <= 0.9; c += 0.1) {
    ME[0] = Rf(r[0], i[0], a[0], c), ME[1] = Rf(r[1], i[1], a[1], c);
    var d = M4(IE(ME, e) - l);
    d < o && (o = d, s = c);
  }
  for (var f = 0; f < 32; f++) {
    var p = s + u;
    DE[0] = Rf(r[0], i[0], a[0], s), DE[1] = Rf(r[1], i[1], a[1], s), OE[0] = Rf(r[0], i[0], a[0], p), OE[1] = Rf(r[1], i[1], a[1], p);
    var d = IE(DE, e) - l;
    if (M4(d) < 0.01)
      break;
    var h = IE(OE, e) - l;
    u /= 2, d < 0 ? h >= 0 ? s = s + u : s = s - u : h >= 0 ? s = s - u : s = s + u;
  }
  return s;
}
function LE(n, e) {
  var t = [], r = Xm, i = [[], [], []], a = [[], []], o = [];
  e /= 2, n.eachEdge(function(s, l) {
    var u = s.getLayout(), c = s.getVisual("fromSymbol"), d = s.getVisual("toSymbol");
    u.__original || (u.__original = [ul(u[0]), ul(u[1])], u[2] && u.__original.push(ul(u[2])));
    var f = u.__original;
    if (u[2] != null) {
      if (Si(i[0], f[0]), Si(i[1], f[2]), Si(i[2], f[1]), c && c !== "none") {
        var p = Bv(s.node1), h = D4(i, f[0], p * e);
        r(i[0][0], i[1][0], i[2][0], h, t), i[0][0] = t[3], i[1][0] = t[4], r(i[0][1], i[1][1], i[2][1], h, t), i[0][1] = t[3], i[1][1] = t[4];
      }
      if (d && d !== "none") {
        var p = Bv(s.node2), h = D4(i, f[1], p * e);
        r(i[0][0], i[1][0], i[2][0], h, t), i[1][0] = t[1], i[2][0] = t[2], r(i[0][1], i[1][1], i[2][1], h, t), i[1][1] = t[1], i[2][1] = t[2];
      }
      Si(u[0], i[0]), Si(u[1], i[2]), Si(u[2], i[1]);
    } else {
      if (Si(a[0], f[0]), Si(a[1], f[1]), Hc(o, a[1], a[0]), sh(o, o), c && c !== "none") {
        var p = Bv(s.node1);
        jC(a[0], a[0], o, p * e);
      }
      if (d && d !== "none") {
        var p = Bv(s.node2);
        jC(a[1], a[1], o, -p * e);
      }
      Si(u[0], a[0]), Si(u[1], a[1]);
    }
  });
}
function O4(n) {
  return n.type === "view";
}
var Q$e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      var i = new Jg(), a = new HO(), o = this.group;
      this._controller = new ry(r.getZr()), this._controllerHost = {
        target: o
      }, o.add(i.group), o.add(a.group), this._symbolDraw = i, this._lineDraw = a, this._firstRender = !0;
    }, e.prototype.render = function(t, r, i) {
      var a = this, o = t.coordinateSystem;
      this._model = t;
      var s = this._symbolDraw, l = this._lineDraw, u = this.group;
      if (O4(o)) {
        var c = {
          x: o.x,
          y: o.y,
          scaleX: o.scaleX,
          scaleY: o.scaleY
        };
        this._firstRender ? u.attr(c) : ln(u, c, t);
      }
      LE(t.getGraph(), jv(t));
      var d = t.getData();
      s.updateData(d);
      var f = t.getEdgeData();
      l.updateData(f), this._updateNodeAndLinkScale(), this._updateController(t, r, i), clearTimeout(this._layoutTimeout);
      var p = t.forceLayout, h = t.get(["force", "layoutAnimation"]);
      p && this._startForceLayoutIteration(p, h);
      var v = t.get("layout");
      d.graph.eachNode(function(b) {
        var _ = b.dataIndex, x = b.getGraphicEl(), w = b.getModel();
        if (x) {
          x.off("drag").off("dragend");
          var S = w.get("draggable");
          S && x.on("drag", function(k) {
            switch (v) {
              case "force":
                p.warmUp(), !a._layouting && a._startForceLayoutIteration(p, h), p.setFixed(_), d.setItemLayout(_, [x.x, x.y]);
                break;
              case "circular":
                d.setItemLayout(_, [x.x, x.y]), b.setLayout({
                  fixed: !0
                }, !0), FO(t, "symbolSize", b, [k.offsetX, k.offsetY]), a.updateLayout(t);
                break;
              case "none":
              default:
                d.setItemLayout(_, [x.x, x.y]), zO(t.getGraph(), t), a.updateLayout(t);
                break;
            }
          }).on("dragend", function() {
            p && p.setUnfixed(_);
          }), x.setDraggable(S, !!w.get("cursor"));
          var C = w.get(["emphasis", "focus"]);
          C === "adjacency" && (yt(x).focus = b.getAdjacentDataIndices());
        }
      }), d.graph.eachEdge(function(b) {
        var _ = b.getGraphicEl(), x = b.getModel().get(["emphasis", "focus"]);
        _ && x === "adjacency" && (yt(_).focus = {
          edge: [b.dataIndex],
          node: [b.node1.dataIndex, b.node2.dataIndex]
        });
      });
      var m = t.get("layout") === "circular" && t.get(["circular", "rotateLabel"]), g = d.getLayout("cx"), y = d.getLayout("cy");
      d.graph.eachNode(function(b) {
        VY(b, m, g, y);
      }), this._firstRender = !1;
    }, e.prototype.dispose = function() {
      this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype._startForceLayoutIteration = function(t, r) {
      var i = this;
      (function a() {
        t.step(function(o) {
          i.updateLayout(i._model), (i._layouting = !o) && (r ? i._layoutTimeout = setTimeout(a, 16) : a());
        });
      })();
    }, e.prototype._updateController = function(t, r, i) {
      var a = this, o = this._controller, s = this._controllerHost, l = this.group;
      if (o.setPointerChecker(function(u, c, d) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(c, d) && !Tw(u, i, t);
      }), !O4(t.coordinateSystem)) {
        o.disable();
        return;
      }
      o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
        OO(s, u.dx, u.dy), i.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        IO(s, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(), LE(t.getGraph(), jv(t)), a._lineDraw.updateLayout(), i.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function() {
      var t = this._model, r = t.getData(), i = jv(t);
      r.eachItemGraphicEl(function(a, o) {
        a && a.setSymbolScale(i);
      });
    }, e.prototype.updateLayout = function(t) {
      LE(t.getGraph(), jv(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
    }, e.prototype.remove = function() {
      clearTimeout(this._layoutTimeout), this._layouting = !1, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
    }, e.type = "graph", e;
  }(Tn)
);
function Pf(n) {
  return "_EC_" + n;
}
var eze = (
  /** @class */
  function() {
    function n(e) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = e || !1;
    }
    return n.prototype.isDirected = function() {
      return this._directed;
    }, n.prototype.addNode = function(e, t) {
      e = e == null ? "" + t : "" + e;
      var r = this._nodesMap;
      if (r[Pf(e)]) {
        process.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var i = new Ac(e, t);
      return i.hostGraph = this, this.nodes.push(i), r[Pf(e)] = i, i;
    }, n.prototype.getNodeByIndex = function(e) {
      var t = this.data.getRawIndex(e);
      return this.nodes[t];
    }, n.prototype.getNodeById = function(e) {
      return this._nodesMap[Pf(e)];
    }, n.prototype.addEdge = function(e, t, r) {
      var i = this._nodesMap, a = this._edgesMap;
      if (sn(e) && (e = this.nodes[e]), sn(t) && (t = this.nodes[t]), e instanceof Ac || (e = i[Pf(e)]), t instanceof Ac || (t = i[Pf(t)]), !(!e || !t)) {
        var o = e.id + "-" + t.id, s = new GY(e, t, r);
        return s.hostGraph = this, this._directed && (e.outEdges.push(s), t.inEdges.push(s)), e.edges.push(s), e !== t && t.edges.push(s), this.edges.push(s), a[o] = s, s;
      }
    }, n.prototype.getEdgeByIndex = function(e) {
      var t = this.edgeData.getRawIndex(e);
      return this.edges[t];
    }, n.prototype.getEdge = function(e, t) {
      e instanceof Ac && (e = e.id), t instanceof Ac && (t = t.id);
      var r = this._edgesMap;
      return this._directed ? r[e + "-" + t] : r[e + "-" + t] || r[t + "-" + e];
    }, n.prototype.eachNode = function(e, t) {
      for (var r = this.nodes, i = r.length, a = 0; a < i; a++)
        r[a].dataIndex >= 0 && e.call(t, r[a], a);
    }, n.prototype.eachEdge = function(e, t) {
      for (var r = this.edges, i = r.length, a = 0; a < i; a++)
        r[a].dataIndex >= 0 && r[a].node1.dataIndex >= 0 && r[a].node2.dataIndex >= 0 && e.call(t, r[a], a);
    }, n.prototype.breadthFirstTraverse = function(e, t, r, i) {
      if (t instanceof Ac || (t = this._nodesMap[Pf(t)]), !!t) {
        for (var a = r === "out" ? "outEdges" : r === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++)
          this.nodes[o].__visited = !1;
        if (!e.call(i, t, null))
          for (var s = [t]; s.length; )
            for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
              var c = u[o], d = c.node1 === l ? c.node2 : c.node1;
              if (!d.__visited) {
                if (e.call(i, d, l))
                  return;
                s.push(d), d.__visited = !0;
              }
            }
      }
    }, n.prototype.update = function() {
      for (var e = this.data, t = this.edgeData, r = this.nodes, i = this.edges, a = 0, o = r.length; a < o; a++)
        r[a].dataIndex = -1;
      for (var a = 0, o = e.count(); a < o; a++)
        r[e.getRawIndex(a)].dataIndex = a;
      t.filterSelf(function(s) {
        var l = i[t.getRawIndex(s)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, o = i.length; a < o; a++)
        i[a].dataIndex = -1;
      for (var a = 0, o = t.count(); a < o; a++)
        i[t.getRawIndex(a)].dataIndex = a;
    }, n.prototype.clone = function() {
      for (var e = new n(this._directed), t = this.nodes, r = this.edges, i = 0; i < t.length; i++)
        e.addNode(t[i].id, t[i].dataIndex);
      for (var i = 0; i < r.length; i++) {
        var a = r[i];
        e.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return e;
    }, n;
  }()
), Ac = (
  /** @class */
  function() {
    function n(e, t) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = e ?? "", this.dataIndex = t ?? -1;
    }
    return n.prototype.degree = function() {
      return this.edges.length;
    }, n.prototype.inDegree = function() {
      return this.inEdges.length;
    }, n.prototype.outDegree = function() {
      return this.outEdges.length;
    }, n.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, r = t.data.getItemModel(this.dataIndex);
        return r.getModel(e);
      }
    }, n.prototype.getAdjacentDataIndices = function() {
      for (var e = {
        edge: [],
        node: []
      }, t = 0; t < this.edges.length; t++) {
        var r = this.edges[t];
        r.dataIndex < 0 || (e.edge.push(r.dataIndex), e.node.push(r.node1.dataIndex, r.node2.dataIndex));
      }
      return e;
    }, n.prototype.getTrajectoryDataIndices = function() {
      for (var e = tt(), t = tt(), r = 0; r < this.edges.length; r++) {
        var i = this.edges[r];
        if (!(i.dataIndex < 0)) {
          e.set(i.dataIndex, !0);
          for (var a = [i.node1], o = [i.node2], s = 0; s < a.length; ) {
            var l = a[s];
            s++, t.set(l.dataIndex, !0);
            for (var u = 0; u < l.inEdges.length; u++)
              e.set(l.inEdges[u].dataIndex, !0), a.push(l.inEdges[u].node1);
          }
          for (s = 0; s < o.length; ) {
            var c = o[s];
            s++, t.set(c.dataIndex, !0);
            for (var u = 0; u < c.outEdges.length; u++)
              e.set(c.outEdges[u].dataIndex, !0), o.push(c.outEdges[u].node2);
          }
        }
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, n;
  }()
), GY = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.dataIndex = -1, this.node1 = e, this.node2 = t, this.dataIndex = r ?? -1;
    }
    return n.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, r = t.edgeData.getItemModel(this.dataIndex);
        return r.getModel(e);
      }
    }, n.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, n.prototype.getTrajectoryDataIndices = function() {
      var e = tt(), t = tt();
      e.set(this.dataIndex, !0);
      for (var r = [this.node1], i = [this.node2], a = 0; a < r.length; ) {
        var o = r[a];
        a++, t.set(o.dataIndex, !0);
        for (var s = 0; s < o.inEdges.length; s++)
          e.set(o.inEdges[s].dataIndex, !0), r.push(o.inEdges[s].node1);
      }
      for (a = 0; a < i.length; ) {
        var l = i[a];
        a++, t.set(l.dataIndex, !0);
        for (var s = 0; s < l.outEdges.length; s++)
          e.set(l.outEdges[s].dataIndex, !0), i.push(l.outEdges[s].node2);
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, n;
  }()
);
function UY(n, e) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(t) {
      var r = this[n][e];
      return r.getStore().get(r.getDimensionIndex(t || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(t, r) {
      this.dataIndex >= 0 && this[n][e].setItemVisual(this.dataIndex, t, r);
    },
    getVisual: function(t) {
      return this[n][e].getItemVisual(this.dataIndex, t);
    },
    setLayout: function(t, r) {
      this.dataIndex >= 0 && this[n][e].setItemLayout(this.dataIndex, t, r);
    },
    getLayout: function() {
      return this[n][e].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[n][e].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[n][e].getRawIndex(this.dataIndex);
    }
  };
}
_r(Ac, UY("hostGraph", "data"));
_r(GY, UY("hostGraph", "edgeData"));
function WY(n, e, t, r, i) {
  for (var a = new eze(r), o = 0; o < n.length; o++)
    a.addNode(mr(
      // Id, name, dataIndex
      n[o].id,
      n[o].name,
      o
    ), o);
  for (var s = [], l = [], u = 0, o = 0; o < e.length; o++) {
    var c = e[o], d = c.source, f = c.target;
    a.addEdge(d, f, u) && (l.push(c), s.push(mr(wr(c.id, null), d + " > " + f)), u++);
  }
  var p = t.get("coordinateSystem"), h;
  if (p === "cartesian2d" || p === "polar")
    h = Dl(n, t);
  else {
    var v = gh.get(p), m = v ? v.dimensions || [] : [];
    Pt(m, "value") < 0 && m.concat(["value"]);
    var g = Kg(n, {
      coordDimensions: m,
      encodeDefine: t.getEncode()
    }).dimensions;
    h = new Oi(g, t), h.initData(n);
  }
  var y = new Oi(["value"], t);
  return y.initData(l, s), i && i(h, y), kY({
    mainData: h,
    struct: a,
    structAttr: "graph",
    datas: {
      node: h,
      edge: y
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), a.update(), a;
}
var tze = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments);
      var r = this;
      function i() {
        return r._categoriesData;
      }
      this.legendVisualProvider = new ny(i, i), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeOption = function(t) {
      n.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeDefaultAndTheme = function(t) {
      n.prototype.mergeDefaultAndTheme.apply(this, arguments), Od(t, "edgeLabel", ["show"]);
    }, e.prototype.getInitialData = function(t, r) {
      var i = t.edges || t.links || [], a = t.data || t.nodes || [], o = this;
      if (a && i) {
        F$e(this);
        var s = WY(a, i, this, !0, l);
        return $(s.edges, function(u) {
          V$e(u.node1, u.node2, this, u.dataIndex);
        }, this), s.data;
      }
      function l(u, c) {
        u.wrapMethod("getItemModel", function(h) {
          var v = o._categoriesModels, m = h.getShallow("category"), g = v[m];
          return g && (g.parentModel = h.parentModel, h.parentModel = g), h;
        });
        var d = yn.prototype.getModel;
        function f(h, v) {
          var m = d.call(this, h, v);
          return m.resolveParentPath = p, m;
        }
        c.wrapMethod("getItemModel", function(h) {
          return h.resolveParentPath = p, h.getModel = f, h;
        });
        function p(h) {
          if (h && (h[0] === "label" || h[1] === "label")) {
            var v = h.slice();
            return h[0] === "label" ? v[0] = "edgeLabel" : h[1] === "label" && (v[1] = "edgeLabel"), v;
          }
          return h;
        }
      }
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, e.prototype.formatTooltip = function(t, r, i) {
      if (i === "edge") {
        var a = this.getData(), o = this.getDataParams(t, i), s = a.graph.getEdgeByIndex(t), l = a.getName(s.node1.dataIndex), u = a.getName(s.node2.dataIndex), c = [];
        return l != null && c.push(l), u != null && c.push(u), Rr("nameValue", {
          name: c.join(" > "),
          value: o.value,
          noValue: o.value == null
        });
      }
      var d = gW({
        series: this,
        dataIndex: t,
        multipleSeries: r
      });
      return d;
    }, e.prototype._updateCategoriesData = function() {
      var t = De(this.option.categories || [], function(i) {
        return i.value != null ? i : xe({
          value: 0
        }, i);
      }), r = new Oi(["value"], this);
      r.initData(t), this._categoriesData = r, this._categoriesModels = r.mapArray(function(i) {
        return r.getItemModel(i);
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.isAnimationEnabled = function() {
      return n.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
    }, e.type = "series.graph", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // Default option for all coordinate systems
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // geoIndex: 0,
      legendHoverLink: !0,
      layout: null,
      // Configuration of circular layout
      circular: {
        rotateLabel: !1
      },
      // Configuration of force directed layout
      force: {
        initLayout: null,
        // Node repulsion. Can be an array to represent range.
        repulsion: [0, 50],
        gravity: 0.1,
        // Initial friction
        friction: 0.6,
        // Edge length. Can be an array to represent range.
        edgeLength: 30,
        layoutAnimation: !0
      },
      left: "center",
      top: "center",
      // right: null,
      // bottom: null,
      // width: '80%',
      // height: '80%',
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: !1,
      roam: !1,
      // Default on center of graph
      center: null,
      zoom: 1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.6,
      // cursor: null,
      // categories: [],
      // data: []
      // Or
      // nodes: []
      //
      // links: []
      // Or
      // edges: []
      label: {
        show: !1,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: !0,
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Rn)
), nze = {
  type: "graphRoam",
  event: "graphRoam",
  update: "none"
};
function rze(n) {
  n.registerChartView(Q$e), n.registerSeriesModel(tze), n.registerProcessor(P$e), n.registerVisual(j$e), n.registerVisual(B$e), n.registerLayout(H$e), n.registerLayout(n.PRIORITY.VISUAL.POST_CHART_LAYOUT, U$e), n.registerLayout(q$e), n.registerCoordinateSystem("graphView", {
    dimensions: iy.dimensions,
    create: K$e
  }), n.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, dr), n.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, dr), n.registerAction(nze, function(e, t, r) {
    t.eachComponent({
      mainType: "series",
      query: e
    }, function(i) {
      var a = i.coordinateSystem, o = NO(a, e, void 0, r);
      i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom);
    });
  });
}
var ize = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return n;
  }()
), aze = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "pointer", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new ize();
    }, e.prototype.buildPath = function(t, r) {
      var i = Math.cos, a = Math.sin, o = r.r, s = r.width, l = r.angle, u = r.x - i(l) * s * (s >= o / 3 ? 1 : 2), c = r.y - a(l) * s * (s >= o / 3 ? 1 : 2);
      l = r.angle - Math.PI / 2, t.moveTo(u, c), t.lineTo(r.x + i(l) * s, r.y + a(l) * s), t.lineTo(r.x + i(r.angle) * o, r.y + a(r.angle) * o), t.lineTo(r.x - i(l) * s, r.y - a(l) * s), t.lineTo(u, c);
    }, e;
  }(Ht)
);
function oze(n, e) {
  var t = n.get("center"), r = e.getWidth(), i = e.getHeight(), a = Math.min(r, i), o = ze(t[0], e.getWidth()), s = ze(t[1], e.getHeight()), l = ze(n.get("radius"), a / 2);
  return {
    cx: o,
    cy: s,
    r: l
  };
}
function H0(n, e) {
  var t = n == null ? "" : n + "";
  return e && (We(e) ? t = e.replace("{value}", t) : at(e) && (t = e(n))), t;
}
var sze = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      this.group.removeAll();
      var a = t.get(["axisLine", "lineStyle", "color"]), o = oze(t, i);
      this._renderMain(t, r, i, a, o), this._data = t.getData();
    }, e.prototype.dispose = function() {
    }, e.prototype._renderMain = function(t, r, i, a, o) {
      var s = this.group, l = t.get("clockwise"), u = -t.get("startAngle") / 180 * Math.PI, c = -t.get("endAngle") / 180 * Math.PI, d = t.getModel("axisLine"), f = d.get("roundCap"), p = f ? x_ : Fi, h = d.get("show"), v = d.getModel("lineStyle"), m = v.get("width"), g = [u, c];
      PD(g, !l), u = g[0], c = g[1];
      for (var y = c - u, b = u, _ = [], x = 0; h && x < a.length; x++) {
        var w = Math.min(Math.max(a[x][0], 0), 1);
        c = u + y * w;
        var S = new p({
          shape: {
            startAngle: b,
            endAngle: c,
            cx: o.cx,
            cy: o.cy,
            clockwise: l,
            r0: o.r - m,
            r: o.r
          },
          silent: !0
        });
        S.setStyle({
          fill: a[x][1]
        }), S.setStyle(v.getLineStyle(
          // Because we use sector to simulate arc
          // so the properties for stroking are useless
          ["color", "width"]
        )), _.push(S), b = c;
      }
      _.reverse(), $(_, function(k) {
        return s.add(k);
      });
      var C = function(k) {
        if (k <= 0)
          return a[0][1];
        var M;
        for (M = 0; M < a.length; M++)
          if (a[M][0] >= k && (M === 0 ? 0 : a[M - 1][0]) < k)
            return a[M][1];
        return a[M - 1][1];
      };
      this._renderTicks(t, r, i, C, o, u, c, l, m), this._renderTitleAndDetail(t, r, i, C, o), this._renderAnchor(t, o), this._renderPointer(t, r, i, C, o, u, c, l, m);
    }, e.prototype._renderTicks = function(t, r, i, a, o, s, l, u, c) {
      for (var d = this.group, f = o.cx, p = o.cy, h = o.r, v = +t.get("min"), m = +t.get("max"), g = t.getModel("splitLine"), y = t.getModel("axisTick"), b = t.getModel("axisLabel"), _ = t.get("splitNumber"), x = y.get("splitNumber"), w = ze(g.get("length"), h), S = ze(y.get("length"), h), C = s, k = (l - s) / _, M = k / x, D = g.getModel("lineStyle").getLineStyle(), N = y.getModel("lineStyle").getLineStyle(), R = g.get("distance"), j, z, F = 0; F <= _; F++) {
        if (j = Math.cos(C), z = Math.sin(C), g.get("show")) {
          var B = R ? R + c : c, H = new Dr({
            shape: {
              x1: j * (h - B) + f,
              y1: z * (h - B) + p,
              x2: j * (h - w - B) + f,
              y2: z * (h - w - B) + p
            },
            style: D,
            silent: !0
          });
          D.stroke === "auto" && H.setStyle({
            stroke: a(F / _)
          }), d.add(H);
        }
        if (b.get("show")) {
          var B = b.get("distance") + R, Y = H0(ir(F / _ * (m - v) + v), b.get("formatter")), ne = a(F / _), J = j * (h - w - B) + f, X = z * (h - w - B) + p, ie = b.get("rotate"), ye = 0;
          ie === "radial" ? (ye = -C + 2 * Math.PI, ye > Math.PI / 2 && (ye += Math.PI)) : ie === "tangential" ? ye = -C - Math.PI / 2 : sn(ie) && (ye = ie * Math.PI / 180), ye === 0 ? d.add(new nn({
            style: Ln(b, {
              text: Y,
              x: J,
              y: X,
              verticalAlign: z < -0.8 ? "top" : z > 0.8 ? "bottom" : "middle",
              align: j < -0.4 ? "left" : j > 0.4 ? "right" : "center"
            }, {
              inheritColor: ne
            }),
            silent: !0
          })) : d.add(new nn({
            style: Ln(b, {
              text: Y,
              x: J,
              y: X,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: ne
            }),
            silent: !0,
            originX: J,
            originY: X,
            rotation: ye
          }));
        }
        if (y.get("show") && F !== _) {
          var B = y.get("distance");
          B = B ? B + c : c;
          for (var pe = 0; pe <= x; pe++) {
            j = Math.cos(C), z = Math.sin(C);
            var Be = new Dr({
              shape: {
                x1: j * (h - B) + f,
                y1: z * (h - B) + p,
                x2: j * (h - S - B) + f,
                y2: z * (h - S - B) + p
              },
              silent: !0,
              style: N
            });
            N.stroke === "auto" && Be.setStyle({
              stroke: a((F + pe / x) / _)
            }), d.add(Be), C += M;
          }
          C -= M;
        } else
          C += k;
      }
    }, e.prototype._renderPointer = function(t, r, i, a, o, s, l, u, c) {
      var d = this.group, f = this._data, p = this._progressEls, h = [], v = t.get(["pointer", "show"]), m = t.getModel("progress"), g = m.get("show"), y = t.getData(), b = y.mapDimension("value"), _ = +t.get("min"), x = +t.get("max"), w = [_, x], S = [s, l];
      function C(M, D) {
        var N = y.getItemModel(M), R = N.getModel("pointer"), j = ze(R.get("width"), o.r), z = ze(R.get("length"), o.r), F = t.get(["pointer", "icon"]), B = R.get("offsetCenter"), H = ze(B[0], o.r), Y = ze(B[1], o.r), ne = R.get("keepAspect"), J;
        return F ? J = yr(F, H - j / 2, Y - z, j, z, null, ne) : J = new aze({
          shape: {
            angle: -Math.PI / 2,
            width: j,
            r: z,
            x: H,
            y: Y
          }
        }), J.rotation = -(D + Math.PI / 2), J.x = o.cx, J.y = o.cy, J;
      }
      function k(M, D) {
        var N = m.get("roundCap"), R = N ? x_ : Fi, j = m.get("overlap"), z = j ? m.get("width") : c / y.count(), F = j ? o.r - z : o.r - (M + 1) * z, B = j ? o.r : o.r - M * z, H = new R({
          shape: {
            startAngle: s,
            endAngle: D,
            cx: o.cx,
            cy: o.cy,
            clockwise: u,
            r0: F,
            r: B
          }
        });
        return j && (H.z2 = mn(y.get(b, M), [_, x], [100, 0], !0)), H;
      }
      (g || v) && (y.diff(f).add(function(M) {
        var D = y.get(b, M);
        if (v) {
          var N = C(M, s);
          Gn(N, {
            rotation: -((isNaN(+D) ? S[0] : mn(D, w, S, !0)) + Math.PI / 2)
          }, t), d.add(N), y.setItemGraphicEl(M, N);
        }
        if (g) {
          var R = k(M, s), j = m.get("clip");
          Gn(R, {
            shape: {
              endAngle: mn(D, w, S, j)
            }
          }, t), d.add(R), ck(t.seriesIndex, y.dataType, M, R), h[M] = R;
        }
      }).update(function(M, D) {
        var N = y.get(b, M);
        if (v) {
          var R = f.getItemGraphicEl(D), j = R ? R.rotation : s, z = C(M, j);
          z.rotation = j, ln(z, {
            rotation: -((isNaN(+N) ? S[0] : mn(N, w, S, !0)) + Math.PI / 2)
          }, t), d.add(z), y.setItemGraphicEl(M, z);
        }
        if (g) {
          var F = p[D], B = F ? F.shape.endAngle : s, H = k(M, B), Y = m.get("clip");
          ln(H, {
            shape: {
              endAngle: mn(N, w, S, Y)
            }
          }, t), d.add(H), ck(t.seriesIndex, y.dataType, M, H), h[M] = H;
        }
      }).execute(), y.each(function(M) {
        var D = y.getItemModel(M), N = D.getModel("emphasis"), R = N.get("focus"), j = N.get("blurScope"), z = N.get("disabled");
        if (v) {
          var F = y.getItemGraphicEl(M), B = y.getItemVisual(M, "style"), H = B.fill;
          if (F instanceof Ur) {
            var Y = F.style;
            F.useStyle(xe({
              image: Y.image,
              x: Y.x,
              y: Y.y,
              width: Y.width,
              height: Y.height
            }, B));
          } else
            F.useStyle(B), F.type !== "pointer" && F.setColor(H);
          F.setStyle(D.getModel(["pointer", "itemStyle"]).getItemStyle()), F.style.fill === "auto" && F.setStyle("fill", a(mn(y.get(b, M), w, [0, 1], !0))), F.z2EmphasisLift = 0, Qr(F, D), er(F, R, j, z);
        }
        if (g) {
          var ne = h[M];
          ne.useStyle(y.getItemVisual(M, "style")), ne.setStyle(D.getModel(["progress", "itemStyle"]).getItemStyle()), ne.z2EmphasisLift = 0, Qr(ne, D), er(ne, R, j, z);
        }
      }), this._progressEls = h);
    }, e.prototype._renderAnchor = function(t, r) {
      var i = t.getModel("anchor"), a = i.get("show");
      if (a) {
        var o = i.get("size"), s = i.get("icon"), l = i.get("offsetCenter"), u = i.get("keepAspect"), c = yr(s, r.cx - o / 2 + ze(l[0], r.r), r.cy - o / 2 + ze(l[1], r.r), o, o, null, u);
        c.z2 = i.get("showAbove") ? 1 : 0, c.setStyle(i.getModel("itemStyle").getItemStyle()), this.group.add(c);
      }
    }, e.prototype._renderTitleAndDetail = function(t, r, i, a, o) {
      var s = this, l = t.getData(), u = l.mapDimension("value"), c = +t.get("min"), d = +t.get("max"), f = new mt(), p = [], h = [], v = t.isAnimationEnabled(), m = t.get(["pointer", "showAbove"]);
      l.diff(this._data).add(function(g) {
        p[g] = new nn({
          silent: !0
        }), h[g] = new nn({
          silent: !0
        });
      }).update(function(g, y) {
        p[g] = s._titleEls[y], h[g] = s._detailEls[y];
      }).execute(), l.each(function(g) {
        var y = l.getItemModel(g), b = l.get(u, g), _ = new mt(), x = a(mn(b, [c, d], [0, 1], !0)), w = y.getModel("title");
        if (w.get("show")) {
          var S = w.get("offsetCenter"), C = o.cx + ze(S[0], o.r), k = o.cy + ze(S[1], o.r), M = p[g];
          M.attr({
            z2: m ? 0 : 2,
            style: Ln(w, {
              x: C,
              y: k,
              text: l.getName(g),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: x
            })
          }), _.add(M);
        }
        var D = y.getModel("detail");
        if (D.get("show")) {
          var N = D.get("offsetCenter"), R = o.cx + ze(N[0], o.r), j = o.cy + ze(N[1], o.r), z = ze(D.get("width"), o.r), F = ze(D.get("height"), o.r), B = t.get(["progress", "show"]) ? l.getItemVisual(g, "style").fill : x, M = h[g], H = D.get("formatter");
          M.attr({
            z2: m ? 0 : 2,
            style: Ln(D, {
              x: R,
              y: j,
              text: H0(b, H),
              width: isNaN(z) ? null : z,
              height: isNaN(F) ? null : F,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: B
            })
          }), wU(M, {
            normal: D
          }, b, function(ne) {
            return H0(ne, H);
          }), v && SU(M, g, l, t, {
            getFormattedLabel: function(ne, J, X, ie, ye, pe) {
              return H0(pe ? pe.interpolatedValue : b, H);
            }
          }), _.add(M);
        }
        f.add(_);
      }), this.group.add(f), this._titleEls = p, this._detailEls = h;
    }, e.type = "gauge", e;
  }(Tn)
), lze = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "itemStyle", t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return wh(this, ["value"]);
    }, e.type = "series.gauge", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      // 默认全局居中
      center: ["50%", "50%"],
      legendHoverLink: !0,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: !0,
      // 最小值
      min: 0,
      // 最大值
      max: 100,
      // 分割段数，默认为10
      splitNumber: 10,
      // 坐标轴线
      axisLine: {
        // 默认显示，属性show控制显示与否
        show: !0,
        roundCap: !1,
        lineStyle: {
          color: [[1, "#E6EBF8"]],
          width: 10
        }
      },
      // 坐标轴线
      progress: {
        // 默认显示，属性show控制显示与否
        show: !1,
        overlap: !0,
        width: 10,
        roundCap: !1,
        clip: !0
      },
      // 分隔线
      splitLine: {
        // 默认显示，属性show控制显示与否
        show: !0,
        // 属性length控制线长
        length: 10,
        distance: 10,
        // 属性lineStyle（详见lineStyle）控制线条样式
        lineStyle: {
          color: "#63677A",
          width: 3,
          type: "solid"
        }
      },
      // 坐标轴小标记
      axisTick: {
        // 属性show控制显示与否，默认不显示
        show: !0,
        // 每份split细分多少段
        splitNumber: 5,
        // 属性length控制线长
        length: 6,
        distance: 10,
        // 属性lineStyle控制线条样式
        lineStyle: {
          color: "#63677A",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: !0,
        distance: 15,
        // formatter: null,
        color: "#464646",
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [0, 0],
        show: !0,
        showAbove: !0,
        length: "60%",
        width: 6,
        keepAspect: !1
      },
      anchor: {
        show: !1,
        showAbove: !1,
        size: 6,
        icon: "circle",
        offsetCenter: [0, 0],
        keepAspect: !1,
        itemStyle: {
          color: "#fff",
          borderWidth: 0,
          borderColor: "#5470c6"
        }
      },
      title: {
        show: !0,
        // x, y，单位px
        offsetCenter: [0, "20%"],
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#464646",
        fontSize: 16,
        valueAnimation: !1
      },
      detail: {
        show: !0,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        padding: [5, 10],
        // x, y，单位px
        offsetCenter: [0, "40%"],
        // formatter: null,
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#464646",
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: !1
      }
    }, e;
  }(Rn)
);
function uze(n) {
  n.registerChartView(sze), n.registerSeriesModel(lze);
}
var cze = ["itemStyle", "opacity"], dze = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r) {
      var i = n.call(this) || this, a = i, o = new Hi(), s = new nn();
      return a.setTextContent(s), i.setTextGuideLine(o), i.updateData(t, r, !0), i;
    }
    return e.prototype.updateData = function(t, r, i) {
      var a = this, o = t.hostModel, s = t.getItemModel(r), l = t.getItemLayout(r), u = s.getModel("emphasis"), c = s.get(cze);
      c = c ?? 1, i || Oo(a), a.useStyle(t.getItemVisual(r, "style")), a.style.lineJoin = "round", i ? (a.setShape({
        points: l.points
      }), a.style.opacity = 0, Gn(a, {
        style: {
          opacity: c
        }
      }, o, r)) : ln(a, {
        style: {
          opacity: c
        },
        shape: {
          points: l.points
        }
      }, o, r), Qr(a, s), this._updateLabel(t, r), er(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t, r) {
      var i = this, a = this.getTextGuideLine(), o = i.getTextContent(), s = t.hostModel, l = t.getItemModel(r), u = t.getItemLayout(r), c = u.label, d = t.getItemVisual(r, "style"), f = d.fill;
      ei(
        // position will not be used in setLabelStyle
        o,
        Nr(l),
        {
          labelFetcher: t.hostModel,
          labelDataIndex: r,
          defaultOpacity: d.opacity,
          defaultText: t.getName(r)
        },
        {
          normal: {
            align: c.textAlign,
            verticalAlign: c.verticalAlign
          }
        }
      ), i.setTextConfig({
        local: !0,
        inside: !!c.inside,
        insideStroke: f,
        // insideFill: 'auto',
        outsideFill: f
      });
      var p = c.linePoints;
      a.setShape({
        points: p
      }), i.textGuideLineConfig = {
        anchor: p ? new Mt(p[0][0], p[0][1]) : null
      }, ln(o, {
        style: {
          x: c.x,
          y: c.y
        }
      }, s, r), o.attr({
        rotation: c.rotation,
        originX: c.x,
        originY: c.y,
        z2: 10
      }), _O(i, xO(l), {
        // Default use item visual color
        stroke: f
      });
    }, e;
  }(Vi)
), fze = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.ignoreLabelLineUpdate = !0, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = t.getData(), o = this._data, s = this.group;
      a.diff(o).add(function(l) {
        var u = new dze(a, l);
        a.setItemGraphicEl(l, u), s.add(u);
      }).update(function(l, u) {
        var c = o.getItemGraphicEl(u);
        c.updateData(a, l), s.add(c), a.setItemGraphicEl(l, c);
      }).remove(function(l) {
        var u = o.getItemGraphicEl(l);
        tg(u, t, l);
      }).execute(), this._data = a;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.prototype.dispose = function() {
    }, e.type = "funnel", e;
  }(Tn)
), pze = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new ny(Ze(this.getData, this), Ze(this.getRawData, this)), this._defaultLabelLine(t);
    }, e.prototype.getInitialData = function(t, r) {
      return wh(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Tt(QD, this)
      });
    }, e.prototype._defaultLabelLine = function(t) {
      Od(t, "labelLine", ["show"]);
      var r = t.labelLine, i = t.emphasis.labelLine;
      r.show = r.show && t.label.show, i.show = i.show && t.emphasis.label.show;
    }, e.prototype.getDataParams = function(t) {
      var r = this.getData(), i = n.prototype.getDataParams.call(this, t), a = r.mapDimension("value"), o = r.getSum(a);
      return i.percent = o ? +(r.get(a, t) / o * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
    }, e.type = "series.funnel", e.defaultOption = {
      // zlevel: 0,                  // 一级层叠
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      // 默认取数据最小最大值
      // min: 0,
      // max: 100,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: !0,
        position: "outer"
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      },
      labelLine: {
        show: !0,
        length: 20,
        lineStyle: {
          // color: 各异,
          width: 1
        }
      },
      itemStyle: {
        // color: 各异,
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Rn)
);
function hze(n, e) {
  return Er(n.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function vze(n, e) {
  for (var t = n.mapDimension("value"), r = n.mapArray(t, function(l) {
    return l;
  }), i = [], a = e === "ascending", o = 0, s = n.count(); o < s; o++)
    i[o] = o;
  return at(e) ? i.sort(e) : e !== "none" && i.sort(function(l, u) {
    return a ? r[l] - r[u] : r[u] - r[l];
  }), i;
}
function mze(n) {
  var e = n.hostModel, t = e.get("orient");
  n.each(function(r) {
    var i = n.getItemModel(r), a = i.getModel("label"), o = a.get("position"), s = i.getModel("labelLine"), l = n.getItemLayout(r), u = l.points, c = o === "inner" || o === "inside" || o === "center" || o === "insideLeft" || o === "insideRight", d, f, p, h;
    if (c)
      o === "insideLeft" ? (f = (u[0][0] + u[3][0]) / 2 + 5, p = (u[0][1] + u[3][1]) / 2, d = "left") : o === "insideRight" ? (f = (u[1][0] + u[2][0]) / 2 - 5, p = (u[1][1] + u[2][1]) / 2, d = "right") : (f = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, p = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, d = "center"), h = [[f, p], [f, p]];
    else {
      var v = void 0, m = void 0, g = void 0, y = void 0, b = s.get("length");
      process.env.NODE_ENV !== "production" && (t === "vertical" && ["top", "bottom"].indexOf(o) > -1 && (o = "left", console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.")), t === "horizontal" && ["left", "right"].indexOf(o) > -1 && (o = "bottom", console.warn("Position error: Funnel chart on horizontal orient dose not support left and right."))), o === "left" ? (v = (u[3][0] + u[0][0]) / 2, m = (u[3][1] + u[0][1]) / 2, g = v - b, f = g - 5, d = "right") : o === "right" ? (v = (u[1][0] + u[2][0]) / 2, m = (u[1][1] + u[2][1]) / 2, g = v + b, f = g + 5, d = "left") : o === "top" ? (v = (u[3][0] + u[0][0]) / 2, m = (u[3][1] + u[0][1]) / 2, y = m - b, p = y - 5, d = "center") : o === "bottom" ? (v = (u[1][0] + u[2][0]) / 2, m = (u[1][1] + u[2][1]) / 2, y = m + b, p = y + 5, d = "center") : o === "rightTop" ? (v = t === "horizontal" ? u[3][0] : u[1][0], m = t === "horizontal" ? u[3][1] : u[1][1], t === "horizontal" ? (y = m - b, p = y - 5, d = "center") : (g = v + b, f = g + 5, d = "top")) : o === "rightBottom" ? (v = u[2][0], m = u[2][1], t === "horizontal" ? (y = m + b, p = y + 5, d = "center") : (g = v + b, f = g + 5, d = "bottom")) : o === "leftTop" ? (v = u[0][0], m = t === "horizontal" ? u[0][1] : u[1][1], t === "horizontal" ? (y = m - b, p = y - 5, d = "center") : (g = v - b, f = g - 5, d = "right")) : o === "leftBottom" ? (v = t === "horizontal" ? u[1][0] : u[3][0], m = t === "horizontal" ? u[1][1] : u[2][1], t === "horizontal" ? (y = m + b, p = y + 5, d = "center") : (g = v - b, f = g - 5, d = "right")) : (v = (u[1][0] + u[2][0]) / 2, m = (u[1][1] + u[2][1]) / 2, t === "horizontal" ? (y = m + b, p = y + 5, d = "center") : (g = v + b, f = g + 5, d = "left")), t === "horizontal" ? (g = v, f = g) : (y = m, p = y), h = [[v, m], [g, y]];
    }
    l.label = {
      linePoints: h,
      x: f,
      y: p,
      verticalAlign: "middle",
      textAlign: d,
      inside: c
    };
  });
}
function gze(n, e) {
  n.eachSeriesByType("funnel", function(t) {
    var r = t.getData(), i = r.mapDimension("value"), a = t.get("sort"), o = hze(t, e), s = t.get("orient"), l = o.width, u = o.height, c = vze(r, a), d = o.x, f = o.y, p = s === "horizontal" ? [ze(t.get("minSize"), u), ze(t.get("maxSize"), u)] : [ze(t.get("minSize"), l), ze(t.get("maxSize"), l)], h = r.getDataExtent(i), v = t.get("min"), m = t.get("max");
    v == null && (v = Math.min(h[0], 0)), m == null && (m = h[1]);
    var g = t.get("funnelAlign"), y = t.get("gap"), b = s === "horizontal" ? l : u, _ = (b - y * (r.count() - 1)) / r.count(), x = function(j, z) {
      if (s === "horizontal") {
        var F = r.get(i, j) || 0, B = mn(F, [v, m], p, !0), H = void 0;
        switch (g) {
          case "top":
            H = f;
            break;
          case "center":
            H = f + (u - B) / 2;
            break;
          case "bottom":
            H = f + (u - B);
            break;
        }
        return [[z, H], [z, H + B]];
      }
      var Y = r.get(i, j) || 0, ne = mn(Y, [v, m], p, !0), J;
      switch (g) {
        case "left":
          J = d;
          break;
        case "center":
          J = d + (l - ne) / 2;
          break;
        case "right":
          J = d + l - ne;
          break;
      }
      return [[J, z], [J + ne, z]];
    };
    a === "ascending" && (_ = -_, y = -y, s === "horizontal" ? d += l : f += u, c = c.reverse());
    for (var w = 0; w < c.length; w++) {
      var S = c[w], C = c[w + 1], k = r.getItemModel(S);
      if (s === "horizontal") {
        var M = k.get(["itemStyle", "width"]);
        M == null ? M = _ : (M = ze(M, l), a === "ascending" && (M = -M));
        var D = x(S, d), N = x(C, d + M);
        d += M + y, r.setItemLayout(S, {
          points: D.concat(N.slice().reverse())
        });
      } else {
        var R = k.get(["itemStyle", "height"]);
        R == null ? R = _ : (R = ze(R, u), a === "ascending" && (R = -R));
        var D = x(S, f), N = x(C, f + R);
        f += R + y, r.setItemLayout(S, {
          points: D.concat(N.slice().reverse())
        });
      }
    }
    mze(r);
  });
}
function yze(n) {
  n.registerChartView(fze), n.registerSeriesModel(pze), n.registerLayout(gze), n.registerProcessor(ty("funnel"));
}
var bze = 0.3, _ze = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._dataGroup = new mt(), t._initialized = !1, t;
    }
    return e.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, e.prototype.render = function(t, r, i, a) {
      this._progressiveEls = null;
      var o = this._dataGroup, s = t.getData(), l = this._data, u = t.coordinateSystem, c = u.dimensions, d = L4(t);
      s.diff(l).add(f).update(p).remove(h).execute();
      function f(m) {
        var g = I4(s, o, m, c, u);
        NE(g, s, m, d);
      }
      function p(m, g) {
        var y = l.getItemGraphicEl(g), b = qY(s, m, c, u);
        s.setItemGraphicEl(m, y), ln(y, {
          shape: {
            points: b
          }
        }, t, m), Oo(y), NE(y, s, m, d);
      }
      function h(m) {
        var g = l.getItemGraphicEl(m);
        o.remove(g);
      }
      if (!this._initialized) {
        this._initialized = !0;
        var v = xze(u, t, function() {
          setTimeout(function() {
            o.removeClipPath();
          });
        });
        o.setClipPath(v);
      }
      this._data = s;
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      this._initialized = !0, this._data = null, this._dataGroup.removeAll();
    }, e.prototype.incrementalRender = function(t, r, i) {
      for (var a = r.getData(), o = r.coordinateSystem, s = o.dimensions, l = L4(r), u = this._progressiveEls = [], c = t.start; c < t.end; c++) {
        var d = I4(a, this._dataGroup, c, s, o);
        d.incremental = !0, NE(d, a, c, l), u.push(d);
      }
    }, e.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, e.type = "parallel", e;
  }(Tn)
);
function xze(n, e, t) {
  var r = n.model, i = n.getRect(), a = new Qt({
    shape: {
      x: i.x,
      y: i.y,
      width: i.width,
      height: i.height
    }
  }), o = r.get("layout") === "horizontal" ? "width" : "height";
  return a.setShape(o, 0), Gn(a, {
    shape: {
      width: i.width,
      height: i.height
    }
  }, e, t), a;
}
function qY(n, e, t, r) {
  for (var i = [], a = 0; a < t.length; a++) {
    var o = t[a], s = n.get(n.mapDimension(o), e);
    wze(s, r.getAxis(o).type) || i.push(r.dataToPoint(s, o));
  }
  return i;
}
function I4(n, e, t, r, i) {
  var a = qY(n, t, r, i), o = new Hi({
    shape: {
      points: a
    },
    // silent: true,
    z2: 10
  });
  return e.add(o), n.setItemGraphicEl(t, o), o;
}
function L4(n) {
  var e = n.get("smooth", !0);
  return e === !0 && (e = bze), e = _l(e), Dd(e) && (e = 0), {
    smooth: e
  };
}
function NE(n, e, t, r) {
  n.useStyle(e.getItemVisual(t, "style")), n.style.fill = null, n.setShape("smooth", r.smooth);
  var i = e.getItemModel(t), a = i.getModel("emphasis");
  Qr(n, i, "lineStyle"), er(n, a.get("focus"), a.get("blurScope"), a.get("disabled"));
}
function wze(n, e) {
  return e === "category" ? n == null : n == null || isNaN(n);
}
var Sze = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return Dl(null, this, {
        useEncodeDefaulter: Ze(Eze, null, this)
      });
    }, e.prototype.getRawIndicesByActiveState = function(t) {
      var r = this.coordinateSystem, i = this.getData(), a = [];
      return r.eachActiveState(i, function(o, s) {
        t === o && a.push(i.getRawIndex(s));
      }), a;
    }, e.type = "series.parallel", e.dependencies = ["parallel"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: !1
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: !1
        }
      },
      progressive: 500,
      smooth: !1,
      animationEasing: "linear"
    }, e;
  }(Rn)
);
function Eze(n) {
  var e = n.ecModel.getComponent("parallel", n.get("parallelIndex"));
  if (e) {
    var t = {};
    return $(e.dimensions, function(r) {
      var i = Tze(r);
      t[r] = i;
    }), t;
  }
}
function Tze(n) {
  return +n.replace("dim", "");
}
var Cze = ["lineStyle", "opacity"], kze = {
  seriesType: "parallel",
  reset: function(n, e) {
    var t = n.coordinateSystem, r = {
      normal: n.get(["lineStyle", "opacity"]),
      active: n.get("activeOpacity"),
      inactive: n.get("inactiveOpacity")
    };
    return {
      progress: function(i, a) {
        t.eachActiveState(a, function(o, s) {
          var l = r[o];
          if (o === "normal" && a.hasItemOption) {
            var u = a.getItemModel(s).get(Cze, !0);
            u != null && (l = u);
          }
          var c = a.ensureUniqueItemVisual(s, "style");
          c.opacity = l;
        }, i.start, i.end);
      }
    };
  }
};
function Aze(n) {
  Mze(n), Dze(n);
}
function Mze(n) {
  if (!n.parallel) {
    var e = !1;
    $(n.series, function(t) {
      t && t.type === "parallel" && (e = !0);
    }), e && (n.parallel = [{}]);
  }
}
function Dze(n) {
  var e = wn(n.parallelAxis);
  $(e, function(t) {
    if (ut(t)) {
      var r = t.parallelIndex || 0, i = wn(n.parallel)[r];
      i && i.parallelAxisDefault && At(t, i.parallelAxisDefault, !1);
    }
  });
}
var Oze = 5, Ize = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      this._model = t, this._api = i, this._handlers || (this._handlers = {}, $(Lze, function(a, o) {
        i.getZr().on(o, this._handlers[o] = Ze(a, this));
      }, this)), bh(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate");
    }, e.prototype.dispose = function(t, r) {
      ag(this, "_throttledDispatchExpand"), $(this._handlers, function(i, a) {
        r.getZr().off(a, i);
      }), this._handlers = null;
    }, e.prototype._throttledDispatchExpand = function(t) {
      this._dispatchExpand(t);
    }, e.prototype._dispatchExpand = function(t) {
      t && this._api.dispatchAction(xe({
        type: "parallelAxisExpand"
      }, t));
    }, e.type = "parallel", e;
  }(Yn)
), Lze = {
  mousedown: function(n) {
    RE(this, "click") && (this._mouseDownPoint = [n.offsetX, n.offsetY]);
  },
  mouseup: function(n) {
    var e = this._mouseDownPoint;
    if (RE(this, "click") && e) {
      var t = [n.offsetX, n.offsetY], r = Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2);
      if (r > Oze)
        return;
      var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([n.offsetX, n.offsetY]);
      i.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: i.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(n) {
    if (!(this._mouseDownPoint || !RE(this, "mousemove"))) {
      var e = this._model, t = e.coordinateSystem.getSlidedAxisExpandWindow([n.offsetX, n.offsetY]), r = t.behavior;
      r === "jump" && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), this._throttledDispatchExpand(r === "none" ? null : {
        axisExpandWindow: t.axisExpandWindow,
        // Jumping uses animation, and sliding suppresses animation.
        animation: r === "jump" ? null : {
          duration: 0
          // Disable animation.
        }
      });
    }
  }
};
function RE(n, e) {
  var t = n._model;
  return t.get("axisExpandable") && t.get("axisExpandTriggerOn") === e;
}
var Nze = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      n.prototype.init.apply(this, arguments), this.mergeOption({});
    }, e.prototype.mergeOption = function(t) {
      var r = this.option;
      t && At(r, t, !0), this._initDimensions();
    }, e.prototype.contains = function(t, r) {
      var i = t.get("parallelIndex");
      return i != null && r.getComponent("parallel", i) === this;
    }, e.prototype.setAxisExpand = function(t) {
      $(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(r) {
        t.hasOwnProperty(r) && (this.option[r] = t[r]);
      }, this);
    }, e.prototype._initDimensions = function() {
      var t = this.dimensions = [], r = this.parallelAxisIndex = [], i = vn(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(a) {
        return (a.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      $(i, function(a) {
        t.push("dim" + a.get("dim")), r.push(a.componentIndex);
      });
    }, e.type = "parallel", e.dependencies = ["parallelAxis"], e.layoutMode = "box", e.defaultOption = {
      // zlevel: 0,
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      layout: "horizontal",
      // FIXME
      // naming?
      axisExpandable: !1,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
      // Do not doc to user until necessary.
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, e;
  }(Ut)
), Rze = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i, a, o) {
      var s = n.call(this, t, r, i) || this;
      return s.type = a || "value", s.axisIndex = o, s;
    }
    return e.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, e;
  }(Po)
);
function af(n, e, t, r, i, a) {
  n = n || 0;
  var o = t[1] - t[0];
  if (i != null && (i = jf(i, [0, o])), a != null && (a = Math.max(a, i ?? 0)), r === "all") {
    var s = Math.abs(e[1] - e[0]);
    s = jf(s, [0, o]), i = a = jf(s, [i, a]), r = 0;
  }
  e[0] = jf(e[0], t), e[1] = jf(e[1], t);
  var l = PE(e, r);
  e[r] += n;
  var u = i || 0, c = t.slice();
  l.sign < 0 ? c[0] += u : c[1] -= u, e[r] = jf(e[r], c);
  var d;
  return d = PE(e, r), i != null && (d.sign !== l.sign || d.span < i) && (e[1 - r] = e[r] + l.sign * i), d = PE(e, r), a != null && d.span > a && (e[1 - r] = e[r] + d.sign * a), e;
}
function PE(n, e) {
  var t = n[e] - n[1 - e];
  return {
    span: Math.abs(t),
    sign: t > 0 ? -1 : t < 0 ? 1 : e ? -1 : 1
  };
}
function jf(n, e) {
  return Math.min(e[1] != null ? e[1] : 1 / 0, Math.max(e[0] != null ? e[0] : -1 / 0, n));
}
var jE = $, YY = Math.min, KY = Math.max, N4 = Math.floor, Pze = Math.ceil, R4 = ir, jze = Math.PI, Bze = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.type = "parallel", this._axesMap = tt(), this._axesLayout = {}, this.dimensions = e.dimensions, this._model = e, this._init(e, t, r);
    }
    return n.prototype._init = function(e, t, r) {
      var i = e.dimensions, a = e.parallelAxisIndex;
      jE(i, function(o, s) {
        var l = a[s], u = t.getComponent("parallelAxis", l), c = this._axesMap.set(o, new Rze(o, Sw(u), [0, 0], u.get("type"), l)), d = c.type === "category";
        c.onBand = d && u.get("boundaryGap"), c.inverse = u.get("inverse"), u.axis = c, c.model = u, c.coordinateSystem = u.coordinateSystem = this;
      }, this);
    }, n.prototype.update = function(e, t) {
      this._updateAxesFromSeries(this._model, e);
    }, n.prototype.containPoint = function(e) {
      var t = this._makeLayoutInfo(), r = t.axisBase, i = t.layoutBase, a = t.pixelDimIndex, o = e[1 - a], s = e[a];
      return o >= r && o <= r + t.axisLength && s >= i && s <= i + t.layoutLength;
    }, n.prototype.getModel = function() {
      return this._model;
    }, n.prototype._updateAxesFromSeries = function(e, t) {
      t.eachSeries(function(r) {
        if (e.contains(r, t)) {
          var i = r.getData();
          jE(this.dimensions, function(a) {
            var o = this._axesMap.get(a);
            o.scale.unionExtentFromData(i, i.mapDimension(a)), Gp(o.scale, o.model);
          }, this);
        }
      }, this);
    }, n.prototype.resize = function(e, t) {
      this._rect = Er(e.getBoxLayoutParams(), {
        width: t.getWidth(),
        height: t.getHeight()
      }), this._layoutAxes();
    }, n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype._makeLayoutInfo = function() {
      var e = this._model, t = this._rect, r = ["x", "y"], i = ["width", "height"], a = e.get("layout"), o = a === "horizontal" ? 0 : 1, s = t[i[o]], l = [0, s], u = this.dimensions.length, c = G0(e.get("axisExpandWidth"), l), d = G0(e.get("axisExpandCount") || 0, [0, u]), f = e.get("axisExpandable") && u > 3 && u > d && d > 1 && c > 0 && s > 0, p = e.get("axisExpandWindow"), h;
      if (p)
        h = G0(p[1] - p[0], l), p[1] = p[0] + h;
      else {
        h = G0(c * (d - 1), l);
        var v = e.get("axisExpandCenter") || N4(u / 2);
        p = [c * v - h / 2], p[1] = p[0] + h;
      }
      var m = (s - h) / (u - d);
      m < 3 && (m = 0);
      var g = [N4(R4(p[0] / c, 1)) + 1, Pze(R4(p[1] / c, 1)) - 1], y = m / c * p[0];
      return {
        layout: a,
        pixelDimIndex: o,
        layoutBase: t[r[o]],
        layoutLength: s,
        axisBase: t[r[1 - o]],
        axisLength: t[i[1 - o]],
        axisExpandable: f,
        axisExpandWidth: c,
        axisCollapseWidth: m,
        axisExpandWindow: p,
        axisCount: u,
        winInnerIndices: g,
        axisExpandWindow0Pos: y
      };
    }, n.prototype._layoutAxes = function() {
      var e = this._rect, t = this._axesMap, r = this.dimensions, i = this._makeLayoutInfo(), a = i.layout;
      t.each(function(o) {
        var s = [0, i.axisLength], l = o.inverse ? 1 : 0;
        o.setExtent(s[l], s[1 - l]);
      }), jE(r, function(o, s) {
        var l = (i.axisExpandable ? zze : $ze)(s, i), u = {
          horizontal: {
            x: l.position,
            y: i.axisLength
          },
          vertical: {
            x: 0,
            y: l.position
          }
        }, c = {
          horizontal: jze / 2,
          vertical: 0
        }, d = [u[a].x + e.x, u[a].y + e.y], f = c[a], p = ya();
        Zd(p, p, f), ws(p, p, d), this._axesLayout[o] = {
          position: d,
          rotation: f,
          transform: p,
          axisNameAvailableWidth: l.axisNameAvailableWidth,
          axisLabelShow: l.axisLabelShow,
          nameTruncateMaxWidth: l.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, n.prototype.getAxis = function(e) {
      return this._axesMap.get(e);
    }, n.prototype.dataToPoint = function(e, t) {
      return this.axisCoordToPoint(this._axesMap.get(t).dataToCoord(e), t);
    }, n.prototype.eachActiveState = function(e, t, r, i) {
      r == null && (r = 0), i == null && (i = e.count());
      var a = this._axesMap, o = this.dimensions, s = [], l = [];
      $(o, function(m) {
        s.push(e.mapDimension(m)), l.push(a.get(m).model);
      });
      for (var u = this.hasAxisBrushed(), c = r; c < i; c++) {
        var d = void 0;
        if (!u)
          d = "normal";
        else {
          d = "active";
          for (var f = e.getValues(s, c), p = 0, h = o.length; p < h; p++) {
            var v = l[p].getActiveState(f[p]);
            if (v === "inactive") {
              d = "inactive";
              break;
            }
          }
        }
        t(d, c);
      }
    }, n.prototype.hasAxisBrushed = function() {
      for (var e = this.dimensions, t = this._axesMap, r = !1, i = 0, a = e.length; i < a; i++)
        t.get(e[i]).model.getActiveState() !== "normal" && (r = !0);
      return r;
    }, n.prototype.axisCoordToPoint = function(e, t) {
      var r = this._axesLayout[t];
      return wo([e, 0], r.transform);
    }, n.prototype.getAxisLayout = function(e) {
      return ht(this._axesLayout[e]);
    }, n.prototype.getSlidedAxisExpandWindow = function(e) {
      var t = this._makeLayoutInfo(), r = t.pixelDimIndex, i = t.axisExpandWindow.slice(), a = i[1] - i[0], o = [0, t.axisExpandWidth * (t.axisCount - 1)];
      if (!this.containPoint(e))
        return {
          behavior: "none",
          axisExpandWindow: i
        };
      var s = e[r] - t.layoutBase - t.axisExpandWindow0Pos, l, u = "slide", c = t.axisCollapseWidth, d = this._model.get("axisExpandSlideTriggerArea"), f = d[0] != null;
      if (c)
        f && c && s < a * d[0] ? (u = "jump", l = s - a * d[2]) : f && c && s > a * (1 - d[0]) ? (u = "jump", l = s - a * (1 - d[2])) : (l = s - a * d[1]) >= 0 && (l = s - a * (1 - d[1])) <= 0 && (l = 0), l *= t.axisExpandWidth / c, l ? af(l, i, o, "all") : u = "none";
      else {
        var p = i[1] - i[0], h = o[1] * s / p;
        i = [KY(0, h - p / 2)], i[1] = YY(o[1], i[0] + p), i[0] = i[1] - p;
      }
      return {
        axisExpandWindow: i,
        behavior: u
      };
    }, n;
  }()
);
function G0(n, e) {
  return YY(KY(n, e[0]), e[1]);
}
function $ze(n, e) {
  var t = e.layoutLength / (e.axisCount - 1);
  return {
    position: t * n,
    axisNameAvailableWidth: t,
    axisLabelShow: !0
  };
}
function zze(n, e) {
  var t = e.layoutLength, r = e.axisExpandWidth, i = e.axisCount, a = e.axisCollapseWidth, o = e.winInnerIndices, s, l = a, u = !1, c;
  return n < o[0] ? (s = n * a, c = a) : n <= o[1] ? (s = e.axisExpandWindow0Pos + n * r - e.axisExpandWindow[0], l = r, u = !0) : (s = t - (i - 1 - n) * a, c = a), {
    position: s,
    axisNameAvailableWidth: l,
    axisLabelShow: u,
    nameTruncateMaxWidth: c
  };
}
function Fze(n, e) {
  var t = [];
  return n.eachComponent("parallel", function(r, i) {
    var a = new Bze(r, n, e);
    a.name = "parallel_" + i, a.resize(r, e), r.coordinateSystem = a, a.model = r, t.push(a);
  }), n.eachSeries(function(r) {
    if (r.get("coordinateSystem") === "parallel") {
      var i = r.getReferringComponents("parallel", gr).models[0];
      r.coordinateSystem = i.coordinateSystem;
    }
  }), t;
}
var Vze = {
  create: Fze
}, tA = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.activeIntervals = [], t;
    }
    return e.prototype.getAreaSelectStyle = function() {
      return Ld([
        ["fill", "color"],
        ["lineWidth", "borderWidth"],
        ["stroke", "borderColor"],
        ["width", "width"],
        ["opacity", "opacity"]
        // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
        // So do not transfer decal directly.
      ])(this.getModel("areaSelectStyle"));
    }, e.prototype.setActiveIntervals = function(t) {
      var r = this.activeIntervals = ht(t);
      if (r)
        for (var i = r.length - 1; i >= 0; i--)
          Ya(r[i]);
    }, e.prototype.getActiveState = function(t) {
      var r = this.activeIntervals;
      if (!r.length)
        return "normal";
      if (t == null || isNaN(+t))
        return "inactive";
      if (r.length === 1) {
        var i = r[0];
        if (i[0] <= t && t <= i[1])
          return "active";
      } else
        for (var a = 0, o = r.length; a < o; a++)
          if (r[a][0] <= t && t <= r[a][1])
            return "active";
      return "inactive";
    }, e;
  }(Ut)
);
_r(tA, Xg);
var Pd = !0, gg = Math.min, qp = Math.max, Hze = Math.pow, Gze = 1e4, Uze = 6, Wze = 6, P4 = "globalPan", qze = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
}, Yze = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
}, j4 = {
  brushStyle: {
    lineWidth: 2,
    stroke: "rgba(210,219,238,0.3)",
    fill: "#D2DBEE"
  },
  transformable: !0,
  brushMode: "single",
  removeOnClick: !1
}, Kze = 0, GO = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this) || this;
      return r._track = [], r._covers = [], r._handlers = {}, process.env.NODE_ENV !== "production" && ct(t), r._zr = t, r.group = new mt(), r._uid = "brushController_" + Kze++, $(nFe, function(i, a) {
        this._handlers[a] = Ze(i, this);
      }, r), r;
    }
    return e.prototype.enableBrush = function(t) {
      return process.env.NODE_ENV !== "production" && ct(this._mounted), this._brushType && this._doDisableBrush(), t.brushType && this._doEnableBrush(t), this;
    }, e.prototype._doEnableBrush = function(t) {
      var r = this._zr;
      this._enableGlobalPan || $Be(r, P4, this._uid), $(this._handlers, function(i, a) {
        r.on(a, i);
      }), this._brushType = t.brushType, this._brushOption = At(ht(j4), t, !0);
    }, e.prototype._doDisableBrush = function() {
      var t = this._zr;
      zBe(t, P4, this._uid), $(this._handlers, function(r, i) {
        t.off(i, r);
      }), this._brushType = this._brushOption = null;
    }, e.prototype.setPanels = function(t) {
      if (t && t.length) {
        var r = this._panels = {};
        $(t, function(i) {
          r[i.panelId] = ht(i);
        });
      } else
        this._panels = null;
      return this;
    }, e.prototype.mount = function(t) {
      t = t || {}, process.env.NODE_ENV !== "production" && (this._mounted = !0), this._enableGlobalPan = t.enableGlobalPan;
      var r = this.group;
      return this._zr.add(r), r.attr({
        x: t.x || 0,
        y: t.y || 0,
        rotation: t.rotation || 0,
        scaleX: t.scaleX || 1,
        scaleY: t.scaleY || 1
      }), this._transform = r.getLocalTransform(), this;
    }, e.prototype.updateCovers = function(t) {
      process.env.NODE_ENV !== "production" && ct(this._mounted), t = De(t, function(f) {
        return At(ht(j4), f, !0);
      });
      var r = "\0-brush-index-", i = this._covers, a = this._covers = [], o = this, s = this._creatingCover;
      return new Sl(i, t, u, l).add(c).update(c).remove(d).execute(), this;
      function l(f, p) {
        return (f.id != null ? f.id : r + p) + "-" + f.brushType;
      }
      function u(f, p) {
        return l(f.__brushOption, p);
      }
      function c(f, p) {
        var h = t[f];
        if (p != null && i[p] === s)
          a[f] = i[p];
        else {
          var v = a[f] = p != null ? (i[p].__brushOption = h, i[p]) : ZY(o, XY(o, h));
          UO(o, v);
        }
      }
      function d(f) {
        i[f] !== s && o.group.remove(i[f]);
      }
    }, e.prototype.unmount = function() {
      if (!(process.env.NODE_ENV !== "production" && !this._mounted))
        return this.enableBrush(!1), nA(this), this._zr.remove(this.group), process.env.NODE_ENV !== "production" && (this._mounted = !1), this;
    }, e.prototype.dispose = function() {
      this.unmount(), this.off();
    }, e;
  }(io)
);
function XY(n, e) {
  var t = Mw[e.brushType].createCover(n, e);
  return t.__brushOption = e, QY(t, e), n.group.add(t), t;
}
function ZY(n, e) {
  var t = WO(e);
  return t.endCreating && (t.endCreating(n, e), QY(e, e.__brushOption)), e;
}
function JY(n, e) {
  var t = e.__brushOption;
  WO(e).updateCoverShape(n, e, t.range, t);
}
function QY(n, e) {
  var t = e.z;
  t == null && (t = Gze), n.traverse(function(r) {
    r.z = t, r.z2 = t;
  });
}
function UO(n, e) {
  WO(e).updateCommon(n, e), JY(n, e);
}
function WO(n) {
  return Mw[n.__brushOption.brushType];
}
function qO(n, e, t) {
  var r = n._panels;
  if (!r)
    return Pd;
  var i, a = n._transform;
  return $(r, function(o) {
    o.isTargetByCursor(e, t, a) && (i = o);
  }), i;
}
function eK(n, e) {
  var t = n._panels;
  if (!t)
    return Pd;
  var r = e.__brushOption.panelId;
  return r != null ? t[r] : Pd;
}
function nA(n) {
  var e = n._covers, t = e.length;
  return $(e, function(r) {
    n.group.remove(r);
  }, n), e.length = 0, !!t;
}
function jd(n, e) {
  var t = De(n._covers, function(r) {
    var i = r.__brushOption, a = ht(i.range);
    return {
      brushType: i.brushType,
      panelId: i.panelId,
      range: a
    };
  });
  n.trigger("brush", {
    areas: t,
    isEnd: !!e.isEnd,
    removeOnClick: !!e.removeOnClick
  });
}
function Xze(n) {
  var e = n._track;
  if (!e.length)
    return !1;
  var t = e[e.length - 1], r = e[0], i = t[0] - r[0], a = t[1] - r[1], o = Hze(i * i + a * a, 0.5);
  return o > Uze;
}
function tK(n) {
  var e = n.length - 1;
  return e < 0 && (e = 0), [n[0], n[e]];
}
function nK(n, e, t, r) {
  var i = new mt();
  return i.add(new Qt({
    name: "main",
    style: YO(t),
    silent: !0,
    draggable: !0,
    cursor: "move",
    drift: Tt(B4, n, e, i, ["n", "s", "w", "e"]),
    ondragend: Tt(jd, e, {
      isEnd: !0
    })
  })), $(r, function(a) {
    i.add(new Qt({
      name: a.join(""),
      style: {
        opacity: 0
      },
      draggable: !0,
      silent: !0,
      invisible: !0,
      drift: Tt(B4, n, e, i, a),
      ondragend: Tt(jd, e, {
        isEnd: !0
      })
    }));
  }), i;
}
function rK(n, e, t, r) {
  var i = r.brushStyle.lineWidth || 0, a = qp(i, Wze), o = t[0][0], s = t[1][0], l = o - i / 2, u = s - i / 2, c = t[0][1], d = t[1][1], f = c - a + i / 2, p = d - a + i / 2, h = c - o, v = d - s, m = h + i, g = v + i;
  zs(n, e, "main", o, s, h, v), r.transformable && (zs(n, e, "w", l, u, a, g), zs(n, e, "e", f, u, a, g), zs(n, e, "n", l, u, m, a), zs(n, e, "s", l, p, m, a), zs(n, e, "nw", l, u, a, a), zs(n, e, "ne", f, u, a, a), zs(n, e, "sw", l, p, a, a), zs(n, e, "se", f, p, a, a));
}
function rA(n, e) {
  var t = e.__brushOption, r = t.transformable, i = e.childAt(0);
  i.useStyle(YO(t)), i.attr({
    silent: !r,
    cursor: r ? "move" : "default"
  }), $([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(a) {
    var o = e.childOfName(a.join("")), s = a.length === 1 ? iA(n, a[0]) : Jze(n, a);
    o && o.attr({
      silent: !r,
      invisible: !r,
      cursor: r ? Yze[s] + "-resize" : null
    });
  });
}
function zs(n, e, t, r, i, a, o) {
  var s = e.childOfName(t);
  s && s.setShape(eFe(KO(n, e, [[r, i], [r + a, i + o]])));
}
function YO(n) {
  return dt({
    strokeNoScale: !0
  }, n.brushStyle);
}
function iK(n, e, t, r) {
  var i = [gg(n, t), gg(e, r)], a = [qp(n, t), qp(e, r)];
  return [
    [i[0], a[0]],
    [i[1], a[1]]
    // y range
  ];
}
function Zze(n) {
  return vd(n.group);
}
function iA(n, e) {
  var t = {
    w: "left",
    e: "right",
    n: "top",
    s: "bottom"
  }, r = {
    left: "w",
    right: "e",
    top: "n",
    bottom: "s"
  }, i = sw(t[e], Zze(n));
  return r[i];
}
function Jze(n, e) {
  var t = [iA(n, e[0]), iA(n, e[1])];
  return (t[0] === "e" || t[0] === "w") && t.reverse(), t.join("");
}
function B4(n, e, t, r, i, a) {
  var o = t.__brushOption, s = n.toRectRange(o.range), l = aK(e, i, a);
  $(r, function(u) {
    var c = qze[u];
    s[c[0]][c[1]] += l[c[0]];
  }), o.range = n.fromRectRange(iK(s[0][0], s[1][0], s[0][1], s[1][1])), UO(e, t), jd(e, {
    isEnd: !1
  });
}
function Qze(n, e, t, r) {
  var i = e.__brushOption.range, a = aK(n, t, r);
  $(i, function(o) {
    o[0] += a[0], o[1] += a[1];
  }), UO(n, e), jd(n, {
    isEnd: !1
  });
}
function aK(n, e, t) {
  var r = n.group, i = r.transformCoordToLocal(e, t), a = r.transformCoordToLocal(0, 0);
  return [i[0] - a[0], i[1] - a[1]];
}
function KO(n, e, t) {
  var r = eK(n, e);
  return r && r !== Pd ? r.clipPath(t, n._transform) : ht(t);
}
function eFe(n) {
  var e = gg(n[0][0], n[1][0]), t = gg(n[0][1], n[1][1]), r = qp(n[0][0], n[1][0]), i = qp(n[0][1], n[1][1]);
  return {
    x: e,
    y: t,
    width: r - e,
    height: i - t
  };
}
function tFe(n, e, t) {
  if (
    // Check active
    !(!n._brushType || rFe(n, e.offsetX, e.offsetY))
  ) {
    var r = n._zr, i = n._covers, a = qO(n, e, t);
    if (!n._dragging)
      for (var o = 0; o < i.length; o++) {
        var s = i[o].__brushOption;
        if (a && (a === Pd || s.panelId === a.panelId) && Mw[s.brushType].contain(i[o], t[0], t[1]))
          return;
      }
    a && r.setCursorStyle("crosshair");
  }
}
function aA(n) {
  var e = n.event;
  e.preventDefault && e.preventDefault();
}
function oA(n, e, t) {
  return n.childOfName("main").contain(e, t);
}
function oK(n, e, t, r) {
  var i = n._creatingCover, a = n._creatingPanel, o = n._brushOption, s;
  if (n._track.push(t.slice()), Xze(n) || i) {
    if (a && !i) {
      o.brushMode === "single" && nA(n);
      var l = ht(o);
      l.brushType = $4(l.brushType, a), l.panelId = a === Pd ? null : a.panelId, i = n._creatingCover = XY(n, l), n._covers.push(i);
    }
    if (i) {
      var u = Mw[$4(n._brushType, a)], c = i.__brushOption;
      c.range = u.getCreatingRange(KO(n, i, n._track)), r && (ZY(n, i), u.updateCommon(n, i)), JY(n, i), s = {
        isEnd: r
      };
    }
  } else r && o.brushMode === "single" && o.removeOnClick && qO(n, e, t) && nA(n) && (s = {
    isEnd: r,
    removeOnClick: !0
  });
  return s;
}
function $4(n, e) {
  return n === "auto" ? (process.env.NODE_ENV !== "production" && ct(e && e.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"'), e.defaultBrushType) : n;
}
var nFe = {
  mousedown: function(n) {
    if (this._dragging)
      z4(this, n);
    else if (!n.target || !n.target.draggable) {
      aA(n);
      var e = this.group.transformCoordToLocal(n.offsetX, n.offsetY);
      this._creatingCover = null;
      var t = this._creatingPanel = qO(this, n, e);
      t && (this._dragging = !0, this._track = [e.slice()]);
    }
  },
  mousemove: function(n) {
    var e = n.offsetX, t = n.offsetY, r = this.group.transformCoordToLocal(e, t);
    if (tFe(this, n, r), this._dragging) {
      aA(n);
      var i = oK(this, n, r, !1);
      i && jd(this, i);
    }
  },
  mouseup: function(n) {
    z4(this, n);
  }
};
function z4(n, e) {
  if (n._dragging) {
    aA(e);
    var t = e.offsetX, r = e.offsetY, i = n.group.transformCoordToLocal(t, r), a = oK(n, e, i, !0);
    n._dragging = !1, n._track = [], n._creatingCover = null, a && jd(n, a);
  }
}
function rFe(n, e, t) {
  var r = n._zr;
  return e < 0 || e > r.getWidth() || t < 0 || t > r.getHeight();
}
var Mw = {
  lineX: F4(0),
  lineY: F4(1),
  rect: {
    createCover: function(n, e) {
      function t(r) {
        return r;
      }
      return nK({
        toRectRange: t,
        fromRectRange: t
      }, n, e, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(n) {
      var e = tK(n);
      return iK(e[1][0], e[1][1], e[0][0], e[0][1]);
    },
    updateCoverShape: function(n, e, t, r) {
      rK(n, e, t, r);
    },
    updateCommon: rA,
    contain: oA
  },
  polygon: {
    createCover: function(n, e) {
      var t = new mt();
      return t.add(new Hi({
        name: "main",
        style: YO(e),
        silent: !0
      })), t;
    },
    getCreatingRange: function(n) {
      return n;
    },
    endCreating: function(n, e) {
      e.remove(e.childAt(0)), e.add(new Vi({
        name: "main",
        draggable: !0,
        drift: Tt(Qze, n, e),
        ondragend: Tt(jd, n, {
          isEnd: !0
        })
      }));
    },
    updateCoverShape: function(n, e, t, r) {
      e.childAt(0).setShape({
        points: KO(n, e, t)
      });
    },
    updateCommon: rA,
    contain: oA
  }
};
function F4(n) {
  return {
    createCover: function(e, t) {
      return nK({
        toRectRange: function(r) {
          var i = [r, [0, 100]];
          return n && i.reverse(), i;
        },
        fromRectRange: function(r) {
          return r[n];
        }
      }, e, t, [[["w"], ["e"]], [["n"], ["s"]]][n]);
    },
    getCreatingRange: function(e) {
      var t = tK(e), r = gg(t[0][n], t[1][n]), i = qp(t[0][n], t[1][n]);
      return [r, i];
    },
    updateCoverShape: function(e, t, r, i) {
      var a, o = eK(e, t);
      if (o !== Pd && o.getLinearBrushOtherExtent)
        a = o.getLinearBrushOtherExtent(n);
      else {
        var s = e._zr;
        a = [0, [s.getWidth(), s.getHeight()][1 - n]];
      }
      var l = [r, a];
      n && l.reverse(), rK(e, t, l, i);
    },
    updateCommon: rA,
    contain: oA
  };
}
function sK(n) {
  return n = XO(n), function(e) {
    return bU(e, n);
  };
}
function lK(n, e) {
  return n = XO(n), function(t) {
    var r = e ?? t, i = r ? n.width : n.height, a = r ? n.x : n.y;
    return [a, a + (i || 0)];
  };
}
function uK(n, e, t) {
  var r = XO(n);
  return function(i, a) {
    return r.contain(a[0], a[1]) && !Tw(i, e, t);
  };
}
function XO(n) {
  return Ot.create(n);
}
var iFe = ["axisLine", "axisTickLabel", "axisName"], aFe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      n.prototype.init.apply(this, arguments), (this._brushController = new GO(r.getZr())).on("brush", Ze(this._onBrush, this));
    }, e.prototype.render = function(t, r, i, a) {
      if (!oFe(t, r, a)) {
        this.axisModel = t, this.api = i, this.group.removeAll();
        var o = this._axisGroup;
        if (this._axisGroup = new mt(), this.group.add(this._axisGroup), !!t.get("show")) {
          var s = lFe(t, r), l = s.coordinateSystem, u = t.getAreaSelectStyle(), c = u.width, d = t.axis.dim, f = l.getAxisLayout(d), p = xe({
            strokeContainThreshold: c
          }, f), h = new Ii(t, p);
          $(iFe, h.add, h), this._axisGroup.add(h.getGroup()), this._refreshBrushController(p, u, t, s, c, i), Wg(o, this._axisGroup, t);
        }
      }
    }, e.prototype._refreshBrushController = function(t, r, i, a, o, s) {
      var l = i.axis.getExtent(), u = l[1] - l[0], c = Math.min(30, Math.abs(u) * 0.1), d = Ot.create({
        x: l[0],
        y: -o / 2,
        width: u,
        height: o
      });
      d.x -= c, d.width += 2 * c, this._brushController.mount({
        enableGlobalPan: !0,
        rotation: t.rotation,
        x: t.position[0],
        y: t.position[1]
      }).setPanels([{
        panelId: "pl",
        clipPath: sK(d),
        isTargetByCursor: uK(d, s, a),
        getLinearBrushOtherExtent: lK(d, 0)
      }]).enableBrush({
        brushType: "lineX",
        brushStyle: r,
        removeOnClick: !0
      }).updateCovers(sFe(i));
    }, e.prototype._onBrush = function(t) {
      var r = t.areas, i = this.axisModel, a = i.axis, o = De(r, function(s) {
        return [a.coordToData(s.range[0], !0), a.coordToData(s.range[1], !0)];
      });
      (!i.option.realtime === t.isEnd || t.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: i.id,
        intervals: o
      });
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.type = "parallelAxis", e;
  }(Yn)
);
function oFe(n, e, t) {
  return t && t.type === "axisAreaSelect" && e.findComponents({
    mainType: "parallelAxis",
    query: t
  })[0] === n;
}
function sFe(n) {
  var e = n.axis;
  return De(n.activeIntervals, function(t) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [e.dataToCoord(t[0], !0), e.dataToCoord(t[1], !0)]
    };
  });
}
function lFe(n, e) {
  return e.getComponent("parallel", n.get("parallelIndex"));
}
var uFe = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
  // update: 'updateVisual'
};
function cFe(n) {
  n.registerAction(uFe, function(e, t) {
    t.eachComponent({
      mainType: "parallelAxis",
      query: e
    }, function(r) {
      r.axis.model.setActiveIntervals(e.intervals);
    });
  }), n.registerAction("parallelAxisExpand", function(e, t) {
    t.eachComponent({
      mainType: "parallel",
      query: e
    }, function(r) {
      r.setAxisExpand(e);
    });
  });
}
var dFe = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: !0,
  z: 10
};
function cK(n) {
  n.registerComponentView(Ize), n.registerComponentModel(Nze), n.registerCoordinateSystem("parallel", Vze), n.registerPreprocessor(Aze), n.registerComponentModel(tA), n.registerComponentView(aFe), Wp(n, "parallel", tA, dFe), cFe(n);
}
function fFe(n) {
  $t(cK), n.registerChartView(_ze), n.registerSeriesModel(Sze), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, kze);
}
var pFe = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return n;
  }()
), hFe = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new pFe();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.extent;
      t.moveTo(r.x1, r.y1), t.bezierCurveTo(r.cpx1, r.cpy1, r.cpx2, r.cpy2, r.x2, r.y2), r.orient === "vertical" ? (t.lineTo(r.x2 + i, r.y2), t.bezierCurveTo(r.cpx2 + i, r.cpy2, r.cpx1 + i, r.cpy1, r.x1 + i, r.y1)) : (t.lineTo(r.x2, r.y2 + i), t.bezierCurveTo(r.cpx2, r.cpy2 + i, r.cpx1, r.cpy1 + i, r.x1, r.y1 + i)), t.closePath();
    }, e.prototype.highlight = function() {
      xl(this);
    }, e.prototype.downplay = function() {
      wl(this);
    }, e;
  }(Ht)
), vFe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._focusAdjacencyDisabled = !1, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = this, o = t.getGraph(), s = this.group, l = t.layoutInfo, u = l.width, c = l.height, d = t.getData(), f = t.getData("edge"), p = t.get("orient");
      this._model = t, s.removeAll(), s.x = l.x, s.y = l.y, o.eachEdge(function(h) {
        var v = new hFe(), m = yt(v);
        m.dataIndex = h.dataIndex, m.seriesIndex = t.seriesIndex, m.dataType = "edge";
        var g = h.getModel(), y = g.getModel("lineStyle"), b = y.get("curveness"), _ = h.node1.getLayout(), x = h.node1.getModel(), w = x.get("localX"), S = x.get("localY"), C = h.node2.getLayout(), k = h.node2.getModel(), M = k.get("localX"), D = k.get("localY"), N = h.getLayout(), R, j, z, F, B, H, Y, ne;
        v.shape.extent = Math.max(1, N.dy), v.shape.orient = p, p === "vertical" ? (R = (w != null ? w * u : _.x) + N.sy, j = (S != null ? S * c : _.y) + _.dy, z = (M != null ? M * u : C.x) + N.ty, F = D != null ? D * c : C.y, B = R, H = j * (1 - b) + F * b, Y = z, ne = j * b + F * (1 - b)) : (R = (w != null ? w * u : _.x) + _.dx, j = (S != null ? S * c : _.y) + N.sy, z = M != null ? M * u : C.x, F = (D != null ? D * c : C.y) + N.ty, B = R * (1 - b) + z * b, H = j, Y = R * b + z * (1 - b), ne = F), v.setShape({
          x1: R,
          y1: j,
          x2: z,
          y2: F,
          cpx1: B,
          cpy1: H,
          cpx2: Y,
          cpy2: ne
        }), v.useStyle(y.getItemStyle()), V4(v.style, p, h);
        var J = "" + g.get("value"), X = Nr(g, "edgeLabel");
        ei(v, X, {
          labelFetcher: {
            getFormattedLabel: function(pe, Be, Ce, Ee, ce, Pe) {
              return t.getFormattedLabel(
                pe,
                Be,
                "edge",
                Ee,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                Za(ce, X.normal && X.normal.get("formatter"), J),
                Pe
              );
            }
          },
          labelDataIndex: h.dataIndex,
          defaultText: J
        }), v.setTextConfig({
          position: "inside"
        });
        var ie = g.getModel("emphasis");
        Qr(v, g, "lineStyle", function(pe) {
          var Be = pe.getItemStyle();
          return V4(Be, p, h), Be;
        }), s.add(v), f.setItemGraphicEl(h.dataIndex, v);
        var ye = ie.get("focus");
        er(v, ye === "adjacency" ? h.getAdjacentDataIndices() : ye === "trajectory" ? h.getTrajectoryDataIndices() : ye, ie.get("blurScope"), ie.get("disabled"));
      }), o.eachNode(function(h) {
        var v = h.getLayout(), m = h.getModel(), g = m.get("localX"), y = m.get("localY"), b = m.getModel("emphasis"), _ = m.get(["itemStyle", "borderRadius"]) || 0, x = new Qt({
          shape: {
            x: g != null ? g * u : v.x,
            y: y != null ? y * c : v.y,
            width: v.dx,
            height: v.dy,
            r: _
          },
          style: m.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        ei(x, Nr(m), {
          labelFetcher: {
            getFormattedLabel: function(S, C) {
              return t.getFormattedLabel(S, C, "node");
            }
          },
          labelDataIndex: h.dataIndex,
          defaultText: h.id
        }), x.disableLabelAnimation = !0, x.setStyle("fill", h.getVisual("color")), x.setStyle("decal", h.getVisual("style").decal), Qr(x, m), s.add(x), d.setItemGraphicEl(h.dataIndex, x), yt(x).dataType = "node";
        var w = b.get("focus");
        er(x, w === "adjacency" ? h.getAdjacentDataIndices() : w === "trajectory" ? h.getTrajectoryDataIndices() : w, b.get("blurScope"), b.get("disabled"));
      }), d.eachItemGraphicEl(function(h, v) {
        var m = d.getItemModel(v);
        m.get("draggable") && (h.drift = function(g, y) {
          a._focusAdjacencyDisabled = !0, this.shape.x += g, this.shape.y += y, this.dirty(), i.dispatchAction({
            type: "dragNode",
            seriesId: t.id,
            dataIndex: d.getRawIndex(v),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, h.ondragend = function() {
          a._focusAdjacencyDisabled = !1;
        }, h.draggable = !0, h.cursor = "move");
      }), !this._data && t.isAnimationEnabled() && s.setClipPath(mFe(s.getBoundingRect(), t, function() {
        s.removeClipPath();
      })), this._data = t.getData();
    }, e.prototype.dispose = function() {
    }, e.type = "sankey", e;
  }(Tn)
);
function V4(n, e, t) {
  switch (n.fill) {
    case "source":
      n.fill = t.node1.getVisual("color"), n.decal = t.node1.getVisual("style").decal;
      break;
    case "target":
      n.fill = t.node2.getVisual("color"), n.decal = t.node2.getVisual("style").decal;
      break;
    case "gradient":
      var r = t.node1.getVisual("color"), i = t.node2.getVisual("color");
      We(r) && We(i) && (n.fill = new Ug(0, 0, +(e === "horizontal"), +(e === "vertical"), [{
        color: r,
        offset: 0
      }, {
        color: i,
        offset: 1
      }]));
  }
}
function mFe(n, e, t) {
  var r = new Qt({
    shape: {
      x: n.x - 10,
      y: n.y - 10,
      width: 0,
      height: n.height + 20
    }
  });
  return Gn(r, {
    shape: {
      width: n.width + 20
    }
  }, e, t), r;
}
var gFe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      var i = t.edges || t.links || [], a = t.data || t.nodes || [], o = t.levels || [];
      this.levelModels = [];
      for (var s = this.levelModels, l = 0; l < o.length; l++)
        if (o[l].depth != null && o[l].depth >= 0)
          s[o[l].depth] = new yn(o[l], this, r);
        else if (process.env.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      var u = WY(a, i, this, !0, c);
      return u.data;
      function c(d, f) {
        d.wrapMethod("getItemModel", function(p, h) {
          var v = p.parentModel, m = v.getData().getItemLayout(h);
          if (m) {
            var g = m.depth, y = v.levelModels[g];
            y && (p.parentModel = y);
          }
          return p;
        }), f.wrapMethod("getItemModel", function(p, h) {
          var v = p.parentModel, m = v.getGraph().getEdgeByIndex(h), g = m.node1.getLayout();
          if (g) {
            var y = g.depth, b = v.levelModels[y];
            b && (p.parentModel = b);
          }
          return p;
        });
      }
    }, e.prototype.setNodePosition = function(t, r) {
      var i = this.option.data || this.option.nodes, a = i[t];
      a.localX = r[0], a.localY = r[1];
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.formatTooltip = function(t, r, i) {
      function a(p) {
        return isNaN(p) || p == null;
      }
      if (i === "edge") {
        var o = this.getDataParams(t, i), s = o.data, l = o.value, u = s.source + " -- " + s.target;
        return Rr("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(t), d = c.getLayout().value, f = this.getDataParams(t, i).data.name;
        return Rr("nameValue", {
          name: f != null ? f + "" : null,
          value: d,
          noValue: a(d)
        });
      }
    }, e.prototype.optionUpdated = function() {
    }, e.prototype.getDataParams = function(t, r) {
      var i = n.prototype.getDataParams.call(this, t, r);
      if (i.value == null && r === "node") {
        var a = this.getGraph().getNodeByIndex(t), o = a.getLayout().value;
        i.value = o;
      }
      return i;
    }, e.type = "series.sankey", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, e;
  }(Rn)
);
function yFe(n, e) {
  n.eachSeriesByType("sankey", function(t) {
    var r = t.get("nodeWidth"), i = t.get("nodeGap"), a = bFe(t, e);
    t.layoutInfo = a;
    var o = a.width, s = a.height, l = t.getGraph(), u = l.nodes, c = l.edges;
    xFe(u);
    var d = vn(u, function(v) {
      return v.getLayout().value === 0;
    }), f = d.length !== 0 ? 0 : t.get("layoutIterations"), p = t.get("orient"), h = t.get("nodeAlign");
    _Fe(u, c, r, i, o, s, f, p, h);
  });
}
function bFe(n, e) {
  return Er(n.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function _Fe(n, e, t, r, i, a, o, s, l) {
  wFe(n, e, t, i, a, s, l), CFe(n, e, a, i, r, o, s), RFe(n, s);
}
function xFe(n) {
  $(n, function(e) {
    var t = ku(e.outEdges, k_), r = ku(e.inEdges, k_), i = e.getValue() || 0, a = Math.max(t, r, i);
    e.setLayout({
      value: a
    }, !0);
  });
}
function wFe(n, e, t, r, i, a, o) {
  for (var s = [], l = [], u = [], c = [], d = 0, f = 0; f < e.length; f++)
    s[f] = 1;
  for (var f = 0; f < n.length; f++)
    l[f] = n[f].inEdges.length, l[f] === 0 && u.push(n[f]);
  for (var p = -1; u.length; ) {
    for (var h = 0; h < u.length; h++) {
      var v = u[h], m = v.hostGraph.data.getRawDataItem(v.dataIndex), g = m.depth != null && m.depth >= 0;
      g && m.depth > p && (p = m.depth), v.setLayout({
        depth: g ? m.depth : d
      }, !0), a === "vertical" ? v.setLayout({
        dy: t
      }, !0) : v.setLayout({
        dx: t
      }, !0);
      for (var y = 0; y < v.outEdges.length; y++) {
        var b = v.outEdges[y], _ = e.indexOf(b);
        s[_] = 0;
        var x = b.node2, w = n.indexOf(x);
        --l[w] === 0 && c.indexOf(x) < 0 && c.push(x);
      }
    }
    ++d, u = c, c = [];
  }
  for (var f = 0; f < s.length; f++)
    if (s[f] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var S = p > d - 1 ? p : d - 1;
  o && o !== "left" && SFe(n, o, a, S);
  var C = a === "vertical" ? (i - t) / S : (r - t) / S;
  TFe(n, C, a);
}
function dK(n) {
  var e = n.hostGraph.data.getRawDataItem(n.dataIndex);
  return e.depth != null && e.depth >= 0;
}
function SFe(n, e, t, r) {
  if (e === "right") {
    for (var i = [], a = n, o = 0; a.length; ) {
      for (var s = 0; s < a.length; s++) {
        var l = a[s];
        l.setLayout({
          skNodeHeight: o
        }, !0);
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u];
          i.indexOf(c.node1) < 0 && i.push(c.node1);
        }
      }
      a = i, i = [], ++o;
    }
    $(n, function(d) {
      dK(d) || d.setLayout({
        depth: Math.max(0, r - d.getLayout().skNodeHeight)
      }, !0);
    });
  } else e === "justify" && EFe(n, r);
}
function EFe(n, e) {
  $(n, function(t) {
    !dK(t) && !t.outEdges.length && t.setLayout({
      depth: e
    }, !0);
  });
}
function TFe(n, e, t) {
  $(n, function(r) {
    var i = r.getLayout().depth * e;
    t === "vertical" ? r.setLayout({
      y: i
    }, !0) : r.setLayout({
      x: i
    }, !0);
  });
}
function CFe(n, e, t, r, i, a, o) {
  var s = kFe(n, o);
  AFe(s, e, t, r, i, o), BE(s, i, t, r, o);
  for (var l = 1; a > 0; a--)
    l *= 0.99, MFe(s, l, o), BE(s, i, t, r, o), NFe(s, l, o), BE(s, i, t, r, o);
}
function kFe(n, e) {
  var t = [], r = e === "vertical" ? "y" : "x", i = ok(n, function(a) {
    return a.getLayout()[r];
  });
  return i.keys.sort(function(a, o) {
    return a - o;
  }), $(i.keys, function(a) {
    t.push(i.buckets.get(a));
  }), t;
}
function AFe(n, e, t, r, i, a) {
  var o = 1 / 0;
  $(n, function(s) {
    var l = s.length, u = 0;
    $(s, function(d) {
      u += d.getLayout().value;
    });
    var c = a === "vertical" ? (r - (l - 1) * i) / u : (t - (l - 1) * i) / u;
    c < o && (o = c);
  }), $(n, function(s) {
    $(s, function(l, u) {
      var c = l.getLayout().value * o;
      a === "vertical" ? (l.setLayout({
        x: u
      }, !0), l.setLayout({
        dx: c
      }, !0)) : (l.setLayout({
        y: u
      }, !0), l.setLayout({
        dy: c
      }, !0));
    });
  }), $(e, function(s) {
    var l = +s.getValue() * o;
    s.setLayout({
      dy: l
    }, !0);
  });
}
function BE(n, e, t, r, i) {
  var a = i === "vertical" ? "x" : "y";
  $(n, function(o) {
    o.sort(function(v, m) {
      return v.getLayout()[a] - m.getLayout()[a];
    });
    for (var s, l, u, c = 0, d = o.length, f = i === "vertical" ? "dx" : "dy", p = 0; p < d; p++)
      l = o[p], u = c - l.getLayout()[a], u > 0 && (s = l.getLayout()[a] + u, i === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0)), c = l.getLayout()[a] + l.getLayout()[f] + e;
    var h = i === "vertical" ? r : t;
    if (u = c - e - h, u > 0) {
      s = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0), c = s;
      for (var p = d - 2; p >= 0; --p)
        l = o[p], u = l.getLayout()[a] + l.getLayout()[f] + e - c, u > 0 && (s = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
          x: s
        }, !0) : l.setLayout({
          y: s
        }, !0)), c = l.getLayout()[a];
    }
  });
}
function MFe(n, e, t) {
  $(n.slice().reverse(), function(r) {
    $(r, function(i) {
      if (i.outEdges.length) {
        var a = ku(i.outEdges, DFe, t) / ku(i.outEdges, k_);
        if (isNaN(a)) {
          var o = i.outEdges.length;
          a = o ? ku(i.outEdges, OFe, t) / o : 0;
        }
        if (t === "vertical") {
          var s = i.getLayout().x + (a - $u(i, t)) * e;
          i.setLayout({
            x: s
          }, !0);
        } else {
          var l = i.getLayout().y + (a - $u(i, t)) * e;
          i.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function DFe(n, e) {
  return $u(n.node2, e) * n.getValue();
}
function OFe(n, e) {
  return $u(n.node2, e);
}
function IFe(n, e) {
  return $u(n.node1, e) * n.getValue();
}
function LFe(n, e) {
  return $u(n.node1, e);
}
function $u(n, e) {
  return e === "vertical" ? n.getLayout().x + n.getLayout().dx / 2 : n.getLayout().y + n.getLayout().dy / 2;
}
function k_(n) {
  return n.getValue();
}
function ku(n, e, t) {
  for (var r = 0, i = n.length, a = -1; ++a < i; ) {
    var o = +e(n[a], t);
    isNaN(o) || (r += o);
  }
  return r;
}
function NFe(n, e, t) {
  $(n, function(r) {
    $(r, function(i) {
      if (i.inEdges.length) {
        var a = ku(i.inEdges, IFe, t) / ku(i.inEdges, k_);
        if (isNaN(a)) {
          var o = i.inEdges.length;
          a = o ? ku(i.inEdges, LFe, t) / o : 0;
        }
        if (t === "vertical") {
          var s = i.getLayout().x + (a - $u(i, t)) * e;
          i.setLayout({
            x: s
          }, !0);
        } else {
          var l = i.getLayout().y + (a - $u(i, t)) * e;
          i.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function RFe(n, e) {
  var t = e === "vertical" ? "x" : "y";
  $(n, function(r) {
    r.outEdges.sort(function(i, a) {
      return i.node2.getLayout()[t] - a.node2.getLayout()[t];
    }), r.inEdges.sort(function(i, a) {
      return i.node1.getLayout()[t] - a.node1.getLayout()[t];
    });
  }), $(n, function(r) {
    var i = 0, a = 0;
    $(r.outEdges, function(o) {
      o.setLayout({
        sy: i
      }, !0), i += o.getLayout().dy;
    }), $(r.inEdges, function(o) {
      o.setLayout({
        ty: a
      }, !0), a += o.getLayout().dy;
    });
  });
}
function PFe(n) {
  n.eachSeriesByType("sankey", function(e) {
    var t = e.getGraph(), r = t.nodes, i = t.edges;
    if (r.length) {
      var a = 1 / 0, o = -1 / 0;
      $(r, function(s) {
        var l = s.getLayout().value;
        l < a && (a = l), l > o && (o = l);
      }), $(r, function(s) {
        var l = new Lr({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [a, o],
          visual: e.get("color")
        }), u = l.mapValueToVisual(s.getLayout().value), c = s.getModel().get(["itemStyle", "color"]);
        c != null ? (s.setVisual("color", c), s.setVisual("style", {
          fill: c
        })) : (s.setVisual("color", u), s.setVisual("style", {
          fill: u
        }));
      });
    }
    i.length && $(i, function(s) {
      var l = s.getModel().get("lineStyle");
      s.setVisual("style", l);
    });
  });
}
function jFe(n) {
  n.registerChartView(vFe), n.registerSeriesModel(gFe), n.registerLayout(yFe), n.registerVisual(PFe), n.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(e, t) {
    t.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: e
    }, function(r) {
      r.setNodePosition(e.dataIndex, [e.localX, e.localY]);
    });
  });
}
var fK = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype._hasEncodeRule = function(e) {
      var t = this.getEncode();
      return t && t.get(e) != null;
    }, n.prototype.getInitialData = function(e, t) {
      var r, i = t.getComponent("xAxis", this.get("xAxisIndex")), a = t.getComponent("yAxis", this.get("yAxisIndex")), o = i.get("type"), s = a.get("type"), l;
      o === "category" ? (e.layout = "horizontal", r = i.getOrdinalMeta(), l = !this._hasEncodeRule("x")) : s === "category" ? (e.layout = "vertical", r = a.getOrdinalMeta(), l = !this._hasEncodeRule("y")) : e.layout = e.layout || "horizontal";
      var u = ["x", "y"], c = e.layout === "horizontal" ? 0 : 1, d = this._baseAxisDim = u[c], f = u[1 - c], p = [i, a], h = p[c].get("type"), v = p[1 - c].get("type"), m = e.data;
      if (m && l) {
        var g = [];
        $(m, function(_, x) {
          var w;
          Me(_) ? (w = _.slice(), _.unshift(x)) : Me(_.value) ? (w = xe({}, _), w.value = w.value.slice(), _.value.unshift(x)) : w = _, g.push(w);
        }), e.data = g;
      }
      var y = this.defaultValueDimensions, b = [{
        name: d,
        type: m_(h),
        ordinalMeta: r,
        otherDims: {
          tooltip: !1,
          itemName: 0
        },
        dimsDef: ["base"]
      }, {
        name: f,
        type: m_(v),
        dimsDef: y.slice()
      }];
      return wh(this, {
        coordDimensions: b,
        dimensionsCount: y.length + 1,
        encodeDefaulter: Tt(GU, b, this)
      });
    }, n.prototype.getBaseAxis = function() {
      var e = this._baseAxisDim;
      return this.ecModel.getComponent(e + "Axis", this.get(e + "AxisIndex")).axis;
    }, n;
  }()
), pK = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.defaultValueDimensions = [{
        name: "min",
        defaultTooltip: !0
      }, {
        name: "Q1",
        defaultTooltip: !0
      }, {
        name: "median",
        defaultTooltip: !0
      }, {
        name: "Q3",
        defaultTooltip: !0
      }, {
        name: "max",
        defaultTooltip: !0
      }], t.visualDrawType = "stroke", t;
    }
    return e.type = "series.boxplot", e.dependencies = ["xAxis", "yAxis", "grid"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      layout: null,
      boxWidth: [7, 50],
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      animationDuration: 800
    }, e;
  }(Rn)
);
_r(pK, fK, !0);
var BFe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = t.getData(), o = this.group, s = this._data;
      this._data || o.removeAll();
      var l = t.get("layout") === "horizontal" ? 1 : 0;
      a.diff(s).add(function(u) {
        if (a.hasValue(u)) {
          var c = a.getItemLayout(u), d = H4(c, a, u, l, !0);
          a.setItemGraphicEl(u, d), o.add(d);
        }
      }).update(function(u, c) {
        var d = s.getItemGraphicEl(c);
        if (!a.hasValue(u)) {
          o.remove(d);
          return;
        }
        var f = a.getItemLayout(u);
        d ? (Oo(d), hK(f, d, a, u)) : d = H4(f, a, u, l), o.add(d), a.setItemGraphicEl(u, d);
      }).remove(function(u) {
        var c = s.getItemGraphicEl(u);
        c && o.remove(c);
      }).execute(), this._data = a;
    }, e.prototype.remove = function(t) {
      var r = this.group, i = this._data;
      this._data = null, i && i.eachItemGraphicEl(function(a) {
        a && r.remove(a);
      });
    }, e.type = "boxplot", e;
  }(Tn)
), $Fe = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }()
), zFe = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "boxplotBoxPath", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new $Fe();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points, a = 0;
      for (t.moveTo(i[a][0], i[a][1]), a++; a < 4; a++)
        t.lineTo(i[a][0], i[a][1]);
      for (t.closePath(); a < i.length; a++)
        t.moveTo(i[a][0], i[a][1]), a++, t.lineTo(i[a][0], i[a][1]);
    }, e;
  }(Ht)
);
function H4(n, e, t, r, i) {
  var a = n.ends, o = new zFe({
    shape: {
      points: i ? FFe(a, r, n) : a
    }
  });
  return hK(n, o, e, t, i), o;
}
function hK(n, e, t, r, i) {
  var a = t.hostModel, o = Qd[i ? "initProps" : "updateProps"];
  o(e, {
    shape: {
      points: n.ends
    }
  }, a, r), e.useStyle(t.getItemVisual(r, "style")), e.style.strokeNoScale = !0, e.z2 = 100;
  var s = t.getItemModel(r), l = s.getModel("emphasis");
  Qr(e, s), er(e, l.get("focus"), l.get("blurScope"), l.get("disabled"));
}
function FFe(n, e, t) {
  return De(n, function(r) {
    return r = r.slice(), r[e] = t.initBaseline, r;
  });
}
var bm = $;
function VFe(n) {
  var e = HFe(n);
  bm(e, function(t) {
    var r = t.seriesModels;
    r.length && (GFe(t), bm(r, function(i, a) {
      UFe(i, t.boxOffsetList[a], t.boxWidthList[a]);
    }));
  });
}
function HFe(n) {
  var e = [], t = [];
  return n.eachSeriesByType("boxplot", function(r) {
    var i = r.getBaseAxis(), a = Pt(t, i);
    a < 0 && (a = t.length, t[a] = i, e[a] = {
      axis: i,
      seriesModels: []
    }), e[a].seriesModels.push(r);
  }), e;
}
function GFe(n) {
  var e = n.axis, t = n.seriesModels, r = t.length, i = n.boxWidthList = [], a = n.boxOffsetList = [], o = [], s;
  if (e.type === "category")
    s = e.getBandWidth();
  else {
    var l = 0;
    bm(t, function(h) {
      l = Math.max(l, h.getData().count());
    });
    var u = e.getExtent();
    s = Math.abs(u[1] - u[0]) / l;
  }
  bm(t, function(h) {
    var v = h.get("boxWidth");
    Me(v) || (v = [v, v]), o.push([ze(v[0], s) || 0, ze(v[1], s) || 0]);
  });
  var c = s * 0.8 - 2, d = c / r * 0.3, f = (c - d * (r - 1)) / r, p = f / 2 - c / 2;
  bm(t, function(h, v) {
    a.push(p), p += d + f, i.push(Math.min(Math.max(f, o[v][0]), o[v][1]));
  });
}
function UFe(n, e, t) {
  var r = n.coordinateSystem, i = n.getData(), a = t / 2, o = n.get("layout") === "horizontal" ? 0 : 1, s = 1 - o, l = ["x", "y"], u = i.mapDimension(l[o]), c = i.mapDimensionsAll(l[s]);
  if (u == null || c.length < 5)
    return;
  for (var d = 0; d < i.count(); d++) {
    var f = i.get(u, d), p = b(f, c[2], d), h = b(f, c[0], d), v = b(f, c[1], d), m = b(f, c[3], d), g = b(f, c[4], d), y = [];
    _(y, v, !1), _(y, m, !0), y.push(h, v, g, m), x(y, h), x(y, g), x(y, p), i.setItemLayout(d, {
      initBaseline: p[s],
      ends: y
    });
  }
  function b(w, S, C) {
    var k = i.get(S, C), M = [];
    M[o] = w, M[s] = k;
    var D;
    return isNaN(w) || isNaN(k) ? D = [NaN, NaN] : (D = r.dataToPoint(M), D[o] += e), D;
  }
  function _(w, S, C) {
    var k = S.slice(), M = S.slice();
    k[o] += a, M[o] -= a, C ? w.push(k, M) : w.push(M, k);
  }
  function x(w, S) {
    var C = S.slice(), k = S.slice();
    C[o] -= a, k[o] += a, w.push(C, k);
  }
}
function WFe(n, e) {
  e = e || {};
  for (var t = [], r = [], i = e.boundIQR, a = i === "none" || i === 0, o = 0; o < n.length; o++) {
    var s = Ya(n[o].slice()), l = d2(s, 0.25), u = d2(s, 0.5), c = d2(s, 0.75), d = s[0], f = s[s.length - 1], p = (i ?? 1.5) * (c - l), h = a ? d : Math.max(d, l - p), v = a ? f : Math.min(f, c + p), m = e.itemNameFormatter, g = at(m) ? m({
      value: o
    }) : We(m) ? m.replace("{value}", o + "") : o + "";
    t.push([g, h, l, u, c, v]);
    for (var y = 0; y < s.length; y++) {
      var b = s[y];
      if (b < h || b > v) {
        var _ = [g, b];
        r.push(_);
      }
    }
  }
  return {
    boxData: t,
    outliers: r
  };
}
var qFe = {
  type: "echarts:boxplot",
  transform: function(e) {
    var t = e.upstream;
    if (t.sourceFormat !== vi) {
      var r = "";
      process.env.NODE_ENV !== "production" && (r = $i("source data is not applicable for this boxplot transform. Expect number[][].")), hn(r);
    }
    var i = WFe(t.getRawData(), e.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: i.boxData
    }, {
      data: i.outliers
    }];
  }
};
function YFe(n) {
  n.registerSeriesModel(pK), n.registerChartView(BFe), n.registerLayout(VFe), n.registerTransform(qFe);
}
var KFe = ["itemStyle", "borderColor"], XFe = ["itemStyle", "borderColor0"], ZFe = ["itemStyle", "borderColorDoji"], JFe = ["itemStyle", "color"], QFe = ["itemStyle", "color0"];
function ZO(n, e) {
  return e.get(n > 0 ? JFe : QFe);
}
function JO(n, e) {
  return e.get(n === 0 ? ZFe : n > 0 ? KFe : XFe);
}
var eVe = {
  seriesType: "candlestick",
  plan: yh(),
  // For legend.
  performRawSeries: !0,
  reset: function(n, e) {
    if (!e.isSeriesFiltered(n)) {
      var t = n.pipelineContext.large;
      return !t && {
        progress: function(r, i) {
          for (var a; (a = r.next()) != null; ) {
            var o = i.getItemModel(a), s = i.getItemLayout(a).sign, l = o.getItemStyle();
            l.fill = ZO(s, o), l.stroke = JO(s, o) || l.fill;
            var u = i.ensureUniqueItemVisual(a, "style");
            xe(u, l);
          }
        }
      };
    }
  }
}, tVe = ["color", "borderColor"], nVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(t), this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t);
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      this._clear(), this._updateDrawMode(t);
    }, e.prototype.incrementalRender = function(t, r, i, a) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(t, r) : this._incrementalRenderNormal(t, r);
    }, e.prototype.eachRendered = function(t) {
      Yu(this._progressiveEls || this.group, t);
    }, e.prototype._updateDrawMode = function(t) {
      var r = t.pipelineContext.large;
      (this._isLargeDraw == null || r !== this._isLargeDraw) && (this._isLargeDraw = r, this._clear());
    }, e.prototype._renderNormal = function(t) {
      var r = t.getData(), i = this._data, a = this.group, o = r.getLayout("isSimpleBox"), s = t.get("clip", !0), l = t.coordinateSystem, u = l.getArea && l.getArea();
      this._data || a.removeAll(), r.diff(i).add(function(c) {
        if (r.hasValue(c)) {
          var d = r.getItemLayout(c);
          if (s && G4(u, d))
            return;
          var f = $E(d, c, !0);
          Gn(f, {
            shape: {
              points: d.ends
            }
          }, t, c), zE(f, r, c, o), a.add(f), r.setItemGraphicEl(c, f);
        }
      }).update(function(c, d) {
        var f = i.getItemGraphicEl(d);
        if (!r.hasValue(c)) {
          a.remove(f);
          return;
        }
        var p = r.getItemLayout(c);
        if (s && G4(u, p)) {
          a.remove(f);
          return;
        }
        f ? (ln(f, {
          shape: {
            points: p.ends
          }
        }, t, c), Oo(f)) : f = $E(p), zE(f, r, c, o), a.add(f), r.setItemGraphicEl(c, f);
      }).remove(function(c) {
        var d = i.getItemGraphicEl(c);
        d && a.remove(d);
      }).execute(), this._data = r;
    }, e.prototype._renderLarge = function(t) {
      this._clear(), U4(t, this.group);
      var r = t.get("clip", !0) ? Qg(t.coordinateSystem, !1, t) : null;
      r ? this.group.setClipPath(r) : this.group.removeClipPath();
    }, e.prototype._incrementalRenderNormal = function(t, r) {
      for (var i = r.getData(), a = i.getLayout("isSimpleBox"), o; (o = t.next()) != null; ) {
        var s = i.getItemLayout(o), l = $E(s);
        zE(l, i, o, a), l.incremental = !0, this.group.add(l), this._progressiveEls.push(l);
      }
    }, e.prototype._incrementalRenderLarge = function(t, r) {
      U4(r, this.group, this._progressiveEls, !0);
    }, e.prototype.remove = function(t) {
      this._clear();
    }, e.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "candlestick", e;
  }(Tn)
), rVe = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }()
), iVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "normalCandlestickBox", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new rVe();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points;
      this.__simpleBox ? (t.moveTo(i[4][0], i[4][1]), t.lineTo(i[6][0], i[6][1])) : (t.moveTo(i[0][0], i[0][1]), t.lineTo(i[1][0], i[1][1]), t.lineTo(i[2][0], i[2][1]), t.lineTo(i[3][0], i[3][1]), t.closePath(), t.moveTo(i[4][0], i[4][1]), t.lineTo(i[5][0], i[5][1]), t.moveTo(i[6][0], i[6][1]), t.lineTo(i[7][0], i[7][1]));
    }, e;
  }(Ht)
);
function $E(n, e, t) {
  var r = n.ends;
  return new iVe({
    shape: {
      points: t ? aVe(r, n) : r
    },
    z2: 100
  });
}
function G4(n, e) {
  for (var t = !0, r = 0; r < e.ends.length; r++)
    if (n.contain(e.ends[r][0], e.ends[r][1])) {
      t = !1;
      break;
    }
  return t;
}
function zE(n, e, t, r) {
  var i = e.getItemModel(t);
  n.useStyle(e.getItemVisual(t, "style")), n.style.strokeNoScale = !0, n.__simpleBox = r, Qr(n, i);
  var a = e.getItemLayout(t).sign;
  $(n.states, function(s, l) {
    var u = i.getModel(l), c = ZO(a, u), d = JO(a, u) || c, f = s.style || (s.style = {});
    c && (f.fill = c), d && (f.stroke = d);
  });
  var o = i.getModel("emphasis");
  er(n, o.get("focus"), o.get("blurScope"), o.get("disabled"));
}
function aVe(n, e) {
  return De(n, function(t) {
    return t = t.slice(), t[1] = e.initBaseline, t;
  });
}
var oVe = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }()
), FE = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "largeCandlestickBox", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new oVe();
    }, e.prototype.buildPath = function(t, r) {
      for (var i = r.points, a = 0; a < i.length; )
        if (this.__sign === i[a++]) {
          var o = i[a++];
          t.moveTo(o, i[a++]), t.lineTo(o, i[a++]);
        } else
          a += 3;
    }, e;
  }(Ht)
);
function U4(n, e, t, r) {
  var i = n.getData(), a = i.getLayout("largePoints"), o = new FE({
    shape: {
      points: a
    },
    __sign: 1,
    ignoreCoarsePointer: !0
  });
  e.add(o);
  var s = new FE({
    shape: {
      points: a
    },
    __sign: -1,
    ignoreCoarsePointer: !0
  });
  e.add(s);
  var l = new FE({
    shape: {
      points: a
    },
    __sign: 0,
    ignoreCoarsePointer: !0
  });
  e.add(l), VE(1, o, n), VE(-1, s, n), VE(0, l, n), r && (o.incremental = !0, s.incremental = !0), t && t.push(o, s);
}
function VE(n, e, t, r) {
  var i = JO(n, t) || ZO(n, t), a = t.getModel("itemStyle").getItemStyle(tVe);
  e.useStyle(a), e.style.fill = null, e.style.stroke = i;
}
var vK = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.defaultValueDimensions = [{
        name: "open",
        defaultTooltip: !0
      }, {
        name: "close",
        defaultTooltip: !0
      }, {
        name: "lowest",
        defaultTooltip: !0
      }, {
        name: "highest",
        defaultTooltip: !0
      }], t;
    }
    return e.prototype.getShadowDim = function() {
      return "open";
    }, e.prototype.brushSelector = function(t, r, i) {
      var a = r.getItemLayout(t);
      return a && i.rect(a.brushRect);
    }, e.type = "series.candlestick", e.dependencies = ["xAxis", "yAxis", "grid"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      layout: null,
      clip: !0,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        // borderColor: '#d24040',
        // borderColor0: '#398f4f',
        borderWidth: 1
      },
      emphasis: {
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, e;
  }(Rn)
);
_r(vK, fK, !0);
function sVe(n) {
  !n || !Me(n.series) || $(n.series, function(e) {
    ut(e) && e.type === "k" && (e.type = "candlestick");
  });
}
var lVe = {
  seriesType: "candlestick",
  plan: yh(),
  reset: function(n) {
    var e = n.coordinateSystem, t = n.getData(), r = uVe(n, t), i = 0, a = 1, o = ["x", "y"], s = t.getDimensionIndex(t.mapDimension(o[i])), l = De(t.mapDimensionsAll(o[a]), t.getDimensionIndex, t), u = l[0], c = l[1], d = l[2], f = l[3];
    if (t.setLayout({
      candleWidth: r,
      // The value is experimented visually.
      isSimpleBox: r <= 1.3
    }), s < 0 || l.length < 4)
      return;
    return {
      progress: n.pipelineContext.large ? h : p
    };
    function p(v, m) {
      for (var g, y = m.getStore(); (g = v.next()) != null; ) {
        var b = y.get(s, g), _ = y.get(u, g), x = y.get(c, g), w = y.get(d, g), S = y.get(f, g), C = Math.min(_, x), k = Math.max(_, x), M = B(C, b), D = B(k, b), N = B(w, b), R = B(S, b), j = [];
        H(j, D, 0), H(j, M, 1), j.push(ne(R), ne(D), ne(N), ne(M));
        var z = m.getItemModel(g), F = !!z.get(["itemStyle", "borderColorDoji"]);
        m.setItemLayout(g, {
          sign: W4(y, g, _, x, c, F),
          initBaseline: _ > x ? D[a] : M[a],
          ends: j,
          brushRect: Y(w, S, b)
        });
      }
      function B(J, X) {
        var ie = [];
        return ie[i] = X, ie[a] = J, isNaN(X) || isNaN(J) ? [NaN, NaN] : e.dataToPoint(ie);
      }
      function H(J, X, ie) {
        var ye = X.slice(), pe = X.slice();
        ye[i] = C1(ye[i] + r / 2, 1, !1), pe[i] = C1(pe[i] - r / 2, 1, !0), ie ? J.push(ye, pe) : J.push(pe, ye);
      }
      function Y(J, X, ie) {
        var ye = B(J, ie), pe = B(X, ie);
        return ye[i] -= r / 2, pe[i] -= r / 2, {
          x: ye[0],
          y: ye[1],
          width: r,
          height: pe[1] - ye[1]
        };
      }
      function ne(J) {
        return J[i] = C1(J[i], 1), J;
      }
    }
    function h(v, m) {
      for (var g = us(v.count * 4), y = 0, b, _ = [], x = [], w, S = m.getStore(), C = !!n.get(["itemStyle", "borderColorDoji"]); (w = v.next()) != null; ) {
        var k = S.get(s, w), M = S.get(u, w), D = S.get(c, w), N = S.get(d, w), R = S.get(f, w);
        if (isNaN(k) || isNaN(N) || isNaN(R)) {
          g[y++] = NaN, y += 3;
          continue;
        }
        g[y++] = W4(S, w, M, D, c, C), _[i] = k, _[a] = N, b = e.dataToPoint(_, null, x), g[y++] = b ? b[0] : NaN, g[y++] = b ? b[1] : NaN, _[a] = R, b = e.dataToPoint(_, null, x), g[y++] = b ? b[1] : NaN;
      }
      m.setLayout("largePoints", g);
    }
  }
};
function W4(n, e, t, r, i, a) {
  var o;
  return t > r ? o = -1 : t < r ? o = 1 : o = a ? 0 : e > 0 ? n.get(i, e - 1) <= r ? 1 : -1 : 1, o;
}
function uVe(n, e) {
  var t = n.getBaseAxis(), r, i = t.type === "category" ? t.getBandWidth() : (r = t.getExtent(), Math.abs(r[1] - r[0]) / e.count()), a = ze(bt(n.get("barMaxWidth"), i), i), o = ze(bt(n.get("barMinWidth"), 1), i), s = n.get("barWidth");
  return s != null ? ze(s, i) : Math.max(Math.min(i / 2, a), o);
}
function cVe(n) {
  n.registerChartView(nVe), n.registerSeriesModel(vK), n.registerPreprocessor(sVe), n.registerVisual(eVe), n.registerLayout(lVe);
}
function q4(n, e) {
  var t = e.rippleEffectColor || e.color;
  n.eachChild(function(r) {
    r.attr({
      z: e.z,
      zlevel: e.zlevel,
      style: {
        stroke: e.brushType === "stroke" ? t : null,
        fill: e.brushType === "fill" ? t : null
      }
    });
  });
}
var dVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r) {
      var i = n.call(this) || this, a = new Zg(t, r), o = new mt();
      return i.add(a), i.add(o), i.updateData(t, r), i;
    }
    return e.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, e.prototype.startEffectAnimation = function(t) {
      for (var r = t.symbolType, i = t.color, a = t.rippleNumber, o = this.childAt(1), s = 0; s < a; s++) {
        var l = yr(r, -1, -1, 2, 2, i);
        l.attr({
          style: {
            strokeNoScale: !0
          },
          z2: 99,
          silent: !0,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var u = -s / a * t.period + t.effectOffset;
        l.animate("", !0).when(t.period, {
          scaleX: t.rippleScale / 2,
          scaleY: t.rippleScale / 2
        }).delay(u).start(), l.animateStyle(!0).when(t.period, {
          opacity: 0
        }).delay(u).start(), o.add(l);
      }
      q4(o, t);
    }, e.prototype.updateEffectAnimation = function(t) {
      for (var r = this._effectCfg, i = this.childAt(1), a = ["symbolType", "period", "rippleScale", "rippleNumber"], o = 0; o < a.length; o++) {
        var s = a[o];
        if (r[s] !== t[s]) {
          this.stopEffectAnimation(), this.startEffectAnimation(t);
          return;
        }
      }
      q4(i, t);
    }, e.prototype.highlight = function() {
      xl(this);
    }, e.prototype.downplay = function() {
      wl(this);
    }, e.prototype.getSymbolType = function() {
      var t = this.childAt(0);
      return t && t.getSymbolType();
    }, e.prototype.updateData = function(t, r) {
      var i = this, a = t.hostModel;
      this.childAt(0).updateData(t, r);
      var o = this.childAt(1), s = t.getItemModel(r), l = t.getItemVisual(r, "symbol"), u = _h(t.getItemVisual(r, "symbolSize")), c = t.getItemVisual(r, "style"), d = c && c.fill, f = s.getModel("emphasis");
      o.setScale(u), o.traverse(function(m) {
        m.setStyle("fill", d);
      });
      var p = ef(t.getItemVisual(r, "symbolOffset"), u);
      p && (o.x = p[0], o.y = p[1]);
      var h = t.getItemVisual(r, "symbolRotate");
      o.rotation = (h || 0) * Math.PI / 180 || 0;
      var v = {};
      v.showEffectOn = a.get("showEffectOn"), v.rippleScale = s.get(["rippleEffect", "scale"]), v.brushType = s.get(["rippleEffect", "brushType"]), v.period = s.get(["rippleEffect", "period"]) * 1e3, v.effectOffset = r / t.count(), v.z = a.getShallow("z") || 0, v.zlevel = a.getShallow("zlevel") || 0, v.symbolType = l, v.color = d, v.rippleEffectColor = s.get(["rippleEffect", "color"]), v.rippleNumber = s.get(["rippleEffect", "number"]), v.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(v) : this.startEffectAnimation(v), this._effectCfg = v) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(m) {
        m === "emphasis" ? v.showEffectOn !== "render" && i.startEffectAnimation(v) : m === "normal" && v.showEffectOn !== "render" && i.stopEffectAnimation();
      }), this._effectCfg = v, er(this, f.get("focus"), f.get("blurScope"), f.get("disabled"));
    }, e.prototype.fadeOut = function(t) {
      t && t();
    }, e;
  }(mt)
), fVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this._symbolDraw = new Jg(dVe);
    }, e.prototype.render = function(t, r, i) {
      var a = t.getData(), o = this._symbolDraw;
      o.updateData(a, {
        clipShape: this._getClipShape(t)
      }), this.group.add(o.group);
    }, e.prototype._getClipShape = function(t) {
      var r = t.coordinateSystem, i = r && r.getArea && r.getArea();
      return t.get("clip", !0) ? i : null;
    }, e.prototype.updateTransform = function(t, r, i) {
      var a = t.getData();
      this.group.dirty();
      var o = ey("").reset(t, r, i);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout();
    }, e.prototype._updateGroupTransform = function(t) {
      var r = t.coordinateSystem;
      r && r.getRoamTransform && (this.group.transform = ODe(r.getRoamTransform()), this.group.decomposeTransform());
    }, e.prototype.remove = function(t, r) {
      this._symbolDraw && this._symbolDraw.remove(!0);
    }, e.type = "effectScatter", e;
  }(Tn)
), pVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return Dl(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.brushSelector = function(t, r, i) {
      return i.point(r.getItemLayout(t));
    }, e.type = "series.effectScatter", e.dependencies = ["grid", "polar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      effectType: "ripple",
      progressive: 0,
      // When to show the effect, option: 'render'|'emphasis'
      showEffectOn: "render",
      clip: !0,
      // Ripple effect config
      rippleEffect: {
        period: 4,
        // Scale of ripple
        scale: 2.5,
        // Brush type can be fill or stroke
        brushType: "fill",
        // Ripple number
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // symbol: null,        // 图形类型
      symbolSize: 10
      // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
      // symbolRotate: null,  // 图形旋转控制
      // itemStyle: {
      //     opacity: 1
      // }
    }, e;
  }(Rn)
);
function hVe(n) {
  n.registerChartView(fVe), n.registerSeriesModel(pVe), n.registerLayout(ey("effectScatter"));
}
var mK = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i) {
      var a = n.call(this) || this;
      return a.add(a.createLine(t, r, i)), a._updateEffectSymbol(t, r), a;
    }
    return e.prototype.createLine = function(t, r, i) {
      return new VO(t, r, i);
    }, e.prototype._updateEffectSymbol = function(t, r) {
      var i = t.getItemModel(r), a = i.getModel("effect"), o = a.get("symbolSize"), s = a.get("symbol");
      Me(o) || (o = [o, o]);
      var l = t.getItemVisual(r, "style"), u = a.get("color") || l && l.stroke, c = this.childAt(1);
      this._symbolType !== s && (this.remove(c), c = yr(s, -0.5, -0.5, 1, 1, u), c.z2 = 100, c.culling = !0, this.add(c)), c && (c.setStyle("shadowColor", u), c.setStyle(a.getItemStyle(["color"])), c.scaleX = o[0], c.scaleY = o[1], c.setColor(u), this._symbolType = s, this._symbolScale = o, this._updateEffectAnimation(t, a, r));
    }, e.prototype._updateEffectAnimation = function(t, r, i) {
      var a = this.childAt(1);
      if (a) {
        var o = t.getItemLayout(i), s = r.get("period") * 1e3, l = r.get("loop"), u = r.get("roundTrip"), c = r.get("constantSpeed"), d = mr(r.get("delay"), function(p) {
          return p / t.count() * s / 3;
        });
        if (a.ignore = !0, this._updateAnimationPoints(a, o), c > 0 && (s = this._getLineLength(a) / c * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
          a.stopAnimation();
          var f = void 0;
          at(d) ? f = d(i) : f = d, a.__t > 0 && (f = -s * a.__t), this._animateSymbol(a, s, f, l, u);
        }
        this._period = s, this._loop = l, this._roundTrip = u;
      }
    }, e.prototype._animateSymbol = function(t, r, i, a, o) {
      if (r > 0) {
        t.__t = 0;
        var s = this, l = t.animate("", a).when(o ? r * 2 : r, {
          __t: o ? 2 : 1
        }).delay(i).during(function() {
          s._updateSymbolPosition(t);
        });
        a || l.done(function() {
          s.remove(t);
        }), l.start();
      }
    }, e.prototype._getLineLength = function(t) {
      return du(t.__p1, t.__cp1) + du(t.__cp1, t.__p2);
    }, e.prototype._updateAnimationPoints = function(t, r) {
      t.__p1 = r[0], t.__p2 = r[1], t.__cp1 = r[2] || [(r[0][0] + r[1][0]) / 2, (r[0][1] + r[1][1]) / 2];
    }, e.prototype.updateData = function(t, r, i) {
      this.childAt(0).updateData(t, r, i), this._updateEffectSymbol(t, r);
    }, e.prototype._updateSymbolPosition = function(t) {
      var r = t.__p1, i = t.__p2, a = t.__cp1, o = t.__t < 1 ? t.__t : 2 - t.__t, s = [t.x, t.y], l = s.slice(), u = Br, c = GC;
      s[0] = u(r[0], a[0], i[0], o), s[1] = u(r[1], a[1], i[1], o);
      var d = t.__t < 1 ? c(r[0], a[0], i[0], o) : c(i[0], a[0], r[0], 1 - o), f = t.__t < 1 ? c(r[1], a[1], i[1], o) : c(i[1], a[1], r[1], 1 - o);
      t.rotation = -Math.atan2(f, d) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (t.__lastT !== void 0 && t.__lastT < t.__t ? (t.scaleY = du(l, s) * 1.05, o === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : t.__lastT === 1 ? t.scaleY = 2 * du(r, s) : t.scaleY = this._symbolScale[1]), t.__lastT = t.__t, t.ignore = !1, t.x = s[0], t.y = s[1];
    }, e.prototype.updateLayout = function(t, r) {
      this.childAt(0).updateLayout(t, r);
      var i = t.getItemModel(r).getModel("effect");
      this._updateEffectAnimation(t, i, r);
    }, e;
  }(mt)
), gK = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i) {
      var a = n.call(this) || this;
      return a._createPolyline(t, r, i), a;
    }
    return e.prototype._createPolyline = function(t, r, i) {
      var a = t.getItemLayout(r), o = new Hi({
        shape: {
          points: a
        }
      });
      this.add(o), this._updateCommonStl(t, r, i);
    }, e.prototype.updateData = function(t, r, i) {
      var a = t.hostModel, o = this.childAt(0), s = {
        shape: {
          points: t.getItemLayout(r)
        }
      };
      ln(o, s, a, r), this._updateCommonStl(t, r, i);
    }, e.prototype._updateCommonStl = function(t, r, i) {
      var a = this.childAt(0), o = t.getItemModel(r), s = i && i.emphasisLineStyle, l = i && i.focus, u = i && i.blurScope, c = i && i.emphasisDisabled;
      if (!i || t.hasItemOption) {
        var d = o.getModel("emphasis");
        s = d.getModel("lineStyle").getLineStyle(), c = d.get("disabled"), l = d.get("focus"), u = d.get("blurScope");
      }
      a.useStyle(t.getItemVisual(r, "style")), a.style.fill = null, a.style.strokeNoScale = !0;
      var f = a.ensureState("emphasis");
      f.style = s, er(this, l, u, c);
    }, e.prototype.updateLayout = function(t, r) {
      var i = this.childAt(0);
      i.setShape("points", t.getItemLayout(r));
    }, e;
  }(mt)
), vVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t._lastFrame = 0, t._lastFramePercent = 0, t;
    }
    return e.prototype.createLine = function(t, r, i) {
      return new gK(t, r, i);
    }, e.prototype._updateAnimationPoints = function(t, r) {
      this._points = r;
      for (var i = [0], a = 0, o = 1; o < r.length; o++) {
        var s = r[o - 1], l = r[o];
        a += du(s, l), i.push(a);
      }
      if (a === 0) {
        this._length = 0;
        return;
      }
      for (var o = 0; o < i.length; o++)
        i[o] /= a;
      this._offsets = i, this._length = a;
    }, e.prototype._getLineLength = function() {
      return this._length;
    }, e.prototype._updateSymbolPosition = function(t) {
      var r = t.__t < 1 ? t.__t : 2 - t.__t, i = this._points, a = this._offsets, o = i.length;
      if (a) {
        var s = this._lastFrame, l;
        if (r < this._lastFramePercent) {
          var u = Math.min(s + 1, o - 1);
          for (l = u; l >= 0 && !(a[l] <= r); l--)
            ;
          l = Math.min(l, o - 2);
        } else {
          for (l = s; l < o && !(a[l] > r); l++)
            ;
          l = Math.min(l - 1, o - 2);
        }
        var c = (r - a[l]) / (a[l + 1] - a[l]), d = i[l], f = i[l + 1];
        t.x = d[0] * (1 - c) + c * f[0], t.y = d[1] * (1 - c) + c * f[1];
        var p = t.__t < 1 ? f[0] - d[0] : d[0] - f[0], h = t.__t < 1 ? f[1] - d[1] : d[1] - f[1];
        t.rotation = -Math.atan2(h, p) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = r, t.ignore = !1;
      }
    }, e;
  }(mK)
), mVe = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
      this.polyline = !1, this.curveness = 0, this.segs = [];
    }
    return n;
  }()
), gVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r._off = 0, r.hoverDataIdx = -1, r;
    }
    return e.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new mVe();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.segs, a = r.curveness, o;
      if (r.polyline)
        for (o = this._off; o < i.length; ) {
          var s = i[o++];
          if (s > 0) {
            t.moveTo(i[o++], i[o++]);
            for (var l = 1; l < s; l++)
              t.lineTo(i[o++], i[o++]);
          }
        }
      else
        for (o = this._off; o < i.length; ) {
          var u = i[o++], c = i[o++], d = i[o++], f = i[o++];
          if (t.moveTo(u, c), a > 0) {
            var p = (u + d) / 2 - (c - f) * a, h = (c + f) / 2 - (d - u) * a;
            t.quadraticCurveTo(p, h, d, f);
          } else
            t.lineTo(d, f);
        }
      this.incremental && (this._off = o, this.notClear = !0);
    }, e.prototype.findDataIndex = function(t, r) {
      var i = this.shape, a = i.segs, o = i.curveness, s = this.style.lineWidth;
      if (i.polyline)
        for (var l = 0, u = 0; u < a.length; ) {
          var c = a[u++];
          if (c > 0)
            for (var d = a[u++], f = a[u++], p = 1; p < c; p++) {
              var h = a[u++], v = a[u++];
              if (eu(d, f, h, v, s, t, r))
                return l;
            }
          l++;
        }
      else
        for (var l = 0, u = 0; u < a.length; ) {
          var d = a[u++], f = a[u++], h = a[u++], v = a[u++];
          if (o > 0) {
            var m = (d + h) / 2 - (f - v) * o, g = (f + v) / 2 - (h - d) * o;
            if (UG(d, f, m, g, h, v, s, t, r))
              return l;
          } else if (eu(d, f, h, v, s, t, r))
            return l;
          l++;
        }
      return -1;
    }, e.prototype.contain = function(t, r) {
      var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect();
      if (t = i[0], r = i[1], a.contain(t, r)) {
        var o = this.hoverDataIdx = this.findDataIndex(t, r);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect;
      if (!t) {
        for (var r = this.shape, i = r.segs, a = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < i.length; ) {
          var c = i[u++], d = i[u++];
          a = Math.min(c, a), s = Math.max(c, s), o = Math.min(d, o), l = Math.max(d, l);
        }
        t = this._rect = new Ot(a, o, s, l);
      }
      return t;
    }, e;
  }(Ht)
), yVe = (
  /** @class */
  function() {
    function n() {
      this.group = new mt();
    }
    return n.prototype.updateData = function(e) {
      this._clear();
      var t = this._create();
      t.setShape({
        segs: e.getLayout("linesPoints")
      }), this._setCommon(t, e);
    }, n.prototype.incrementalPrepareUpdate = function(e) {
      this.group.removeAll(), this._clear();
    }, n.prototype.incrementalUpdate = function(e, t) {
      var r = this._newAdded[0], i = t.getLayout("linesPoints"), a = r && r.shape.segs;
      if (a && a.length < 2e4) {
        var o = a.length, s = new Float32Array(o + i.length);
        s.set(a), s.set(i, o), r.setShape({
          segs: s
        });
      } else {
        this._newAdded = [];
        var l = this._create();
        l.incremental = !0, l.setShape({
          segs: i
        }), this._setCommon(l, t), l.__startIndex = e.start;
      }
    }, n.prototype.remove = function() {
      this._clear();
    }, n.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, n.prototype._create = function() {
      var e = new gVe({
        cursor: "default",
        ignoreCoarsePointer: !0
      });
      return this._newAdded.push(e), this.group.add(e), e;
    }, n.prototype._setCommon = function(e, t, r) {
      var i = t.hostModel;
      e.setShape({
        polyline: i.get("polyline"),
        curveness: i.get(["lineStyle", "curveness"])
      }), e.useStyle(i.getModel("lineStyle").getLineStyle()), e.style.strokeNoScale = !0;
      var a = t.getVisual("style");
      a && a.stroke && e.setStyle("stroke", a.stroke), e.setStyle("fill", null);
      var o = yt(e);
      o.seriesIndex = i.seriesIndex, e.on("mousemove", function(s) {
        o.dataIndex = null;
        var l = e.hoverDataIdx;
        l > 0 && (o.dataIndex = l + e.__startIndex);
      });
    }, n.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, n;
  }()
), yK = {
  seriesType: "lines",
  plan: yh(),
  reset: function(n) {
    var e = n.coordinateSystem;
    if (!e) {
      process.env.NODE_ENV !== "production" && Jr("The lines series must have a coordinate system.");
      return;
    }
    var t = n.get("polyline"), r = n.pipelineContext.large;
    return {
      progress: function(i, a) {
        var o = [];
        if (r) {
          var s = void 0, l = i.end - i.start;
          if (t) {
            for (var u = 0, c = i.start; c < i.end; c++)
              u += n.getLineCoordsCount(c);
            s = new Float32Array(l + u * 2);
          } else
            s = new Float32Array(l * 4);
          for (var d = 0, f = [], c = i.start; c < i.end; c++) {
            var p = n.getLineCoords(c, o);
            t && (s[d++] = p);
            for (var h = 0; h < p; h++)
              f = e.dataToPoint(o[h], !1, f), s[d++] = f[0], s[d++] = f[1];
          }
          a.setLayout("linesPoints", s);
        } else
          for (var c = i.start; c < i.end; c++) {
            var v = a.getItemModel(c), p = n.getLineCoords(c, o), m = [];
            if (t)
              for (var g = 0; g < p; g++)
                m.push(e.dataToPoint(o[g]));
            else {
              m[0] = e.dataToPoint(o[0]), m[1] = e.dataToPoint(o[1]);
              var y = v.get(["lineStyle", "curveness"]);
              +y && (m[2] = [(m[0][0] + m[1][0]) / 2 - (m[0][1] - m[1][1]) * y, (m[0][1] + m[1][1]) / 2 - (m[1][0] - m[0][0]) * y]);
            }
            a.setItemLayout(c, m);
          }
      }
    };
  }
}, bVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = t.getData(), o = this._updateLineDraw(a, t), s = t.get("zlevel"), l = t.get(["effect", "trailLength"]), u = i.getZr(), c = u.painter.getType() === "svg";
      c || u.painter.getLayer(s).clear(!0), this._lastZlevel != null && !c && u.configLayer(this._lastZlevel, {
        motionBlur: !1
      }), this._showEffect(t) && l > 0 && (c ? process.env.NODE_ENV !== "production" && console.warn("SVG render mode doesn't support lines with trail effect") : u.configLayer(s, {
        motionBlur: !0,
        lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0)
      })), o.updateData(a);
      var d = t.get("clip", !0) && Qg(t.coordinateSystem, !1, t);
      d ? this.group.setClipPath(d) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = !0;
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      var a = t.getData(), o = this._updateLineDraw(a, t);
      o.incrementalPrepareUpdate(a), this._clearLayer(i), this._finished = !1;
    }, e.prototype.incrementalRender = function(t, r, i) {
      this._lineDraw.incrementalUpdate(t, r.getData()), this._finished = t.end === r.getData().count();
    }, e.prototype.eachRendered = function(t) {
      this._lineDraw && this._lineDraw.eachRendered(t);
    }, e.prototype.updateTransform = function(t, r, i) {
      var a = t.getData(), o = t.pipelineContext;
      if (!this._finished || o.large || o.progressiveRender)
        return {
          update: !0
        };
      var s = yK.reset(t, r, i);
      s.progress && s.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._lineDraw.updateLayout(), this._clearLayer(i);
    }, e.prototype._updateLineDraw = function(t, r) {
      var i = this._lineDraw, a = this._showEffect(r), o = !!r.get("polyline"), s = r.pipelineContext, l = s.large;
      return process.env.NODE_ENV !== "production" && a && l && console.warn("Large lines not support effect"), (!i || a !== this._hasEffet || o !== this._isPolyline || l !== this._isLargeDraw) && (i && i.remove(), i = this._lineDraw = l ? new yVe() : new HO(o ? a ? vVe : gK : a ? mK : VO), this._hasEffet = a, this._isPolyline = o, this._isLargeDraw = l), this.group.add(i.group), i;
    }, e.prototype._showEffect = function(t) {
      return !!t.get(["effect", "show"]);
    }, e.prototype._clearLayer = function(t) {
      var r = t.getZr(), i = r.painter.getType() === "svg";
      !i && this._lastZlevel != null && r.painter.getLayer(this._lastZlevel).clear(!0);
    }, e.prototype.remove = function(t, r) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(r);
    }, e.prototype.dispose = function(t, r) {
      this.remove(t, r);
    }, e.type = "lines", e;
  }(Tn)
), _Ve = typeof Uint32Array > "u" ? Array : Uint32Array, xVe = typeof Float64Array > "u" ? Array : Float64Array;
function Y4(n) {
  var e = n.data;
  e && e[0] && e[0][0] && e[0][0].coord && (process.env.NODE_ENV !== "production" && console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }"), n.data = De(e, function(t) {
    var r = [t[0].coord, t[1].coord], i = {
      coords: r
    };
    return t[0].name && (i.fromName = t[0].name), t[1].name && (i.toName = t[1].name), wD([i, t[0], t[1]]);
  }));
}
var wVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t;
    }
    return e.prototype.init = function(t) {
      t.data = t.data || [], Y4(t);
      var r = this._processFlatCoordsArray(t.data);
      this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (t.data = new Float32Array(r.count)), n.prototype.init.apply(this, arguments);
    }, e.prototype.mergeOption = function(t) {
      if (Y4(t), t.data) {
        var r = this._processFlatCoordsArray(t.data);
        this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (t.data = new Float32Array(r.count));
      }
      n.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.appendData = function(t) {
      var r = this._processFlatCoordsArray(t.data);
      r.flatCoords && (this._flatCoords ? (this._flatCoords = Km(this._flatCoords, r.flatCoords), this._flatCoordsOffset = Km(this._flatCoordsOffset, r.flatCoordsOffset)) : (this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset), t.data = new Float32Array(r.count)), this.getRawData().appendData(t.data);
    }, e.prototype._getCoordsFromItemModel = function(t) {
      var r = this.getData().getItemModel(t), i = r.option instanceof Array ? r.option : r.getShallow("coords");
      if (process.env.NODE_ENV !== "production" && !(i instanceof Array && i.length > 0 && i[0] instanceof Array))
        throw new Error("Invalid coords " + JSON.stringify(i) + ". Lines must have 2d coords array in data item.");
      return i;
    }, e.prototype.getLineCoordsCount = function(t) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[t * 2 + 1] : this._getCoordsFromItemModel(t).length;
    }, e.prototype.getLineCoords = function(t, r) {
      if (this._flatCoordsOffset) {
        for (var i = this._flatCoordsOffset[t * 2], a = this._flatCoordsOffset[t * 2 + 1], o = 0; o < a; o++)
          r[o] = r[o] || [], r[o][0] = this._flatCoords[i + o * 2], r[o][1] = this._flatCoords[i + o * 2 + 1];
        return a;
      } else {
        for (var s = this._getCoordsFromItemModel(t), o = 0; o < s.length; o++)
          r[o] = r[o] || [], r[o][0] = s[o][0], r[o][1] = s[o][1];
        return s.length;
      }
    }, e.prototype._processFlatCoordsArray = function(t) {
      var r = 0;
      if (this._flatCoords && (r = this._flatCoords.length), sn(t[0])) {
        for (var i = t.length, a = new _Ve(i), o = new xVe(i), s = 0, l = 0, u = 0, c = 0; c < i; ) {
          u++;
          var d = t[c++];
          a[l++] = s + r, a[l++] = d;
          for (var f = 0; f < d; f++) {
            var p = t[c++], h = t[c++];
            if (o[s++] = p, o[s++] = h, c > i && process.env.NODE_ENV !== "production")
              throw new Error("Invalid data format.");
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(a.buffer, 0, l),
          flatCoords: o,
          count: u
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: t.length
      };
    }, e.prototype.getInitialData = function(t, r) {
      if (process.env.NODE_ENV !== "production") {
        var i = gh.get(t.coordinateSystem);
        if (!i)
          throw new Error("Unknown coordinate system " + t.coordinateSystem);
      }
      var a = new Oi(["value"], this);
      return a.hasItemOption = !1, a.initData(t.data, [], function(o, s, l, u) {
        if (o instanceof Array)
          return NaN;
        a.hasItemOption = !0;
        var c = o.value;
        if (c != null)
          return c instanceof Array ? c[u] : c;
      }), a;
    }, e.prototype.formatTooltip = function(t, r, i) {
      var a = this.getData(), o = a.getItemModel(t), s = o.get("name");
      if (s)
        return s;
      var l = o.get("fromName"), u = o.get("toName"), c = [];
      return l != null && c.push(l), u != null && c.push(u), Rr("nameValue", {
        name: c.join(" > ")
      });
    }, e.prototype.preventIncremental = function() {
      return !!this.get(["effect", "show"]);
    }, e.prototype.getProgressive = function() {
      var t = this.option.progressive;
      return t ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.option.progressiveThreshold;
      return t ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, e.prototype.getZLevelKey = function() {
      var t = this.getModel("effect"), r = t.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : t.get("show") && r > 0 ? r + "" : "";
    }, e.type = "series.lines", e.dependencies = ["grid", "polar", "geo", "calendar"], e.defaultOption = {
      coordinateSystem: "geo",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Cartesian coordinate system
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      // Geo coordinate system
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2
      },
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: {
        show: !1,
        position: "end"
        // distance: 5,
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      },
      lineStyle: {
        opacity: 0.5
      }
    }, e;
  }(Rn)
);
function U0(n) {
  return n instanceof Array || (n = [n, n]), n;
}
var SVe = {
  seriesType: "lines",
  reset: function(n) {
    var e = U0(n.get("symbol")), t = U0(n.get("symbolSize")), r = n.getData();
    r.setVisual("fromSymbol", e && e[0]), r.setVisual("toSymbol", e && e[1]), r.setVisual("fromSymbolSize", t && t[0]), r.setVisual("toSymbolSize", t && t[1]);
    function i(a, o) {
      var s = a.getItemModel(o), l = U0(s.getShallow("symbol", !0)), u = U0(s.getShallow("symbolSize", !0));
      l[0] && a.setItemVisual(o, "fromSymbol", l[0]), l[1] && a.setItemVisual(o, "toSymbol", l[1]), u[0] && a.setItemVisual(o, "fromSymbolSize", u[0]), u[1] && a.setItemVisual(o, "toSymbolSize", u[1]);
    }
    return {
      dataEach: r.hasItemOption ? i : null
    };
  }
};
function EVe(n) {
  n.registerChartView(bVe), n.registerSeriesModel(wVe), n.registerLayout(yK), n.registerVisual(SVe);
}
var TVe = 256, CVe = (
  /** @class */
  function() {
    function n() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var e = Lu.createCanvas();
      this.canvas = e;
    }
    return n.prototype.update = function(e, t, r, i, a, o) {
      var s = this._getBrush(), l = this._getGradient(a, "inRange"), u = this._getGradient(a, "outOfRange"), c = this.pointSize + this.blurSize, d = this.canvas, f = d.getContext("2d"), p = e.length;
      d.width = t, d.height = r;
      for (var h = 0; h < p; ++h) {
        var v = e[h], m = v[0], g = v[1], y = v[2], b = i(y);
        f.globalAlpha = b, f.drawImage(s, m - c, g - c);
      }
      if (!d.width || !d.height)
        return d;
      for (var _ = f.getImageData(0, 0, d.width, d.height), x = _.data, w = 0, S = x.length, C = this.minOpacity, k = this.maxOpacity, M = k - C; w < S; ) {
        var b = x[w + 3] / 256, D = Math.floor(b * (TVe - 1)) * 4;
        if (b > 0) {
          var N = o(b) ? l : u;
          b > 0 && (b = b * M + C), x[w++] = N[D], x[w++] = N[D + 1], x[w++] = N[D + 2], x[w++] = N[D + 3] * b * 256;
        } else
          w += 4;
      }
      return f.putImageData(_, 0, 0), d;
    }, n.prototype._getBrush = function() {
      var e = this._brushCanvas || (this._brushCanvas = Lu.createCanvas()), t = this.pointSize + this.blurSize, r = t * 2;
      e.width = r, e.height = r;
      var i = e.getContext("2d");
      return i.clearRect(0, 0, r, r), i.shadowOffsetX = r, i.shadowBlur = this.blurSize, i.shadowColor = "#000", i.beginPath(), i.arc(-t, t, this.pointSize, 0, Math.PI * 2, !0), i.closePath(), i.fill(), e;
    }, n.prototype._getGradient = function(e, t) {
      for (var r = this._gradientPixels, i = r[t] || (r[t] = new Uint8ClampedArray(256 * 4)), a = [0, 0, 0, 0], o = 0, s = 0; s < 256; s++)
        e[t](s / 255, !0, a), i[o++] = a[0], i[o++] = a[1], i[o++] = a[2], i[o++] = a[3];
      return i;
    }, n;
  }()
);
function kVe(n, e, t) {
  var r = n[1] - n[0];
  e = De(e, function(o) {
    return {
      interval: [(o.interval[0] - n[0]) / r, (o.interval[1] - n[0]) / r]
    };
  });
  var i = e.length, a = 0;
  return function(o) {
    var s;
    for (s = a; s < i; s++) {
      var l = e[s].interval;
      if (l[0] <= o && o <= l[1]) {
        a = s;
        break;
      }
    }
    if (s === i)
      for (s = a - 1; s >= 0; s--) {
        var l = e[s].interval;
        if (l[0] <= o && o <= l[1]) {
          a = s;
          break;
        }
      }
    return s >= 0 && s < i && t[s];
  };
}
function AVe(n, e) {
  var t = n[1] - n[0];
  return e = [(e[0] - n[0]) / t, (e[1] - n[0]) / t], function(r) {
    return r >= e[0] && r <= e[1];
  };
}
function K4(n) {
  var e = n.dimensions;
  return e[0] === "lng" && e[1] === "lat";
}
var MVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a;
      if (r.eachComponent("visualMap", function(s) {
        s.eachTargetSeries(function(l) {
          l === t && (a = s);
        });
      }), process.env.NODE_ENV !== "production" && !a)
        throw new Error("Heatmap must use with visualMap");
      this._progressiveEls = null, this.group.removeAll();
      var o = t.coordinateSystem;
      o.type === "cartesian2d" || o.type === "calendar" ? this._renderOnCartesianAndCalendar(t, i, 0, t.getData().count()) : K4(o) && this._renderOnGeo(o, t, a, i);
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      this.group.removeAll();
    }, e.prototype.incrementalRender = function(t, r, i, a) {
      var o = r.coordinateSystem;
      o && (K4(o) ? this.render(r, i, a) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(r, a, t.start, t.end, !0)));
    }, e.prototype.eachRendered = function(t) {
      Yu(this._progressiveEls || this.group, t);
    }, e.prototype._renderOnCartesianAndCalendar = function(t, r, i, a, o) {
      var s = t.coordinateSystem, l = nf(s, "cartesian2d"), u, c, d, f;
      if (l) {
        var p = s.getAxis("x"), h = s.getAxis("y");
        if (process.env.NODE_ENV !== "production") {
          if (!(p.type === "category" && h.type === "category"))
            throw new Error("Heatmap on cartesian must have two category axes");
          if (!(p.onBand && h.onBand))
            throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
        }
        u = p.getBandWidth() + 0.5, c = h.getBandWidth() + 0.5, d = p.scale.getExtent(), f = h.scale.getExtent();
      }
      for (var v = this.group, m = t.getData(), g = t.getModel(["emphasis", "itemStyle"]).getItemStyle(), y = t.getModel(["blur", "itemStyle"]).getItemStyle(), b = t.getModel(["select", "itemStyle"]).getItemStyle(), _ = t.get(["itemStyle", "borderRadius"]), x = Nr(t), w = t.getModel("emphasis"), S = w.get("focus"), C = w.get("blurScope"), k = w.get("disabled"), M = l ? [m.mapDimension("x"), m.mapDimension("y"), m.mapDimension("value")] : [m.mapDimension("time"), m.mapDimension("value")], D = i; D < a; D++) {
        var N = void 0, R = m.getItemVisual(D, "style");
        if (l) {
          var j = m.get(M[0], D), z = m.get(M[1], D);
          if (isNaN(m.get(M[2], D)) || isNaN(j) || isNaN(z) || j < d[0] || j > d[1] || z < f[0] || z > f[1])
            continue;
          var F = s.dataToPoint([j, z]);
          N = new Qt({
            shape: {
              x: F[0] - u / 2,
              y: F[1] - c / 2,
              width: u,
              height: c
            },
            style: R
          });
        } else {
          if (isNaN(m.get(M[1], D)))
            continue;
          N = new Qt({
            z2: 1,
            shape: s.dataToRect([m.get(M[0], D)]).contentShape,
            style: R
          });
        }
        if (m.hasItemOption) {
          var B = m.getItemModel(D), H = B.getModel("emphasis");
          g = H.getModel("itemStyle").getItemStyle(), y = B.getModel(["blur", "itemStyle"]).getItemStyle(), b = B.getModel(["select", "itemStyle"]).getItemStyle(), _ = B.get(["itemStyle", "borderRadius"]), S = H.get("focus"), C = H.get("blurScope"), k = H.get("disabled"), x = Nr(B);
        }
        N.shape.r = _;
        var Y = t.getRawValue(D), ne = "-";
        Y && Y[2] != null && (ne = Y[2] + ""), ei(N, x, {
          labelFetcher: t,
          labelDataIndex: D,
          defaultOpacity: R.opacity,
          defaultText: ne
        }), N.ensureState("emphasis").style = g, N.ensureState("blur").style = y, N.ensureState("select").style = b, er(N, S, C, k), N.incremental = o, o && (N.states.emphasis.hoverLayer = !0), v.add(N), m.setItemGraphicEl(D, N), this._progressiveEls && this._progressiveEls.push(N);
      }
    }, e.prototype._renderOnGeo = function(t, r, i, a) {
      var o = i.targetVisuals.inRange, s = i.targetVisuals.outOfRange, l = r.getData(), u = this._hmLayer || this._hmLayer || new CVe();
      u.blurSize = r.get("blurSize"), u.pointSize = r.get("pointSize"), u.minOpacity = r.get("minOpacity"), u.maxOpacity = r.get("maxOpacity");
      var c = t.getViewRect().clone(), d = t.getRoamTransform();
      c.applyTransform(d);
      var f = Math.max(c.x, 0), p = Math.max(c.y, 0), h = Math.min(c.width + c.x, a.getWidth()), v = Math.min(c.height + c.y, a.getHeight()), m = h - f, g = v - p, y = [l.mapDimension("lng"), l.mapDimension("lat"), l.mapDimension("value")], b = l.mapArray(y, function(S, C, k) {
        var M = t.dataToPoint([S, C]);
        return M[0] -= f, M[1] -= p, M.push(k), M;
      }), _ = i.getExtent(), x = i.type === "visualMap.continuous" ? AVe(_, i.option.range) : kVe(_, i.getPieceList(), i.option.selected);
      u.update(b, m, g, o.color.getNormalizer(), {
        inRange: o.color.getColorMapper(),
        outOfRange: s.color.getColorMapper()
      }, x);
      var w = new Ur({
        style: {
          width: m,
          height: g,
          x: f,
          y: p,
          image: u.canvas
        },
        silent: !0
      });
      this.group.add(w);
    }, e.type = "heatmap", e;
  }(Tn)
), DVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return Dl(null, this, {
        generateCoord: "value"
      });
    }, e.prototype.preventIncremental = function() {
      var t = gh.get(this.get("coordinateSystem"));
      if (t && t.dimensions)
        return t.dimensions[0] === "lng" && t.dimensions[1] === "lat";
    }, e.type = "series.heatmap", e.dependencies = ["grid", "geo", "calendar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Geo coordinate system
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Rn)
);
function OVe(n) {
  n.registerChartView(MVe), n.registerSeriesModel(DVe);
}
var IVe = ["itemStyle", "borderWidth"], X4 = [{
  xy: "x",
  wh: "width",
  index: 0,
  posDesc: ["left", "right"]
}, {
  xy: "y",
  wh: "height",
  index: 1,
  posDesc: ["top", "bottom"]
}], HE = new Ml(), LVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = this.group, o = t.getData(), s = this._data, l = t.coordinateSystem, u = l.getBaseAxis(), c = u.isHorizontal(), d = l.master.getRect(), f = {
        ecSize: {
          width: i.getWidth(),
          height: i.getHeight()
        },
        seriesModel: t,
        coordSys: l,
        coordSysExtent: [[d.x, d.x + d.width], [d.y, d.y + d.height]],
        isHorizontal: c,
        valueDim: X4[+c],
        categoryDim: X4[1 - +c]
      };
      o.diff(s).add(function(h) {
        if (o.hasValue(h)) {
          var v = J4(o, h), m = Z4(o, h, v, f), g = Q4(o, f, m);
          o.setItemGraphicEl(h, g), a.add(g), t$(g, f, m);
        }
      }).update(function(h, v) {
        var m = s.getItemGraphicEl(v);
        if (!o.hasValue(h)) {
          a.remove(m);
          return;
        }
        var g = J4(o, h), y = Z4(o, h, g, f), b = EK(o, y);
        m && b !== m.__pictorialShapeStr && (a.remove(m), o.setItemGraphicEl(h, null), m = null), m ? zVe(m, f, y) : m = Q4(o, f, y, !0), o.setItemGraphicEl(h, m), m.__pictorialSymbolMeta = y, a.add(m), t$(m, f, y);
      }).remove(function(h) {
        var v = s.getItemGraphicEl(h);
        v && e$(s, h, v.__pictorialSymbolMeta.animationModel, v);
      }).execute();
      var p = t.get("clip", !0) ? Qg(t.coordinateSystem, !1, t) : null;
      return p ? a.setClipPath(p) : a.removeClipPath(), this._data = o, this.group;
    }, e.prototype.remove = function(t, r) {
      var i = this.group, a = this._data;
      t.get("animation") ? a && a.eachItemGraphicEl(function(o) {
        e$(a, yt(o).dataIndex, t, o);
      }) : i.removeAll();
    }, e.type = "pictorialBar", e;
  }(Tn)
);
function Z4(n, e, t, r) {
  var i = n.getItemLayout(e), a = t.get("symbolRepeat"), o = t.get("symbolClip"), s = t.get("symbolPosition") || "start", l = t.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, c = t.get("symbolPatternSize") || 2, d = t.isAnimationEnabled(), f = {
    dataIndex: e,
    layout: i,
    itemModel: t,
    symbolType: n.getItemVisual(e, "symbol") || "circle",
    style: n.getItemVisual(e, "style"),
    symbolClip: o,
    symbolRepeat: a,
    symbolRepeatDirection: t.get("symbolRepeatDirection"),
    symbolPatternSize: c,
    rotation: u,
    animationModel: d ? t : null,
    hoverScale: d && t.get(["emphasis", "scale"]),
    z2: t.getShallow("z", !0) || 0
  };
  NVe(t, a, i, r, f), RVe(n, e, i, a, o, f.boundingLength, f.pxSign, c, r, f), PVe(t, f.symbolScale, u, r, f);
  var p = f.symbolSize, h = ef(t.get("symbolOffset"), p);
  return jVe(t, p, i, a, o, h, s, f.valueLineWidth, f.boundingLength, f.repeatCutLength, r, f), f;
}
function NVe(n, e, t, r, i) {
  var a = r.valueDim, o = n.get("symbolBoundingData"), s = r.coordSys.getOtherAxis(r.coordSys.getBaseAxis()), l = s.toGlobalCoord(s.dataToCoord(0)), u = 1 - +(t[a.wh] <= 0), c;
  if (Me(o)) {
    var d = [GE(s, o[0]) - l, GE(s, o[1]) - l];
    d[1] < d[0] && d.reverse(), c = d[u];
  } else o != null ? c = GE(s, o) - l : e ? c = r.coordSysExtent[a.index][u] - l : c = t[a.wh];
  i.boundingLength = c, e && (i.repeatCutLength = t[a.wh]);
  var f = a.xy === "x", p = s.inverse;
  i.pxSign = f && !p || !f && p ? c >= 0 ? 1 : -1 : c > 0 ? 1 : -1;
}
function GE(n, e) {
  return n.toGlobalCoord(n.dataToCoord(n.scale.parse(e)));
}
function RVe(n, e, t, r, i, a, o, s, l, u) {
  var c = l.valueDim, d = l.categoryDim, f = Math.abs(t[d.wh]), p = n.getItemVisual(e, "symbolSize"), h;
  Me(p) ? h = p.slice() : p == null ? h = ["100%", "100%"] : h = [p, p], h[d.index] = ze(h[d.index], f), h[c.index] = ze(h[c.index], r ? f : Math.abs(a)), u.symbolSize = h;
  var v = u.symbolScale = [h[0] / s, h[1] / s];
  v[c.index] *= (l.isHorizontal ? -1 : 1) * o;
}
function PVe(n, e, t, r, i) {
  var a = n.get(IVe) || 0;
  a && (HE.attr({
    scaleX: e[0],
    scaleY: e[1],
    rotation: t
  }), HE.updateTransform(), a /= HE.getLineScale(), a *= e[r.valueDim.index]), i.valueLineWidth = a || 0;
}
function jVe(n, e, t, r, i, a, o, s, l, u, c, d) {
  var f = c.categoryDim, p = c.valueDim, h = d.pxSign, v = Math.max(e[p.index] + s, 0), m = v;
  if (r) {
    var g = Math.abs(l), y = mr(n.get("symbolMargin"), "15%") + "", b = !1;
    y.lastIndexOf("!") === y.length - 1 && (b = !0, y = y.slice(0, y.length - 1));
    var _ = ze(y, e[p.index]), x = Math.max(v + _ * 2, 0), w = b ? 0 : _ * 2, S = OD(r), C = S ? r : n$((g + w) / x), k = g - C * v;
    _ = k / 2 / (b ? C : Math.max(C - 1, 1)), x = v + _ * 2, w = b ? 0 : _ * 2, !S && r !== "fixed" && (C = u ? n$((Math.abs(u) + w) / x) : 0), m = C * x - w, d.repeatTimes = C, d.symbolMargin = _;
  }
  var M = h * (m / 2), D = d.pathPosition = [];
  D[f.index] = t[f.wh] / 2, D[p.index] = o === "start" ? M : o === "end" ? l - M : l / 2, a && (D[0] += a[0], D[1] += a[1]);
  var N = d.bundlePosition = [];
  N[f.index] = t[f.xy], N[p.index] = t[p.xy];
  var R = d.barRectShape = xe({}, t);
  R[p.wh] = h * Math.max(Math.abs(t[p.wh]), Math.abs(D[p.index] + M)), R[f.wh] = t[f.wh];
  var j = d.clipShape = {};
  j[f.xy] = -t[f.xy], j[f.wh] = c.ecSize[f.wh], j[p.xy] = 0, j[p.wh] = t[p.wh];
}
function bK(n) {
  var e = n.symbolPatternSize, t = yr(
    // Consider texture img, make a big size.
    n.symbolType,
    -e / 2,
    -e / 2,
    e,
    e
  );
  return t.attr({
    culling: !0
  }), t.type !== "image" && t.setStyle({
    strokeNoScale: !0
  }), t;
}
function _K(n, e, t, r) {
  var i = n.__pictorialBundle, a = t.symbolSize, o = t.valueLineWidth, s = t.pathPosition, l = e.valueDim, u = t.repeatTimes || 0, c = 0, d = a[e.valueDim.index] + o + t.symbolMargin * 2;
  for (QO(n, function(v) {
    v.__pictorialAnimationIndex = c, v.__pictorialRepeatTimes = u, c < u ? Sp(v, null, h(c), t, r) : Sp(v, null, {
      scaleX: 0,
      scaleY: 0
    }, t, r, function() {
      i.remove(v);
    }), c++;
  }); c < u; c++) {
    var f = bK(t);
    f.__pictorialAnimationIndex = c, f.__pictorialRepeatTimes = u, i.add(f);
    var p = h(c);
    Sp(f, {
      x: p.x,
      y: p.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: p.scaleX,
      scaleY: p.scaleY,
      rotation: p.rotation
    }, t, r);
  }
  function h(v) {
    var m = s.slice(), g = t.pxSign, y = v;
    return (t.symbolRepeatDirection === "start" ? g > 0 : g < 0) && (y = u - 1 - v), m[l.index] = d * (y - u / 2 + 0.5) + s[l.index], {
      x: m[0],
      y: m[1],
      scaleX: t.symbolScale[0],
      scaleY: t.symbolScale[1],
      rotation: t.rotation
    };
  }
}
function xK(n, e, t, r) {
  var i = n.__pictorialBundle, a = n.__pictorialMainPath;
  a ? Sp(a, null, {
    x: t.pathPosition[0],
    y: t.pathPosition[1],
    scaleX: t.symbolScale[0],
    scaleY: t.symbolScale[1],
    rotation: t.rotation
  }, t, r) : (a = n.__pictorialMainPath = bK(t), i.add(a), Sp(a, {
    x: t.pathPosition[0],
    y: t.pathPosition[1],
    scaleX: 0,
    scaleY: 0,
    rotation: t.rotation
  }, {
    scaleX: t.symbolScale[0],
    scaleY: t.symbolScale[1]
  }, t, r));
}
function wK(n, e, t) {
  var r = xe({}, e.barRectShape), i = n.__pictorialBarRect;
  i ? Sp(i, null, {
    shape: r
  }, e, t) : (i = n.__pictorialBarRect = new Qt({
    z2: 2,
    shape: r,
    silent: !0,
    style: {
      stroke: "transparent",
      fill: "transparent",
      lineWidth: 0
    }
  }), i.disableMorphing = !0, n.add(i));
}
function SK(n, e, t, r) {
  if (t.symbolClip) {
    var i = n.__pictorialClipPath, a = xe({}, t.clipShape), o = e.valueDim, s = t.animationModel, l = t.dataIndex;
    if (i)
      ln(i, {
        shape: a
      }, s, l);
    else {
      a[o.wh] = 0, i = new Qt({
        shape: a
      }), n.__pictorialBundle.setClipPath(i), n.__pictorialClipPath = i;
      var u = {};
      u[o.wh] = t.clipShape[o.wh], Qd[r ? "updateProps" : "initProps"](i, {
        shape: u
      }, s, l);
    }
  }
}
function J4(n, e) {
  var t = n.getItemModel(e);
  return t.getAnimationDelayParams = BVe, t.isAnimationEnabled = $Ve, t;
}
function BVe(n) {
  return {
    index: n.__pictorialAnimationIndex,
    count: n.__pictorialRepeatTimes
  };
}
function $Ve() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function Q4(n, e, t, r) {
  var i = new mt(), a = new mt();
  return i.add(a), i.__pictorialBundle = a, a.x = t.bundlePosition[0], a.y = t.bundlePosition[1], t.symbolRepeat ? _K(i, e, t) : xK(i, e, t), wK(i, t, r), SK(i, e, t, r), i.__pictorialShapeStr = EK(n, t), i.__pictorialSymbolMeta = t, i;
}
function zVe(n, e, t) {
  var r = t.animationModel, i = t.dataIndex, a = n.__pictorialBundle;
  ln(a, {
    x: t.bundlePosition[0],
    y: t.bundlePosition[1]
  }, r, i), t.symbolRepeat ? _K(n, e, t, !0) : xK(n, e, t, !0), wK(n, t, !0), SK(n, e, t, !0);
}
function e$(n, e, t, r) {
  var i = r.__pictorialBarRect;
  i && i.removeTextContent();
  var a = [];
  QO(r, function(o) {
    a.push(o);
  }), r.__pictorialMainPath && a.push(r.__pictorialMainPath), r.__pictorialClipPath && (t = null), $(a, function(o) {
    Pu(o, {
      scaleX: 0,
      scaleY: 0
    }, t, e, function() {
      r.parent && r.parent.remove(r);
    });
  }), n.setItemGraphicEl(e, null);
}
function EK(n, e) {
  return [n.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip].join(":");
}
function QO(n, e, t) {
  $(n.__pictorialBundle.children(), function(r) {
    r !== n.__pictorialBarRect && e.call(t, r);
  });
}
function Sp(n, e, t, r, i, a) {
  e && n.attr(e), r.symbolClip && !i ? t && n.attr(t) : t && Qd[i ? "updateProps" : "initProps"](n, t, r.animationModel, r.dataIndex, a);
}
function t$(n, e, t) {
  var r = t.dataIndex, i = t.itemModel, a = i.getModel("emphasis"), o = a.getModel("itemStyle").getItemStyle(), s = i.getModel(["blur", "itemStyle"]).getItemStyle(), l = i.getModel(["select", "itemStyle"]).getItemStyle(), u = i.getShallow("cursor"), c = a.get("focus"), d = a.get("blurScope"), f = a.get("scale");
  QO(n, function(v) {
    if (v instanceof Ur) {
      var m = v.style;
      v.useStyle(xe({
        // TODO other properties like dx, dy ?
        image: m.image,
        x: m.x,
        y: m.y,
        width: m.width,
        height: m.height
      }, t.style));
    } else
      v.useStyle(t.style);
    var g = v.ensureState("emphasis");
    g.style = o, f && (g.scaleX = v.scaleX * 1.1, g.scaleY = v.scaleY * 1.1), v.ensureState("blur").style = s, v.ensureState("select").style = l, u && (v.cursor = u), v.z2 = t.z2;
  });
  var p = e.valueDim.posDesc[+(t.boundingLength > 0)], h = n.__pictorialBarRect;
  h.ignoreClip = !0, ei(h, Nr(i), {
    labelFetcher: e.seriesModel,
    labelDataIndex: r,
    defaultText: Up(e.seriesModel.getData(), r),
    inheritColor: t.style.fill,
    defaultOpacity: t.style.opacity,
    defaultOutsidePosition: p
  }), er(n, c, d, a.get("disabled"));
}
function n$(n) {
  var e = Math.round(n);
  return Math.abs(n - e) < 1e-4 ? e : Math.ceil(n);
}
var FVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t.defaultSymbol = "roundRect", t;
    }
    return e.prototype.getInitialData = function(t) {
      return t.stack = null, n.prototype.getInitialData.apply(this, arguments);
    }, e.type = "series.pictorialBar", e.dependencies = ["grid"], e.defaultOption = Ku(dg.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: !1,
      symbolRepeatDirection: "end",
      symbolClip: !1,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      // Pictorial bar do not clip by default because in many cases
      // xAxis and yAxis are not displayed and it's expected not to clip
      clip: !1,
      // z can be set in data item, which is z2 actually.
      // Disable progressive
      progressive: 0,
      emphasis: {
        // By default pictorialBar do not hover scale. Hover scale is not suitable
        // for the case that both has foreground and background.
        scale: !1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }), e;
  }(dg)
);
function VVe(n) {
  n.registerChartView(LVe), n.registerSeriesModel(FVe), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, Tt(sq, "pictorialBar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, lq("pictorialBar"));
}
var HVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._layers = [], t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = t.getData(), o = this, s = this.group, l = t.getLayerSeries(), u = a.getLayout("layoutInfo"), c = u.rect, d = u.boundaryGap;
      s.x = 0, s.y = c.y + d[0];
      function f(m) {
        return m.name;
      }
      var p = new Sl(this._layersSeries || [], l, f, f), h = [];
      p.add(Ze(v, this, "add")).update(Ze(v, this, "update")).remove(Ze(v, this, "remove")).execute();
      function v(m, g, y) {
        var b = o._layers;
        if (m === "remove") {
          s.remove(b[g]);
          return;
        }
        for (var _ = [], x = [], w, S = l[g].indices, C = 0; C < S.length; C++) {
          var k = a.getItemLayout(S[C]), M = k.x, D = k.y0, N = k.y;
          _.push(M, D), x.push(M, D + N), w = a.getItemVisual(S[C], "style");
        }
        var R, j = a.getItemLayout(S[0]), z = t.getModel("label"), F = z.get("margin"), B = t.getModel("emphasis");
        if (m === "add") {
          var H = h[g] = new mt();
          R = new Xq({
            shape: {
              points: _,
              stackedOnPoints: x,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: !1
            },
            z2: 0
          }), H.add(R), s.add(H), t.isAnimationEnabled() && R.setClipPath(GVe(R.getBoundingRect(), t, function() {
            R.removeClipPath();
          }));
        } else {
          var H = b[y];
          R = H.childAt(0), s.add(H), h[g] = H, ln(R, {
            shape: {
              points: _,
              stackedOnPoints: x
            }
          }, t), Oo(R);
        }
        ei(R, Nr(t), {
          labelDataIndex: S[C - 1],
          defaultText: a.getName(S[C - 1]),
          inheritColor: w.fill
        }, {
          normal: {
            verticalAlign: "middle"
            // align: 'right'
          }
        }), R.setTextConfig({
          position: null,
          local: !0
        });
        var Y = R.getTextContent();
        Y && (Y.x = j.x - F, Y.y = j.y0 + j.y / 2), R.useStyle(w), a.setItemGraphicEl(g, R), Qr(R, t), er(R, B.get("focus"), B.get("blurScope"), B.get("disabled"));
      }
      this._layersSeries = l, this._layers = h;
    }, e.type = "themeRiver", e;
  }(Tn)
);
function GVe(n, e, t) {
  var r = new Qt({
    shape: {
      x: n.x - 10,
      y: n.y - 10,
      width: 0,
      height: n.height + 20
    }
  });
  return Gn(r, {
    shape: {
      x: n.x - 50,
      width: n.width + 100,
      height: n.height + 20
    }
  }, e, t), r;
}
var UE = 2, UVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new ny(Ze(this.getData, this), Ze(this.getRawData, this));
    }, e.prototype.fixData = function(t) {
      var r = t.length, i = {}, a = ok(t, function(f) {
        return i.hasOwnProperty(f[0] + "") || (i[f[0] + ""] = -1), f[2];
      }), o = [];
      a.buckets.each(function(f, p) {
        o.push({
          name: p,
          dataList: f
        });
      });
      for (var s = o.length, l = 0; l < s; ++l) {
        for (var u = o[l].name, c = 0; c < o[l].dataList.length; ++c) {
          var d = o[l].dataList[c][0] + "";
          i[d] = l;
        }
        for (var d in i)
          i.hasOwnProperty(d) && i[d] !== l && (i[d] = l, t[r] = [d, 0, u], r++);
      }
      return t;
    }, e.prototype.getInitialData = function(t, r) {
      for (var i = this.getReferringComponents("singleAxis", gr).models[0], a = i.get("type"), o = vn(t.data, function(h) {
        return h[2] !== void 0;
      }), s = this.fixData(o || []), l = [], u = this.nameMap = tt(), c = 0, d = 0; d < s.length; ++d)
        l.push(s[d][UE]), u.get(s[d][UE]) || (u.set(s[d][UE], c), c++);
      var f = Kg(s, {
        coordDimensions: ["single"],
        dimensionsDefine: [{
          name: "time",
          type: m_(a)
        }, {
          name: "value",
          type: "float"
        }, {
          name: "name",
          type: "ordinal"
        }],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, p = new Oi(f, this);
      return p.initData(s), p;
    }, e.prototype.getLayerSeries = function() {
      for (var t = this.getData(), r = t.count(), i = [], a = 0; a < r; ++a)
        i[a] = a;
      var o = t.mapDimension("single"), s = ok(i, function(u) {
        return t.get("name", u);
      }), l = [];
      return s.buckets.each(function(u, c) {
        u.sort(function(d, f) {
          return t.get(o, d) - t.get(o, f);
        }), l.push({
          name: c,
          indices: u
        });
      }), l;
    }, e.prototype.getAxisTooltipData = function(t, r, i) {
      Me(t) || (t = t ? [t] : []);
      for (var a = this.getData(), o = this.getLayerSeries(), s = [], l = o.length, u, c = 0; c < l; ++c) {
        for (var d = Number.MAX_VALUE, f = -1, p = o[c].indices.length, h = 0; h < p; ++h) {
          var v = a.get(t[0], o[c].indices[h]), m = Math.abs(v - r);
          m <= d && (u = v, d = m, f = o[c].indices[h]);
        }
        s.push(f);
      }
      return {
        dataIndices: s,
        nestestValue: u
      };
    }, e.prototype.formatTooltip = function(t, r, i) {
      var a = this.getData(), o = a.getName(t), s = a.get(a.mapDimension("value"), t);
      return Rr("nameValue", {
        name: o,
        value: s
      });
    }, e.type = "series.themeRiver", e.dependencies = ["singleAxis"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      // gap in axis's orthogonal orientation
      boundaryGap: ["10%", "10%"],
      // legendHoverLink: true,
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: !0,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, e;
  }(Rn)
);
function WVe(n, e) {
  n.eachSeriesByType("themeRiver", function(t) {
    var r = t.getData(), i = t.coordinateSystem, a = {}, o = i.getRect();
    a.rect = o;
    var s = t.get("boundaryGap"), l = i.getAxis();
    if (a.boundaryGap = s, l.orient === "horizontal") {
      s[0] = ze(s[0], o.height), s[1] = ze(s[1], o.height);
      var u = o.height - s[0] - s[1];
      r$(r, t, u);
    } else {
      s[0] = ze(s[0], o.width), s[1] = ze(s[1], o.width);
      var c = o.width - s[0] - s[1];
      r$(r, t, c);
    }
    r.setLayout("layoutInfo", a);
  });
}
function r$(n, e, t) {
  if (n.count())
    for (var r = e.coordinateSystem, i = e.getLayerSeries(), a = n.mapDimension("single"), o = n.mapDimension("value"), s = De(i, function(m) {
      return De(m.indices, function(g) {
        var y = r.dataToPoint(n.get(a, g));
        return y[1] = n.get(o, g), y;
      });
    }), l = qVe(s), u = l.y0, c = t / l.max, d = i.length, f = i[0].indices.length, p, h = 0; h < f; ++h) {
      p = u[h] * c, n.setItemLayout(i[0].indices[h], {
        layerIndex: 0,
        x: s[0][h][0],
        y0: p,
        y: s[0][h][1] * c
      });
      for (var v = 1; v < d; ++v)
        p += s[v - 1][h][1] * c, n.setItemLayout(i[v].indices[h], {
          layerIndex: v,
          x: s[v][h][0],
          y0: p,
          y: s[v][h][1] * c
        });
    }
}
function qVe(n) {
  for (var e = n.length, t = n[0].length, r = [], i = [], a = 0, o = 0; o < t; ++o) {
    for (var s = 0, l = 0; l < e; ++l)
      s += n[l][o][1];
    s > a && (a = s), r.push(s);
  }
  for (var u = 0; u < t; ++u)
    i[u] = (a - r[u]) / 2;
  a = 0;
  for (var c = 0; c < t; ++c) {
    var d = r[c] + i[c];
    d > a && (a = d);
  }
  return {
    y0: i,
    max: a
  };
}
function YVe(n) {
  n.registerChartView(HVe), n.registerSeriesModel(UVe), n.registerLayout(WVe), n.registerProcessor(ty("themeRiver"));
}
var KVe = 2, XVe = 4, i$ = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i, a) {
      var o = n.call(this) || this;
      o.z2 = KVe, o.textConfig = {
        inside: !0
      }, yt(o).seriesIndex = r.seriesIndex;
      var s = new nn({
        z2: XVe,
        silent: t.getModel().get(["label", "silent"])
      });
      return o.setTextContent(s), o.updateData(!0, t, r, i, a), o;
    }
    return e.prototype.updateData = function(t, r, i, a, o) {
      this.node = r, r.piece = this, i = i || this._seriesModel, a = a || this._ecModel;
      var s = this;
      yt(s).dataIndex = r.dataIndex;
      var l = r.getModel(), u = l.getModel("emphasis"), c = r.getLayout(), d = xe({}, c);
      d.label = null;
      var f = r.getVisual("style");
      f.lineJoin = "bevel";
      var p = r.getVisual("decal");
      p && (f.decal = Hp(p, o));
      var h = Xc(l.getModel("itemStyle"), d, !0);
      xe(d, h), $(zi, function(y) {
        var b = s.ensureState(y), _ = l.getModel([y, "itemStyle"]);
        b.style = _.getItemStyle();
        var x = Xc(_, d);
        x && (b.shape = x);
      }), t ? (s.setShape(d), s.shape.r = c.r0, Gn(s, {
        shape: {
          r: c.r
        }
      }, i, r.dataIndex)) : (ln(s, {
        shape: d
      }, i), Oo(s)), s.useStyle(f), this._updateLabel(i);
      var v = l.getShallow("cursor");
      v && s.attr("cursor", v), this._seriesModel = i || this._seriesModel, this._ecModel = a || this._ecModel;
      var m = u.get("focus"), g = m === "relative" ? Km(r.getAncestorsIndices(), r.getDescendantIndices()) : m === "ancestor" ? r.getAncestorsIndices() : m === "descendant" ? r.getDescendantIndices() : m;
      er(this, g, u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t) {
      var r = this, i = this.node.getModel(), a = i.getModel("label"), o = this.node.getLayout(), s = o.endAngle - o.startAngle, l = (o.startAngle + o.endAngle) / 2, u = Math.cos(l), c = Math.sin(l), d = this, f = d.getTextContent(), p = this.node.dataIndex, h = a.get("minAngle") / 180 * Math.PI, v = a.get("show") && !(h != null && Math.abs(s) < h);
      f.ignore = !v, $(eg, function(g) {
        var y = g === "normal" ? i.getModel("label") : i.getModel([g, "label"]), b = g === "normal", _ = b ? f : f.ensureState(g), x = t.getFormattedLabel(p, g);
        b && (x = x || r.node.name), _.style = Ln(y, {}, null, g !== "normal", !0), x && (_.style.text = x);
        var w = y.get("show");
        w != null && !b && (_.ignore = !w);
        var S = m(y, "position"), C = b ? d : d.states[g], k = C.style.fill;
        C.textConfig = {
          outsideFill: y.get("color") === "inherit" ? k : null,
          inside: S !== "outside"
        };
        var M, D = m(y, "distance") || 0, N = m(y, "align"), R = m(y, "rotate"), j = Math.PI * 0.5, z = Math.PI * 1.5, F = va(R === "tangential" ? Math.PI / 2 - l : l), B = F > j && !Qm(F - j) && F < z;
        S === "outside" ? (M = o.r + D, N = B ? "right" : "left") : !N || N === "center" ? (s === 2 * Math.PI && o.r0 === 0 ? M = 0 : M = (o.r + o.r0) / 2, N = "center") : N === "left" ? (M = o.r0 + D, N = B ? "right" : "left") : N === "right" && (M = o.r - D, N = B ? "left" : "right"), _.style.align = N, _.style.verticalAlign = m(y, "verticalAlign") || "middle", _.x = M * u + o.cx, _.y = M * c + o.cy;
        var H = 0;
        R === "radial" ? H = va(-l) + (B ? Math.PI : 0) : R === "tangential" ? H = va(Math.PI / 2 - l) + (B ? Math.PI : 0) : sn(R) && (H = R * Math.PI / 180), _.rotation = va(H);
      });
      function m(g, y) {
        var b = g.get(y);
        return b ?? a.get(y);
      }
      f.dirtyStyle();
    }, e;
  }(Fi)
), sA = "sunburstRootToNode", a$ = "sunburstHighlight", ZVe = "sunburstUnhighlight";
function JVe(n) {
  n.registerAction({
    type: sA,
    update: "updateView"
  }, function(e, t) {
    t.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: e
    }, r);
    function r(i, a) {
      var o = pg(e, [sA], i);
      if (o) {
        var s = i.getViewRoot();
        s && (e.direction = jO(s, o.node) ? "rollUp" : "drillDown"), i.resetViewRoot(o.node);
      }
    }
  }), n.registerAction({
    type: a$,
    update: "none"
  }, function(e, t, r) {
    e = xe({}, e), t.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: e
    }, i);
    function i(a) {
      var o = pg(e, [a$], a);
      o && (e.dataIndex = o.node.dataIndex);
    }
    process.env.NODE_ENV !== "production" && vr("sunburstHighlight", "highlight"), r.dispatchAction(xe(e, {
      type: "highlight"
    }));
  }), n.registerAction({
    type: ZVe,
    update: "updateView"
  }, function(e, t, r) {
    e = xe({}, e), process.env.NODE_ENV !== "production" && vr("sunburstUnhighlight", "downplay"), r.dispatchAction(xe(e, {
      type: "downplay"
    }));
  });
}
var QVe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      var o = this;
      this.seriesModel = t, this.api = i, this.ecModel = r;
      var s = t.getData(), l = s.tree.root, u = t.getViewRoot(), c = this.group, d = t.get("renderLabelForZeroData"), f = [];
      u.eachNode(function(y) {
        f.push(y);
      });
      var p = this._oldChildren || [];
      h(f, p), g(l, u), this._initEvents(), this._oldChildren = f;
      function h(y, b) {
        if (y.length === 0 && b.length === 0)
          return;
        new Sl(b, y, _, _).add(x).update(x).remove(Tt(x, null)).execute();
        function _(w) {
          return w.getId();
        }
        function x(w, S) {
          var C = w == null ? null : y[w], k = S == null ? null : b[S];
          v(C, k);
        }
      }
      function v(y, b) {
        if (!d && y && !y.getValue() && (y = null), y !== l && b !== l) {
          if (b && b.piece)
            y ? (b.piece.updateData(!1, y, t, r, i), s.setItemGraphicEl(y.dataIndex, b.piece)) : m(b);
          else if (y) {
            var _ = new i$(y, t, r, i);
            c.add(_), s.setItemGraphicEl(y.dataIndex, _);
          }
        }
      }
      function m(y) {
        y && y.piece && (c.remove(y.piece), y.piece = null);
      }
      function g(y, b) {
        b.depth > 0 ? (o.virtualPiece ? o.virtualPiece.updateData(!1, y, t, r, i) : (o.virtualPiece = new i$(y, t, r, i), c.add(o.virtualPiece)), b.piece.off("click"), o.virtualPiece.on("click", function(_) {
          o._rootToNode(b.parentNode);
        })) : o.virtualPiece && (c.remove(o.virtualPiece), o.virtualPiece = null);
      }
    }, e.prototype._initEvents = function() {
      var t = this;
      this.group.off("click"), this.group.on("click", function(r) {
        var i = !1, a = t.seriesModel.getViewRoot();
        a.eachNode(function(o) {
          if (!i && o.piece && o.piece === r.target) {
            var s = o.getModel().get("nodeClick");
            if (s === "rootToNode")
              t._rootToNode(o);
            else if (s === "link") {
              var l = o.getModel(), u = l.get("link");
              if (u) {
                var c = l.get("target", !0) || "_blank";
                o_(u, c);
              }
            }
            i = !0;
          }
        });
      });
    }, e.prototype._rootToNode = function(t) {
      t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: sA,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t
      });
    }, e.prototype.containPoint = function(t, r) {
      var i = r.getData(), a = i.getItemLayout(0);
      if (a) {
        var o = t[0] - a.cx, s = t[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, e.type = "sunburst", e;
  }(Tn)
), e6e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.ignoreStyleOnData = !0, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      var i = {
        name: t.name,
        children: t.data
      };
      TK(i);
      var a = this._levelModels = De(t.levels || [], function(l) {
        return new yn(l, this, r);
      }, this), o = PO.createTree(i, this, s);
      function s(l) {
        l.wrapMethod("getItemModel", function(u, c) {
          var d = o.getNodeByDataIndex(c), f = a[d.depth];
          return f && (u.parentModel = f), u;
        });
      }
      return o.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.getDataParams = function(t) {
      var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
      return r.treePathInfo = kw(i, this), r;
    }, e.prototype.getLevelModel = function(t) {
      return this._levelModels && this._levelModels[t.depth];
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(t) {
      t ? this._viewRoot = t : t = this._viewRoot;
      var r = this.getRawData().tree.root;
      (!t || t !== r && !r.contains(t)) && (this._viewRoot = r);
    }, e.prototype.enableAriaDecal = function() {
      DY(this);
    }, e.type = "series.sunburst", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      // 默认全局居中
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 默认顺时针
      clockwise: !0,
      startAngle: 90,
      // 最小角度改为0
      minAngle: 0,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // 'rootToNode', 'link', or false
      nodeClick: "rootToNode",
      renderLabelForZeroData: !1,
      label: {
        // could be: 'radial', 'tangential', or 'none'
        rotate: "radial",
        show: !0,
        opacity: 1,
        // 'left' is for inner side of inside, and 'right' is for outer
        // side for inside
        align: "center",
        position: "inside",
        distance: 5,
        silent: !0
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      // Animation type can be expansion, scale.
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      /**
       * Sort order.
       *
       * Valid values: 'desc', 'asc', null, or callback function.
       * 'desc' and 'asc' for descend and ascendant order;
       * null for not sorting;
       * example of callback function:
       * function(nodeA, nodeB) {
       *     return nodeA.getValue() - nodeB.getValue();
       * }
       */
      sort: "desc"
    }, e;
  }(Rn)
);
function TK(n) {
  var e = 0;
  $(n.children, function(r) {
    TK(r);
    var i = r.value;
    Me(i) && (i = i[0]), e += i;
  });
  var t = n.value;
  Me(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), Me(n.value) ? n.value[0] = t : n.value = t;
}
var o$ = Math.PI / 180;
function t6e(n, e, t) {
  e.eachSeriesByType(n, function(r) {
    var i = r.get("center"), a = r.get("radius");
    Me(a) || (a = [0, a]), Me(i) || (i = [i, i]);
    var o = t.getWidth(), s = t.getHeight(), l = Math.min(o, s), u = ze(i[0], o), c = ze(i[1], s), d = ze(a[0], l / 2), f = ze(a[1], l / 2), p = -r.get("startAngle") * o$, h = r.get("minAngle") * o$, v = r.getData().tree.root, m = r.getViewRoot(), g = m.depth, y = r.get("sort");
    y != null && CK(m, y);
    var b = 0;
    $(m.children, function(F) {
      !isNaN(F.getValue()) && b++;
    });
    var _ = m.getValue(), x = Math.PI / (_ || b) * 2, w = m.depth > 0, S = m.height - (w ? -1 : 1), C = (f - d) / (S || 1), k = r.get("clockwise"), M = r.get("stillShowZeroSum"), D = k ? 1 : -1, N = function(F, B) {
      if (F) {
        var H = B;
        if (F !== v) {
          var Y = F.getValue(), ne = _ === 0 && M ? x : Y * x;
          ne < h && (ne = h), H = B + D * ne;
          var J = F.depth - g - (w ? -1 : 1), X = d + C * J, ie = d + C * (J + 1), ye = r.getLevelModel(F);
          if (ye) {
            var pe = ye.get("r0", !0), Be = ye.get("r", !0), Ce = ye.get("radius", !0);
            Ce != null && (pe = Ce[0], Be = Ce[1]), pe != null && (X = ze(pe, l / 2)), Be != null && (ie = ze(Be, l / 2));
          }
          F.setLayout({
            angle: ne,
            startAngle: B,
            endAngle: H,
            clockwise: k,
            cx: u,
            cy: c,
            r0: X,
            r: ie
          });
        }
        if (F.children && F.children.length) {
          var Ee = 0;
          $(F.children, function(ce) {
            Ee += N(ce, B + Ee);
          });
        }
        return H - B;
      }
    };
    if (w) {
      var R = d, j = d + C, z = Math.PI * 2;
      v.setLayout({
        angle: z,
        startAngle: p,
        endAngle: p + z,
        clockwise: k,
        cx: u,
        cy: c,
        r0: R,
        r: j
      });
    }
    N(m, p);
  });
}
function CK(n, e) {
  var t = n.children || [];
  n.children = n6e(t, e), t.length && $(n.children, function(r) {
    CK(r, e);
  });
}
function n6e(n, e) {
  if (at(e)) {
    var t = De(n, function(i, a) {
      var o = i.getValue();
      return {
        params: {
          depth: i.depth,
          height: i.height,
          dataIndex: i.dataIndex,
          getValue: function() {
            return o;
          }
        },
        index: a
      };
    });
    return t.sort(function(i, a) {
      return e(i.params, a.params);
    }), De(t, function(i) {
      return n[i.index];
    });
  } else {
    var r = e === "asc";
    return n.sort(function(i, a) {
      var o = (i.getValue() - a.getValue()) * (r ? 1 : -1);
      return o === 0 ? (i.dataIndex - a.dataIndex) * (r ? -1 : 1) : o;
    });
  }
}
function r6e(n) {
  var e = {};
  function t(r, i, a) {
    for (var o = r; o && o.depth > 1; )
      o = o.parentNode;
    var s = i.getColorFromPalette(o.name || o.dataIndex + "", e);
    return r.depth > 1 && We(s) && (s = qC(s, (r.depth - 1) / (a - 1) * 0.5)), s;
  }
  n.eachSeriesByType("sunburst", function(r) {
    var i = r.getData(), a = i.tree;
    a.eachNode(function(o) {
      var s = o.getModel(), l = s.getModel("itemStyle").getItemStyle();
      l.fill || (l.fill = t(o, r, a.root.height));
      var u = i.ensureUniqueItemVisual(o.dataIndex, "style");
      xe(u, l);
    });
  });
}
function i6e(n) {
  n.registerChartView(QVe), n.registerSeriesModel(e6e), n.registerLayout(Tt(t6e, "sunburst")), n.registerProcessor(Tt(ty, "sunburst")), n.registerVisual(r6e), JVe(n);
}
var s$ = {
  color: "fill",
  borderColor: "stroke"
}, a6e = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
}, pl = en(), o6e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", !0), this.currentZ = this.get("z", !0);
    }, e.prototype.getInitialData = function(t, r) {
      return Dl(null, this);
    }, e.prototype.getDataParams = function(t, r, i) {
      var a = n.prototype.getDataParams.call(this, t, r);
      return i && (a.info = pl(i).info), a;
    }, e.type = "series.custom", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Custom series will not clip by default.
      // Some case will use custom series to draw label
      // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
      clip: !1
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
    }, e;
  }(Rn)
);
function s6e(n, e) {
  return e = e || [0, 0], De(["x", "y"], function(t, r) {
    var i = this.getAxis(t), a = e[r], o = n[r] / 2;
    return i.type === "category" ? i.getBandWidth() : Math.abs(i.dataToCoord(a - o) - i.dataToCoord(a + o));
  }, this);
}
function l6e(n) {
  var e = n.master.getRect();
  return {
    coordSys: {
      // The name exposed to user is always 'cartesian2d' but not 'grid'.
      type: "cartesian2d",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    },
    api: {
      coord: function(t) {
        return n.dataToPoint(t);
      },
      size: Ze(s6e, n)
    }
  };
}
function u6e(n, e) {
  return e = e || [0, 0], De([0, 1], function(t) {
    var r = e[t], i = n[t] / 2, a = [], o = [];
    return a[t] = r - i, o[t] = r + i, a[1 - t] = o[1 - t] = e[1 - t], Math.abs(this.dataToPoint(a)[t] - this.dataToPoint(o)[t]);
  }, this);
}
function c6e(n) {
  var e = n.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height,
      zoom: n.getZoom()
    },
    api: {
      coord: function(t) {
        return n.dataToPoint(t);
      },
      size: Ze(u6e, n)
    }
  };
}
function d6e(n, e) {
  var t = this.getAxis(), r = e instanceof Array ? e[0] : e, i = (n instanceof Array ? n[0] : n) / 2;
  return t.type === "category" ? t.getBandWidth() : Math.abs(t.dataToCoord(r - i) - t.dataToCoord(r + i));
}
function f6e(n) {
  var e = n.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    },
    api: {
      coord: function(t) {
        return n.dataToPoint(t);
      },
      size: Ze(d6e, n)
    }
  };
}
function p6e(n, e) {
  return e = e || [0, 0], De(["Radius", "Angle"], function(t, r) {
    var i = "get" + t + "Axis", a = this[i](), o = e[r], s = n[r] / 2, l = a.type === "category" ? a.getBandWidth() : Math.abs(a.dataToCoord(o - s) - a.dataToCoord(o + s));
    return t === "Angle" && (l = l * Math.PI / 180), l;
  }, this);
}
function h6e(n) {
  var e = n.getRadiusAxis(), t = n.getAngleAxis(), r = e.getExtent();
  return r[0] > r[1] && r.reverse(), {
    coordSys: {
      type: "polar",
      cx: n.cx,
      cy: n.cy,
      r: r[1],
      r0: r[0]
    },
    api: {
      coord: function(i) {
        var a = e.dataToRadius(i[0]), o = t.dataToAngle(i[1]), s = n.coordToPoint([a, o]);
        return s.push(a, o * Math.PI / 180), s;
      },
      size: Ze(p6e, n)
    }
  };
}
function v6e(n) {
  var e = n.getRect(), t = n.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height,
      cellWidth: n.getCellWidth(),
      cellHeight: n.getCellHeight(),
      rangeInfo: {
        start: t.start,
        end: t.end,
        weeks: t.weeks,
        dayCount: t.allDay
      }
    },
    api: {
      coord: function(r, i) {
        return n.dataToPoint(r, i);
      }
    }
  };
}
var l$ = {};
function kK(n, e, t, r) {
  return n && (n.legacy || n.legacy !== !1 && !t && !r && e !== "tspan" && (e === "text" || Je(n, "text")));
}
function AK(n, e, t) {
  var r = n, i, a, o;
  if (e === "text")
    o = r;
  else {
    o = {}, Je(r, "text") && (o.text = r.text), Je(r, "rich") && (o.rich = r.rich), Je(r, "textFill") && (o.fill = r.textFill), Je(r, "textStroke") && (o.stroke = r.textStroke), Je(r, "fontFamily") && (o.fontFamily = r.fontFamily), Je(r, "fontSize") && (o.fontSize = r.fontSize), Je(r, "fontStyle") && (o.fontStyle = r.fontStyle), Je(r, "fontWeight") && (o.fontWeight = r.fontWeight), a = {
      type: "text",
      style: o,
      // ec4 does not support rectText trigger.
      // And when text position is different in normal and emphasis
      // => hover text trigger emphasis;
      // => text position changed, leave mouse pointer immediately;
      // That might cause incorrect state.
      silent: !0
    }, i = {};
    var s = Je(r, "textPosition");
    t ? i.position = s ? r.textPosition : "inside" : s && (i.position = r.textPosition), Je(r, "textPosition") && (i.position = r.textPosition), Je(r, "textOffset") && (i.offset = r.textOffset), Je(r, "textRotation") && (i.rotation = r.textRotation), Je(r, "textDistance") && (i.distance = r.textDistance);
  }
  return u$(o, n), $(o.rich, function(l) {
    u$(l, l);
  }), {
    textConfig: i,
    textContent: a
  };
}
function u$(n, e) {
  e && (e.font = e.textFont || e.font, Je(e, "textStrokeWidth") && (n.lineWidth = e.textStrokeWidth), Je(e, "textAlign") && (n.align = e.textAlign), Je(e, "textVerticalAlign") && (n.verticalAlign = e.textVerticalAlign), Je(e, "textLineHeight") && (n.lineHeight = e.textLineHeight), Je(e, "textWidth") && (n.width = e.textWidth), Je(e, "textHeight") && (n.height = e.textHeight), Je(e, "textBackgroundColor") && (n.backgroundColor = e.textBackgroundColor), Je(e, "textPadding") && (n.padding = e.textPadding), Je(e, "textBorderColor") && (n.borderColor = e.textBorderColor), Je(e, "textBorderWidth") && (n.borderWidth = e.textBorderWidth), Je(e, "textBorderRadius") && (n.borderRadius = e.textBorderRadius), Je(e, "textBoxShadowColor") && (n.shadowColor = e.textBoxShadowColor), Je(e, "textBoxShadowBlur") && (n.shadowBlur = e.textBoxShadowBlur), Je(e, "textBoxShadowOffsetX") && (n.shadowOffsetX = e.textBoxShadowOffsetX), Je(e, "textBoxShadowOffsetY") && (n.shadowOffsetY = e.textBoxShadowOffsetY));
}
function c$(n, e, t) {
  var r = n;
  r.textPosition = r.textPosition || t.position || "inside", t.offset != null && (r.textOffset = t.offset), t.rotation != null && (r.textRotation = t.rotation), t.distance != null && (r.textDistance = t.distance);
  var i = r.textPosition.indexOf("inside") >= 0, a = n.fill || "#000";
  d$(r, e);
  var o = r.textFill == null;
  return i ? o && (r.textFill = t.insideFill || "#fff", !r.textStroke && t.insideStroke && (r.textStroke = t.insideStroke), !r.textStroke && (r.textStroke = a), r.textStrokeWidth == null && (r.textStrokeWidth = 2)) : (o && (r.textFill = n.fill || t.outsideFill || "#000"), !r.textStroke && t.outsideStroke && (r.textStroke = t.outsideStroke)), r.text = e.text, r.rich = e.rich, $(e.rich, function(s) {
    d$(s, s);
  }), r;
}
function d$(n, e) {
  e && (Je(e, "fill") && (n.textFill = e.fill), Je(e, "stroke") && (n.textStroke = e.fill), Je(e, "lineWidth") && (n.textStrokeWidth = e.lineWidth), Je(e, "font") && (n.font = e.font), Je(e, "fontStyle") && (n.fontStyle = e.fontStyle), Je(e, "fontWeight") && (n.fontWeight = e.fontWeight), Je(e, "fontSize") && (n.fontSize = e.fontSize), Je(e, "fontFamily") && (n.fontFamily = e.fontFamily), Je(e, "align") && (n.textAlign = e.align), Je(e, "verticalAlign") && (n.textVerticalAlign = e.verticalAlign), Je(e, "lineHeight") && (n.textLineHeight = e.lineHeight), Je(e, "width") && (n.textWidth = e.width), Je(e, "height") && (n.textHeight = e.height), Je(e, "backgroundColor") && (n.textBackgroundColor = e.backgroundColor), Je(e, "padding") && (n.textPadding = e.padding), Je(e, "borderColor") && (n.textBorderColor = e.borderColor), Je(e, "borderWidth") && (n.textBorderWidth = e.borderWidth), Je(e, "borderRadius") && (n.textBorderRadius = e.borderRadius), Je(e, "shadowColor") && (n.textBoxShadowColor = e.shadowColor), Je(e, "shadowBlur") && (n.textBoxShadowBlur = e.shadowBlur), Je(e, "shadowOffsetX") && (n.textBoxShadowOffsetX = e.shadowOffsetX), Je(e, "shadowOffsetY") && (n.textBoxShadowOffsetY = e.shadowOffsetY), Je(e, "textShadowColor") && (n.textShadowColor = e.textShadowColor), Je(e, "textShadowBlur") && (n.textShadowBlur = e.textShadowBlur), Je(e, "textShadowOffsetX") && (n.textShadowOffsetX = e.textShadowOffsetX), Je(e, "textShadowOffsetY") && (n.textShadowOffsetY = e.textShadowOffsetY));
}
function f$(n, e) {
  if (process.env.NODE_ENV !== "production") {
    var t = n + "^_^" + e;
    l$[t] || (console.warn('[ECharts] DEPRECATED: "' + n + '" has been deprecated. ' + e), l$[t] = !0);
  }
}
var MK = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
}, p$ = Yt(MK), A_ = xs(Ss, function(n, e) {
  return n[e] = 1, n;
}, {}), h$ = Ss.join(", "), M_ = ["", "style", "shape", "extra"], Yp = en();
function eI(n, e, t, r, i) {
  var a = n + "Animation", o = dh(n, r, i) || {}, s = Yp(e).userDuring;
  return o.duration > 0 && (o.during = s ? Ze(_6e, {
    el: e,
    userDuring: s
  }) : null, o.setToFinal = !0, o.scope = n), xe(o, t[a]), o;
}
function I1(n, e, t, r) {
  r = r || {};
  var i = r.dataIndex, a = r.isInit, o = r.clearStyle, s = t.isAnimationEnabled(), l = Yp(n), u = e.style;
  l.userDuring = e.during;
  var c = {}, d = {};
  if (w6e(n, e, d), m$("shape", e, d), m$("extra", e, d), !a && s && (x6e(n, e, c), v$("shape", n, e, c), v$("extra", n, e, c), S6e(n, e, u, c)), d.style = u, m6e(n, d, o), y6e(n, e), s)
    if (a) {
      var f = {};
      $(M_, function(h) {
        var v = h ? e[h] : e;
        v && v.enterFrom && (h && (f[h] = f[h] || {}), xe(h ? f[h] : f, v.enterFrom));
      });
      var p = eI("enter", n, e, t, i);
      p.duration > 0 && n.animateFrom(f, p);
    } else
      g6e(n, e, i || 0, t, c);
  DK(n, e), u ? n.dirty() : n.markRedraw();
}
function DK(n, e) {
  for (var t = Yp(n).leaveToProps, r = 0; r < M_.length; r++) {
    var i = M_[r], a = i ? e[i] : e;
    a && a.leaveTo && (t || (t = Yp(n).leaveToProps = {}), i && (t[i] = t[i] || {}), xe(i ? t[i] : t, a.leaveTo));
  }
}
function Dw(n, e, t, r) {
  if (n) {
    var i = n.parent, a = Yp(n).leaveToProps;
    if (a) {
      var o = eI("update", n, e, t, 0);
      o.done = function() {
        i.remove(n);
      }, n.animateTo(a, o);
    } else
      i.remove(n);
  }
}
function yd(n) {
  return n === "all";
}
function m6e(n, e, t) {
  var r = e.style;
  if (!n.isGroup && r) {
    if (t) {
      n.useStyle({});
      for (var i = n.animators, a = 0; a < i.length; a++) {
        var o = i[a];
        o.targetName === "style" && o.changeTarget(n.style);
      }
    }
    n.setStyle(r);
  }
  e && (e.style = null, e && n.attr(e), e.style = r);
}
function g6e(n, e, t, r, i) {
  if (i) {
    var a = eI("update", n, e, r, t);
    a.duration > 0 && n.animateFrom(i, a);
  }
}
function y6e(n, e) {
  Je(e, "silent") && (n.silent = e.silent), Je(e, "ignore") && (n.ignore = e.ignore), n instanceof no && Je(e, "invisible") && (n.invisible = e.invisible), n instanceof Ht && Je(e, "autoBatch") && (n.autoBatch = e.autoBatch);
}
var Wo = {}, b6e = {
  // Usually other props do not need to be changed in animation during.
  setTransform: function(n, e) {
    return process.env.NODE_ENV !== "production" && ct(Je(A_, n), "Only " + h$ + " available in `setTransform`."), Wo.el[n] = e, this;
  },
  getTransform: function(n) {
    return process.env.NODE_ENV !== "production" && ct(Je(A_, n), "Only " + h$ + " available in `getTransform`."), Wo.el[n];
  },
  setShape: function(n, e) {
    process.env.NODE_ENV !== "production" && Bf(n);
    var t = Wo.el, r = t.shape || (t.shape = {});
    return r[n] = e, t.dirtyShape && t.dirtyShape(), this;
  },
  getShape: function(n) {
    process.env.NODE_ENV !== "production" && Bf(n);
    var e = Wo.el.shape;
    if (e)
      return e[n];
  },
  setStyle: function(n, e) {
    process.env.NODE_ENV !== "production" && Bf(n);
    var t = Wo.el, r = t.style;
    return r && (process.env.NODE_ENV !== "production" && Dd(e) && Jn("style." + n + " must not be assigned with NaN."), r[n] = e, t.dirtyStyle && t.dirtyStyle()), this;
  },
  getStyle: function(n) {
    process.env.NODE_ENV !== "production" && Bf(n);
    var e = Wo.el.style;
    if (e)
      return e[n];
  },
  setExtra: function(n, e) {
    process.env.NODE_ENV !== "production" && Bf(n);
    var t = Wo.el.extra || (Wo.el.extra = {});
    return t[n] = e, this;
  },
  getExtra: function(n) {
    process.env.NODE_ENV !== "production" && Bf(n);
    var e = Wo.el.extra;
    if (e)
      return e[n];
  }
};
function Bf(n) {
  if (process.env.NODE_ENV !== "production" && (n === "transition" || n === "enterFrom" || n === "leaveTo"))
    throw new Error('key must not be "' + n + '"');
}
function _6e() {
  var n = this, e = n.el;
  if (e) {
    var t = Yp(e).userDuring, r = n.userDuring;
    if (t !== r) {
      n.el = n.userDuring = null;
      return;
    }
    Wo.el = e, r(b6e);
  }
}
function v$(n, e, t, r) {
  var i = t[n];
  if (i) {
    var a = e[n], o;
    if (a) {
      var s = t.transition, l = i.transition;
      if (l)
        if (!o && (o = r[n] = {}), yd(l))
          xe(o, a);
        else
          for (var u = wn(l), c = 0; c < u.length; c++) {
            var d = u[c], f = a[d];
            o[d] = f;
          }
      else if (yd(s) || Pt(s, n) >= 0) {
        !o && (o = r[n] = {});
        for (var p = Yt(a), c = 0; c < p.length; c++) {
          var d = p[c], f = a[d];
          E6e(i[d], f) && (o[d] = f);
        }
      }
    }
  }
}
function m$(n, e, t) {
  var r = e[n];
  if (r)
    for (var i = t[n] = {}, a = Yt(r), o = 0; o < a.length; o++) {
      var s = a[o];
      i[s] = lm(r[s]);
    }
}
function x6e(n, e, t) {
  for (var r = e.transition, i = yd(r) ? Ss : wn(r || []), a = 0; a < i.length; a++) {
    var o = i[a];
    if (!(o === "style" || o === "shape" || o === "extra")) {
      var s = n[o];
      process.env.NODE_ENV !== "production" && OK(o, "el.transition"), t[o] = s;
    }
  }
}
function w6e(n, e, t) {
  for (var r = 0; r < p$.length; r++) {
    var i = p$[r], a = MK[i], o = e[i];
    o && (t[a[0]] = o[0], t[a[1]] = o[1]);
  }
  for (var r = 0; r < Ss.length; r++) {
    var s = Ss[r];
    e[s] != null && (t[s] = e[s]);
  }
}
function S6e(n, e, t, r) {
  if (t) {
    var i = n.style, a;
    if (i) {
      var o = t.transition, s = e.transition;
      if (o && !yd(o)) {
        var l = wn(o);
        !a && (a = r.style = {});
        for (var u = 0; u < l.length; u++) {
          var c = l[u], d = i[c];
          a[c] = d;
        }
      } else if (n.getAnimationStyleProps && (yd(s) || yd(o) || Pt(s, "style") >= 0)) {
        var f = n.getAnimationStyleProps(), p = f ? f.style : null;
        if (p) {
          !a && (a = r.style = {});
          for (var h = Yt(t), u = 0; u < h.length; u++) {
            var c = h[u];
            if (p[c]) {
              var d = i[c];
              a[c] = d;
            }
          }
        }
      }
    }
  }
}
function E6e(n, e) {
  return hi(n) ? n !== e : n != null && isFinite(n);
}
var OK;
process.env.NODE_ENV !== "production" && (OK = function(n, e) {
  Je(A_, n) || Jn("Prop `" + n + "` is not a permitted in `" + e + "`. Only `" + Yt(A_).join("`, `") + "` are permitted.");
});
var IK = en(), T6e = ["percent", "easing", "shape", "style", "extra"];
function LK(n) {
  n.stopAnimation("keyframe"), n.attr(IK(n));
}
function D_(n, e, t) {
  if (!(!t.isAnimationEnabled() || !e)) {
    if (Me(e)) {
      $(e, function(s) {
        D_(n, s, t);
      });
      return;
    }
    var r = e.keyframes, i = e.duration;
    if (t && i == null) {
      var a = dh("enter", t, 0);
      i = a && a.duration;
    }
    if (!(!r || !i)) {
      var o = IK(n);
      $(M_, function(s) {
        if (!(s && !n[s])) {
          var l, u = !1;
          r.sort(function(c, d) {
            return c.percent - d.percent;
          }), $(r, function(c) {
            var d = n.animators, f = s ? c[s] : c;
            if (process.env.NODE_ENV !== "production" && c.percent >= 1 && (u = !0), !!f) {
              var p = Yt(f);
              if (s || (p = vn(p, function(m) {
                return Pt(T6e, m) < 0;
              })), !!p.length) {
                l || (l = n.animate(s, e.loop, !0), l.scope = "keyframe");
                for (var h = 0; h < d.length; h++)
                  d[h] !== l && d[h].targetName === l.targetName && d[h].stopTracks(p);
                s && (o[s] = o[s] || {});
                var v = s ? o[s] : o;
                $(p, function(m) {
                  v[m] = ((s ? n[s] : n) || {})[m];
                }), l.whenWithKeys(i * c.percent, f, p, c.easing);
              }
            }
          }), l && (process.env.NODE_ENV !== "production" && (u || Jn("End frame with percent: 1 is missing in the keyframeAnimation.", !0)), l.delay(e.delay || 0).duration(i).start(e.easing));
        }
      });
    }
  }
}
var hl = "emphasis", yu = "normal", tI = "blur", nI = "select", zu = [yu, hl, tI, nI], WE = {
  normal: ["itemStyle"],
  emphasis: [hl, "itemStyle"],
  blur: [tI, "itemStyle"],
  select: [nI, "itemStyle"]
}, qE = {
  normal: ["label"],
  emphasis: [hl, "label"],
  blur: [tI, "label"],
  select: [nI, "label"]
}, C6e = ["x", "y"], k6e = "e\0\0", La = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
}, g$ = {
  cartesian2d: l6e,
  geo: c6e,
  single: f6e,
  polar: h6e,
  calendar: v6e
};
function O_(n) {
  return n instanceof Ht;
}
function lA(n) {
  return n instanceof no;
}
function A6e(n, e) {
  e.copyTransform(n), lA(e) && lA(n) && (e.setStyle(n.style), e.z = n.z, e.z2 = n.z2, e.zlevel = n.zlevel, e.invisible = n.invisible, e.ignore = n.ignore, O_(e) && O_(n) && e.setShape(n.shape));
}
var M6e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      this._progressiveEls = null;
      var o = this._data, s = t.getData(), l = this.group, u = y$(t, s, r, i);
      o || l.removeAll(), s.diff(o).add(function(d) {
        YE(i, null, d, u(d, a), t, l, s);
      }).remove(function(d) {
        var f = o.getItemGraphicEl(d);
        f && Dw(f, pl(f).option, t);
      }).update(function(d, f) {
        var p = o.getItemGraphicEl(f);
        YE(i, p, d, u(d, a), t, l, s);
      }).execute();
      var c = t.get("clip", !0) ? Qg(t.coordinateSystem, !1, t) : null;
      c ? l.setClipPath(c) : l.removeClipPath(), this._data = s;
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      this.group.removeAll(), this._data = null;
    }, e.prototype.incrementalRender = function(t, r, i, a, o) {
      var s = r.getData(), l = y$(r, s, i, a), u = this._progressiveEls = [];
      function c(p) {
        p.isGroup || (p.incremental = !0, p.ensureState("emphasis").hoverLayer = !0);
      }
      for (var d = t.start; d < t.end; d++) {
        var f = YE(null, null, d, l(d, o), r, this.group, s);
        f && (f.traverse(c), u.push(f));
      }
    }, e.prototype.eachRendered = function(t) {
      Yu(this._progressiveEls || this.group, t);
    }, e.prototype.filterForExposedEvent = function(t, r, i, a) {
      var o = r.element;
      if (o == null || i.name === o)
        return !0;
      for (; (i = i.__hostTarget || i.parent) && i !== this.group; )
        if (i.name === o)
          return !0;
      return !1;
    }, e.type = "custom", e;
  }(Tn)
);
function rI(n) {
  var e = n.type, t;
  if (e === "path") {
    var r = n.shape, i = r.width != null && r.height != null ? {
      x: r.x || 0,
      y: r.y || 0,
      width: r.width,
      height: r.height
    } : null, a = PK(r);
    t = ow(a, null, i, r.layout || "center"), pl(t).customPathData = a;
  } else if (e === "image")
    t = new Ur({}), pl(t).customImagePath = n.style.image;
  else if (e === "text")
    t = new nn({});
  else if (e === "group")
    t = new mt();
  else {
    if (e === "compoundPath")
      throw new Error('"compoundPath" is not supported yet.');
    var o = UD(e);
    if (!o) {
      var s = "";
      process.env.NODE_ENV !== "production" && (s = 'graphic type "' + e + '" can not be found.'), hn(s);
    }
    t = new o();
  }
  return pl(t).customGraphicType = e, t.name = n.name, t.z2EmphasisLift = 1, t.z2SelectLift = 1, t;
}
function iI(n, e, t, r, i, a, o) {
  LK(e);
  var s = i && i.normal.cfg;
  s && e.setTextConfig(s), r && r.transition == null && (r.transition = C6e);
  var l = r && r.style;
  if (l) {
    if (e.type === "text") {
      var u = l;
      Je(u, "textFill") && (u.fill = u.textFill), Je(u, "textStroke") && (u.stroke = u.textStroke);
    }
    var c = void 0, d = O_(e) ? l.decal : null;
    n && d && (d.dirty = !0, c = Hp(d, n)), l.__decalPattern = c;
  }
  if (lA(e) && l) {
    var c = l.__decalPattern;
    c && (l.decal = c);
  }
  I1(e, r, a, {
    dataIndex: t,
    isInit: o,
    clearStyle: !0
  }), D_(e, r.keyframeAnimation, a);
}
function NK(n, e, t, r, i) {
  var a = e.isGroup ? null : e, o = i && i[n].cfg;
  if (a) {
    var s = a.ensureState(n);
    if (r === !1) {
      var l = a.getState(n);
      l && (l.style = null);
    } else
      s.style = r || null;
    o && (s.textConfig = o), Nd(a);
  }
}
function D6e(n, e, t) {
  if (!n.isGroup) {
    var r = n, i = t.currentZ, a = t.currentZLevel;
    r.z = i, r.zlevel = a;
    var o = e.z2;
    o != null && (r.z2 = o || 0);
    for (var s = 0; s < zu.length; s++)
      O6e(r, e, zu[s]);
  }
}
function O6e(n, e, t) {
  var r = t === yu, i = r ? e : I_(e, t), a = i ? i.z2 : null, o;
  a != null && (o = r ? n : n.ensureState(t), o.z2 = a || 0);
}
function y$(n, e, t, r) {
  var i = n.get("renderItem"), a = n.coordinateSystem, o = {};
  a && (process.env.NODE_ENV !== "production" && (ct(i, "series.render is required."), ct(a.prepareCustoms || g$[a.type], "This coordSys does not support custom series.")), o = a.prepareCustoms ? a.prepareCustoms(a) : g$[a.type](a));
  for (var s = dt({
    getWidth: r.getWidth,
    getHeight: r.getHeight,
    getZr: r.getZr,
    getDevicePixelRatio: r.getDevicePixelRatio,
    value: _,
    style: w,
    ordinalRawValue: x,
    styleEmphasis: S,
    visual: M,
    barLayout: D,
    currentSeriesIndices: N,
    font: R
  }, o.api || {}), l = {
    // The life cycle of context: current round of rendering.
    // The global life cycle is probably not necessary, because
    // user can store global status by themselves.
    context: {},
    seriesId: n.id,
    seriesName: n.name,
    seriesIndex: n.seriesIndex,
    coordSys: o.coordSys,
    dataInsideLength: e.count(),
    encode: I6e(n.getData())
  }, u, c, d = {}, f = {}, p = {}, h = {}, v = 0; v < zu.length; v++) {
    var m = zu[v];
    p[m] = n.getModel(WE[m]), h[m] = n.getModel(qE[m]);
  }
  function g(j) {
    return j === u ? c || (c = e.getItemModel(j)) : e.getItemModel(j);
  }
  function y(j, z) {
    return e.hasItemOption ? j === u ? d[z] || (d[z] = g(j).getModel(WE[z])) : g(j).getModel(WE[z]) : p[z];
  }
  function b(j, z) {
    return e.hasItemOption ? j === u ? f[z] || (f[z] = g(j).getModel(qE[z])) : g(j).getModel(qE[z]) : h[z];
  }
  return function(j, z) {
    return u = j, c = null, d = {}, f = {}, i && i(dt({
      dataIndexInside: j,
      dataIndex: e.getRawIndex(j),
      // Can be used for optimization when zoom or roam.
      actionType: z ? z.type : null
    }, l), s);
  };
  function _(j, z) {
    return z == null && (z = u), e.getStore().get(e.getDimensionIndex(j || 0), z);
  }
  function x(j, z) {
    z == null && (z = u), j = j || 0;
    var F = e.getDimensionInfo(j);
    if (!F) {
      var B = e.getDimensionIndex(j);
      return B >= 0 ? e.getStore().get(B, z) : void 0;
    }
    var H = e.get(F.name, z), Y = F && F.ordinalMeta;
    return Y ? Y.categories[H] : H;
  }
  function w(j, z) {
    process.env.NODE_ENV !== "production" && f$("api.style", "Please write literal style directly instead."), z == null && (z = u);
    var F = e.getItemVisual(z, "style"), B = F && F.fill, H = F && F.opacity, Y = y(z, yu).getItemStyle();
    B != null && (Y.fill = B), H != null && (Y.opacity = H);
    var ne = {
      inheritColor: We(B) ? B : "#000"
    }, J = b(z, yu), X = Ln(J, null, ne, !1, !0);
    X.text = J.getShallow("show") ? bt(n.getFormattedLabel(z, yu), Up(e, z)) : null;
    var ie = i_(J, ne, !1);
    return k(j, Y), Y = c$(Y, X, ie), j && C(Y, j), Y.legacy = !0, Y;
  }
  function S(j, z) {
    process.env.NODE_ENV !== "production" && f$("api.styleEmphasis", "Please write literal style directly instead."), z == null && (z = u);
    var F = y(z, hl).getItemStyle(), B = b(z, hl), H = Ln(B, null, null, !0, !0);
    H.text = B.getShallow("show") ? Za(n.getFormattedLabel(z, hl), n.getFormattedLabel(z, yu), Up(e, z)) : null;
    var Y = i_(B, null, !0);
    return k(j, F), F = c$(F, H, Y), j && C(F, j), F.legacy = !0, F;
  }
  function C(j, z) {
    for (var F in z)
      Je(z, F) && (j[F] = z[F]);
  }
  function k(j, z) {
    j && (j.textFill && (z.textFill = j.textFill), j.textPosition && (z.textPosition = j.textPosition));
  }
  function M(j, z) {
    if (z == null && (z = u), Je(s$, j)) {
      var F = e.getItemVisual(z, "style");
      return F ? F[s$[j]] : null;
    }
    if (Je(a6e, j))
      return e.getItemVisual(z, j);
  }
  function D(j) {
    if (a.type === "cartesian2d") {
      var z = a.getBaseAxis();
      return w3e(dt({
        axis: z
      }, j));
    }
  }
  function N() {
    return t.getCurrentSeriesIndices();
  }
  function R(j) {
    return WD(j, t);
  }
}
function I6e(n) {
  var e = {};
  return $(n.dimensions, function(t) {
    var r = n.getDimensionInfo(t);
    if (!r.isExtraCoord) {
      var i = r.coordDim, a = e[i] = e[i] || [];
      a[r.coordDimIndex] = n.getDimensionIndex(t);
    }
  }), e;
}
function YE(n, e, t, r, i, a, o) {
  if (!r) {
    a.remove(e);
    return;
  }
  var s = aI(n, e, t, r, i, a);
  return s && o.setItemGraphicEl(t, s), s && er(s, r.focus, r.blurScope, r.emphasisDisabled), s;
}
function aI(n, e, t, r, i, a) {
  process.env.NODE_ENV !== "production" && ct(r, "should not have an null/undefined element setting");
  var o = -1, s = e;
  e && RK(e, r, i) && (o = Pt(a.childrenRef(), e), e = null);
  var l = !e, u = e;
  u ? u.clearStates() : (u = rI(r), s && A6e(s, u)), r.morph === !1 ? u.disableMorphing = !0 : u.disableMorphing && (u.disableMorphing = !1), La.normal.cfg = La.normal.conOpt = La.emphasis.cfg = La.emphasis.conOpt = La.blur.cfg = La.blur.conOpt = La.select.cfg = La.select.conOpt = null, La.isLegacy = !1, N6e(u, t, r, i, l, La), L6e(u, t, r, i, l), iI(n, u, t, r, La, i, l), Je(r, "info") && (pl(u).info = r.info);
  for (var c = 0; c < zu.length; c++) {
    var d = zu[c];
    if (d !== yu) {
      var f = I_(r, d), p = oI(r, f, d);
      NK(d, u, f, p, La);
    }
  }
  return D6e(u, r, i), r.type === "group" && R6e(n, u, t, r, i), o >= 0 ? a.replaceAt(u, o) : a.add(u), u;
}
function RK(n, e, t) {
  var r = pl(n), i = e.type, a = e.shape, o = e.style;
  return (
    // Always create new if universal transition is enabled.
    // Because we do transition after render. It needs to know what old element is. Replacement will loose it.
    t.isUniversalTransitionEnabled() || i != null && i !== r.customGraphicType || i === "path" && $6e(a) && PK(a) !== r.customPathData || i === "image" && Je(o, "image") && o.image !== r.customImagePath
  );
}
function L6e(n, e, t, r, i) {
  var a = t.clipPath;
  if (a === !1)
    n && n.getClipPath() && n.removeClipPath();
  else if (a) {
    var o = n.getClipPath();
    o && RK(o, a, r) && (o = null), o || (o = rI(a), process.env.NODE_ENV !== "production" && ct(O_(o), "Only any type of `path` can be used in `clipPath`, rather than " + o.type + "."), n.setClipPath(o)), iI(null, o, e, a, null, r, i);
  }
}
function N6e(n, e, t, r, i, a) {
  if (!n.isGroup) {
    b$(t, null, a), b$(t, hl, a);
    var o = a.normal.conOpt, s = a.emphasis.conOpt, l = a.blur.conOpt, u = a.select.conOpt;
    if (o != null || s != null || u != null || l != null) {
      var c = n.getTextContent();
      if (o === !1)
        c && n.removeTextContent();
      else {
        o = a.normal.conOpt = o || {
          type: "text"
        }, c ? c.clearStates() : (c = rI(o), n.setTextContent(c)), iI(null, c, e, o, null, r, i);
        for (var d = o && o.style, f = 0; f < zu.length; f++) {
          var p = zu[f];
          if (p !== yu) {
            var h = a[p].conOpt;
            NK(p, c, h, oI(o, h, p), null);
          }
        }
        d ? c.dirty() : c.markRedraw();
      }
    }
  }
}
function b$(n, e, t) {
  var r = e ? I_(n, e) : n, i = e ? oI(n, r, hl) : n.style, a = n.type, o = r ? r.textConfig : null, s = n.textContent, l = s ? e ? I_(s, e) : s : null;
  if (i && // Because emphasis style has little info to detect legacy,
  // if normal is legacy, emphasis is trade as legacy.
  (t.isLegacy || kK(i, a, !!o, !!l))) {
    t.isLegacy = !0;
    var u = AK(i, a, !e);
    !o && u.textConfig && (o = u.textConfig), !l && u.textContent && (l = u.textContent);
  }
  if (!e && l) {
    var c = l;
    !c.type && (c.type = "text"), process.env.NODE_ENV !== "production" && ct(c.type === "text", 'textContent.type must be "text"');
  }
  var d = e ? t[e] : t.normal;
  d.cfg = o, d.conOpt = l;
}
function I_(n, e) {
  return e ? n ? n[e] : null : n;
}
function oI(n, e, t) {
  var r = e && e.style;
  return r == null && t === hl && n && (r = n.styleEmphasis), r;
}
function R6e(n, e, t, r, i) {
  var a = r.children, o = a ? a.length : 0, s = r.$mergeChildren, l = s === "byName" || r.diffChildrenByName, u = s === !1;
  if (!(!o && !l && !u)) {
    if (l) {
      j6e({
        api: n,
        oldChildren: e.children() || [],
        newChildren: a || [],
        dataIndex: t,
        seriesModel: i,
        group: e
      });
      return;
    }
    u && e.removeAll();
    for (var c = 0; c < o; c++) {
      var d = a[c], f = e.childAt(c);
      d ? (d.ignore == null && (d.ignore = !1), aI(n, f, t, d, i, e)) : (process.env.NODE_ENV !== "production" && ct(f, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before."), f.ignore = !0);
    }
    for (var p = e.childCount() - 1; p >= c; p--) {
      var h = e.childAt(p);
      P6e(e, h, i);
    }
  }
}
function P6e(n, e, t) {
  e && Dw(e, pl(n).option, t);
}
function j6e(n) {
  new Sl(n.oldChildren, n.newChildren, _$, _$, n).add(x$).update(x$).remove(B6e).execute();
}
function _$(n, e) {
  var t = n && n.name;
  return t ?? k6e + e;
}
function x$(n, e) {
  var t = this.context, r = n != null ? t.newChildren[n] : null, i = e != null ? t.oldChildren[e] : null;
  aI(t.api, i, t.dataIndex, r, t.seriesModel, t.group);
}
function B6e(n) {
  var e = this.context, t = e.oldChildren[n];
  t && Dw(t, pl(t).option, e.seriesModel);
}
function PK(n) {
  return n && (n.pathData || n.d);
}
function $6e(n) {
  return n && (Je(n, "pathData") || Je(n, "d"));
}
function z6e(n) {
  n.registerChartView(M6e), n.registerSeriesModel(o6e);
}
var Pc = en(), w$ = ht, KE = Ze, sI = (
  /** @class */
  function() {
    function n() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return n.prototype.render = function(e, t, r, i) {
      var a = t.get("value"), o = t.get("status");
      if (this._axisModel = e, this._axisPointerModel = t, this._api = r, !(!i && this._lastValue === a && this._lastStatus === o)) {
        this._lastValue = a, this._lastStatus = o;
        var s = this._group, l = this._handle;
        if (!o || o === "hide") {
          s && s.hide(), l && l.hide();
          return;
        }
        s && s.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, e, t, r);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(r), this._lastGraphicKey = c;
        var d = this._moveAnimation = this.determineAnimation(e, t);
        if (!s)
          s = this._group = new mt(), this.createPointerEl(s, u, e, t), this.createLabelEl(s, u, e, t), r.getZr().add(s);
        else {
          var f = Tt(S$, t, d);
          this.updatePointerEl(s, u, f), this.updateLabelEl(s, u, f, t);
        }
        T$(s, t, !0), this._renderHandle(a);
      }
    }, n.prototype.remove = function(e) {
      this.clear(e);
    }, n.prototype.dispose = function(e) {
      this.clear(e);
    }, n.prototype.determineAnimation = function(e, t) {
      var r = t.get("animation"), i = e.axis, a = i.type === "category", o = t.get("snap");
      if (!o && !a)
        return !1;
      if (r === "auto" || r == null) {
        var s = this.animationThreshold;
        if (a && i.getBandWidth() > s)
          return !0;
        if (o) {
          var l = MO(e).seriesDataCount, u = i.getExtent();
          return Math.abs(u[0] - u[1]) / l > s;
        }
        return !1;
      }
      return r === !0;
    }, n.prototype.makeElOption = function(e, t, r, i, a) {
    }, n.prototype.createPointerEl = function(e, t, r, i) {
      var a = t.pointer;
      if (a) {
        var o = Pc(e).pointerEl = new Qd[a.type](w$(t.pointer));
        e.add(o);
      }
    }, n.prototype.createLabelEl = function(e, t, r, i) {
      if (t.label) {
        var a = Pc(e).labelEl = new nn(w$(t.label));
        e.add(a), E$(a, i);
      }
    }, n.prototype.updatePointerEl = function(e, t, r) {
      var i = Pc(e).pointerEl;
      i && t.pointer && (i.setStyle(t.pointer.style), r(i, {
        shape: t.pointer.shape
      }));
    }, n.prototype.updateLabelEl = function(e, t, r, i) {
      var a = Pc(e).labelEl;
      a && (a.setStyle(t.label.style), r(a, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: t.label.x,
        y: t.label.y
      }), E$(a, i));
    }, n.prototype._renderHandle = function(e) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var t = this._axisPointerModel, r = this._api.getZr(), i = this._handle, a = t.getModel("handle"), o = t.get("status");
        if (!a.get("show") || !o || o === "hide") {
          i && r.remove(i), this._handle = null;
          return;
        }
        var s;
        this._handle || (s = !0, i = this._handle = qg(a.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            bl(u.event);
          },
          onmousedown: KE(this._onHandleDragMove, this, 0, 0),
          drift: KE(this._onHandleDragMove, this),
          ondragend: KE(this._onHandleDragEnd, this)
        }), r.add(i)), T$(i, t, !1), i.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = a.get("size");
        Me(l) || (l = [l, l]), i.scaleX = l[0] / 2, i.scaleY = l[1] / 2, bh(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(e, s);
      }
    }, n.prototype._moveHandleToValue = function(e, t) {
      S$(this._axisPointerModel, !t && this._moveAnimation, this._handle, XE(this.getHandleTransform(e, this._axisModel, this._axisPointerModel)));
    }, n.prototype._onHandleDragMove = function(e, t) {
      var r = this._handle;
      if (r) {
        this._dragging = !0;
        var i = this.updateHandleTransform(XE(r), [e, t], this._axisModel, this._axisPointerModel);
        this._payloadInfo = i, r.stopAnimation(), r.attr(XE(i)), Pc(r).lastProp = null, this._doDispatchAxisPointer();
      }
    }, n.prototype._doDispatchAxisPointer = function() {
      var e = this._handle;
      if (e) {
        var t = this._payloadInfo, r = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: t.cursorPoint[0],
          y: t.cursorPoint[1],
          tooltipOption: t.tooltipOption,
          axesInfo: [{
            axisDim: r.axis.dim,
            axisIndex: r.componentIndex
          }]
        });
      }
    }, n.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var e = this._handle;
      if (e) {
        var t = this._axisPointerModel.get("value");
        this._moveHandleToValue(t), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, n.prototype.clear = function(e) {
      this._lastValue = null, this._lastStatus = null;
      var t = e.getZr(), r = this._group, i = this._handle;
      t && r && (this._lastGraphicKey = null, r && t.remove(r), i && t.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), ag(this, "_doDispatchAxisPointer");
    }, n.prototype.doClear = function() {
    }, n.prototype.buildLabel = function(e, t, r) {
      return r = r || 0, {
        x: e[r],
        y: e[1 - r],
        width: t[r],
        height: t[1 - r]
      };
    }, n;
  }()
);
function S$(n, e, t, r) {
  jK(Pc(t).lastProp, r) || (Pc(t).lastProp = r, e ? ln(t, r, n) : (t.stopAnimation(), t.attr(r)));
}
function jK(n, e) {
  if (ut(n) && ut(e)) {
    var t = !0;
    return $(e, function(r, i) {
      t = t && jK(n[i], r);
    }), !!t;
  } else
    return n === e;
}
function E$(n, e) {
  n[e.get(["label", "show"]) ? "show" : "hide"]();
}
function XE(n) {
  return {
    x: n.x || 0,
    y: n.y || 0,
    rotation: n.rotation || 0
  };
}
function T$(n, e, t) {
  var r = e.get("z"), i = e.get("zlevel");
  n && n.traverse(function(a) {
    a.type !== "group" && (r != null && (a.z = r), i != null && (a.zlevel = i), a.silent = t);
  });
}
function lI(n) {
  var e = n.get("type"), t = n.getModel(e + "Style"), r;
  return e === "line" ? (r = t.getLineStyle(), r.fill = null) : e === "shadow" && (r = t.getAreaStyle(), r.stroke = null), r;
}
function BK(n, e, t, r, i) {
  var a = t.get("value"), o = $K(a, e.axis, e.ecModel, t.get("seriesDataIndices"), {
    precision: t.get(["label", "precision"]),
    formatter: t.get(["label", "formatter"])
  }), s = t.getModel("label"), l = hh(s.get("padding") || 0), u = s.getFont(), c = zg(o, u), d = i.position, f = c.width + l[1] + l[3], p = c.height + l[0] + l[2], h = i.align;
  h === "right" && (d[0] -= f), h === "center" && (d[0] -= f / 2);
  var v = i.verticalAlign;
  v === "bottom" && (d[1] -= p), v === "middle" && (d[1] -= p / 2), F6e(d, f, p, r);
  var m = s.get("backgroundColor");
  (!m || m === "auto") && (m = e.get(["axisLine", "lineStyle", "color"])), n.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: d[0],
    y: d[1],
    style: Ln(s, {
      text: o,
      font: u,
      fill: s.getTextColor(),
      padding: l,
      backgroundColor: m
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function F6e(n, e, t, r) {
  var i = r.getWidth(), a = r.getHeight();
  n[0] = Math.min(n[0] + e, i) - e, n[1] = Math.min(n[1] + t, a) - t, n[0] = Math.max(n[0], 0), n[1] = Math.max(n[1], 0);
}
function $K(n, e, t, r, i) {
  n = e.scale.parse(n);
  var a = e.scale.getLabel({
    value: n
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: i.precision
  }), o = i.formatter;
  if (o) {
    var s = {
      value: yO(e, {
        value: n
      }),
      axisDimension: e.dim,
      axisIndex: e.index,
      seriesData: []
    };
    $(r, function(l) {
      var u = t.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, d = u && u.getDataParams(c);
      d && s.seriesData.push(d);
    }), We(o) ? a = o.replace("{value}", a) : at(o) && (a = o(s));
  }
  return a;
}
function uI(n, e, t) {
  var r = ya();
  return Zd(r, r, t.rotation), ws(r, r, t.position), wo([n.dataToCoord(e), (t.labelOffset || 0) + (t.labelDirection || 1) * (t.labelMargin || 0)], r);
}
function zK(n, e, t, r, i, a) {
  var o = Ii.innerTextLayout(t.rotation, 0, t.labelDirection);
  t.labelMargin = i.get(["label", "margin"]), BK(e, r, i, a, {
    position: uI(r.axis, n, t),
    align: o.textAlign,
    verticalAlign: o.textVerticalAlign
  });
}
function cI(n, e, t) {
  return t = t || 0, {
    x1: n[t],
    y1: n[1 - t],
    x2: e[t],
    y2: e[1 - t]
  };
}
function FK(n, e, t) {
  return t = t || 0, {
    x: n[t],
    y: n[1 - t],
    width: e[t],
    height: e[1 - t]
  };
}
function C$(n, e, t, r, i, a) {
  return {
    cx: n,
    cy: e,
    r0: t,
    r,
    startAngle: i,
    endAngle: a,
    clockwise: !0
  };
}
var V6e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, r, i, a, o) {
      var s = i.axis, l = s.grid, u = a.get("type"), c = k$(l, s).getOtherAxis(s).getGlobalExtent(), d = s.toGlobalCoord(s.dataToCoord(r, !0));
      if (u && u !== "none") {
        var f = lI(a), p = H6e[u](s, d, c);
        p.style = f, t.graphicKey = p.type, t.pointer = p;
      }
      var h = Hk(l.model, i);
      zK(
        // @ts-ignore
        r,
        t,
        h,
        i,
        a,
        o
      );
    }, e.prototype.getHandleTransform = function(t, r, i) {
      var a = Hk(r.axis.grid.model, r, {
        labelInside: !1
      });
      a.labelMargin = i.get(["handle", "margin"]);
      var o = uI(r.axis, t, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(t, r, i, a) {
      var o = i.axis, s = o.grid, l = o.getGlobalExtent(!0), u = k$(s, o).getOtherAxis(o).getGlobalExtent(), c = o.dim === "x" ? 0 : 1, d = [t.x, t.y];
      d[c] += r[c], d[c] = Math.min(l[1], d[c]), d[c] = Math.max(l[0], d[c]);
      var f = (u[1] + u[0]) / 2, p = [f, f];
      p[c] = d[c];
      var h = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: d[0],
        y: d[1],
        rotation: t.rotation,
        cursorPoint: p,
        tooltipOption: h[c]
      };
    }, e;
  }(sI)
);
function k$(n, e) {
  var t = {};
  return t[e.dim + "AxisIndex"] = e.index, n.getCartesian(t);
}
var H6e = {
  line: function(n, e, t) {
    var r = cI([e, t[0]], [e, t[1]], A$(n));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: r
    };
  },
  shadow: function(n, e, t) {
    var r = Math.max(1, n.getBandWidth()), i = t[1] - t[0];
    return {
      type: "Rect",
      shape: FK([e - r / 2, t[0]], [r, i], A$(n))
    };
  }
};
function A$(n) {
  return n.dim === "x" ? 0 : 1;
}
var G6e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "axisPointer", e.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [5, 7, 5, 7],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        // For mobile performance
        throttle: 40
      }
    }, e;
  }(Ut)
), il = en(), U6e = $;
function VK(n, e, t) {
  if (!Vt.node) {
    var r = e.getZr();
    il(r).records || (il(r).records = {}), W6e(r, e);
    var i = il(r).records[n] || (il(r).records[n] = {});
    i.handler = t;
  }
}
function W6e(n, e) {
  if (il(n).initialized)
    return;
  il(n).initialized = !0, t("click", Tt(M$, "click")), t("mousemove", Tt(M$, "mousemove")), t("globalout", Y6e);
  function t(r, i) {
    n.on(r, function(a) {
      var o = K6e(e);
      U6e(il(n).records, function(s) {
        s && i(s, a, o.dispatchAction);
      }), q6e(o.pendings, e);
    });
  }
}
function q6e(n, e) {
  var t = n.showTip.length, r = n.hideTip.length, i;
  t ? i = n.showTip[t - 1] : r && (i = n.hideTip[r - 1]), i && (i.dispatchAction = null, e.dispatchAction(i));
}
function Y6e(n, e, t) {
  n.handler("leave", null, t);
}
function M$(n, e, t, r) {
  e.handler(n, t, r);
}
function K6e(n) {
  var e = {
    showTip: [],
    hideTip: []
  }, t = function(r) {
    var i = e[r.type];
    i ? i.push(r) : (r.dispatchAction = t, n.dispatchAction(r));
  };
  return {
    dispatchAction: t,
    pendings: e
  };
}
function uA(n, e) {
  if (!Vt.node) {
    var t = e.getZr(), r = (il(t).records || {})[n];
    r && (il(t).records[n] = null);
  }
}
var X6e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = r.getComponent("tooltip"), o = t.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      VK("axisPointer", i, function(s, l, u) {
        o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: s,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, e.prototype.remove = function(t, r) {
      uA("axisPointer", r);
    }, e.prototype.dispose = function(t, r) {
      uA("axisPointer", r);
    }, e.type = "axisPointer", e;
  }(Yn)
);
function HK(n, e) {
  var t = [], r = n.seriesIndex, i;
  if (r == null || !(i = e.getSeriesByIndex(r)))
    return {
      point: []
    };
  var a = i.getData(), o = Id(a, n);
  if (o == null || o < 0 || Me(o))
    return {
      point: []
    };
  var s = a.getItemGraphicEl(o), l = i.coordinateSystem;
  if (i.getTooltipPosition)
    t = i.getTooltipPosition(o) || [];
  else if (l && l.dataToPoint)
    if (n.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), d = c.dim, f = u.dim, p = d === "x" || d === "radius" ? 1 : 0, h = a.mapDimension(f), v = [];
      v[p] = a.get(h, o), v[1 - p] = a.get(a.getCalculationInfo("stackResultDimension"), o), t = l.dataToPoint(v) || [];
    } else
      t = l.dataToPoint(a.getValues(De(l.dimensions, function(g) {
        return a.mapDimension(g);
      }), o)) || [];
  else if (s) {
    var m = s.getBoundingRect().clone();
    m.applyTransform(s.transform), t = [m.x + m.width / 2, m.y + m.height / 2];
  }
  return {
    point: t,
    el: s
  };
}
var D$ = en();
function Z6e(n, e, t) {
  var r = n.currTrigger, i = [n.x, n.y], a = n, o = n.dispatchAction || Ze(t.dispatchAction, t), s = e.getComponent("axisPointer").coordSysAxesInfo;
  if (s) {
    L1(i) && (i = HK({
      seriesIndex: a.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: a.dataIndex
    }, e).point);
    var l = L1(i), u = a.axesInfo, c = s.axesInfo, d = r === "leave" || L1(i), f = {}, p = {}, h = {
      list: [],
      map: {}
    }, v = {
      showPointer: Tt(Q6e, p),
      showTooltip: Tt(e8e, h)
    };
    $(s.coordSysMap, function(g, y) {
      var b = l || g.containPoint(i);
      $(s.coordSysAxesInfo[y], function(_, x) {
        var w = _.axis, S = i8e(u, _);
        if (!d && b && (!u || S)) {
          var C = S && S.value;
          C == null && !l && (C = w.pointToData(i)), C != null && O$(_, C, v, !1, f);
        }
      });
    });
    var m = {};
    return $(c, function(g, y) {
      var b = g.linkGroup;
      b && !p[y] && $(b.axesInfo, function(_, x) {
        var w = p[x];
        if (_ !== g && w) {
          var S = w.value;
          b.mapper && (S = g.axis.scale.parse(b.mapper(S, I$(_), I$(g)))), m[g.key] = S;
        }
      });
    }), $(m, function(g, y) {
      O$(c[y], g, v, !0, f);
    }), t8e(p, c, f), n8e(h, i, n, o), r8e(c, o, t), f;
  }
}
function O$(n, e, t, r, i) {
  var a = n.axis;
  if (!(a.scale.isBlank() || !a.containData(e))) {
    if (!n.involveSeries) {
      t.showPointer(n, e);
      return;
    }
    var o = J6e(e, n), s = o.payloadBatch, l = o.snapToValue;
    s[0] && i.seriesIndex == null && xe(i, s[0]), !r && n.snap && a.containData(l) && l != null && (e = l), t.showPointer(n, e, s), t.showTooltip(n, o, l);
  }
}
function J6e(n, e) {
  var t = e.axis, r = t.dim, i = n, a = [], o = Number.MAX_VALUE, s = -1;
  return $(e.seriesModels, function(l, u) {
    var c = l.getData().mapDimensionsAll(r), d, f;
    if (l.getAxisTooltipData) {
      var p = l.getAxisTooltipData(c, n, t);
      f = p.dataIndices, d = p.nestestValue;
    } else {
      if (f = l.getData().indicesOfNearest(
        c[0],
        n,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        t.type === "category" ? 0.5 : null
      ), !f.length)
        return;
      d = l.getData().get(c[0], f[0]);
    }
    if (!(d == null || !isFinite(d))) {
      var h = n - d, v = Math.abs(h);
      v <= o && ((v < o || h >= 0 && s < 0) && (o = v, s = h, i = d, a.length = 0), $(f, function(m) {
        a.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: m,
          dataIndex: l.getData().getRawIndex(m)
        });
      }));
    }
  }), {
    payloadBatch: a,
    snapToValue: i
  };
}
function Q6e(n, e, t, r) {
  n[e.key] = {
    value: t,
    payloadBatch: r
  };
}
function e8e(n, e, t, r) {
  var i = t.payloadBatch, a = e.axis, o = a.model, s = e.axisPointerModel;
  if (!(!e.triggerTooltip || !i.length)) {
    var l = e.coordSys.model, u = fg(l), c = n.map[u];
    c || (c = n.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, n.list.push(c)), c.dataByAxis.push({
      axisDim: a.dim,
      axisIndex: o.componentIndex,
      axisType: o.type,
      axisId: o.id,
      value: r,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: s.get(["label", "precision"]),
        formatter: s.get(["label", "formatter"])
      },
      seriesDataIndices: i.slice()
    });
  }
}
function t8e(n, e, t) {
  var r = t.axesInfo = [];
  $(e, function(i, a) {
    var o = i.axisPointerModel.option, s = n[a];
    s ? (!i.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !i.useHandle && (o.status = "hide"), o.status === "show" && r.push({
      axisDim: i.axis.dim,
      axisIndex: i.axis.model.componentIndex,
      value: o.value
    });
  });
}
function n8e(n, e, t, r) {
  if (L1(e) || !n.list.length) {
    r({
      type: "hideTip"
    });
    return;
  }
  var i = ((n.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  r({
    type: "showTip",
    escapeConnect: !0,
    x: e[0],
    y: e[1],
    tooltipOption: t.tooltipOption,
    position: t.position,
    dataIndexInside: i.dataIndexInside,
    dataIndex: i.dataIndex,
    seriesIndex: i.seriesIndex,
    dataByCoordSys: n.list
  });
}
function r8e(n, e, t) {
  var r = t.getZr(), i = "axisPointerLastHighlights", a = D$(r)[i] || {}, o = D$(r)[i] = {};
  $(n, function(u, c) {
    var d = u.axisPointerModel.option;
    d.status === "show" && u.triggerEmphasis && $(d.seriesDataIndices, function(f) {
      var p = f.seriesIndex + " | " + f.dataIndex;
      o[p] = f;
    });
  });
  var s = [], l = [];
  $(a, function(u, c) {
    !o[c] && l.push(u);
  }), $(o, function(u, c) {
    !a[c] && s.push(u);
  }), l.length && t.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), s.length && t.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: s
  });
}
function i8e(n, e) {
  for (var t = 0; t < (n || []).length; t++) {
    var r = n[t];
    if (e.axis.dim === r.axisDim && e.axis.model.componentIndex === r.axisIndex)
      return r;
  }
}
function I$(n) {
  var e = n.axis.model, t = {}, r = t.axisDim = n.axis.dim;
  return t.axisIndex = t[r + "AxisIndex"] = e.componentIndex, t.axisName = t[r + "AxisName"] = e.name, t.axisId = t[r + "AxisId"] = e.id, t;
}
function L1(n) {
  return !n || n[0] == null || isNaN(n[0]) || n[1] == null || isNaN(n[1]);
}
function ay(n) {
  rf.registerAxisPointerClass("CartesianAxisPointer", V6e), n.registerComponentModel(G6e), n.registerComponentView(X6e), n.registerPreprocessor(function(e) {
    if (e) {
      (!e.axisPointer || e.axisPointer.length === 0) && (e.axisPointer = {});
      var t = e.axisPointer.link;
      t && !Me(t) && (e.axisPointer.link = [t]);
    }
  }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, function(e, t) {
    e.getComponent("axisPointer").coordSysAxesInfo = vBe(e, t);
  }), n.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, Z6e);
}
function a8e(n) {
  $t(mY), $t(ay);
}
var o8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, r, i, a, o) {
      var s = i.axis;
      s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var l = s.polar, u = l.getOtherAxis(s), c = u.getExtent(), d = s.dataToCoord(r), f = a.get("type");
      if (f && f !== "none") {
        var p = lI(a), h = l8e[f](s, l, d, c);
        h.style = p, t.graphicKey = h.type, t.pointer = h;
      }
      var v = a.get(["label", "margin"]), m = s8e(r, i, a, l, v);
      BK(t, i, a, o, m);
    }, e;
  }(sI)
);
function s8e(n, e, t, r, i) {
  var a = e.axis, o = a.dataToCoord(n), s = r.getAngleAxis().getExtent()[0];
  s = s / 180 * Math.PI;
  var l = r.getRadiusAxis().getExtent(), u, c, d;
  if (a.dim === "radius") {
    var f = ya();
    Zd(f, f, s), ws(f, f, [r.cx, r.cy]), u = wo([o, -i], f);
    var p = e.getModel("axisLabel").get("rotate") || 0, h = Ii.innerTextLayout(s, p * Math.PI / 180, -1);
    c = h.textAlign, d = h.textVerticalAlign;
  } else {
    var v = l[1];
    u = r.coordToPoint([v + i, o]);
    var m = r.cx, g = r.cy;
    c = Math.abs(u[0] - m) / v < 0.3 ? "center" : u[0] > m ? "left" : "right", d = Math.abs(u[1] - g) / v < 0.3 ? "middle" : u[1] > g ? "top" : "bottom";
  }
  return {
    position: u,
    align: c,
    verticalAlign: d
  };
}
var l8e = {
  line: function(n, e, t, r) {
    return n.dim === "angle" ? {
      type: "Line",
      shape: cI(e.coordToPoint([r[0], t]), e.coordToPoint([r[1], t]))
    } : {
      type: "Circle",
      shape: {
        cx: e.cx,
        cy: e.cy,
        r: t
      }
    };
  },
  shadow: function(n, e, t, r) {
    var i = Math.max(1, n.getBandWidth()), a = Math.PI / 180;
    return n.dim === "angle" ? {
      type: "Sector",
      shape: C$(
        e.cx,
        e.cy,
        r[0],
        r[1],
        // In ECharts y is negative if angle is positive
        (-t - i / 2) * a,
        (-t + i / 2) * a
      )
    } : {
      type: "Sector",
      shape: C$(e.cx, e.cy, t - i / 2, t + i / 2, 0, Math.PI * 2)
    };
  }
}, u8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.findAxisModel = function(t) {
      var r, i = this.ecModel;
      return i.eachComponent(t, function(a) {
        a.getCoordSysModel() === this && (r = a);
      }, this), r;
    }, e.type = "polar", e.dependencies = ["radiusAxis", "angleAxis"], e.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "80%"
    }, e;
  }(Ut)
), dI = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", gr).models[0];
    }, e.type = "polarAxis", e;
  }(Ut)
);
_r(dI, Xg);
var c8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "angleAxis", e;
  }(dI)
), d8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "radiusAxis", e;
  }(dI)
), fI = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r) {
      return n.call(this, "radius", t, r) || this;
    }
    return e.prototype.pointToData = function(t, r) {
      return this.polar.pointToData(t, r)[this.dim === "radius" ? 0 : 1];
    }, e;
  }(Po)
);
fI.prototype.dataToRadius = Po.prototype.dataToCoord;
fI.prototype.radiusToData = Po.prototype.coordToData;
var f8e = en(), pI = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r) {
      return n.call(this, "angle", t, r || [0, 360]) || this;
    }
    return e.prototype.pointToData = function(t, r) {
      return this.polar.pointToData(t, r)[this.dim === "radius" ? 0 : 1];
    }, e.prototype.calculateCategoryInterval = function() {
      var t = this, r = t.getLabelModel(), i = t.scale, a = i.getExtent(), o = i.count();
      if (a[1] - a[0] < 1)
        return 0;
      var s = a[0], l = t.dataToCoord(s + 1) - t.dataToCoord(s), u = Math.abs(l), c = zg(s == null ? "" : s + "", r.getFont(), "center", "top"), d = Math.max(c.height, 7), f = d / u;
      isNaN(f) && (f = 1 / 0);
      var p = Math.max(0, Math.floor(f)), h = f8e(t.model), v = h.lastAutoInterval, m = h.lastTickCount;
      return v != null && m != null && Math.abs(v - p) <= 1 && Math.abs(m - o) <= 1 && v > p ? p = v : (h.lastTickCount = o, h.lastAutoInterval = p), p;
    }, e;
  }(Po)
);
pI.prototype.dataToAngle = Po.prototype.dataToCoord;
pI.prototype.angleToData = Po.prototype.coordToData;
var GK = ["radius", "angle"], p8e = (
  /** @class */
  function() {
    function n(e) {
      this.dimensions = GK, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new fI(), this._angleAxis = new pI(), this.axisPointerEnabled = !0, this.name = e || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return n.prototype.containPoint = function(e) {
      var t = this.pointToCoord(e);
      return this._radiusAxis.contain(t[0]) && this._angleAxis.contain(t[1]);
    }, n.prototype.containData = function(e) {
      return this._radiusAxis.containData(e[0]) && this._angleAxis.containData(e[1]);
    }, n.prototype.getAxis = function(e) {
      var t = "_" + e + "Axis";
      return this[t];
    }, n.prototype.getAxes = function() {
      return [this._radiusAxis, this._angleAxis];
    }, n.prototype.getAxesByScale = function(e) {
      var t = [], r = this._angleAxis, i = this._radiusAxis;
      return r.scale.type === e && t.push(r), i.scale.type === e && t.push(i), t;
    }, n.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, n.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, n.prototype.getOtherAxis = function(e) {
      var t = this._angleAxis;
      return e === t ? this._radiusAxis : t;
    }, n.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, n.prototype.getTooltipAxes = function(e) {
      var t = e != null && e !== "auto" ? this.getAxis(e) : this.getBaseAxis();
      return {
        baseAxes: [t],
        otherAxes: [this.getOtherAxis(t)]
      };
    }, n.prototype.dataToPoint = function(e, t) {
      return this.coordToPoint([this._radiusAxis.dataToRadius(e[0], t), this._angleAxis.dataToAngle(e[1], t)]);
    }, n.prototype.pointToData = function(e, t) {
      var r = this.pointToCoord(e);
      return [this._radiusAxis.radiusToData(r[0], t), this._angleAxis.angleToData(r[1], t)];
    }, n.prototype.pointToCoord = function(e) {
      var t = e[0] - this.cx, r = e[1] - this.cy, i = this.getAngleAxis(), a = i.getExtent(), o = Math.min(a[0], a[1]), s = Math.max(a[0], a[1]);
      i.inverse ? o = s - 360 : s = o + 360;
      var l = Math.sqrt(t * t + r * r);
      t /= l, r /= l;
      for (var u = Math.atan2(-r, t) / Math.PI * 180, c = u < o ? 1 : -1; u < o || u > s; )
        u += c * 360;
      return [l, u];
    }, n.prototype.coordToPoint = function(e) {
      var t = e[0], r = e[1] / 180 * Math.PI, i = Math.cos(r) * t + this.cx, a = -Math.sin(r) * t + this.cy;
      return [i, a];
    }, n.prototype.getArea = function() {
      var e = this.getAngleAxis(), t = this.getRadiusAxis(), r = t.getExtent().slice();
      r[0] > r[1] && r.reverse();
      var i = e.getExtent(), a = Math.PI / 180, o = 1e-4;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: r[0],
        r: r[1],
        startAngle: -i[0] * a,
        endAngle: -i[1] * a,
        clockwise: e.inverse,
        contain: function(s, l) {
          var u = s - this.cx, c = l - this.cy, d = u * u + c * c, f = this.r, p = this.r0;
          return f !== p && d - o <= f * f && d + o >= p * p;
        }
      };
    }, n.prototype.convertToPixel = function(e, t, r) {
      var i = L$(t);
      return i === this ? this.dataToPoint(r) : null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      var i = L$(t);
      return i === this ? this.pointToData(r) : null;
    }, n;
  }()
);
function L$(n) {
  var e = n.seriesModel, t = n.polarModel;
  return t && t.coordinateSystem || e && e.coordinateSystem;
}
function h8e(n, e, t) {
  var r = e.get("center"), i = t.getWidth(), a = t.getHeight();
  n.cx = ze(r[0], i), n.cy = ze(r[1], a);
  var o = n.getRadiusAxis(), s = Math.min(i, a) / 2, l = e.get("radius");
  l == null ? l = [0, "100%"] : Me(l) || (l = [0, l]);
  var u = [ze(l[0], s), ze(l[1], s)];
  o.inverse ? o.setExtent(u[1], u[0]) : o.setExtent(u[0], u[1]);
}
function v8e(n, e) {
  var t = this, r = t.getAngleAxis(), i = t.getRadiusAxis();
  if (r.scale.setExtent(1 / 0, -1 / 0), i.scale.setExtent(1 / 0, -1 / 0), n.eachSeries(function(s) {
    if (s.coordinateSystem === t) {
      var l = s.getData();
      $(g_(l, "radius"), function(u) {
        i.scale.unionExtentFromData(l, u);
      }), $(g_(l, "angle"), function(u) {
        r.scale.unionExtentFromData(l, u);
      });
    }
  }), Gp(r.scale, r.model), Gp(i.scale, i.model), r.type === "category" && !r.onBand) {
    var a = r.getExtent(), o = 360 / r.scale.count();
    r.inverse ? a[1] += o : a[1] -= o, r.setExtent(a[0], a[1]);
  }
}
function m8e(n) {
  return n.mainType === "angleAxis";
}
function N$(n, e) {
  var t;
  if (n.type = e.get("type"), n.scale = Sw(e), n.onBand = e.get("boundaryGap") && n.type === "category", n.inverse = e.get("inverse"), m8e(e)) {
    n.inverse = n.inverse !== e.get("clockwise");
    var r = e.get("startAngle"), i = (t = e.get("endAngle")) !== null && t !== void 0 ? t : r + (n.inverse ? -360 : 360);
    n.setExtent(r, i);
  }
  e.axis = n, n.model = e;
}
var g8e = {
  dimensions: GK,
  create: function(n, e) {
    var t = [];
    return n.eachComponent("polar", function(r, i) {
      var a = new p8e(i + "");
      a.update = v8e;
      var o = a.getRadiusAxis(), s = a.getAngleAxis(), l = r.findAxisModel("radiusAxis"), u = r.findAxisModel("angleAxis");
      N$(o, l), N$(s, u), h8e(a, r, e), t.push(a), r.coordinateSystem = a, a.model = r;
    }), n.eachSeries(function(r) {
      if (r.get("coordinateSystem") === "polar") {
        var i = r.getReferringComponents("polar", gr).models[0];
        if (process.env.NODE_ENV !== "production" && !i)
          throw new Error('Polar "' + mr(r.get("polarIndex"), r.get("polarId"), 0) + '" not found');
        r.coordinateSystem = i.coordinateSystem;
      }
    }), t;
  }
}, y8e = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
function W0(n, e, t) {
  e[1] > e[0] && (e = e.slice().reverse());
  var r = n.coordToPoint([e[0], t]), i = n.coordToPoint([e[1], t]);
  return {
    x1: r[0],
    y1: r[1],
    x2: i[0],
    y2: i[1]
  };
}
function q0(n) {
  var e = n.getRadiusAxis();
  return e.inverse ? 0 : 1;
}
function R$(n) {
  var e = n[0], t = n[n.length - 1];
  e && t && Math.abs(Math.abs(e.coord - t.coord) - 360) < 1e-4 && n.pop();
}
var b8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t;
    }
    return e.prototype.render = function(t, r) {
      if (this.group.removeAll(), !!t.get("show")) {
        var i = t.axis, a = i.polar, o = a.getRadiusAxis().getExtent(), s = i.getTicksCoords(), l = i.getMinorTicksCoords(), u = De(i.getViewLabels(), function(c) {
          c = ht(c);
          var d = i.scale, f = d.type === "ordinal" ? d.getRawOrdinalNumber(c.tickValue) : c.tickValue;
          return c.coord = i.dataToCoord(f), c;
        });
        R$(u), R$(s), $(y8e, function(c) {
          t.get([c, "show"]) && (!i.scale.isBlank() || c === "axisLine") && _8e[c](this.group, t, a, s, l, o, u);
        }, this);
      }
    }, e.type = "angleAxis", e;
  }(rf)
), _8e = {
  axisLine: function(n, e, t, r, i, a) {
    var o = e.getModel(["axisLine", "lineStyle"]), s = t.getAngleAxis(), l = Math.PI / 180, u = s.getExtent(), c = q0(t), d = c ? 0 : 1, f, p = Math.abs(u[1] - u[0]) === 360 ? "Circle" : "Arc";
    a[d] === 0 ? f = new Qd[p]({
      shape: {
        cx: t.cx,
        cy: t.cy,
        r: a[c],
        startAngle: -u[0] * l,
        endAngle: -u[1] * l,
        clockwise: s.inverse
      },
      style: o.getLineStyle(),
      z2: 1,
      silent: !0
    }) : f = new Hg({
      shape: {
        cx: t.cx,
        cy: t.cy,
        r: a[c],
        r0: a[d]
      },
      style: o.getLineStyle(),
      z2: 1,
      silent: !0
    }), f.style.fill = null, n.add(f);
  },
  axisTick: function(n, e, t, r, i, a) {
    var o = e.getModel("axisTick"), s = (o.get("inside") ? -1 : 1) * o.get("length"), l = a[q0(t)], u = De(r, function(c) {
      return new Dr({
        shape: W0(t, [l, l + s], c.coord)
      });
    });
    n.add(Wa(u, {
      style: dt(o.getModel("lineStyle").getLineStyle(), {
        stroke: e.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick: function(n, e, t, r, i, a) {
    if (i.length) {
      for (var o = e.getModel("axisTick"), s = e.getModel("minorTick"), l = (o.get("inside") ? -1 : 1) * s.get("length"), u = a[q0(t)], c = [], d = 0; d < i.length; d++)
        for (var f = 0; f < i[d].length; f++)
          c.push(new Dr({
            shape: W0(t, [u, u + l], i[d][f].coord)
          }));
      n.add(Wa(c, {
        style: dt(s.getModel("lineStyle").getLineStyle(), dt(o.getLineStyle(), {
          stroke: e.get(["axisLine", "lineStyle", "color"])
        }))
      }));
    }
  },
  axisLabel: function(n, e, t, r, i, a, o) {
    var s = e.getCategories(!0), l = e.getModel("axisLabel"), u = l.get("margin"), c = e.get("triggerEvent");
    $(o, function(d, f) {
      var p = l, h = d.tickValue, v = a[q0(t)], m = t.coordToPoint([v + u, d.coord]), g = t.cx, y = t.cy, b = Math.abs(m[0] - g) / v < 0.3 ? "center" : m[0] > g ? "left" : "right", _ = Math.abs(m[1] - y) / v < 0.3 ? "middle" : m[1] > y ? "top" : "bottom";
      if (s && s[h]) {
        var x = s[h];
        ut(x) && x.textStyle && (p = new yn(x.textStyle, l, l.ecModel));
      }
      var w = new nn({
        silent: Ii.isLabelSilent(e),
        style: Ln(p, {
          x: m[0],
          y: m[1],
          fill: p.getTextColor() || e.get(["axisLine", "lineStyle", "color"]),
          text: d.formattedLabel,
          align: b,
          verticalAlign: _
        })
      });
      if (n.add(w), c) {
        var S = Ii.makeAxisEventDataBase(e);
        S.targetType = "axisLabel", S.value = d.rawLabel, yt(w).eventData = S;
      }
    }, this);
  },
  splitLine: function(n, e, t, r, i, a) {
    var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0;
    l = l instanceof Array ? l : [l];
    for (var c = [], d = 0; d < r.length; d++) {
      var f = u++ % l.length;
      c[f] = c[f] || [], c[f].push(new Dr({
        shape: W0(t, a, r[d].coord)
      }));
    }
    for (var d = 0; d < c.length; d++)
      n.add(Wa(c[d], {
        style: dt({
          stroke: l[d % l.length]
        }, s.getLineStyle()),
        silent: !0,
        z: e.get("z")
      }));
  },
  minorSplitLine: function(n, e, t, r, i, a) {
    if (i.length) {
      for (var o = e.getModel("minorSplitLine"), s = o.getModel("lineStyle"), l = [], u = 0; u < i.length; u++)
        for (var c = 0; c < i[u].length; c++)
          l.push(new Dr({
            shape: W0(t, a, i[u][c].coord)
          }));
      n.add(Wa(l, {
        style: s.getLineStyle(),
        silent: !0,
        z: e.get("z")
      }));
    }
  },
  splitArea: function(n, e, t, r, i, a) {
    if (r.length) {
      var o = e.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], d = Math.PI / 180, f = -r[0].coord * d, p = Math.min(a[0], a[1]), h = Math.max(a[0], a[1]), v = e.get("clockwise"), m = 1, g = r.length; m <= g; m++) {
        var y = m === g ? r[0].coord : r[m].coord, b = u++ % l.length;
        c[b] = c[b] || [], c[b].push(new Fi({
          shape: {
            cx: t.cx,
            cy: t.cy,
            r0: p,
            r: h,
            startAngle: f,
            endAngle: -y * d,
            clockwise: v
          },
          silent: !0
        })), f = -y * d;
      }
      for (var m = 0; m < c.length; m++)
        n.add(Wa(c[m], {
          style: dt({
            fill: l[m % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
}, x8e = ["axisLine", "axisTickLabel", "axisName"], w8e = ["splitLine", "splitArea", "minorSplitLine"], S8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t;
    }
    return e.prototype.render = function(t, r) {
      if (this.group.removeAll(), !!t.get("show")) {
        var i = this._axisGroup, a = this._axisGroup = new mt();
        this.group.add(a);
        var o = t.axis, s = o.polar, l = s.getAngleAxis(), u = o.getTicksCoords(), c = o.getMinorTicksCoords(), d = l.getExtent()[0], f = o.getExtent(), p = T8e(s, t, d), h = new Ii(t, p);
        $(x8e, h.add, h), a.add(h.getGroup()), Wg(i, a, t), $(w8e, function(v) {
          t.get([v, "show"]) && !o.scale.isBlank() && E8e[v](this.group, t, s, d, f, u, c);
        }, this);
      }
    }, e.type = "radiusAxis", e;
  }(rf)
), E8e = {
  splitLine: function(n, e, t, r, i, a) {
    var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0, c = t.getAngleAxis(), d = Math.PI / 180, f = c.getExtent(), p = Math.abs(f[1] - f[0]) === 360 ? "Circle" : "Arc";
    l = l instanceof Array ? l : [l];
    for (var h = [], v = 0; v < a.length; v++) {
      var m = u++ % l.length;
      h[m] = h[m] || [], h[m].push(new Qd[p]({
        shape: {
          cx: t.cx,
          cy: t.cy,
          // ensure circle radius >= 0
          r: Math.max(a[v].coord, 0),
          startAngle: -f[0] * d,
          endAngle: -f[1] * d,
          clockwise: c.inverse
        }
      }));
    }
    for (var v = 0; v < h.length; v++)
      n.add(Wa(h[v], {
        style: dt({
          stroke: l[v % l.length],
          fill: null
        }, s.getLineStyle()),
        silent: !0
      }));
  },
  minorSplitLine: function(n, e, t, r, i, a, o) {
    if (o.length) {
      for (var s = e.getModel("minorSplitLine"), l = s.getModel("lineStyle"), u = [], c = 0; c < o.length; c++)
        for (var d = 0; d < o[c].length; d++)
          u.push(new Ml({
            shape: {
              cx: t.cx,
              cy: t.cy,
              r: o[c][d].coord
            }
          }));
      n.add(Wa(u, {
        style: dt({
          fill: null
        }, l.getLineStyle()),
        silent: !0
      }));
    }
  },
  splitArea: function(n, e, t, r, i, a) {
    if (a.length) {
      var o = e.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], d = a[0].coord, f = 1; f < a.length; f++) {
        var p = u++ % l.length;
        c[p] = c[p] || [], c[p].push(new Fi({
          shape: {
            cx: t.cx,
            cy: t.cy,
            r0: d,
            r: a[f].coord,
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: !0
        })), d = a[f].coord;
      }
      for (var f = 0; f < c.length; f++)
        n.add(Wa(c[f], {
          style: dt({
            fill: l[f % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
function T8e(n, e, t) {
  return {
    position: [n.cx, n.cy],
    rotation: t / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: e.getModel("axisLabel").get("rotate"),
    // Over splitLine and splitArea
    z2: 1
  };
}
function UK(n) {
  return n.get("stack") || "__ec_stack_" + n.seriesIndex;
}
function WK(n, e) {
  return e.dim + n.model.componentIndex;
}
function C8e(n, e, t) {
  var r = {}, i = k8e(vn(e.getSeriesByType(n), function(a) {
    return !e.isSeriesFiltered(a) && a.coordinateSystem && a.coordinateSystem.type === "polar";
  }));
  e.eachSeriesByType(n, function(a) {
    if (a.coordinateSystem.type === "polar") {
      var o = a.getData(), s = a.coordinateSystem, l = s.getBaseAxis(), u = WK(s, l), c = UK(a), d = i[u][c], f = d.offset, p = d.width, h = s.getOtherAxis(l), v = a.coordinateSystem.cx, m = a.coordinateSystem.cy, g = a.get("barMinHeight") || 0, y = a.get("barMinAngle") || 0;
      r[c] = r[c] || [];
      for (var b = o.mapDimension(h.dim), _ = o.mapDimension(l.dim), x = Bu(
        o,
        b
        /* , baseDim */
      ), w = l.dim !== "radius" || !a.get("roundCap", !0), S = h.model, C = S.get("startValue"), k = h.dataToCoord(C || 0), M = 0, D = o.count(); M < D; M++) {
        var N = o.get(b, M), R = o.get(_, M), j = N >= 0 ? "p" : "n", z = k;
        x && (r[c][R] || (r[c][R] = {
          p: k,
          n: k
          // Negative stack
        }), z = r[c][R][j]);
        var F = void 0, B = void 0, H = void 0, Y = void 0;
        if (h.dim === "radius") {
          var ne = h.dataToCoord(N) - k, J = l.dataToCoord(R);
          Math.abs(ne) < g && (ne = (ne < 0 ? -1 : 1) * g), F = z, B = z + ne, H = J - f, Y = H - p, x && (r[c][R][j] = B);
        } else {
          var X = h.dataToCoord(N, w) - k, ie = l.dataToCoord(R);
          Math.abs(X) < y && (X = (X < 0 ? -1 : 1) * y), F = ie + f, B = F + p, H = z, Y = z + X, x && (r[c][R][j] = Y);
        }
        o.setItemLayout(M, {
          cx: v,
          cy: m,
          r0: F,
          r: B,
          // Consider that positive angle is anti-clockwise,
          // while positive radian of sector is clockwise
          startAngle: -H * Math.PI / 180,
          endAngle: -Y * Math.PI / 180,
          /**
           * Keep the same logic with bar in catesion: use end value to
           * control direction. Notice that if clockwise is true (by
           * default), the sector will always draw clockwisely, no matter
           * whether endAngle is greater or less than startAngle.
           */
          clockwise: H >= Y
        });
      }
    }
  });
}
function k8e(n) {
  var e = {};
  $(n, function(r, i) {
    var a = r.getData(), o = r.coordinateSystem, s = o.getBaseAxis(), l = WK(o, s), u = s.getExtent(), c = s.type === "category" ? s.getBandWidth() : Math.abs(u[1] - u[0]) / a.count(), d = e[l] || {
      bandWidth: c,
      remainedWidth: c,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    }, f = d.stacks;
    e[l] = d;
    var p = UK(r);
    f[p] || d.autoWidthCount++, f[p] = f[p] || {
      width: 0,
      maxWidth: 0
    };
    var h = ze(r.get("barWidth"), c), v = ze(r.get("barMaxWidth"), c), m = r.get("barGap"), g = r.get("barCategoryGap");
    h && !f[p].width && (h = Math.min(d.remainedWidth, h), f[p].width = h, d.remainedWidth -= h), v && (f[p].maxWidth = v), m != null && (d.gap = m), g != null && (d.categoryGap = g);
  });
  var t = {};
  return $(e, function(r, i) {
    t[i] = {};
    var a = r.stacks, o = r.bandWidth, s = ze(r.categoryGap, o), l = ze(r.gap, 1), u = r.remainedWidth, c = r.autoWidthCount, d = (u - s) / (c + (c - 1) * l);
    d = Math.max(d, 0), $(a, function(v, m) {
      var g = v.maxWidth;
      g && g < d && (g = Math.min(g, u), v.width && (g = Math.min(g, v.width)), u -= g, v.width = g, c--);
    }), d = (u - s) / (c + (c - 1) * l), d = Math.max(d, 0);
    var f = 0, p;
    $(a, function(v, m) {
      v.width || (v.width = d), p = v, f += v.width * (1 + l);
    }), p && (f -= p.width * l);
    var h = -f / 2;
    $(a, function(v, m) {
      t[i][m] = t[i][m] || {
        offset: h,
        width: v.width
      }, h += v.width * (1 + l);
    });
  }), t;
}
var A8e = {
  startAngle: 90,
  clockwise: !0,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
}, M8e = {
  splitNumber: 5
}, D8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "polar", e;
  }(Yn)
);
function O8e(n) {
  $t(ay), rf.registerAxisPointerClass("PolarAxisPointer", o8e), n.registerCoordinateSystem("polar", g8e), n.registerComponentModel(u8e), n.registerComponentView(D8e), Wp(n, "angle", c8e, A8e), Wp(n, "radius", d8e, M8e), n.registerComponentView(b8e), n.registerComponentView(S8e), n.registerLayout(Tt(C8e, "bar"));
}
function cA(n, e) {
  e = e || {};
  var t = n.coordinateSystem, r = n.axis, i = {}, a = r.position, o = r.orient, s = t.getRect(), l = [s.x, s.x + s.width, s.y, s.y + s.height], u = {
    horizontal: {
      top: l[2],
      bottom: l[3]
    },
    vertical: {
      left: l[0],
      right: l[1]
    }
  };
  i.position = [o === "vertical" ? u.vertical[a] : l[0], o === "horizontal" ? u.horizontal[a] : l[3]];
  var c = {
    horizontal: 0,
    vertical: 1
  };
  i.rotation = Math.PI / 2 * c[o];
  var d = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1
  };
  i.labelDirection = i.tickDirection = i.nameDirection = d[a], n.get(["axisTick", "inside"]) && (i.tickDirection = -i.tickDirection), mr(e.labelInside, n.get(["axisLabel", "inside"])) && (i.labelDirection = -i.labelDirection);
  var f = e.rotate;
  return f == null && (f = n.get(["axisLabel", "rotate"])), i.labelRotation = a === "top" ? -f : f, i.z2 = 1, i;
}
var I8e = ["axisLine", "axisTickLabel", "axisName"], L8e = ["splitArea", "splitLine"], N8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "SingleAxisPointer", t;
    }
    return e.prototype.render = function(t, r, i, a) {
      var o = this.group;
      o.removeAll();
      var s = this._axisGroup;
      this._axisGroup = new mt();
      var l = cA(t), u = new Ii(t, l);
      $(I8e, u.add, u), o.add(this._axisGroup), o.add(u.getGroup()), $(L8e, function(c) {
        t.get([c, "show"]) && R8e[c](this, this.group, this._axisGroup, t);
      }, this), Wg(s, this._axisGroup, t), n.prototype.render.call(this, t, r, i, a);
    }, e.prototype.remove = function() {
      pY(this);
    }, e.type = "singleAxis", e;
  }(rf)
), R8e = {
  splitLine: function(n, e, t, r) {
    var i = r.axis;
    if (!i.scale.isBlank()) {
      var a = r.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color");
      s = s instanceof Array ? s : [s];
      for (var l = o.get("width"), u = r.coordinateSystem.getRect(), c = i.isHorizontal(), d = [], f = 0, p = i.getTicksCoords({
        tickModel: a
      }), h = [], v = [], m = 0; m < p.length; ++m) {
        var g = i.toGlobalCoord(p[m].coord);
        c ? (h[0] = g, h[1] = u.y, v[0] = g, v[1] = u.y + u.height) : (h[0] = u.x, h[1] = g, v[0] = u.x + u.width, v[1] = g);
        var y = new Dr({
          shape: {
            x1: h[0],
            y1: h[1],
            x2: v[0],
            y2: v[1]
          },
          silent: !0
        });
        Fp(y.shape, l);
        var b = f++ % s.length;
        d[b] = d[b] || [], d[b].push(y);
      }
      for (var _ = o.getLineStyle(["color"]), m = 0; m < d.length; ++m)
        e.add(Wa(d[m], {
          style: dt({
            stroke: s[m % s.length]
          }, _),
          silent: !0
        }));
    }
  },
  splitArea: function(n, e, t, r) {
    fY(n, t, r, r);
  }
}, N1 = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getCoordSysModel = function() {
      return this;
    }, e.type = "singleAxis", e.layoutMode = "box", e.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: !0,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      // Single coordinate system and single axis is the,
      // which is used as the parent tooltip model.
      // same model, so we set default tooltip show as true.
      tooltip: {
        show: !0
      },
      axisTick: {
        show: !0,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: !0,
        interval: "auto"
      },
      splitLine: {
        show: !0,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    }, e;
  }(Ut)
);
_r(N1, Xg.prototype);
var P8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i, a, o) {
      var s = n.call(this, t, r, i) || this;
      return s.type = a || "value", s.position = o || "bottom", s;
    }
    return e.prototype.isHorizontal = function() {
      var t = this.position;
      return t === "top" || t === "bottom";
    }, e.prototype.pointToData = function(t, r) {
      return this.coordinateSystem.pointToData(t)[0];
    }, e;
  }(Po)
), qK = ["single"], j8e = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.type = "single", this.dimension = "single", this.dimensions = qK, this.axisPointerEnabled = !0, this.model = e, this._init(e, t, r);
    }
    return n.prototype._init = function(e, t, r) {
      var i = this.dimension, a = new P8e(i, Sw(e), [0, 0], e.get("type"), e.get("position")), o = a.type === "category";
      a.onBand = o && e.get("boundaryGap"), a.inverse = e.get("inverse"), a.orient = e.get("orient"), e.axis = a, a.model = e, a.coordinateSystem = this, this._axis = a;
    }, n.prototype.update = function(e, t) {
      e.eachSeries(function(r) {
        if (r.coordinateSystem === this) {
          var i = r.getData();
          $(i.mapDimensionsAll(this.dimension), function(a) {
            this._axis.scale.unionExtentFromData(i, a);
          }, this), Gp(this._axis.scale, this._axis.model);
        }
      }, this);
    }, n.prototype.resize = function(e, t) {
      this._rect = Er({
        left: e.get("left"),
        top: e.get("top"),
        right: e.get("right"),
        bottom: e.get("bottom"),
        width: e.get("width"),
        height: e.get("height")
      }, {
        width: t.getWidth(),
        height: t.getHeight()
      }), this._adjustAxis();
    }, n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype._adjustAxis = function() {
      var e = this._rect, t = this._axis, r = t.isHorizontal(), i = r ? [0, e.width] : [0, e.height], a = t.inverse ? 1 : 0;
      t.setExtent(i[a], i[1 - a]), this._updateAxisTransform(t, r ? e.x : e.y);
    }, n.prototype._updateAxisTransform = function(e, t) {
      var r = e.getExtent(), i = r[0] + r[1], a = e.isHorizontal();
      e.toGlobalCoord = a ? function(o) {
        return o + t;
      } : function(o) {
        return i - o + t;
      }, e.toLocalCoord = a ? function(o) {
        return o - t;
      } : function(o) {
        return i - o + t;
      };
    }, n.prototype.getAxis = function() {
      return this._axis;
    }, n.prototype.getBaseAxis = function() {
      return this._axis;
    }, n.prototype.getAxes = function() {
      return [this._axis];
    }, n.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [this.getAxis()],
        // Empty otherAxes
        otherAxes: []
      };
    }, n.prototype.containPoint = function(e) {
      var t = this.getRect(), r = this.getAxis(), i = r.orient;
      return i === "horizontal" ? r.contain(r.toLocalCoord(e[0])) && e[1] >= t.y && e[1] <= t.y + t.height : r.contain(r.toLocalCoord(e[1])) && e[0] >= t.y && e[0] <= t.y + t.height;
    }, n.prototype.pointToData = function(e) {
      var t = this.getAxis();
      return [t.coordToData(t.toLocalCoord(e[t.orient === "horizontal" ? 0 : 1]))];
    }, n.prototype.dataToPoint = function(e) {
      var t = this.getAxis(), r = this.getRect(), i = [], a = t.orient === "horizontal" ? 0 : 1;
      return e instanceof Array && (e = e[0]), i[a] = t.toGlobalCoord(t.dataToCoord(+e)), i[1 - a] = a === 0 ? r.y + r.height / 2 : r.x + r.width / 2, i;
    }, n.prototype.convertToPixel = function(e, t, r) {
      var i = P$(t);
      return i === this ? this.dataToPoint(r) : null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      var i = P$(t);
      return i === this ? this.pointToData(r) : null;
    }, n;
  }()
);
function P$(n) {
  var e = n.seriesModel, t = n.singleAxisModel;
  return t && t.coordinateSystem || e && e.coordinateSystem;
}
function B8e(n, e) {
  var t = [];
  return n.eachComponent("singleAxis", function(r, i) {
    var a = new j8e(r, n, e);
    a.name = "single_" + i, a.resize(r, e), r.coordinateSystem = a, t.push(a);
  }), n.eachSeries(function(r) {
    if (r.get("coordinateSystem") === "singleAxis") {
      var i = r.getReferringComponents("singleAxis", gr).models[0];
      r.coordinateSystem = i && i.coordinateSystem;
    }
  }), t;
}
var $8e = {
  create: B8e,
  dimensions: qK
}, j$ = ["x", "y"], z8e = ["width", "height"], F8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, r, i, a, o) {
      var s = i.axis, l = s.coordinateSystem, u = ZE(l, 1 - L_(s)), c = l.dataToPoint(r)[0], d = a.get("type");
      if (d && d !== "none") {
        var f = lI(a), p = V8e[d](s, c, u);
        p.style = f, t.graphicKey = p.type, t.pointer = p;
      }
      var h = cA(i);
      zK(
        // @ts-ignore
        r,
        t,
        h,
        i,
        a,
        o
      );
    }, e.prototype.getHandleTransform = function(t, r, i) {
      var a = cA(r, {
        labelInside: !1
      });
      a.labelMargin = i.get(["handle", "margin"]);
      var o = uI(r.axis, t, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(t, r, i, a) {
      var o = i.axis, s = o.coordinateSystem, l = L_(o), u = ZE(s, l), c = [t.x, t.y];
      c[l] += r[l], c[l] = Math.min(u[1], c[l]), c[l] = Math.max(u[0], c[l]);
      var d = ZE(s, 1 - l), f = (d[1] + d[0]) / 2, p = [f, f];
      return p[l] = c[l], {
        x: c[0],
        y: c[1],
        rotation: t.rotation,
        cursorPoint: p,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, e;
  }(sI)
), V8e = {
  line: function(n, e, t) {
    var r = cI([e, t[0]], [e, t[1]], L_(n));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: r
    };
  },
  shadow: function(n, e, t) {
    var r = n.getBandWidth(), i = t[1] - t[0];
    return {
      type: "Rect",
      shape: FK([e - r / 2, t[0]], [r, i], L_(n))
    };
  }
};
function L_(n) {
  return n.isHorizontal() ? 0 : 1;
}
function ZE(n, e) {
  var t = n.getRect();
  return [t[j$[e]], t[j$[e]] + t[z8e[e]]];
}
var H8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "single", e;
  }(Yn)
);
function G8e(n) {
  $t(ay), rf.registerAxisPointerClass("SingleAxisPointer", F8e), n.registerComponentView(H8e), n.registerComponentView(N8e), n.registerComponentModel(N1), Wp(n, "single", N1, N1.defaultOption), n.registerCoordinateSystem("single", $8e);
}
var U8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r, i) {
      var a = vh(t);
      n.prototype.init.apply(this, arguments), B$(t, a);
    }, e.prototype.mergeOption = function(t) {
      n.prototype.mergeOption.apply(this, arguments), B$(this.option, t);
    }, e.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, e.type = "calendar", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      // horizontal vertical
      orient: "horizontal",
      // month separate line style
      splitLine: {
        show: !0,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      // rect style  temporarily unused emphasis
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      // week text style
      dayLabel: {
        show: !0,
        firstDay: 0,
        // start end
        position: "start",
        margin: "50%",
        color: "#000"
      },
      // month text style
      monthLabel: {
        show: !0,
        // start end
        position: "start",
        margin: 5,
        // center or left
        align: "center",
        formatter: null,
        color: "#000"
      },
      // year text style
      yearLabel: {
        show: !0,
        // top bottom left right
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, e;
  }(Ut)
);
function B$(n, e) {
  var t = n.cellSize, r;
  Me(t) ? r = t : r = n.cellSize = [t, t], r.length === 1 && (r[1] = r[0]);
  var i = De([0, 1], function(a) {
    return uNe(e, a) && (r[a] = "auto"), r[a] != null && r[a] !== "auto";
  });
  ju(n, e, {
    type: "box",
    ignoreSize: i
  });
}
var W8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = this.group;
      a.removeAll();
      var o = t.coordinateSystem, s = o.getRangeInfo(), l = o.getOrient(), u = r.getLocaleModel();
      this._renderDayRect(t, s, a), this._renderLines(t, s, l, a), this._renderYearText(t, s, l, a), this._renderMonthText(t, u, l, a), this._renderWeekText(t, u, s, l, a);
    }, e.prototype._renderDayRect = function(t, r, i) {
      for (var a = t.coordinateSystem, o = t.getModel("itemStyle").getItemStyle(), s = a.getCellWidth(), l = a.getCellHeight(), u = r.start.time; u <= r.end.time; u = a.getNextNDay(u, 1).time) {
        var c = a.dataToRect([u], !1).tl, d = new Qt({
          shape: {
            x: c[0],
            y: c[1],
            width: s,
            height: l
          },
          cursor: "default",
          style: o
        });
        i.add(d);
      }
    }, e.prototype._renderLines = function(t, r, i, a) {
      var o = this, s = t.coordinateSystem, l = t.getModel(["splitLine", "lineStyle"]).getLineStyle(), u = t.get(["splitLine", "show"]), c = l.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var d = r.start, f = 0; d.time <= r.end.time; f++) {
        h(d.formatedDate), f === 0 && (d = s.getDateInfo(r.start.y + "-" + r.start.m));
        var p = d.date;
        p.setMonth(p.getMonth() + 1), d = s.getDateInfo(p);
      }
      h(s.getNextNDay(r.end.time, 1).formatedDate);
      function h(v) {
        o._firstDayOfMonth.push(s.getDateInfo(v)), o._firstDayPoints.push(s.dataToRect([v], !1).tl);
        var m = o._getLinePointsOfOneWeek(t, v, i);
        o._tlpoints.push(m[0]), o._blpoints.push(m[m.length - 1]), u && o._drawSplitline(m, l, a);
      }
      u && this._drawSplitline(o._getEdgesPoints(o._tlpoints, c, i), l, a), u && this._drawSplitline(o._getEdgesPoints(o._blpoints, c, i), l, a);
    }, e.prototype._getEdgesPoints = function(t, r, i) {
      var a = [t[0].slice(), t[t.length - 1].slice()], o = i === "horizontal" ? 0 : 1;
      return a[0][o] = a[0][o] - r / 2, a[1][o] = a[1][o] + r / 2, a;
    }, e.prototype._drawSplitline = function(t, r, i) {
      var a = new Hi({
        z2: 20,
        shape: {
          points: t
        },
        style: r
      });
      i.add(a);
    }, e.prototype._getLinePointsOfOneWeek = function(t, r, i) {
      for (var a = t.coordinateSystem, o = a.getDateInfo(r), s = [], l = 0; l < 7; l++) {
        var u = a.getNextNDay(o.time, l), c = a.dataToRect([u.time], !1);
        s[2 * u.day] = c.tl, s[2 * u.day + 1] = c[i === "horizontal" ? "bl" : "tr"];
      }
      return s;
    }, e.prototype._formatterLabel = function(t, r) {
      return We(t) && t ? oNe(t, r) : at(t) ? t(r) : r.nameMap;
    }, e.prototype._yearTextPositionControl = function(t, r, i, a, o) {
      var s = r[0], l = r[1], u = ["center", "bottom"];
      a === "bottom" ? (l += o, u = ["center", "top"]) : a === "left" ? s -= o : a === "right" ? (s += o, u = ["center", "top"]) : l -= o;
      var c = 0;
      return (a === "left" || a === "right") && (c = Math.PI / 2), {
        rotation: c,
        x: s,
        y: l,
        style: {
          align: u[0],
          verticalAlign: u[1]
        }
      };
    }, e.prototype._renderYearText = function(t, r, i, a) {
      var o = t.getModel("yearLabel");
      if (o.get("show")) {
        var s = o.get("margin"), l = o.get("position");
        l || (l = i !== "horizontal" ? "top" : "left");
        var u = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], c = (u[0][0] + u[1][0]) / 2, d = (u[0][1] + u[1][1]) / 2, f = i === "horizontal" ? 0 : 1, p = {
          top: [c, u[f][1]],
          bottom: [c, u[1 - f][1]],
          left: [u[1 - f][0], d],
          right: [u[f][0], d]
        }, h = r.start.y;
        +r.end.y > +r.start.y && (h = h + "-" + r.end.y);
        var v = o.get("formatter"), m = {
          start: r.start.y,
          end: r.end.y,
          nameMap: h
        }, g = this._formatterLabel(v, m), y = new nn({
          z2: 30,
          style: Ln(o, {
            text: g
          }),
          silent: o.get("silent")
        });
        y.attr(this._yearTextPositionControl(y, p[l], i, l, s)), a.add(y);
      }
    }, e.prototype._monthTextPositionControl = function(t, r, i, a, o) {
      var s = "left", l = "top", u = t[0], c = t[1];
      return i === "horizontal" ? (c = c + o, r && (s = "center"), a === "start" && (l = "bottom")) : (u = u + o, r && (l = "middle"), a === "start" && (s = "right")), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, e.prototype._renderMonthText = function(t, r, i, a) {
      var o = t.getModel("monthLabel");
      if (o.get("show")) {
        var s = o.get("nameMap"), l = o.get("margin"), u = o.get("position"), c = o.get("align"), d = [this._tlpoints, this._blpoints];
        (!s || We(s)) && (s && (r = yk(s) || r), s = r.get(["time", "monthAbbr"]) || []);
        var f = u === "start" ? 0 : 1, p = i === "horizontal" ? 0 : 1;
        l = u === "start" ? -l : l;
        for (var h = c === "center", v = o.get("silent"), m = 0; m < d[f].length - 1; m++) {
          var g = d[f][m].slice(), y = this._firstDayOfMonth[m];
          if (h) {
            var b = this._firstDayPoints[m];
            g[p] = (b[p] + d[0][m + 1][p]) / 2;
          }
          var _ = o.get("formatter"), x = s[+y.m - 1], w = {
            yyyy: y.y,
            yy: (y.y + "").slice(2),
            MM: y.m,
            M: +y.m,
            nameMap: x
          }, S = this._formatterLabel(_, w), C = new nn({
            z2: 30,
            style: xe(Ln(o, {
              text: S
            }), this._monthTextPositionControl(g, h, i, u, l)),
            silent: v
          });
          a.add(C);
        }
      }
    }, e.prototype._weekTextPositionControl = function(t, r, i, a, o) {
      var s = "center", l = "middle", u = t[0], c = t[1], d = i === "start";
      return r === "horizontal" ? (u = u + a + (d ? 1 : -1) * o[0] / 2, s = d ? "right" : "left") : (c = c + a + (d ? 1 : -1) * o[1] / 2, l = d ? "bottom" : "top"), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, e.prototype._renderWeekText = function(t, r, i, a, o) {
      var s = t.getModel("dayLabel");
      if (s.get("show")) {
        var l = t.coordinateSystem, u = s.get("position"), c = s.get("nameMap"), d = s.get("margin"), f = l.getFirstDayOfWeek();
        if (!c || We(c)) {
          c && (r = yk(c) || r);
          var p = r.get(["time", "dayOfWeekShort"]);
          c = p || De(r.get(["time", "dayOfWeekAbbr"]), function(w) {
            return w[0];
          });
        }
        var h = l.getNextNDay(i.end.time, 7 - i.lweek).time, v = [l.getCellWidth(), l.getCellHeight()];
        d = ze(d, Math.min(v[1], v[0])), u === "start" && (h = l.getNextNDay(i.start.time, -(7 + i.fweek)).time, d = -d);
        for (var m = s.get("silent"), g = 0; g < 7; g++) {
          var y = l.getNextNDay(h, g), b = l.dataToRect([y.time], !1).center, _ = g;
          _ = Math.abs((g + f) % 7);
          var x = new nn({
            z2: 30,
            style: xe(Ln(s, {
              text: c[_]
            }), this._weekTextPositionControl(b, a, u, d, v)),
            silent: m
          });
          o.add(x);
        }
      }
    }, e.type = "calendar", e;
  }(Yn)
), JE = 864e5, q8e = (
  /** @class */
  function() {
    function n(e, t, r) {
      this.type = "calendar", this.dimensions = n.dimensions, this.getDimensionsInfo = n.getDimensionsInfo, this._model = e;
    }
    return n.getDimensionsInfo = function() {
      return [{
        name: "time",
        type: "time"
      }, "value"];
    }, n.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, n.prototype.getModel = function() {
      return this._model;
    }, n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype.getCellWidth = function() {
      return this._sw;
    }, n.prototype.getCellHeight = function() {
      return this._sh;
    }, n.prototype.getOrient = function() {
      return this._orient;
    }, n.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, n.prototype.getDateInfo = function(e) {
      e = Es(e);
      var t = e.getFullYear(), r = e.getMonth() + 1, i = r < 10 ? "0" + r : "" + r, a = e.getDate(), o = a < 10 ? "0" + a : "" + a, s = e.getDay();
      return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), {
        y: t + "",
        m: i,
        d: o,
        day: s,
        time: e.getTime(),
        formatedDate: t + "-" + i + "-" + o,
        date: e
      };
    }, n.prototype.getNextNDay = function(e, t) {
      return t = t || 0, t === 0 ? this.getDateInfo(e) : (e = new Date(this.getDateInfo(e).time), e.setDate(e.getDate() + t), this.getDateInfo(e));
    }, n.prototype.update = function(e, t) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var r = this._rangeInfo.weeks || 1, i = ["width", "height"], a = this._model.getCellSize().slice(), o = this._model.getBoxLayoutParams(), s = this._orient === "horizontal" ? [r, 7] : [7, r];
      $([0, 1], function(d) {
        c(a, d) && (o[i[d]] = a[d] * s[d]);
      });
      var l = {
        width: t.getWidth(),
        height: t.getHeight()
      }, u = this._rect = Er(o, l);
      $([0, 1], function(d) {
        c(a, d) || (a[d] = u[i[d]] / s[d]);
      });
      function c(d, f) {
        return d[f] != null && d[f] !== "auto";
      }
      this._sw = a[0], this._sh = a[1];
    }, n.prototype.dataToPoint = function(e, t) {
      Me(e) && (e = e[0]), t == null && (t = !0);
      var r = this.getDateInfo(e), i = this._rangeInfo, a = r.formatedDate;
      if (t && !(r.time >= i.start.time && r.time < i.end.time + JE))
        return [NaN, NaN];
      var o = r.day, s = this._getRangeInfo([i.start.time, a]).nthWeek;
      return this._orient === "vertical" ? [this._rect.x + o * this._sw + this._sw / 2, this._rect.y + s * this._sh + this._sh / 2] : [this._rect.x + s * this._sw + this._sw / 2, this._rect.y + o * this._sh + this._sh / 2];
    }, n.prototype.pointToData = function(e) {
      var t = this.pointToDate(e);
      return t && t.time;
    }, n.prototype.dataToRect = function(e, t) {
      var r = this.dataToPoint(e, t);
      return {
        contentShape: {
          x: r[0] - (this._sw - this._lineWidth) / 2,
          y: r[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: r,
        tl: [r[0] - this._sw / 2, r[1] - this._sh / 2],
        tr: [r[0] + this._sw / 2, r[1] - this._sh / 2],
        br: [r[0] + this._sw / 2, r[1] + this._sh / 2],
        bl: [r[0] - this._sw / 2, r[1] + this._sh / 2]
      };
    }, n.prototype.pointToDate = function(e) {
      var t = Math.floor((e[0] - this._rect.x) / this._sw) + 1, r = Math.floor((e[1] - this._rect.y) / this._sh) + 1, i = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(r, t - 1, i) : this._getDateByWeeksAndDay(t, r - 1, i);
    }, n.prototype.convertToPixel = function(e, t, r) {
      var i = $$(t);
      return i === this ? i.dataToPoint(r) : null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      var i = $$(t);
      return i === this ? i.pointToData(r) : null;
    }, n.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), !1;
    }, n.prototype._initRangeOption = function() {
      var e = this._model.get("range"), t;
      if (Me(e) && e.length === 1 && (e = e[0]), Me(e))
        t = e;
      else {
        var r = e.toString();
        if (/^\d{4}$/.test(r) && (t = [r + "-01-01", r + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(r)) {
          var i = this.getDateInfo(r), a = i.date;
          a.setMonth(a.getMonth() + 1);
          var o = this.getNextNDay(a, -1);
          t = [i.formatedDate, o.formatedDate];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(r) && (t = [r, r]);
      }
      if (!t)
        return process.env.NODE_ENV !== "production" && _o("Invalid date range."), e;
      var s = this._getRangeInfo(t);
      return s.start.time > s.end.time && t.reverse(), t;
    }, n.prototype._getRangeInfo = function(e) {
      var t = [this.getDateInfo(e[0]), this.getDateInfo(e[1])], r;
      t[0].time > t[1].time && (r = !0, t.reverse());
      var i = Math.floor(t[1].time / JE) - Math.floor(t[0].time / JE) + 1, a = new Date(t[0].time), o = a.getDate(), s = t[1].date.getDate();
      a.setDate(o + i - 1);
      var l = a.getDate();
      if (l !== s)
        for (var u = a.getTime() - t[1].time > 0 ? 1 : -1; (l = a.getDate()) !== s && (a.getTime() - t[1].time) * u > 0; )
          i -= u, a.setDate(l - u);
      var c = Math.floor((i + t[0].day + 6) / 7), d = r ? -c + 1 : c - 1;
      return r && t.reverse(), {
        range: [t[0].formatedDate, t[1].formatedDate],
        start: t[0],
        end: t[1],
        allDay: i,
        weeks: c,
        // From 0.
        nthWeek: d,
        fweek: t[0].day,
        lweek: t[1].day
      };
    }, n.prototype._getDateByWeeksAndDay = function(e, t, r) {
      var i = this._getRangeInfo(r);
      if (e > i.weeks || e === 0 && t < i.fweek || e === i.weeks && t > i.lweek)
        return null;
      var a = (e - 1) * 7 - i.fweek + t, o = new Date(i.start.time);
      return o.setDate(+i.start.d + a), this.getDateInfo(o);
    }, n.create = function(e, t) {
      var r = [];
      return e.eachComponent("calendar", function(i) {
        var a = new n(i);
        r.push(a), i.coordinateSystem = a;
      }), e.eachSeries(function(i) {
        i.get("coordinateSystem") === "calendar" && (i.coordinateSystem = r[i.get("calendarIndex") || 0]);
      }), r;
    }, n.dimensions = ["time", "value"], n;
  }()
);
function $$(n) {
  var e = n.calendarModel, t = n.seriesModel, r = e ? e.coordinateSystem : t ? t.coordinateSystem : null;
  return r;
}
function Y8e(n) {
  n.registerComponentModel(U8e), n.registerComponentView(W8e), n.registerCoordinateSystem("calendar", q8e);
}
function K8e(n, e) {
  var t = n.existing;
  if (e.id = n.keyInfo.id, !e.type && t && (e.type = t.type), e.parentId == null) {
    var r = e.parentOption;
    r ? e.parentId = r.id : t && (e.parentId = t.parentId);
  }
  e.parentOption = null;
}
function z$(n, e) {
  var t;
  return $(e, function(r) {
    n[r] != null && n[r] !== "auto" && (t = !0);
  }), t;
}
function X8e(n, e, t) {
  var r = xe({}, t), i = n[e], a = t.$action || "merge";
  if (a === "merge")
    if (i) {
      if (process.env.NODE_ENV !== "production") {
        var o = t.type;
        ct(!o || i.type === o, 'Please set $action: "replace" to change `type`');
      }
      At(i, r, !0), ju(i, r, {
        ignoreSize: !0
      }), zU(t, i), Y0(t, i), Y0(t, i, "shape"), Y0(t, i, "style"), Y0(t, i, "extra"), t.clipPath = i.clipPath;
    } else
      n[e] = r;
  else a === "replace" ? n[e] = r : a === "remove" && i && (n[e] = null);
}
var YK = ["transition", "enterFrom", "leaveTo"], Z8e = YK.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function Y0(n, e, t) {
  if (t && (!n[t] && e[t] && (n[t] = {}), n = n[t], e = e[t]), !(!n || !e))
    for (var r = t ? YK : Z8e, i = 0; i < r.length; i++) {
      var a = r[i];
      n[a] == null && e[a] != null && (n[a] = e[a]);
    }
}
function J8e(n, e) {
  if (n && (n.hv = e.hv = [
    // Rigid body, don't care about `width`.
    z$(e, ["left", "right"]),
    // Rigid body, don't care about `height`.
    z$(e, ["top", "bottom"])
  ], n.type === "group")) {
    var t = n, r = e;
    t.width == null && (t.width = r.width = 0), t.height == null && (t.height = r.height = 0);
  }
}
var Q8e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.preventAutoZ = !0, t;
    }
    return e.prototype.mergeOption = function(t, r) {
      var i = this.option.elements;
      this.option.elements = null, n.prototype.mergeOption.call(this, t, r), this.option.elements = i;
    }, e.prototype.optionUpdated = function(t, r) {
      var i = this.option, a = (r ? i : t).elements, o = i.elements = r ? [] : i.elements, s = [];
      this._flatten(a, s, null);
      var l = PG(o, s, "normalMerge"), u = this._elOptionsToUpdate = [];
      $(l, function(c, d) {
        var f = c.newOption;
        process.env.NODE_ENV !== "production" && ct(ut(f) || c.existing, "Empty graphic option definition"), f && (u.push(f), K8e(c, f), X8e(o, d, f), J8e(o[d], f));
      }, this), i.elements = vn(o, function(c) {
        return c && delete c.$action, c != null;
      });
    }, e.prototype._flatten = function(t, r, i) {
      $(t, function(a) {
        if (a) {
          i && (a.parentOption = i), r.push(a);
          var o = a.children;
          o && o.length && this._flatten(o, r, a), delete a.children;
        }
      }, this);
    }, e.prototype.useElOptionsToUpdate = function() {
      var t = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, t;
    }, e.type = "graphic", e.defaultOption = {
      elements: []
      // parentId: null
    }, e;
  }(Ut)
), F$ = {
  // Reserved but not supported in graphic component.
  path: null,
  compoundPath: null,
  // Supported in graphic component.
  group: mt,
  image: Ur,
  text: nn
}, $a = en(), eHe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this._elMap = tt();
    }, e.prototype.render = function(t, r, i) {
      t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, i);
    }, e.prototype._updateElements = function(t) {
      var r = t.useElOptionsToUpdate();
      if (r) {
        var i = this._elMap, a = this.group, o = t.get("z"), s = t.get("zlevel");
        $(r, function(l) {
          var u = wr(l.id, null), c = u != null ? i.get(u) : null, d = wr(l.parentId, null), f = d != null ? i.get(d) : a, p = l.type, h = l.style;
          p === "text" && h && l.hv && l.hv[1] && (h.textVerticalAlign = h.textBaseline = h.verticalAlign = h.align = null);
          var v = l.textContent, m = l.textConfig;
          if (h && kK(h, p, !!m, !!v)) {
            var g = AK(h, p, !0);
            !m && g.textConfig && (m = l.textConfig = g.textConfig), !v && g.textContent && (v = g.textContent);
          }
          var y = tHe(l);
          process.env.NODE_ENV !== "production" && c && ct(f === c.parent, "Changing parent is not supported.");
          var b = l.$action || "merge", _ = b === "merge", x = b === "replace";
          if (_) {
            var w = !c, S = c;
            w ? S = V$(u, f, l.type, i) : (S && ($a(S).isNew = !1), LK(S)), S && (I1(S, y, t, {
              isInit: w
            }), H$(S, l, o, s));
          } else if (x) {
            R1(c, l, i, t);
            var C = V$(u, f, l.type, i);
            C && (I1(C, y, t, {
              isInit: !0
            }), H$(C, l, o, s));
          } else b === "remove" && (DK(c, l), R1(c, l, i, t));
          var k = i.get(u);
          if (k && v)
            if (_) {
              var M = k.getTextContent();
              M ? M.attr(v) : k.setTextContent(new nn(v));
            } else x && k.setTextContent(new nn(v));
          if (k) {
            var D = l.clipPath;
            if (D) {
              var N = D.type, R = void 0, w = !1;
              if (_) {
                var j = k.getClipPath();
                w = !j || $a(j).type !== N, R = w ? dA(N) : j;
              } else x && (w = !0, R = dA(N));
              k.setClipPath(R), I1(R, D, t, {
                isInit: w
              }), D_(R, D.keyframeAnimation, t);
            }
            var z = $a(k);
            k.setTextConfig(m), z.option = l, nHe(k, t, l), Jd({
              el: k,
              componentModel: t,
              itemName: k.name,
              itemTooltipOption: l.tooltip
            }), D_(k, l.keyframeAnimation, t);
          }
        });
      }
    }, e.prototype._relocate = function(t, r) {
      for (var i = t.option.elements, a = this.group, o = this._elMap, s = r.getWidth(), l = r.getHeight(), u = ["x", "y"], c = 0; c < i.length; c++) {
        var d = i[c], f = wr(d.id, null), p = f != null ? o.get(f) : null;
        if (!(!p || !p.isGroup)) {
          var h = p.parent, v = h === a, m = $a(p), g = $a(h);
          m.width = ze(m.option.width, v ? s : g.width) || 0, m.height = ze(m.option.height, v ? l : g.height) || 0;
        }
      }
      for (var c = i.length - 1; c >= 0; c--) {
        var d = i[c], f = wr(d.id, null), p = f != null ? o.get(f) : null;
        if (p) {
          var h = p.parent, g = $a(h), y = h === a ? {
            width: s,
            height: l
          } : {
            width: g.width,
            height: g.height
          }, b = {}, _ = hw(p, d, y, null, {
            hv: d.hv,
            boundingMode: d.bounding
          }, b);
          if (!$a(p).isNew && _) {
            for (var x = d.transition, w = {}, S = 0; S < u.length; S++) {
              var C = u[S], k = b[C];
              x && (yd(x) || Pt(x, C) >= 0) ? w[C] = k : p[C] = k;
            }
            ln(p, w, t, 0);
          } else
            p.attr(b);
        }
      }
    }, e.prototype._clear = function() {
      var t = this, r = this._elMap;
      r.each(function(i) {
        R1(i, $a(i).option, r, t._lastGraphicModel);
      }), this._elMap = tt();
    }, e.prototype.dispose = function() {
      this._clear();
    }, e.type = "graphic", e;
  }(Yn)
);
function dA(n) {
  process.env.NODE_ENV !== "production" && ct(n, "graphic type MUST be set");
  var e = Je(F$, n) ? F$[n] : UD(n);
  process.env.NODE_ENV !== "production" && ct(e, "graphic type " + n + " can not be found");
  var t = new e({});
  return $a(t).type = n, t;
}
function V$(n, e, t, r) {
  var i = dA(t);
  return e.add(i), r.set(n, i), $a(i).id = n, $a(i).isNew = !0, i;
}
function R1(n, e, t, r) {
  var i = n && n.parent;
  i && (n.type === "group" && n.traverse(function(a) {
    R1(a, e, t, r);
  }), Dw(n, e, r), t.removeKey($a(n).id));
}
function H$(n, e, t, r) {
  n.isGroup || $([
    ["cursor", no.prototype.cursor],
    // We should not support configure z and zlevel in the element level.
    // But seems we didn't limit it previously. So here still use it to avoid breaking.
    ["zlevel", r || 0],
    ["z", t || 0],
    // z2 must not be null/undefined, otherwise sort error may occur.
    ["z2", 0]
  ], function(i) {
    var a = i[0];
    Je(e, a) ? n[a] = bt(e[a], i[1]) : n[a] == null && (n[a] = i[1]);
  }), $(Yt(e), function(i) {
    if (i.indexOf("on") === 0) {
      var a = e[i];
      n[i] = at(a) ? a : null;
    }
  }), Je(e, "draggable") && (n.draggable = e.draggable), e.name != null && (n.name = e.name), e.id != null && (n.id = e.id);
}
function tHe(n) {
  return n = xe({}, n), $(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat($U), function(e) {
    delete n[e];
  }), n;
}
function nHe(n, e, t) {
  var r = yt(n).eventData;
  !n.silent && !n.ignore && !r && (r = yt(n).eventData = {
    componentType: "graphic",
    componentIndex: e.componentIndex,
    name: n.name
  }), r && (r.info = t.info);
}
function rHe(n) {
  n.registerComponentModel(Q8e), n.registerComponentView(eHe), n.registerPreprocessor(function(e) {
    var t = e.graphic;
    Me(t) ? !t[0] || !t[0].elements ? e.graphic = [{
      elements: t
    }] : e.graphic = [e.graphic[0]] : t && !t.elements && (e.graphic = [{
      elements: [t]
    }]);
  });
}
var G$ = ["x", "y", "radius", "angle", "single"], iHe = ["cartesian2d", "polar", "singleAxis"];
function aHe(n) {
  var e = n.get("coordinateSystem");
  return Pt(iHe, e) >= 0;
}
function bu(n) {
  return process.env.NODE_ENV !== "production" && ct(n), n + "Axis";
}
function oHe(n, e) {
  var t = tt(), r = [], i = tt();
  n.eachComponent({
    mainType: "dataZoom",
    query: e
  }, function(c) {
    i.get(c.uid) || s(c);
  });
  var a;
  do
    a = !1, n.eachComponent("dataZoom", o);
  while (a);
  function o(c) {
    !i.get(c.uid) && l(c) && (s(c), a = !0);
  }
  function s(c) {
    i.set(c.uid, !0), r.push(c), u(c);
  }
  function l(c) {
    var d = !1;
    return c.eachTargetAxis(function(f, p) {
      var h = t.get(f);
      h && h[p] && (d = !0);
    }), d;
  }
  function u(c) {
    c.eachTargetAxis(function(d, f) {
      (t.get(d) || t.set(d, []))[f] = !0;
    });
  }
  return r;
}
function KK(n) {
  var e = n.ecModel, t = {
    infoList: [],
    infoMap: tt()
  };
  return n.eachTargetAxis(function(r, i) {
    var a = e.getComponent(bu(r), i);
    if (a) {
      var o = a.getCoordSysModel();
      if (o) {
        var s = o.uid, l = t.infoMap.get(s);
        l || (l = {
          model: o,
          axisModels: []
        }, t.infoList.push(l), t.infoMap.set(s, l)), l.axisModels.push(a);
      }
    }
  }), t;
}
var QE = (
  /** @class */
  function() {
    function n() {
      this.indexList = [], this.indexMap = [];
    }
    return n.prototype.add = function(e) {
      this.indexMap[e] || (this.indexList.push(e), this.indexMap[e] = !0);
    }, n;
  }()
), yg = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._autoThrottle = !0, t._noTarget = !0, t._rangePropMode = ["percent", "percent"], t;
    }
    return e.prototype.init = function(t, r, i) {
      var a = U$(t);
      this.settledOption = a, this.mergeDefaultAndTheme(t, i), this._doInit(a);
    }, e.prototype.mergeOption = function(t) {
      var r = U$(t);
      At(this.option, t, !0), At(this.settledOption, r, !0), this._doInit(r);
    }, e.prototype._doInit = function(t) {
      var r = this.option;
      this._setDefaultThrottle(t), this._updateRangeUse(t);
      var i = this.settledOption;
      $([["start", "startValue"], ["end", "endValue"]], function(a, o) {
        this._rangePropMode[o] === "value" && (r[a[0]] = i[a[0]] = null);
      }, this), this._resetTarget();
    }, e.prototype._resetTarget = function() {
      var t = this.get("orient", !0), r = this._targetAxisInfoMap = tt(), i = this._fillSpecifiedTargetAxis(r);
      i ? this._orient = t || this._makeAutoOrientByTargetAxis() : (this._orient = t || "horizontal", this._fillAutoTargetAxisByOrient(r, this._orient)), this._noTarget = !0, r.each(function(a) {
        a.indexList.length && (this._noTarget = !1);
      }, this);
    }, e.prototype._fillSpecifiedTargetAxis = function(t) {
      var r = !1;
      return $(G$, function(i) {
        var a = this.getReferringComponents(bu(i), KOe);
        if (a.specified) {
          r = !0;
          var o = new QE();
          $(a.models, function(s) {
            o.add(s.componentIndex);
          }), t.set(i, o);
        }
      }, this), r;
    }, e.prototype._fillAutoTargetAxisByOrient = function(t, r) {
      var i = this.ecModel, a = !0;
      if (a) {
        var o = r === "vertical" ? "y" : "x", s = i.findComponents({
          mainType: o + "Axis"
        });
        l(s, o);
      }
      if (a) {
        var s = i.findComponents({
          mainType: "singleAxis",
          filter: function(c) {
            return c.get("orient", !0) === r;
          }
        });
        l(s, "single");
      }
      function l(u, c) {
        var d = u[0];
        if (d) {
          var f = new QE();
          if (f.add(d.componentIndex), t.set(c, f), a = !1, c === "x" || c === "y") {
            var p = d.getReferringComponents("grid", gr).models[0];
            p && $(u, function(h) {
              d.componentIndex !== h.componentIndex && p === h.getReferringComponents("grid", gr).models[0] && f.add(h.componentIndex);
            });
          }
        }
      }
      a && $(G$, function(u) {
        if (a) {
          var c = i.findComponents({
            mainType: bu(u),
            filter: function(f) {
              return f.get("type", !0) === "category";
            }
          });
          if (c[0]) {
            var d = new QE();
            d.add(c[0].componentIndex), t.set(u, d), a = !1;
          }
        }
      }, this);
    }, e.prototype._makeAutoOrientByTargetAxis = function() {
      var t;
      return this.eachTargetAxis(function(r) {
        !t && (t = r);
      }, this), t === "y" ? "vertical" : "horizontal";
    }, e.prototype._setDefaultThrottle = function(t) {
      if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
        var r = this.ecModel.option;
        this.option.throttle = r.animation && r.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, e.prototype._updateRangeUse = function(t) {
      var r = this._rangePropMode, i = this.get("rangeMode");
      $([["start", "startValue"], ["end", "endValue"]], function(a, o) {
        var s = t[a[0]] != null, l = t[a[1]] != null;
        s && !l ? r[o] = "percent" : !s && l ? r[o] = "value" : i ? r[o] = i[o] : s && (r[o] = "percent");
      });
    }, e.prototype.noTarget = function() {
      return this._noTarget;
    }, e.prototype.getFirstTargetAxisModel = function() {
      var t;
      return this.eachTargetAxis(function(r, i) {
        t == null && (t = this.ecModel.getComponent(bu(r), i));
      }, this), t;
    }, e.prototype.eachTargetAxis = function(t, r) {
      this._targetAxisInfoMap.each(function(i, a) {
        $(i.indexList, function(o) {
          t.call(r, a, o);
        });
      });
    }, e.prototype.getAxisProxy = function(t, r) {
      var i = this.getAxisModel(t, r);
      if (i)
        return i.__dzAxisProxy;
    }, e.prototype.getAxisModel = function(t, r) {
      process.env.NODE_ENV !== "production" && ct(t && r != null);
      var i = this._targetAxisInfoMap.get(t);
      if (i && i.indexMap[r])
        return this.ecModel.getComponent(bu(t), r);
    }, e.prototype.setRawRange = function(t) {
      var r = this.option, i = this.settledOption;
      $([["start", "startValue"], ["end", "endValue"]], function(a) {
        (t[a[0]] != null || t[a[1]] != null) && (r[a[0]] = i[a[0]] = t[a[0]], r[a[1]] = i[a[1]] = t[a[1]]);
      }, this), this._updateRangeUse(t);
    }, e.prototype.setCalculatedRange = function(t) {
      var r = this.option;
      $(["start", "startValue", "end", "endValue"], function(i) {
        r[i] = t[i];
      });
    }, e.prototype.getPercentRange = function() {
      var t = this.findRepresentativeAxisProxy();
      if (t)
        return t.getDataPercentWindow();
    }, e.prototype.getValueRange = function(t, r) {
      if (t == null && r == null) {
        var i = this.findRepresentativeAxisProxy();
        if (i)
          return i.getDataValueWindow();
      } else
        return this.getAxisProxy(t, r).getDataValueWindow();
    }, e.prototype.findRepresentativeAxisProxy = function(t) {
      if (t)
        return t.__dzAxisProxy;
      for (var r, i = this._targetAxisInfoMap.keys(), a = 0; a < i.length; a++)
        for (var o = i[a], s = this._targetAxisInfoMap.get(o), l = 0; l < s.indexList.length; l++) {
          var u = this.getAxisProxy(o, s.indexList[l]);
          if (u.hostedBy(this))
            return u;
          r || (r = u);
        }
      return r;
    }, e.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, e.prototype.getOrient = function() {
      return process.env.NODE_ENV !== "production" && ct(this._orient), this._orient;
    }, e.type = "dataZoom", e.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], e.defaultOption = {
      // zlevel: 0,
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, e;
  }(Ut)
);
function U$(n) {
  var e = {};
  return $(["start", "end", "startValue", "endValue", "throttle"], function(t) {
    n.hasOwnProperty(t) && (e[t] = n[t]);
  }), e;
}
var sHe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.select", e;
  }(yg)
), hI = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      this.dataZoomModel = t, this.ecModel = r, this.api = i;
    }, e.type = "dataZoom", e;
  }(Yn)
), lHe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.select", e;
  }(hI)
), tp = $, W$ = Ya, uHe = (
  /** @class */
  function() {
    function n(e, t, r, i) {
      this._dimName = e, this._axisIndex = t, this.ecModel = i, this._dataZoomModel = r;
    }
    return n.prototype.hostedBy = function(e) {
      return this._dataZoomModel === e;
    }, n.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, n.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, n.prototype.getTargetSeriesModels = function() {
      var e = [];
      return this.ecModel.eachSeries(function(t) {
        if (aHe(t)) {
          var r = bu(this._dimName), i = t.getReferringComponents(r, gr).models[0];
          i && this._axisIndex === i.componentIndex && e.push(t);
        }
      }, this), e;
    }, n.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, n.prototype.getMinMaxSpan = function() {
      return ht(this._minMaxSpan);
    }, n.prototype.calculateDataWindow = function(e) {
      var t = this._dataExtent, r = this.getAxisModel(), i = r.axis.scale, a = this._dataZoomModel.getRangePropMode(), o = [0, 100], s = [], l = [], u;
      tp(["start", "end"], function(f, p) {
        var h = e[f], v = e[f + "Value"];
        a[p] === "percent" ? (h == null && (h = o[p]), v = i.parse(mn(h, o, t))) : (u = !0, v = v == null ? t[p] : i.parse(v), h = mn(v, t, o)), l[p] = v == null || isNaN(v) ? t[p] : v, s[p] = h == null || isNaN(h) ? o[p] : h;
      }), W$(l), W$(s);
      var c = this._minMaxSpan;
      u ? d(l, s, t, o, !1) : d(s, l, o, t, !0);
      function d(f, p, h, v, m) {
        var g = m ? "Span" : "ValueSpan";
        af(0, f, h, "all", c["min" + g], c["max" + g]);
        for (var y = 0; y < 2; y++)
          p[y] = mn(f[y], h, v, !0), m && (p[y] = i.parse(p[y]));
      }
      return {
        valueWindow: l,
        percentWindow: s
      };
    }, n.prototype.reset = function(e) {
      if (e === this._dataZoomModel) {
        var t = this.getTargetSeriesModels();
        this._dataExtent = cHe(this, this._dimName, t), this._updateMinMaxSpan();
        var r = this.calculateDataWindow(e.settledOption);
        this._valueWindow = r.valueWindow, this._percentWindow = r.percentWindow, this._setAxisModel();
      }
    }, n.prototype.filterData = function(e, t) {
      if (e !== this._dataZoomModel)
        return;
      var r = this._dimName, i = this.getTargetSeriesModels(), a = e.get("filterMode"), o = this._valueWindow;
      if (a === "none")
        return;
      tp(i, function(l) {
        var u = l.getData(), c = u.mapDimensionsAll(r);
        if (c.length) {
          if (a === "weakFilter") {
            var d = u.getStore(), f = De(c, function(p) {
              return u.getDimensionIndex(p);
            }, u);
            u.filterSelf(function(p) {
              for (var h, v, m, g = 0; g < c.length; g++) {
                var y = d.get(f[g], p), b = !isNaN(y), _ = y < o[0], x = y > o[1];
                if (b && !_ && !x)
                  return !0;
                b && (m = !0), _ && (h = !0), x && (v = !0);
              }
              return m && h && v;
            });
          } else
            tp(c, function(p) {
              if (a === "empty")
                l.setData(u = u.map(p, function(v) {
                  return s(v) ? v : NaN;
                }));
              else {
                var h = {};
                h[p] = o, u.selectRange(h);
              }
            });
          tp(c, function(p) {
            u.setApproximateExtent(o, p);
          });
        }
      });
      function s(l) {
        return l >= o[0] && l <= o[1];
      }
    }, n.prototype._updateMinMaxSpan = function() {
      var e = this._minMaxSpan = {}, t = this._dataZoomModel, r = this._dataExtent;
      tp(["min", "max"], function(i) {
        var a = t.get(i + "Span"), o = t.get(i + "ValueSpan");
        o != null && (o = this.getAxisModel().axis.scale.parse(o)), o != null ? a = mn(r[0] + o, r, [0, 100], !0) : a != null && (o = mn(a, [0, 100], r, !0) - r[0]), e[i + "Span"] = a, e[i + "ValueSpan"] = o;
      }, this);
    }, n.prototype._setAxisModel = function() {
      var e = this.getAxisModel(), t = this._percentWindow, r = this._valueWindow;
      if (t) {
        var i = MG(r, [0, 500]);
        i = Math.min(i, 20);
        var a = e.axis.scale.rawExtentInfo;
        t[0] !== 0 && a.setDeterminedMinMax("min", +r[0].toFixed(i)), t[1] !== 100 && a.setDeterminedMinMax("max", +r[1].toFixed(i)), a.freeze();
      }
    }, n;
  }()
);
function cHe(n, e, t) {
  var r = [1 / 0, -1 / 0];
  tp(t, function(o) {
    G3e(r, o.getData(), e);
  });
  var i = n.getAxisModel(), a = fq(i.axis.scale, i, r).calculate();
  return [a.min, a.max];
}
var dHe = {
  // `dataZoomProcessor` will only be performed in needed series. Consider if
  // there is a line series and a pie series, it is better not to update the
  // line series if only pie series is needed to be updated.
  getTargetSeries: function(n) {
    function e(i) {
      n.eachComponent("dataZoom", function(a) {
        a.eachTargetAxis(function(o, s) {
          var l = n.getComponent(bu(o), s);
          i(o, s, l, a);
        });
      });
    }
    e(function(i, a, o, s) {
      o.__dzAxisProxy = null;
    });
    var t = [];
    e(function(i, a, o, s) {
      o.__dzAxisProxy || (o.__dzAxisProxy = new uHe(i, a, s, n), t.push(o.__dzAxisProxy));
    });
    var r = tt();
    return $(t, function(i) {
      $(i.getTargetSeriesModels(), function(a) {
        r.set(a.uid, a);
      });
    }), r;
  },
  // Consider appendData, where filter should be performed. Because data process is
  // in block mode currently, it is not need to worry about that the overallProgress
  // execute every frame.
  overallReset: function(n, e) {
    n.eachComponent("dataZoom", function(t) {
      t.eachTargetAxis(function(r, i) {
        t.getAxisProxy(r, i).reset(t);
      }), t.eachTargetAxis(function(r, i) {
        t.getAxisProxy(r, i).filterData(t, e);
      });
    }), n.eachComponent("dataZoom", function(t) {
      var r = t.findRepresentativeAxisProxy();
      if (r) {
        var i = r.getDataPercentWindow(), a = r.getDataValueWindow();
        t.setCalculatedRange({
          start: i[0],
          end: i[1],
          startValue: a[0],
          endValue: a[1]
        });
      }
    });
  }
};
function fHe(n) {
  n.registerAction("dataZoom", function(e, t) {
    var r = oHe(t, e);
    $(r, function(i) {
      i.setRawRange({
        start: e.start,
        end: e.end,
        startValue: e.startValue,
        endValue: e.endValue
      });
    });
  });
}
var q$ = !1;
function vI(n) {
  q$ || (q$ = !0, n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, dHe), fHe(n), n.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  }));
}
function pHe(n) {
  n.registerComponentModel(sHe), n.registerComponentView(lHe), vI(n);
}
var Ha = (
  /** @class */
  /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }()
), XK = {};
function np(n, e) {
  XK[n] = e;
}
function ZK(n) {
  return XK[n];
}
var hHe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      n.prototype.optionUpdated.apply(this, arguments);
      var t = this.ecModel;
      $(this.option.feature, function(r, i) {
        var a = ZK(i);
        a && (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(t)), At(r, a.defaultOption));
      });
    }, e.type = "toolbox", e.layoutMode = {
      type: "box",
      ignoreSize: !0
    }, e.defaultOption = {
      show: !0,
      z: 6,
      // zlevel: 0,
      orient: "horizontal",
      left: "right",
      top: "top",
      // right
      // bottom
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: !0,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      // textStyle: {},
      // feature
      tooltip: {
        show: !1,
        position: "bottom"
      }
    }, e;
  }(Ut)
);
function vHe(n, e, t) {
  var r = e.getBoxLayoutParams(), i = e.get("padding"), a = {
    width: t.getWidth(),
    height: t.getHeight()
  }, o = Er(r, a, i);
  md(e.get("orient"), n, e.get("itemGap"), o.width, o.height), hw(n, r, a, i);
}
function JK(n, e) {
  var t = hh(e.get("padding")), r = e.getItemStyle(["color", "opacity"]);
  return r.fill = e.get("backgroundColor"), n = new Qt({
    shape: {
      x: n.x - t[3],
      y: n.y - t[0],
      width: n.width + t[1] + t[3],
      height: n.height + t[0] + t[2],
      r: e.get("borderRadius")
    },
    style: r,
    silent: !0,
    z2: -1
  }), n;
}
var mHe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, r, i, a) {
      var o = this.group;
      if (o.removeAll(), !t.get("show"))
        return;
      var s = +t.get("itemSize"), l = t.get("orient") === "vertical", u = t.get("feature") || {}, c = this._features || (this._features = {}), d = [];
      $(u, function(h, v) {
        d.push(v);
      }), new Sl(this._featureNames || [], d).add(f).update(f).remove(Tt(f, null)).execute(), this._featureNames = d;
      function f(h, v) {
        var m = d[h], g = d[v], y = u[m], b = new yn(y, t, t.ecModel), _;
        if (a && a.newTitle != null && a.featureName === m && (y.title = a.newTitle), m && !g) {
          if (gHe(m))
            _ = {
              onclick: b.option.onclick,
              featureName: m
            };
          else {
            var x = ZK(m);
            if (!x)
              return;
            _ = new x();
          }
          c[m] = _;
        } else if (_ = c[g], !_)
          return;
        _.uid = ph("toolbox-feature"), _.model = b, _.ecModel = r, _.api = i;
        var w = _ instanceof Ha;
        if (!m && g) {
          w && _.dispose && _.dispose(r, i);
          return;
        }
        if (!b.get("show") || w && _.unusable) {
          w && _.remove && _.remove(r, i);
          return;
        }
        p(b, _, m), b.setIconStatus = function(S, C) {
          var k = this.option, M = this.iconPaths;
          k.iconStatus = k.iconStatus || {}, k.iconStatus[S] = C, M[S] && (C === "emphasis" ? xl : wl)(M[S]);
        }, _ instanceof Ha && _.render && _.render(b, r, i, a);
      }
      function p(h, v, m) {
        var g = h.getModel("iconStyle"), y = h.getModel(["emphasis", "iconStyle"]), b = v instanceof Ha && v.getIcons ? v.getIcons() : h.get("icon"), _ = h.get("title") || {}, x, w;
        We(b) ? (x = {}, x[m] = b) : x = b, We(_) ? (w = {}, w[m] = _) : w = _;
        var S = h.iconPaths = {};
        $(x, function(C, k) {
          var M = qg(C, {}, {
            x: -s / 2,
            y: -s / 2,
            width: s,
            height: s
          });
          M.setStyle(g.getItemStyle());
          var D = M.ensureState("emphasis");
          D.style = y.getItemStyle();
          var N = new nn({
            style: {
              text: w[k],
              align: y.get("textAlign"),
              borderRadius: y.get("textBorderRadius"),
              padding: y.get("textPadding"),
              fill: null,
              font: WD({
                fontStyle: y.get("textFontStyle"),
                fontFamily: y.get("textFontFamily"),
                fontSize: y.get("textFontSize"),
                fontWeight: y.get("textFontWeight")
              }, r)
            },
            ignore: !0
          });
          M.setTextContent(N), Jd({
            el: M,
            componentModel: t,
            itemName: k,
            formatterParamsExtra: {
              title: w[k]
            }
          }), M.__title = w[k], M.on("mouseover", function() {
            var R = y.getItemStyle(), j = l ? t.get("right") == null && t.get("left") !== "right" ? "right" : "left" : t.get("bottom") == null && t.get("top") !== "bottom" ? "bottom" : "top";
            N.setStyle({
              fill: y.get("textFill") || R.fill || R.stroke || "#000",
              backgroundColor: y.get("textBackgroundColor")
            }), M.setTextConfig({
              position: y.get("textPosition") || j
            }), N.ignore = !t.get("showTitle"), i.enterEmphasis(this);
          }).on("mouseout", function() {
            h.get(["iconStatus", k]) !== "emphasis" && i.leaveEmphasis(this), N.hide();
          }), (h.get(["iconStatus", k]) === "emphasis" ? xl : wl)(M), o.add(M), M.on("click", Ze(v.onclick, v, r, i, k)), S[k] = M;
        });
      }
      vHe(o, t, i), o.add(JK(o.getBoundingRect(), t)), l || o.eachChild(function(h) {
        var v = h.__title, m = h.ensureState("emphasis"), g = m.textConfig || (m.textConfig = {}), y = h.getTextContent(), b = y && y.ensureState("emphasis");
        if (b && !at(b) && v) {
          var _ = b.style || (b.style = {}), x = zg(v, nn.makeFont(_)), w = h.x + o.x, S = h.y + o.y + s, C = !1;
          S + x.height > i.getHeight() && (g.position = "top", C = !0);
          var k = C ? -5 - x.height : s + 10;
          w + x.width / 2 > i.getWidth() ? (g.position = ["100%", k], _.align = "right") : w - x.width / 2 < 0 && (g.position = [0, k], _.align = "left");
        }
      });
    }, e.prototype.updateView = function(t, r, i, a) {
      $(this._features, function(o) {
        o instanceof Ha && o.updateView && o.updateView(o.model, r, i, a);
      });
    }, e.prototype.remove = function(t, r) {
      $(this._features, function(i) {
        i instanceof Ha && i.remove && i.remove(t, r);
      }), this.group.removeAll();
    }, e.prototype.dispose = function(t, r) {
      $(this._features, function(i) {
        i instanceof Ha && i.dispose && i.dispose(t, r);
      });
    }, e.type = "toolbox", e;
  }(Yn)
);
function gHe(n) {
  return n.indexOf("my") === 0;
}
var yHe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, r) {
      var i = this.model, a = i.get("name") || t.get("title.0.text") || "echarts", o = r.getZr().painter.getType() === "svg", s = o ? "svg" : i.get("type", !0) || "png", l = r.getConnectedDataURL({
        type: s,
        backgroundColor: i.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff",
        connectedBackgroundColor: i.get("connectedBackgroundColor"),
        excludeComponents: i.get("excludeComponents"),
        pixelRatio: i.get("pixelRatio")
      }), u = Vt.browser;
      if (typeof MouseEvent == "function" && (u.newEdge || !u.ie && !u.edge)) {
        var c = document.createElement("a");
        c.download = a + "." + s, c.target = "_blank", c.href = l;
        var d = new MouseEvent("click", {
          // some micro front-end framework， window maybe is a Proxy
          view: document.defaultView,
          bubbles: !0,
          cancelable: !1
        });
        c.dispatchEvent(d);
      } else if (window.navigator.msSaveOrOpenBlob || o) {
        var f = l.split(","), p = f[0].indexOf("base64") > -1, h = o ? decodeURIComponent(f[1]) : f[1];
        p && (h = window.atob(h));
        var v = a + "." + s;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var m = h.length, g = new Uint8Array(m); m--; )
            g[m] = h.charCodeAt(m);
          var y = new Blob([g]);
          window.navigator.msSaveOrOpenBlob(y, v);
        } else {
          var b = document.createElement("iframe");
          document.body.appendChild(b);
          var _ = b.contentWindow, x = _.document;
          x.open("image/svg+xml", "replace"), x.write(h), x.close(), _.focus(), x.execCommand("SaveAs", !0, v), document.body.removeChild(b);
        }
      } else {
        var w = i.get("lang"), S = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (w && w[0] || "") + '" /></body>', C = window.open();
        C.document.write(S), C.document.title = a;
      }
    }, e.getDefaultOption = function(t) {
      var r = {
        show: !0,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: t.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
        type: "png",
        // Default use option.backgroundColor
        // backgroundColor: '#fff',
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: ["toolbox"],
        // use current pixel ratio of device by default
        // pixelRatio: 1,
        lang: t.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
      };
      return r;
    }, e;
  }(Ha)
), Y$ = "__ec_magicType_stack__", bHe = [["line", "bar"], ["stack"]], _He = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getIcons = function() {
      var t = this.model, r = t.get("icon"), i = {};
      return $(t.get("type"), function(a) {
        r[a] && (i[a] = r[a]);
      }), i;
    }, e.getDefaultOption = function(t) {
      var r = {
        show: !0,
        type: [],
        // Icon group
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          // eslint-disable-next-line
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
          // jshint ignore:line
        },
        // `line`, `bar`, `stack`, `tiled`
        title: t.getLocaleModel().get(["toolbox", "magicType", "title"]),
        option: {},
        seriesIndex: {}
      };
      return r;
    }, e.prototype.onclick = function(t, r, i) {
      var a = this.model, o = a.get(["seriesIndex", i]);
      if (K$[i]) {
        var s = {
          series: []
        }, l = function(d) {
          var f = d.subType, p = d.id, h = K$[i](f, p, d, a);
          h && (dt(h, d.option), s.series.push(h));
          var v = d.coordinateSystem;
          if (v && v.type === "cartesian2d" && (i === "line" || i === "bar")) {
            var m = v.getAxesByScale("ordinal")[0];
            if (m) {
              var g = m.dim, y = g + "Axis", b = d.getReferringComponents(y, gr).models[0], _ = b.componentIndex;
              s[y] = s[y] || [];
              for (var x = 0; x <= _; x++)
                s[y][_] = s[y][_] || {};
              s[y][_].boundaryGap = i === "bar";
            }
          }
        };
        $(bHe, function(d) {
          Pt(d, i) >= 0 && $(d, function(f) {
            a.setIconStatus(f, "normal");
          });
        }), a.setIconStatus(i, "emphasis"), t.eachComponent({
          mainType: "series",
          query: o == null ? null : {
            seriesIndex: o
          }
        }, l);
        var u, c = i;
        i === "stack" && (u = At({
          stack: a.option.title.tiled,
          tiled: a.option.title.stack
        }, a.option.title), a.get(["iconStatus", i]) !== "emphasis" && (c = "tiled")), r.dispatchAction({
          type: "changeMagicType",
          currentType: c,
          newOption: s,
          newTitle: u,
          featureName: "magicType"
        });
      }
    }, e;
  }(Ha)
), K$ = {
  line: function(n, e, t, r) {
    if (n === "bar")
      return At({
        id: e,
        type: "line",
        // Preserve data related option
        data: t.get("data"),
        stack: t.get("stack"),
        markPoint: t.get("markPoint"),
        markLine: t.get("markLine")
      }, r.get(["option", "line"]) || {}, !0);
  },
  bar: function(n, e, t, r) {
    if (n === "line")
      return At({
        id: e,
        type: "bar",
        // Preserve data related option
        data: t.get("data"),
        stack: t.get("stack"),
        markPoint: t.get("markPoint"),
        markLine: t.get("markLine")
      }, r.get(["option", "bar"]) || {}, !0);
  },
  stack: function(n, e, t, r) {
    var i = t.get("stack") === Y$;
    if (n === "line" || n === "bar")
      return r.setIconStatus("stack", i ? "normal" : "emphasis"), At({
        id: e,
        stack: i ? "" : Y$
      }, r.get(["option", "stack"]) || {}, !0);
  }
};
Ds({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(n, e) {
  e.mergeOption(n.newOption);
});
var Ow = new Array(60).join("-"), Kp = "	";
function xHe(n) {
  var e = {}, t = [], r = [];
  return n.eachRawSeries(function(i) {
    var a = i.coordinateSystem;
    if (a && (a.type === "cartesian2d" || a.type === "polar")) {
      var o = a.getBaseAxis();
      if (o.type === "category") {
        var s = o.dim + "_" + o.index;
        e[s] || (e[s] = {
          categoryAxis: o,
          valueAxis: a.getOtherAxis(o),
          series: []
        }, r.push({
          axisDim: o.dim,
          axisIndex: o.index
        })), e[s].series.push(i);
      } else
        t.push(i);
    } else
      t.push(i);
  }), {
    seriesGroupByCategoryAxis: e,
    other: t,
    meta: r
  };
}
function wHe(n) {
  var e = [];
  return $(n, function(t, r) {
    var i = t.categoryAxis, a = t.valueAxis, o = a.dim, s = [" "].concat(De(t.series, function(p) {
      return p.name;
    })), l = [i.model.getCategories()];
    $(t.series, function(p) {
      var h = p.getRawData();
      l.push(p.getRawData().mapArray(h.mapDimension(o), function(v) {
        return v;
      }));
    });
    for (var u = [s.join(Kp)], c = 0; c < l[0].length; c++) {
      for (var d = [], f = 0; f < l.length; f++)
        d.push(l[f][c]);
      u.push(d.join(Kp));
    }
    e.push(u.join(`
`));
  }), e.join(`

` + Ow + `

`);
}
function SHe(n) {
  return De(n, function(e) {
    var t = e.getRawData(), r = [e.name], i = [];
    return t.each(t.dimensions, function() {
      for (var a = arguments.length, o = arguments[a - 1], s = t.getName(o), l = 0; l < a - 1; l++)
        i[l] = arguments[l];
      r.push((s ? s + Kp : "") + i.join(Kp));
    }), r.join(`
`);
  }).join(`

` + Ow + `

`);
}
function EHe(n) {
  var e = xHe(n);
  return {
    value: vn([wHe(e.seriesGroupByCategoryAxis), SHe(e.other)], function(t) {
      return !!t.replace(/[\n\t\s]/g, "");
    }).join(`

` + Ow + `

`),
    meta: e.meta
  };
}
function N_(n) {
  return n.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function THe(n) {
  var e = n.slice(0, n.indexOf(`
`));
  if (e.indexOf(Kp) >= 0)
    return !0;
}
var fA = new RegExp("[" + Kp + "]+", "g");
function CHe(n) {
  for (var e = n.split(/\n+/g), t = N_(e.shift()).split(fA), r = [], i = De(t, function(l) {
    return {
      name: l,
      data: []
    };
  }), a = 0; a < e.length; a++) {
    var o = N_(e[a]).split(fA);
    r.push(o.shift());
    for (var s = 0; s < o.length; s++)
      i[s] && (i[s].data[a] = o[s]);
  }
  return {
    series: i,
    categories: r
  };
}
function kHe(n) {
  for (var e = n.split(/\n+/g), t = N_(e.shift()), r = [], i = 0; i < e.length; i++) {
    var a = N_(e[i]);
    if (a) {
      var o = a.split(fA), s = "", l = void 0, u = !1;
      isNaN(o[0]) ? (u = !0, s = o[0], o = o.slice(1), r[i] = {
        name: s,
        value: []
      }, l = r[i].value) : l = r[i] = [];
      for (var c = 0; c < o.length; c++)
        l.push(+o[c]);
      l.length === 1 && (u ? r[i].value = l[0] : r[i] = l[0]);
    }
  }
  return {
    name: t,
    data: r
  };
}
function AHe(n, e) {
  var t = n.split(new RegExp(`
*` + Ow + `
*`, "g")), r = {
    series: []
  };
  return $(t, function(i, a) {
    if (THe(i)) {
      var o = CHe(i), s = e[a], l = s.axisDim + "Axis";
      s && (r[l] = r[l] || [], r[l][s.axisIndex] = {
        data: o.categories
      }, r.series = r.series.concat(o.series));
    } else {
      var o = kHe(i);
      r.series.push(o);
    }
  }), r;
}
var MHe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, r) {
      setTimeout(function() {
        r.dispatchAction({
          type: "hideTip"
        });
      });
      var i = r.getDom(), a = this.model;
      this._dom && i.removeChild(this._dom);
      var o = document.createElement("div");
      o.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", o.style.backgroundColor = a.get("backgroundColor") || "#fff";
      var s = document.createElement("h4"), l = a.get("lang") || [];
      s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = a.get("textColor");
      var u = document.createElement("div"), c = document.createElement("textarea");
      u.style.cssText = "overflow:auto";
      var d = a.get("optionToContent"), f = a.get("contentToOption"), p = EHe(t);
      if (at(d)) {
        var h = d(r.getOption());
        We(h) ? u.innerHTML = h : Md(h) && u.appendChild(h);
      } else {
        c.readOnly = a.get("readOnly");
        var v = c.style;
        v.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", v.color = a.get("textColor"), v.borderColor = a.get("textareaBorderColor"), v.backgroundColor = a.get("textareaColor"), c.value = p.value, u.appendChild(c);
      }
      var m = p.meta, g = document.createElement("div");
      g.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var y = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", b = document.createElement("div"), _ = document.createElement("div");
      y += ";background-color:" + a.get("buttonColor"), y += ";color:" + a.get("buttonTextColor");
      var x = this;
      function w() {
        i.removeChild(o), x._dom = null;
      }
      HC(b, "click", w), HC(_, "click", function() {
        if (f == null && d != null || f != null && d == null) {
          process.env.NODE_ENV !== "production" && Jn("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored."), w();
          return;
        }
        var S;
        try {
          at(f) ? S = f(u, r.getOption()) : S = AHe(c.value, m);
        } catch (C) {
          throw w(), new Error("Data view format error " + C);
        }
        S && r.dispatchAction({
          type: "changeDataView",
          newOption: S
        }), w();
      }), b.innerHTML = l[1], _.innerHTML = l[2], _.style.cssText = b.style.cssText = y, !a.get("readOnly") && g.appendChild(_), g.appendChild(b), o.appendChild(s), o.appendChild(u), o.appendChild(g), u.style.height = i.clientHeight - 80 + "px", i.appendChild(o), this._dom = o;
    }, e.prototype.remove = function(t, r) {
      this._dom && r.getDom().removeChild(this._dom);
    }, e.prototype.dispose = function(t, r) {
      this.remove(t, r);
    }, e.getDefaultOption = function(t) {
      var r = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        // eslint-disable-next-line
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: t.getLocaleModel().get(["toolbox", "dataView", "title"]),
        lang: t.getLocaleModel().get(["toolbox", "dataView", "lang"]),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
      };
      return r;
    }, e;
  }(Ha)
);
function DHe(n, e) {
  return De(n, function(t, r) {
    var i = e && e[r];
    if (ut(i) && !Me(i)) {
      var a = ut(t) && !Me(t);
      a || (t = {
        value: t
      });
      var o = i.name != null && t.name == null;
      return t = dt(t, i), o && delete t.name, t;
    } else
      return t;
  });
}
Ds({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(n, e) {
  var t = [];
  $(n.newOption.series, function(r) {
    var i = e.getSeriesByName(r.name)[0];
    if (!i)
      t.push(xe({
        // Default is scatter
        type: "scatter"
      }, r));
    else {
      var a = i.get("data");
      t.push({
        name: r.name,
        data: DHe(r.data, a)
      });
    }
  }), e.mergeOption(dt({
    series: t
  }, n.newOption));
});
var QK = $, eX = en();
function OHe(n, e) {
  var t = mI(n);
  QK(e, function(r, i) {
    for (var a = t.length - 1; a >= 0; a--) {
      var o = t[a];
      if (o[i])
        break;
    }
    if (a < 0) {
      var s = n.queryComponents({
        mainType: "dataZoom",
        subType: "select",
        id: i
      })[0];
      if (s) {
        var l = s.getPercentRange();
        t[0][i] = {
          dataZoomId: i,
          start: l[0],
          end: l[1]
        };
      }
    }
  }), t.push(e);
}
function IHe(n) {
  var e = mI(n), t = e[e.length - 1];
  e.length > 1 && e.pop();
  var r = {};
  return QK(t, function(i, a) {
    for (var o = e.length - 1; o >= 0; o--)
      if (i = e[o][a], i) {
        r[a] = i;
        break;
      }
  }), r;
}
function LHe(n) {
  eX(n).snapshots = null;
}
function NHe(n) {
  return mI(n).length;
}
function mI(n) {
  var e = eX(n);
  return e.snapshots || (e.snapshots = [{}]), e.snapshots;
}
var RHe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, r) {
      LHe(t), r.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, e.getDefaultOption = function(t) {
      var r = {
        show: !0,
        // eslint-disable-next-line
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: t.getLocaleModel().get(["toolbox", "restore", "title"])
      };
      return r;
    }, e;
  }(Ha)
);
Ds({
  type: "restore",
  event: "restore",
  update: "prepareAndUpdate"
}, function(n, e) {
  e.resetOption("recreate");
});
var PHe = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], gI = (
  /** @class */
  function() {
    function n(e, t, r) {
      var i = this;
      this._targetInfoList = [];
      var a = X$(t, e);
      $(jHe, function(o, s) {
        (!r || !r.include || Pt(r.include, s) >= 0) && o(a, i._targetInfoList);
      });
    }
    return n.prototype.setOutputRanges = function(e, t) {
      return this.matchOutputRanges(e, t, function(r, i, a) {
        if ((r.coordRanges || (r.coordRanges = [])).push(i), !r.coordRange) {
          r.coordRange = i;
          var o = eT[r.brushType](0, a, i);
          r.__rangeOffset = {
            offset: ez[r.brushType](o.values, r.range, [1, 1]),
            xyMinMax: o.xyMinMax
          };
        }
      }), e;
    }, n.prototype.matchOutputRanges = function(e, t, r) {
      $(e, function(i) {
        var a = this.findTargetInfo(i, t);
        a && a !== !0 && $(a.coordSyses, function(o) {
          var s = eT[i.brushType](1, o, i.range, !0);
          r(i, s.values, o, t);
        });
      }, this);
    }, n.prototype.setInputRanges = function(e, t) {
      $(e, function(r) {
        var i = this.findTargetInfo(r, t);
        if (process.env.NODE_ENV !== "production" && (ct(!i || i === !0 || r.coordRange, "coordRange must be specified when coord index specified."), ct(!i || i !== !0 || r.range, "range must be specified in global brush.")), r.range = r.range || [], i && i !== !0) {
          r.panelId = i.panelId;
          var a = eT[r.brushType](0, i.coordSys, r.coordRange), o = r.__rangeOffset;
          r.range = o ? ez[r.brushType](a.values, o.offset, BHe(a.xyMinMax, o.xyMinMax)) : a.values;
        }
      }, this);
    }, n.prototype.makePanelOpts = function(e, t) {
      return De(this._targetInfoList, function(r) {
        var i = r.getPanelRect();
        return {
          panelId: r.panelId,
          defaultBrushType: t ? t(r) : null,
          clipPath: sK(i),
          isTargetByCursor: uK(i, e, r.coordSysModel),
          getLinearBrushOtherExtent: lK(i)
        };
      });
    }, n.prototype.controlSeries = function(e, t, r) {
      var i = this.findTargetInfo(e, r);
      return i === !0 || i && Pt(i.coordSyses, t.coordinateSystem) >= 0;
    }, n.prototype.findTargetInfo = function(e, t) {
      for (var r = this._targetInfoList, i = X$(t, e), a = 0; a < r.length; a++) {
        var o = r[a], s = e.panelId;
        if (s) {
          if (o.panelId === s)
            return o;
        } else
          for (var l = 0; l < Z$.length; l++)
            if (Z$[l](i, o))
              return o;
      }
      return !0;
    }, n;
  }()
);
function pA(n) {
  return n[0] > n[1] && n.reverse(), n;
}
function X$(n, e) {
  return cm(n, e, {
    includeMainTypes: PHe
  });
}
var jHe = {
  grid: function(n, e) {
    var t = n.xAxisModels, r = n.yAxisModels, i = n.gridModels, a = tt(), o = {}, s = {};
    !t && !r && !i || ($(t, function(l) {
      var u = l.axis.grid.model;
      a.set(u.id, u), o[u.id] = !0;
    }), $(r, function(l) {
      var u = l.axis.grid.model;
      a.set(u.id, u), s[u.id] = !0;
    }), $(i, function(l) {
      a.set(l.id, l), o[l.id] = !0, s[l.id] = !0;
    }), a.each(function(l) {
      var u = l.coordinateSystem, c = [];
      $(u.getCartesians(), function(d, f) {
        (Pt(t, d.getAxis("x").model) >= 0 || Pt(r, d.getAxis("y").model) >= 0) && c.push(d);
      }), e.push({
        panelId: "grid--" + l.id,
        gridModel: l,
        coordSysModel: l,
        // Use the first one as the representitive coordSys.
        coordSys: c[0],
        coordSyses: c,
        getPanelRect: J$.grid,
        xAxisDeclared: o[l.id],
        yAxisDeclared: s[l.id]
      });
    }));
  },
  geo: function(n, e) {
    $(n.geoModels, function(t) {
      var r = t.coordinateSystem;
      e.push({
        panelId: "geo--" + t.id,
        geoModel: t,
        coordSysModel: t,
        coordSys: r,
        coordSyses: [r],
        getPanelRect: J$.geo
      });
    });
  }
}, Z$ = [
  // grid
  function(n, e) {
    var t = n.xAxisModel, r = n.yAxisModel, i = n.gridModel;
    return !i && t && (i = t.axis.grid.model), !i && r && (i = r.axis.grid.model), i && i === e.gridModel;
  },
  // geo
  function(n, e) {
    var t = n.geoModel;
    return t && t === e.geoModel;
  }
], J$ = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    var n = this.coordSys, e = n.getBoundingRect().clone();
    return e.applyTransform(vd(n)), e;
  }
}, eT = {
  lineX: Tt(Q$, 0),
  lineY: Tt(Q$, 1),
  rect: function(n, e, t, r) {
    var i = n ? e.pointToData([t[0][0], t[1][0]], r) : e.dataToPoint([t[0][0], t[1][0]], r), a = n ? e.pointToData([t[0][1], t[1][1]], r) : e.dataToPoint([t[0][1], t[1][1]], r), o = [pA([i[0], a[0]]), pA([i[1], a[1]])];
    return {
      values: o,
      xyMinMax: o
    };
  },
  polygon: function(n, e, t, r) {
    var i = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], a = De(t, function(o) {
      var s = n ? e.pointToData(o, r) : e.dataToPoint(o, r);
      return i[0][0] = Math.min(i[0][0], s[0]), i[1][0] = Math.min(i[1][0], s[1]), i[0][1] = Math.max(i[0][1], s[0]), i[1][1] = Math.max(i[1][1], s[1]), s;
    });
    return {
      values: a,
      xyMinMax: i
    };
  }
};
function Q$(n, e, t, r) {
  process.env.NODE_ENV !== "production" && ct(t.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
  var i = t.getAxis(["x", "y"][n]), a = pA(De([0, 1], function(s) {
    return e ? i.coordToData(i.toLocalCoord(r[s]), !0) : i.toGlobalCoord(i.dataToCoord(r[s]));
  })), o = [];
  return o[n] = a, o[1 - n] = [NaN, NaN], {
    values: a,
    xyMinMax: o
  };
}
var ez = {
  lineX: Tt(tz, 0),
  lineY: Tt(tz, 1),
  rect: function(n, e, t) {
    return [[n[0][0] - t[0] * e[0][0], n[0][1] - t[0] * e[0][1]], [n[1][0] - t[1] * e[1][0], n[1][1] - t[1] * e[1][1]]];
  },
  polygon: function(n, e, t) {
    return De(n, function(r, i) {
      return [r[0] - t[0] * e[i][0], r[1] - t[1] * e[i][1]];
    });
  }
};
function tz(n, e, t, r) {
  return [e[0] - r[n] * t[0], e[1] - r[n] * t[1]];
}
function BHe(n, e) {
  var t = nz(n), r = nz(e), i = [t[0] / r[0], t[1] / r[1]];
  return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i;
}
function nz(n) {
  return n ? [n[0][1] - n[0][0], n[1][1] - n[1][0]] : [NaN, NaN];
}
var hA = $, $He = GOe("toolbox-dataZoom_"), zHe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, r, i, a) {
      this._brushController || (this._brushController = new GO(i.getZr()), this._brushController.on("brush", Ze(this._onBrush, this)).mount()), HHe(t, r, this, a, i), VHe(t, r);
    }, e.prototype.onclick = function(t, r, i) {
      FHe[i].call(this);
    }, e.prototype.remove = function(t, r) {
      this._brushController && this._brushController.unmount();
    }, e.prototype.dispose = function(t, r) {
      this._brushController && this._brushController.dispose();
    }, e.prototype._onBrush = function(t) {
      var r = t.areas;
      if (!t.isEnd || !r.length)
        return;
      var i = {}, a = this.ecModel;
      this._brushController.updateCovers([]);
      var o = new gI(yI(this.model), a, {
        include: ["grid"]
      });
      o.matchOutputRanges(r, a, function(u, c, d) {
        if (d.type === "cartesian2d") {
          var f = u.brushType;
          f === "rect" ? (s("x", d, c[0]), s("y", d, c[1])) : s({
            lineX: "x",
            lineY: "y"
          }[f], d, c);
        }
      }), OHe(a, i), this._dispatchZoomAction(i);
      function s(u, c, d) {
        var f = c.getAxis(u), p = f.model, h = l(u, p, a), v = h.findRepresentativeAxisProxy(p).getMinMaxSpan();
        (v.minValueSpan != null || v.maxValueSpan != null) && (d = af(0, d.slice(), f.scale.getExtent(), 0, v.minValueSpan, v.maxValueSpan)), h && (i[h.id] = {
          dataZoomId: h.id,
          startValue: d[0],
          endValue: d[1]
        });
      }
      function l(u, c, d) {
        var f;
        return d.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(p) {
          var h = p.getAxisModel(u, c.componentIndex);
          h && (f = p);
        }), f;
      }
    }, e.prototype._dispatchZoomAction = function(t) {
      var r = [];
      hA(t, function(i, a) {
        r.push(ht(i));
      }), r.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: r
      });
    }, e.getDefaultOption = function(t) {
      var r = {
        show: !0,
        filterMode: "filter",
        // Icon group
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        // `zoom`, `back`
        title: t.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
        brushStyle: {
          borderWidth: 0,
          color: "rgba(210,219,238,0.2)"
        }
      };
      return r;
    }, e;
  }(Ha)
), FHe = {
  zoom: function() {
    var n = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: n
    });
  },
  back: function() {
    this._dispatchZoomAction(IHe(this.ecModel));
  }
};
function yI(n) {
  var e = {
    xAxisIndex: n.get("xAxisIndex", !0),
    yAxisIndex: n.get("yAxisIndex", !0),
    xAxisId: n.get("xAxisId", !0),
    yAxisId: n.get("yAxisId", !0)
  };
  return e.xAxisIndex == null && e.xAxisId == null && (e.xAxisIndex = "all"), e.yAxisIndex == null && e.yAxisId == null && (e.yAxisIndex = "all"), e;
}
function VHe(n, e) {
  n.setIconStatus("back", NHe(e) > 1 ? "emphasis" : "normal");
}
function HHe(n, e, t, r, i) {
  var a = t._isZoomActive;
  r && r.type === "takeGlobalCursor" && (a = r.key === "dataZoomSelect" ? r.dataZoomSelectActive : !1), t._isZoomActive = a, n.setIconStatus("zoom", a ? "emphasis" : "normal");
  var o = new gI(yI(n), e, {
    include: ["grid"]
  }), s = o.makePanelOpts(i, function(l) {
    return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
  });
  t._brushController.setPanels(s).enableBrush(a && s.length ? {
    brushType: "auto",
    brushStyle: n.getModel("brushStyle").getItemStyle()
  } : !1);
}
vNe("dataZoom", function(n) {
  var e = n.getComponent("toolbox", 0), t = ["feature", "dataZoom"];
  if (!e || e.get(t) == null)
    return;
  var r = e.getModel(t), i = [], a = yI(r), o = cm(n, a);
  hA(o.xAxisModels, function(l) {
    return s(l, "xAxis", "xAxisIndex");
  }), hA(o.yAxisModels, function(l) {
    return s(l, "yAxis", "yAxisIndex");
  });
  function s(l, u, c) {
    var d = l.componentIndex, f = {
      type: "select",
      $fromToolbox: !0,
      // Default to be filter
      filterMode: r.get("filterMode", !0) || "filter",
      // Id for merge mapping.
      id: $He + u + d
    };
    f[c] = d, i.push(f);
  }
  return i;
});
function GHe(n) {
  n.registerComponentModel(hHe), n.registerComponentView(mHe), np("saveAsImage", yHe), np("magicType", _He), np("dataView", MHe), np("dataZoom", zHe), np("restore", RHe), $t(pHe);
}
var UHe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "tooltip", e.dependencies = ["axisPointer"], e.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      displayMode: "single",
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaut false (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      enterable: !1,
      backgroundColor: "#fff",
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    }, e;
  }(Ut)
);
function tX(n) {
  var e = n.get("confine");
  return e != null ? !!e : n.get("renderMode") === "richText";
}
function nX(n) {
  if (Vt.domSupported) {
    for (var e = document.documentElement.style, t = 0, r = n.length; t < r; t++)
      if (n[t] in e)
        return n[t];
  }
}
var rX = nX(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), WHe = nX(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function iX(n, e) {
  if (!n)
    return e;
  e = jU(e, !0);
  var t = n.indexOf(e);
  return n = t === -1 ? e : "-" + n.slice(0, t) + "-" + e, n.toLowerCase();
}
function qHe(n, e) {
  var t = n.currentStyle || document.defaultView && document.defaultView.getComputedStyle(n);
  return t ? t[e] : null;
}
var YHe = iX(WHe, "transition"), bI = iX(rX, "transform"), KHe = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (Vt.transform3dSupported ? "will-change:transform;" : "");
function XHe(n) {
  return n = n === "left" ? "right" : n === "right" ? "left" : n === "top" ? "bottom" : "top", n;
}
function ZHe(n, e, t) {
  if (!We(t) || t === "inside")
    return "";
  var r = n.get("backgroundColor"), i = n.get("borderWidth");
  e = Rd(e);
  var a = XHe(t), o = Math.max(Math.round(i) * 1.5, 6), s = "", l = bI + ":", u;
  Pt(["left", "right"], a) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
  var c = u * Math.PI / 180, d = o + i, f = d * Math.abs(Math.cos(c)) + d * Math.abs(Math.sin(c)), p = Math.round(((f - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (f - d) / 2) * 100) / 100;
  s += ";" + a + ":-" + p + "px";
  var h = e + " solid " + i + "px;", v = ["position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + h, "border-right:" + h, "background-color:" + r + ";"];
  return '<div style="' + v.join("") + '"></div>';
}
function JHe(n, e) {
  var t = "cubic-bezier(0.23,1,0.32,1)", r = " " + n / 2 + "s " + t, i = "opacity" + r + ",visibility" + r;
  return e || (r = " " + n + "s " + t, i += Vt.transformSupported ? "," + bI + r : ",left" + r + ",top" + r), YHe + ":" + i;
}
function rz(n, e, t) {
  var r = n.toFixed(0) + "px", i = e.toFixed(0) + "px";
  if (!Vt.transformSupported)
    return t ? "top:" + i + ";left:" + r + ";" : [["top", i], ["left", r]];
  var a = Vt.transform3dSupported, o = "translate" + (a ? "3d" : "") + "(" + r + "," + i + (a ? ",0" : "") + ")";
  return t ? "top:0;left:0;" + bI + ":" + o + ";" : [["top", 0], ["left", 0], [rX, o]];
}
function QHe(n) {
  var e = [], t = n.get("fontSize"), r = n.getTextColor();
  r && e.push("color:" + r), e.push("font:" + n.getFont());
  var i = bt(n.get("lineHeight"), Math.round(t * 3 / 2));
  t && e.push("line-height:" + i + "px");
  var a = n.get("textShadowColor"), o = n.get("textShadowBlur") || 0, s = n.get("textShadowOffsetX") || 0, l = n.get("textShadowOffsetY") || 0;
  return a && o && e.push("text-shadow:" + s + "px " + l + "px " + o + "px " + a), $(["decoration", "align"], function(u) {
    var c = n.get(u);
    c && e.push("text-" + u + ":" + c);
  }), e.join(";");
}
function e7e(n, e, t) {
  var r = [], i = n.get("transitionDuration"), a = n.get("backgroundColor"), o = n.get("shadowBlur"), s = n.get("shadowColor"), l = n.get("shadowOffsetX"), u = n.get("shadowOffsetY"), c = n.getModel("textStyle"), d = mW(n, "html"), f = l + "px " + u + "px " + o + "px " + s;
  return r.push("box-shadow:" + f), e && i && r.push(JHe(i, t)), a && r.push("background-color:" + a), $(["width", "color", "radius"], function(p) {
    var h = "border-" + p, v = jU(h), m = n.get(v);
    m != null && r.push(h + ":" + m + (p === "color" ? "" : "px"));
  }), r.push(QHe(c)), d != null && r.push("padding:" + hh(d).join("px ") + "px"), r.join(";") + ";";
}
function iz(n, e, t, r, i) {
  var a = e && e.painter;
  if (t) {
    var o = a && a.getViewportRoot();
    o && _De(n, o, t, r, i);
  } else {
    n[0] = r, n[1] = i;
    var s = a && a.getViewportRootOffset();
    s && (n[0] += s.offsetLeft, n[1] += s.offsetTop);
  }
  n[2] = n[0] / e.getWidth(), n[3] = n[1] / e.getHeight();
}
var t7e = (
  /** @class */
  function() {
    function n(e, t) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, Vt.wxa)
        return null;
      var r = document.createElement("div");
      r.domBelongToZr = !0, this.el = r;
      var i = this._zr = e.getZr(), a = t.appendTo, o = a && (We(a) ? document.querySelector(a) : Md(a) ? a : at(a) && a(e.getDom()));
      iz(this._styleCoord, i, o, e.getWidth() / 2, e.getHeight() / 2), (o || e.getDom()).appendChild(r), this._api = e, this._container = o;
      var s = this;
      r.onmouseenter = function() {
        s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0;
      }, r.onmousemove = function(l) {
        if (l = l || window.event, !s._enterable) {
          var u = i.handler, c = i.painter.getViewportRoot();
          Pa(c, l, !0), u.dispatch("mousemove", l);
        }
      }, r.onmouseleave = function() {
        s._inContent = !1, s._enterable && s._show && s.hideLater(s._hideDelay);
      };
    }
    return n.prototype.update = function(e) {
      if (!this._container) {
        var t = this._api.getDom(), r = qHe(t, "position"), i = t.style;
        i.position !== "absolute" && r !== "absolute" && (i.position = "relative");
      }
      var a = e.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this.el.className = e.get("className") || "";
    }, n.prototype.show = function(e, t) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var r = this.el, i = r.style, a = this._styleCoord;
      r.innerHTML ? i.cssText = KHe + e7e(e, !this._firstShow, this._longHide) + rz(a[0], a[1], !0) + ("border-color:" + Rd(t) + ";") + (e.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : i.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, n.prototype.setContent = function(e, t, r, i, a) {
      var o = this.el;
      if (e == null) {
        o.innerHTML = "";
        return;
      }
      var s = "";
      if (We(a) && r.get("trigger") === "item" && !tX(r) && (s = ZHe(r, i, a)), We(e))
        o.innerHTML = e + s;
      else if (e) {
        o.innerHTML = "", Me(e) || (e = [e]);
        for (var l = 0; l < e.length; l++)
          Md(e[l]) && e[l].parentNode !== o && o.appendChild(e[l]);
        if (s && o.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = s, o.appendChild(u);
        }
      }
    }, n.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, n.prototype.getSize = function() {
      var e = this.el;
      return e ? [e.offsetWidth, e.offsetHeight] : [0, 0];
    }, n.prototype.moveTo = function(e, t) {
      if (this.el) {
        var r = this._styleCoord;
        if (iz(r, this._zr, this._container, e, t), r[0] != null && r[1] != null) {
          var i = this.el.style, a = rz(r[0], r[1]);
          $(a, function(o) {
            i[o[0]] = o[1];
          });
        }
      }
    }, n.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, n.prototype.hide = function() {
      var e = this, t = this.el.style;
      t.visibility = "hidden", t.opacity = "0", Vt.transform3dSupported && (t.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return e._longHide = !0;
      }, 500);
    }, n.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(Ze(this.hide, this), e)) : this.hide());
    }, n.prototype.isShow = function() {
      return this._show;
    }, n.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var e = this.el.parentNode;
      e && e.removeChild(this.el), this.el = this._container = null;
    }, n;
  }()
), n7e = (
  /** @class */
  function() {
    function n(e) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = e.getZr(), oz(this._styleCoord, this._zr, e.getWidth() / 2, e.getHeight() / 2);
    }
    return n.prototype.update = function(e) {
      var t = e.get("alwaysShowContent");
      t && this._moveIfResized(), this._alwaysShowContent = t;
    }, n.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, n.prototype.setContent = function(e, t, r, i, a) {
      var o = this;
      ut(e) && hn(process.env.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var s = r.getModel("textStyle");
      this.el = new nn({
        style: {
          rich: t.richTextStyles,
          text: e,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: i,
          textShadowColor: s.get("textShadowColor"),
          fill: r.get(["textStyle", "color"]),
          padding: mW(r, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: r.get("z")
      }), $(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        o.el.style[u] = r.get(u);
      }), $(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        o.el.style[u] = s.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, n.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, n.prototype.getSize = function() {
      var e = this.el, t = this.el.getBoundingRect(), r = az(e.style);
      return [t.width + r.left + r.right, t.height + r.top + r.bottom];
    }, n.prototype.moveTo = function(e, t) {
      var r = this.el;
      if (r) {
        var i = this._styleCoord;
        oz(i, this._zr, e, t), e = i[0], t = i[1];
        var a = r.style, o = Xl(a.borderWidth || 0), s = az(a);
        r.x = e + o + s.left, r.y = t + o + s.top, r.markRedraw();
      }
    }, n.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, n.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, n.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(Ze(this.hide, this), e)) : this.hide());
    }, n.prototype.isShow = function() {
      return this._show;
    }, n.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, n;
  }()
);
function Xl(n) {
  return Math.max(0, n);
}
function az(n) {
  var e = Xl(n.shadowBlur || 0), t = Xl(n.shadowOffsetX || 0), r = Xl(n.shadowOffsetY || 0);
  return {
    left: Xl(e - t),
    right: Xl(e + t),
    top: Xl(e - r),
    bottom: Xl(e + r)
  };
}
function oz(n, e, t, r) {
  n[0] = t, n[1] = r, n[2] = n[0] / e.getWidth(), n[3] = n[1] / e.getHeight();
}
var r7e = new Qt({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), i7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      if (!(Vt.node || !r.getDom())) {
        var i = t.getComponent("tooltip"), a = this._renderMode = ZOe(i.get("renderMode"));
        this._tooltipContent = a === "richText" ? new n7e(r) : new t7e(r, {
          appendTo: i.get("appendToBody", !0) ? "body" : i.get("appendTo", !0)
        });
      }
    }, e.prototype.render = function(t, r, i) {
      if (!(Vt.node || !i.getDom())) {
        this.group.removeAll(), this._tooltipModel = t, this._ecModel = r, this._api = i;
        var a = this._tooltipContent;
        a.update(t), a.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && t.get("transitionDuration") ? bh(this, "_updatePosition", 50, "fixRate") : ag(this, "_updatePosition");
      }
    }, e.prototype._initGlobalListener = function() {
      var t = this._tooltipModel, r = t.get("triggerOn");
      VK("itemTooltip", this._api, Ze(function(i, a, o) {
        r !== "none" && (r.indexOf(i) >= 0 ? this._tryShow(a, o) : i === "leave" && this._hide(o));
      }, this));
    }, e.prototype._keepShow = function() {
      var t = this._tooltipModel, r = this._ecModel, i = this._api, a = t.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var o = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !i.isDisposed() && o.manuallyShowTip(t, r, i, {
            x: o._lastX,
            y: o._lastY,
            dataByCoordSys: o._lastDataByCoordSys
          });
        });
      }
    }, e.prototype.manuallyShowTip = function(t, r, i, a) {
      if (!(a.from === this.uid || Vt.node || !i.getDom())) {
        var o = sz(a, i);
        this._ticket = "";
        var s = a.dataByCoordSys, l = l7e(a, r, i);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var c = r7e;
          c.x = a.x, c.y = a.y, c.update(), yt(c).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: c
          }, o);
        } else if (s)
          this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            dataByCoordSys: s,
            tooltipOption: a.tooltipOption
          }, o);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(t, r, i, a))
            return;
          var d = HK(a, r), f = d.point[0], p = d.point[1];
          f != null && p != null && this._tryShow({
            offsetX: f,
            offsetY: p,
            target: d.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else a.x != null && a.y != null && (i.dispatchAction({
          type: "updateAxisPointer",
          x: a.x,
          y: a.y
        }), this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          target: i.getZr().findHover(a.x, a.y).target
        }, o));
      }
    }, e.prototype.manuallyHideTip = function(t, r, i, a) {
      var o = this._tooltipContent;
      this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(sz(a, i));
    }, e.prototype._manuallyAxisShowTip = function(t, r, i, a) {
      var o = a.seriesIndex, s = a.dataIndex, l = r.getComponent("axisPointer").coordSysAxesInfo;
      if (!(o == null || s == null || l == null)) {
        var u = r.getSeriesByIndex(o);
        if (u) {
          var c = u.getData(), d = mv([c.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (d.get("trigger") === "axis")
            return i.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: o,
              dataIndex: s,
              position: a.position
            }), !0;
        }
      }
    }, e.prototype._tryShow = function(t, r) {
      var i = t.target, a = this._tooltipModel;
      if (a) {
        this._lastX = t.offsetX, this._lastY = t.offsetY;
        var o = t.dataByCoordSys;
        if (o && o.length)
          this._showAxisTooltip(o, t);
        else if (i) {
          var s = yt(i);
          if (s.ssrType === "legend")
            return;
          this._lastDataByCoordSys = null;
          var l, u;
          qc(i, function(c) {
            if (yt(c).dataIndex != null)
              return l = c, !0;
            if (yt(c).tooltipConfig != null)
              return u = c, !0;
          }, !0), l ? this._showSeriesItemTooltip(t, l, r) : u ? this._showComponentItemTooltip(t, u, r) : this._hide(r);
        } else
          this._lastDataByCoordSys = null, this._hide(r);
      }
    }, e.prototype._showOrMove = function(t, r) {
      var i = t.get("showDelay");
      r = Ze(r, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(r, i) : r();
    }, e.prototype._showAxisTooltip = function(t, r) {
      var i = this._ecModel, a = this._tooltipModel, o = [r.offsetX, r.offsetY], s = mv([r.tooltipOption], a), l = this._renderMode, u = [], c = Rr("section", {
        blocks: [],
        noHeader: !0
      }), d = [], f = new B2();
      $(t, function(y) {
        $(y.dataByAxis, function(b) {
          var _ = i.getComponent(b.axisDim + "Axis", b.axisIndex), x = b.value;
          if (!(!_ || x == null)) {
            var w = $K(x, _.axis, i, b.seriesDataIndices, b.valueLabelOpt), S = Rr("section", {
              header: w,
              noHeader: !yo(w),
              sortBlocks: !0,
              blocks: []
            });
            c.blocks.push(S), $(b.seriesDataIndices, function(C) {
              var k = i.getSeriesByIndex(C.seriesIndex), M = C.dataIndexInside, D = k.getDataParams(M);
              if (!(D.dataIndex < 0)) {
                D.axisDim = b.axisDim, D.axisIndex = b.axisIndex, D.axisType = b.axisType, D.axisId = b.axisId, D.axisValue = yO(_.axis, {
                  value: x
                }), D.axisValueLabel = w, D.marker = f.makeTooltipMarker("item", Rd(D.color), l);
                var N = Gj(k.formatTooltip(M, !0, null)), R = N.frag;
                if (R) {
                  var j = mv([k], a).get("valueFormatter");
                  S.blocks.push(j ? xe({
                    valueFormatter: j
                  }, R) : R);
                }
                N.text && d.push(N.text), u.push(D);
              }
            });
          }
        });
      }), c.blocks.reverse(), d.reverse();
      var p = r.position, h = s.get("order"), v = Xj(c, f, l, h, i.get("useUTC"), s.get("textStyle"));
      v && d.unshift(v);
      var m = l === "richText" ? `

` : "<br/>", g = d.join(m);
      this._showOrMove(s, function() {
        this._updateContentNotChangedOnAxis(t, u) ? this._updatePosition(s, p, o[0], o[1], this._tooltipContent, u) : this._showTooltipContent(s, g, u, Math.random() + "", o[0], o[1], p, null, f);
      });
    }, e.prototype._showSeriesItemTooltip = function(t, r, i) {
      var a = this._ecModel, o = yt(r), s = o.seriesIndex, l = a.getSeriesByIndex(s), u = o.dataModel || l, c = o.dataIndex, d = o.dataType, f = u.getData(d), p = this._renderMode, h = t.positionDefault, v = mv([f.getItemModel(c), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, h ? {
        position: h
      } : null), m = v.get("trigger");
      if (!(m != null && m !== "item")) {
        var g = u.getDataParams(c, d), y = new B2();
        g.marker = y.makeTooltipMarker("item", Rd(g.color), p);
        var b = Gj(u.formatTooltip(c, !1, d)), _ = v.get("order"), x = v.get("valueFormatter"), w = b.frag, S = w ? Xj(x ? xe({
          valueFormatter: x
        }, w) : w, y, p, _, a.get("useUTC"), v.get("textStyle")) : b.text, C = "item_" + u.name + "_" + c;
        this._showOrMove(v, function() {
          this._showTooltipContent(v, S, g, C, t.offsetX, t.offsetY, t.position, t.target, y);
        }), i({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: f.getRawIndex(c),
          seriesIndex: s,
          from: this.uid
        });
      }
    }, e.prototype._showComponentItemTooltip = function(t, r, i) {
      var a = this._renderMode === "html", o = yt(r), s = o.tooltipConfig, l = s.option || {}, u = l.encodeHTMLContent;
      if (We(l)) {
        var c = l;
        l = {
          content: c,
          // Fixed formatter
          formatter: c
        }, u = !0;
      }
      u && a && l.content && (l = ht(l), l.content = Ai(l.content));
      var d = [l], f = this._ecModel.getComponent(o.componentMainType, o.componentIndex);
      f && d.push(f), d.push({
        formatter: l.content
      });
      var p = t.positionDefault, h = mv(d, this._tooltipModel, p ? {
        position: p
      } : null), v = h.get("content"), m = Math.random() + "", g = new B2();
      this._showOrMove(h, function() {
        var y = ht(h.get("formatterParams") || {});
        this._showTooltipContent(h, v, y, m, t.offsetX, t.offsetY, t.position, r, g);
      }), i({
        type: "showTip",
        from: this.uid
      });
    }, e.prototype._showTooltipContent = function(t, r, i, a, o, s, l, u, c) {
      if (this._ticket = "", !(!t.get("showContent") || !t.get("show"))) {
        var d = this._tooltipContent;
        d.setEnterable(t.get("enterable"));
        var f = t.get("formatter");
        l = l || t.get("position");
        var p = r, h = this._getNearestPoint([o, s], i, t.get("trigger"), t.get("borderColor")), v = h.color;
        if (f)
          if (We(f)) {
            var m = t.ecModel.get("useUTC"), g = Me(i) ? i[0] : i, y = g && g.axisType && g.axisType.indexOf("time") >= 0;
            p = f, y && (p = uw(g.axisValue, p, m)), p = BU(p, i, !0);
          } else if (at(f)) {
            var b = Ze(function(_, x) {
              _ === this._ticket && (d.setContent(x, c, t, v, l), this._updatePosition(t, l, o, s, d, i, u));
            }, this);
            this._ticket = a, p = f(i, a, b);
          } else
            p = f;
        d.setContent(p, c, t, v, l), d.show(t, v), this._updatePosition(t, l, o, s, d, i, u);
      }
    }, e.prototype._getNearestPoint = function(t, r, i, a) {
      if (i === "axis" || Me(r))
        return {
          color: a || (this._renderMode === "html" ? "#fff" : "none")
        };
      if (!Me(r))
        return {
          color: a || r.color || r.borderColor
        };
    }, e.prototype._updatePosition = function(t, r, i, a, o, s, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      r = r || t.get("position");
      var d = o.getSize(), f = t.get("align"), p = t.get("verticalAlign"), h = l && l.getBoundingRect().clone();
      if (l && h.applyTransform(l.transform), at(r) && (r = r([i, a], s, o.el, h, {
        viewSize: [u, c],
        contentSize: d.slice()
      })), Me(r))
        i = ze(r[0], u), a = ze(r[1], c);
      else if (ut(r)) {
        var v = r;
        v.width = d[0], v.height = d[1];
        var m = Er(v, {
          width: u,
          height: c
        });
        i = m.x, a = m.y, f = null, p = null;
      } else if (We(r) && l) {
        var g = s7e(r, h, d, t.get("borderWidth"));
        i = g[0], a = g[1];
      } else {
        var g = a7e(i, a, o, u, c, f ? null : 20, p ? null : 20);
        i = g[0], a = g[1];
      }
      if (f && (i -= lz(f) ? d[0] / 2 : f === "right" ? d[0] : 0), p && (a -= lz(p) ? d[1] / 2 : p === "bottom" ? d[1] : 0), tX(t)) {
        var g = o7e(i, a, o, u, c);
        i = g[0], a = g[1];
      }
      o.moveTo(i, a);
    }, e.prototype._updateContentNotChangedOnAxis = function(t, r) {
      var i = this._lastDataByCoordSys, a = this._cbParamsList, o = !!i && i.length === t.length;
      return o && $(i, function(s, l) {
        var u = s.dataByAxis || [], c = t[l] || {}, d = c.dataByAxis || [];
        o = o && u.length === d.length, o && $(u, function(f, p) {
          var h = d[p] || {}, v = f.seriesDataIndices || [], m = h.seriesDataIndices || [];
          o = o && f.value === h.value && f.axisType === h.axisType && f.axisId === h.axisId && v.length === m.length, o && $(v, function(g, y) {
            var b = m[y];
            o = o && g.seriesIndex === b.seriesIndex && g.dataIndex === b.dataIndex;
          }), a && $(f.seriesDataIndices, function(g) {
            var y = g.seriesIndex, b = r[y], _ = a[y];
            b && _ && _.data !== b.data && (o = !1);
          });
        });
      }), this._lastDataByCoordSys = t, this._cbParamsList = r, !!o;
    }, e.prototype._hide = function(t) {
      this._lastDataByCoordSys = null, t({
        type: "hideTip",
        from: this.uid
      });
    }, e.prototype.dispose = function(t, r) {
      Vt.node || !r.getDom() || (ag(this, "_updatePosition"), this._tooltipContent.dispose(), uA("itemTooltip", r));
    }, e.type = "tooltip", e;
  }(Yn)
);
function mv(n, e, t) {
  var r = e.ecModel, i;
  t ? (i = new yn(t, r, r), i = new yn(e.option, i, r)) : i = e;
  for (var a = n.length - 1; a >= 0; a--) {
    var o = n[a];
    o && (o instanceof yn && (o = o.get("tooltip", !0)), We(o) && (o = {
      formatter: o
    }), o && (i = new yn(o, i, r)));
  }
  return i;
}
function sz(n, e) {
  return n.dispatchAction || Ze(e.dispatchAction, e);
}
function a7e(n, e, t, r, i, a, o) {
  var s = t.getSize(), l = s[0], u = s[1];
  return a != null && (n + l + a + 2 > r ? n -= l + a : n += a), o != null && (e + u + o > i ? e -= u + o : e += o), [n, e];
}
function o7e(n, e, t, r, i) {
  var a = t.getSize(), o = a[0], s = a[1];
  return n = Math.min(n + o, r) - o, e = Math.min(e + s, i) - s, n = Math.max(n, 0), e = Math.max(e, 0), [n, e];
}
function s7e(n, e, t, r) {
  var i = t[0], a = t[1], o = Math.ceil(Math.SQRT2 * r) + 8, s = 0, l = 0, u = e.width, c = e.height;
  switch (n) {
    case "inside":
      s = e.x + u / 2 - i / 2, l = e.y + c / 2 - a / 2;
      break;
    case "top":
      s = e.x + u / 2 - i / 2, l = e.y - a - o;
      break;
    case "bottom":
      s = e.x + u / 2 - i / 2, l = e.y + c + o;
      break;
    case "left":
      s = e.x - i - o, l = e.y + c / 2 - a / 2;
      break;
    case "right":
      s = e.x + u + o, l = e.y + c / 2 - a / 2;
  }
  return [s, l];
}
function lz(n) {
  return n === "center" || n === "middle";
}
function l7e(n, e, t) {
  var r = LD(n).queryOptionMap, i = r.keys()[0];
  if (!(!i || i === "series")) {
    var a = Fg(e, i, r.get(i), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), o = a.models[0];
    if (o) {
      var s = t.getViewOfComponentModel(o), l;
      if (s.group.traverse(function(u) {
        var c = yt(u).tooltipConfig;
        if (c && c.name === n.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: i,
          componentIndex: o.componentIndex,
          el: l
        };
    }
  }
}
function u7e(n) {
  $t(ay), n.registerComponentModel(UHe), n.registerComponentView(i7e), n.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, dr), n.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, dr);
}
var c7e = ["rect", "polygon", "keep", "clear"];
function d7e(n, e) {
  var t = wn(n ? n.brush : []);
  if (t.length) {
    var r = [];
    $(t, function(l) {
      var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
      u instanceof Array && (r = r.concat(u));
    });
    var i = n && n.toolbox;
    Me(i) && (i = i[0]), i || (i = {
      feature: {}
    }, n.toolbox = [i]);
    var a = i.feature || (i.feature = {}), o = a.brush || (a.brush = {}), s = o.type || (o.type = []);
    s.push.apply(s, r), f7e(s), e && !s.length && s.push.apply(s, c7e);
  }
}
function f7e(n) {
  var e = {};
  $(n, function(t) {
    e[t] = 1;
  }), n.length = 0, $(e, function(t, r) {
    n.push(r);
  });
}
var uz = $;
function cz(n) {
  if (n) {
    for (var e in n)
      if (n.hasOwnProperty(e))
        return !0;
  }
}
function vA(n, e, t) {
  var r = {};
  return uz(e, function(a) {
    var o = r[a] = i();
    uz(n[a], function(s, l) {
      if (Lr.isValidType(l)) {
        var u = {
          type: l,
          visual: s
        };
        t && t(u, a), o[l] = new Lr(u), l === "opacity" && (u = ht(u), u.type = "colorAlpha", o.__hidden.__alphaForOpacity = new Lr(u));
      }
    });
  }), r;
  function i() {
    var a = function() {
    };
    a.prototype.__hidden = a.prototype;
    var o = new a();
    return o;
  }
}
function aX(n, e, t) {
  var r;
  $(t, function(i) {
    e.hasOwnProperty(i) && cz(e[i]) && (r = !0);
  }), r && $(t, function(i) {
    e.hasOwnProperty(i) && cz(e[i]) ? n[i] = ht(e[i]) : delete n[i];
  });
}
function p7e(n, e, t, r, i, a) {
  var o = {};
  $(n, function(d) {
    var f = Lr.prepareVisualTypes(e[d]);
    o[d] = f;
  });
  var s;
  function l(d) {
    return lO(t, s, d);
  }
  function u(d, f) {
    CW(t, s, d, f);
  }
  t.each(c);
  function c(d, f) {
    s = d;
    var p = t.getRawDataItem(s);
    if (!(p && p.visualMap === !1))
      for (var h = r.call(i, d), v = e[h], m = o[h], g = 0, y = m.length; g < y; g++) {
        var b = m[g];
        v[b] && v[b].applyVisual(d, l, u);
      }
  }
}
function h7e(n, e, t, r) {
  var i = {};
  return $(n, function(a) {
    var o = Lr.prepareVisualTypes(e[a]);
    i[a] = o;
  }), {
    progress: function(o, s) {
      var l;
      r != null && (l = s.getDimensionIndex(r));
      function u(x) {
        return lO(s, d, x);
      }
      function c(x, w) {
        CW(s, d, x, w);
      }
      for (var d, f = s.getStore(); (d = o.next()) != null; ) {
        var p = s.getRawDataItem(d);
        if (!(p && p.visualMap === !1))
          for (var h = r != null ? f.get(l, d) : d, v = t(h), m = e[v], g = i[v], y = 0, b = g.length; y < b; y++) {
            var _ = g[y];
            m[_] && m[_].applyVisual(h, u, c);
          }
      }
    }
  };
}
function v7e(n) {
  var e = n.brushType, t = {
    point: function(r) {
      return dz[e].point(r, t, n);
    },
    rect: function(r) {
      return dz[e].rect(r, t, n);
    }
  };
  return t;
}
var dz = {
  lineX: fz(0),
  lineY: fz(1),
  rect: {
    point: function(n, e, t) {
      return n && t.boundingRect.contain(n[0], n[1]);
    },
    rect: function(n, e, t) {
      return n && t.boundingRect.intersect(n);
    }
  },
  polygon: {
    point: function(n, e, t) {
      return n && t.boundingRect.contain(n[0], n[1]) && Nc(t.range, n[0], n[1]);
    },
    rect: function(n, e, t) {
      var r = t.range;
      if (!n || r.length <= 1)
        return !1;
      var i = n.x, a = n.y, o = n.width, s = n.height, l = r[0];
      if (Nc(r, i, a) || Nc(r, i + o, a) || Nc(r, i, a + s) || Nc(r, i + o, a + s) || Ot.create(n).contain(l[0], l[1]) || Ov(i, a, i + o, a, r) || Ov(i, a, i, a + s, r) || Ov(i + o, a, i + o, a + s, r) || Ov(i, a + s, i + o, a + s, r))
        return !0;
    }
  }
};
function fz(n) {
  var e = ["x", "y"], t = ["width", "height"];
  return {
    point: function(r, i, a) {
      if (r) {
        var o = a.range, s = r[n];
        return gv(s, o);
      }
    },
    rect: function(r, i, a) {
      if (r) {
        var o = a.range, s = [r[e[n]], r[e[n]] + r[t[n]]];
        return s[1] < s[0] && s.reverse(), gv(s[0], o) || gv(s[1], o) || gv(o[0], s) || gv(o[1], s);
      }
    }
  };
}
function gv(n, e) {
  return e[0] <= n && n <= e[1];
}
var pz = ["inBrush", "outOfBrush"], tT = "__ecBrushSelect", mA = "__ecInBrushSelectEvent";
function oX(n) {
  n.eachComponent({
    mainType: "brush"
  }, function(e) {
    var t = e.brushTargetManager = new gI(e.option, n);
    t.setInputRanges(e.areas, n);
  });
}
function m7e(n, e, t) {
  var r = [], i, a;
  n.eachComponent({
    mainType: "brush"
  }, function(o) {
    t && t.type === "takeGlobalCursor" && o.setBrushOption(t.key === "brush" ? t.brushOption : {
      brushType: !1
    });
  }), oX(n), n.eachComponent({
    mainType: "brush"
  }, function(o, s) {
    var l = {
      brushId: o.id,
      brushIndex: s,
      brushName: o.name,
      areas: ht(o.areas),
      selected: []
    };
    r.push(l);
    var u = o.option, c = u.brushLink, d = [], f = [], p = [], h = !1;
    s || (i = u.throttleType, a = u.throttleDelay);
    var v = De(o.areas, function(x) {
      var w = _7e[x.brushType], S = dt({
        boundingRect: w ? w(x) : void 0
      }, x);
      return S.selectors = v7e(S), S;
    }), m = vA(o.option, pz, function(x) {
      x.mappingMethod = "fixed";
    });
    Me(c) && $(c, function(x) {
      d[x] = 1;
    });
    function g(x) {
      return c === "all" || !!d[x];
    }
    function y(x) {
      return !!x.length;
    }
    n.eachSeries(function(x, w) {
      var S = p[w] = [];
      x.subType === "parallel" ? b(x, w) : _(x, w, S);
    });
    function b(x, w) {
      var S = x.coordinateSystem;
      h = h || S.hasAxisBrushed(), g(w) && S.eachActiveState(x.getData(), function(C, k) {
        C === "active" && (f[k] = 1);
      });
    }
    function _(x, w, S) {
      if (!(!x.brushSelector || b7e(o, w)) && ($(v, function(k) {
        o.brushTargetManager.controlSeries(k, x, n) && S.push(k), h = h || y(S);
      }), g(w) && y(S))) {
        var C = x.getData();
        C.each(function(k) {
          hz(x, S, C, k) && (f[k] = 1);
        });
      }
    }
    n.eachSeries(function(x, w) {
      var S = {
        seriesId: x.id,
        seriesIndex: w,
        seriesName: x.name,
        dataIndex: []
      };
      l.selected.push(S);
      var C = p[w], k = x.getData(), M = g(w) ? function(D) {
        return f[D] ? (S.dataIndex.push(k.getRawIndex(D)), "inBrush") : "outOfBrush";
      } : function(D) {
        return hz(x, C, k, D) ? (S.dataIndex.push(k.getRawIndex(D)), "inBrush") : "outOfBrush";
      };
      (g(w) ? h : y(C)) && p7e(pz, m, k, M);
    });
  }), g7e(e, i, a, r, t);
}
function g7e(n, e, t, r, i) {
  if (i) {
    var a = n.getZr();
    if (!a[mA]) {
      a[tT] || (a[tT] = y7e);
      var o = bh(a, tT, t, e);
      o(n, r);
    }
  }
}
function y7e(n, e) {
  if (!n.isDisposed()) {
    var t = n.getZr();
    t[mA] = !0, n.dispatchAction({
      type: "brushSelect",
      batch: e
    }), t[mA] = !1;
  }
}
function hz(n, e, t, r) {
  for (var i = 0, a = e.length; i < a; i++) {
    var o = e[i];
    if (n.brushSelector(r, t, o.selectors, o))
      return !0;
  }
}
function b7e(n, e) {
  var t = n.option.seriesIndex;
  return t != null && t !== "all" && (Me(t) ? Pt(t, e) < 0 : e !== t);
}
var _7e = {
  rect: function(n) {
    return vz(n.range);
  },
  polygon: function(n) {
    for (var e, t = n.range, r = 0, i = t.length; r < i; r++) {
      e = e || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
      var a = t[r];
      a[0] < e[0][0] && (e[0][0] = a[0]), a[0] > e[0][1] && (e[0][1] = a[0]), a[1] < e[1][0] && (e[1][0] = a[1]), a[1] > e[1][1] && (e[1][1] = a[1]);
    }
    return e && vz(e);
  }
};
function vz(n) {
  return new Ot(n[0][0], n[1][0], n[0][1] - n[0][0], n[1][1] - n[1][0]);
}
var x7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      this.ecModel = t, this.api = r, this.model, (this._brushController = new GO(r.getZr())).on("brush", Ze(this._onBrush, this)).mount();
    }, e.prototype.render = function(t, r, i, a) {
      this.model = t, this._updateController(t, r, i, a);
    }, e.prototype.updateTransform = function(t, r, i, a) {
      oX(r), this._updateController(t, r, i, a);
    }, e.prototype.updateVisual = function(t, r, i, a) {
      this.updateTransform(t, r, i, a);
    }, e.prototype.updateView = function(t, r, i, a) {
      this._updateController(t, r, i, a);
    }, e.prototype._updateController = function(t, r, i, a) {
      (!a || a.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(i)).enableBrush(t.brushOption).updateCovers(t.areas.slice());
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.prototype._onBrush = function(t) {
      var r = this.model.id, i = this.model.brushTargetManager.setOutputRanges(t.areas, this.ecModel);
      (!t.isEnd || t.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: r,
        areas: ht(i),
        $from: r
      }), t.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: r,
        areas: ht(i),
        $from: r
      });
    }, e.type = "brush", e;
  }(Yn)
), w7e = "#ddd", S7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.areas = [], t.brushOption = {}, t;
    }
    return e.prototype.optionUpdated = function(t, r) {
      var i = this.option;
      !r && aX(i, t, ["inBrush", "outOfBrush"]);
      var a = i.inBrush = i.inBrush || {};
      i.outOfBrush = i.outOfBrush || {
        color: w7e
      }, a.hasOwnProperty("liftZ") || (a.liftZ = 5);
    }, e.prototype.setAreas = function(t) {
      process.env.NODE_ENV !== "production" && (ct(Me(t)), $(t, function(r) {
        ct(r.brushType, "Illegal areas");
      })), t && (this.areas = De(t, function(r) {
        return mz(this.option, r);
      }, this));
    }, e.prototype.setBrushOption = function(t) {
      this.brushOption = mz(this.option, t), this.brushType = this.brushOption.brushType;
    }, e.type = "brush", e.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], e.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: !0,
      brushStyle: {
        borderWidth: 1,
        color: "rgba(210,219,238,0.3)",
        borderColor: "#D2DBEE"
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: !0,
      z: 1e4
    }, e;
  }(Ut)
);
function mz(n, e) {
  return At({
    brushType: n.brushType,
    brushMode: n.brushMode,
    transformable: n.transformable,
    brushStyle: new yn(n.brushStyle).getItemStyle(),
    removeOnClick: n.removeOnClick,
    z: n.z
  }, e, !0);
}
var E7e = ["rect", "polygon", "lineX", "lineY", "keep", "clear"], T7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, r, i) {
      var a, o, s;
      r.eachComponent({
        mainType: "brush"
      }, function(l) {
        a = l.brushType, o = l.brushOption.brushMode || "single", s = s || !!l.areas.length;
      }), this._brushType = a, this._brushMode = o, $(t.get("type", !0), function(l) {
        t.setIconStatus(l, (l === "keep" ? o === "multiple" : l === "clear" ? s : l === a) ? "emphasis" : "normal");
      });
    }, e.prototype.updateView = function(t, r, i) {
      this.render(t, r, i);
    }, e.prototype.getIcons = function() {
      var t = this.model, r = t.get("icon", !0), i = {};
      return $(t.get("type", !0), function(a) {
        r[a] && (i[a] = r[a]);
      }), i;
    }, e.prototype.onclick = function(t, r, i) {
      var a = this._brushType, o = this._brushMode;
      i === "clear" ? (r.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), r.dispatchAction({
        type: "brush",
        command: "clear",
        // Clear all areas of all brush components.
        areas: []
      })) : r.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: i === "keep" ? a : a === i ? !1 : i,
          brushMode: i === "keep" ? o === "multiple" ? "single" : "multiple" : o
        }
      });
    }, e.getDefaultOption = function(t) {
      var r = {
        show: !0,
        type: E7e.slice(),
        icon: {
          /* eslint-disable */
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
          // jshint ignore:line
          /* eslint-enable */
        },
        // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
        title: t.getLocaleModel().get(["toolbox", "brush", "title"])
      };
      return r;
    }, e;
  }(Ha)
);
function C7e(n) {
  n.registerComponentView(x7e), n.registerComponentModel(S7e), n.registerPreprocessor(d7e), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, m7e), n.registerAction({
    type: "brush",
    event: "brush",
    update: "updateVisual"
  }, function(e, t) {
    t.eachComponent({
      mainType: "brush",
      query: e
    }, function(r) {
      r.setAreas(e.areas);
    });
  }), n.registerAction({
    type: "brushSelect",
    event: "brushSelected",
    update: "none"
  }, dr), n.registerAction({
    type: "brushEnd",
    event: "brushEnd",
    update: "none"
  }, dr), np("brush", T7e);
}
var k7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, t;
    }
    return e.type = "title", e.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    }, e;
  }(Ut)
), A7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      if (this.group.removeAll(), !!t.get("show")) {
        var a = this.group, o = t.getModel("textStyle"), s = t.getModel("subtextStyle"), l = t.get("textAlign"), u = bt(t.get("textBaseline"), t.get("textVerticalAlign")), c = new nn({
          style: Ln(o, {
            text: t.get("text"),
            fill: o.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), d = c.getBoundingRect(), f = t.get("subtext"), p = new nn({
          style: Ln(s, {
            text: f,
            fill: s.getTextColor(),
            y: d.height + t.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), h = t.get("link"), v = t.get("sublink"), m = t.get("triggerEvent", !0);
        c.silent = !h && !m, p.silent = !v && !m, h && c.on("click", function() {
          o_(h, "_" + t.get("target"));
        }), v && p.on("click", function() {
          o_(v, "_" + t.get("subtarget"));
        }), yt(c).eventData = yt(p).eventData = m ? {
          componentType: "title",
          componentIndex: t.componentIndex
        } : null, a.add(c), f && a.add(p);
        var g = a.getBoundingRect(), y = t.getBoxLayoutParams();
        y.width = g.width, y.height = g.height;
        var b = Er(y, {
          width: i.getWidth(),
          height: i.getHeight()
        }, t.get("padding"));
        l || (l = t.get("left") || t.get("right"), l === "middle" && (l = "center"), l === "right" ? b.x += b.width : l === "center" && (b.x += b.width / 2)), u || (u = t.get("top") || t.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? b.y += b.height : u === "middle" && (b.y += b.height / 2), u = u || "top"), a.x = b.x, a.y = b.y, a.markRedraw();
        var _ = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(_), p.setStyle(_), g = a.getBoundingRect();
        var x = b.margin, w = t.getItemStyle(["color", "opacity"]);
        w.fill = t.get("backgroundColor");
        var S = new Qt({
          shape: {
            x: g.x - x[3],
            y: g.y - x[0],
            width: g.width + x[1] + x[3],
            height: g.height + x[0] + x[2],
            r: t.get("borderRadius")
          },
          style: w,
          subPixelOptimize: !0,
          silent: !0
        });
        a.add(S);
      }
    }, e.type = "title", e;
  }(Yn)
);
function M7e(n) {
  n.registerComponentModel(k7e), n.registerComponentView(A7e);
}
var gz = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = "box", t;
    }
    return e.prototype.init = function(t, r, i) {
      this.mergeDefaultAndTheme(t, i), this._initData();
    }, e.prototype.mergeOption = function(t) {
      n.prototype.mergeOption.apply(this, arguments), this._initData();
    }, e.prototype.setCurrentIndex = function(t) {
      t == null && (t = this.option.currentIndex);
      var r = this._data.count();
      this.option.loop ? t = (t % r + r) % r : (t >= r && (t = r - 1), t < 0 && (t = 0)), this.option.currentIndex = t;
    }, e.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, e.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, e.prototype.setPlayState = function(t) {
      this.option.autoPlay = !!t;
    }, e.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, e.prototype._initData = function() {
      var t = this.option, r = t.data || [], i = t.axisType, a = this._names = [], o;
      i === "category" ? (o = [], $(r, function(u, c) {
        var d = wr(uh(u), ""), f;
        ut(u) ? (f = ht(u), f.value = c) : f = c, o.push(f), a.push(d);
      })) : o = r;
      var s = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[i] || "number", l = this._data = new Oi([{
        name: "value",
        type: s
      }], this);
      l.initData(o, a);
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.getCategories = function() {
      if (this.get("axisType") === "category")
        return this._names.slice();
    }, e.type = "timeline", e.defaultOption = {
      // zlevel: 0,                  // 一级层叠
      z: 4,
      show: !0,
      axisType: "time",
      realtime: !0,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      autoPlay: !1,
      rewind: !1,
      loop: !0,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    }, e;
  }(Ut)
), sX = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "timeline.slider", e.defaultOption = Ku(gz.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: !1,
      tooltip: {
        trigger: "item"
        // data item may also have tootip attr.
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: !0,
        width: 2,
        color: "#DAE1F5"
      },
      label: {
        position: "auto",
        // When using number, label position is not
        // restricted by viewRect.
        // positive: right/bottom, negative: left/top
        show: !0,
        interval: "auto",
        rotate: 0,
        // formatter: null,
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#A4B1D7"
      },
      itemStyle: {
        color: "#A4B1D7",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: "#316bf3",
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0, 0, 0, 0.3)",
        // borderColor: 'rgba(194,53,49, 0.5)',
        animation: !0,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: !0,
        showPlayBtn: !0,
        showPrevBtn: !0,
        showNextBtn: !0,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        // eslint-disable-next-line max-len
        nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
        // eslint-disable-next-line max-len
        prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: "#A4B1D7",
        borderColor: "#A4B1D7",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0,
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: "#6f778d"
        },
        itemStyle: {
          color: "#316BF3"
        },
        controlStyle: {
          color: "#316BF3",
          borderColor: "#316BF3",
          borderWidth: 2
        }
      },
      progress: {
        lineStyle: {
          color: "#316BF3"
        },
        itemStyle: {
          color: "#316BF3"
        },
        label: {
          color: "#6f778d"
        }
      },
      data: []
    }), e;
  }(gz)
);
_r(sX, mw.prototype);
var D7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "timeline", e;
  }(Yn)
), O7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e(t, r, i, a) {
      var o = n.call(this, t, r, i) || this;
      return o.type = a || "value", o;
    }
    return e.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, e.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, e;
  }(Po)
), nT = Math.PI, yz = en(), I7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      this.api = r;
    }, e.prototype.render = function(t, r, i) {
      if (this.model = t, this.api = i, this.ecModel = r, this.group.removeAll(), t.get("show", !0)) {
        var a = this._layout(t, i), o = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(a, t);
        t.formatTooltip = function(u) {
          var c = l.scale.getLabel({
            value: u
          });
          return Rr("nameValue", {
            noName: !0,
            value: c
          });
        }, $(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(u) {
          this["_render" + u](a, o, l, t);
        }, this), this._renderAxisLabel(a, s, l, t), this._position(a, t);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, e.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._clearTimer();
    }, e.prototype._layout = function(t, r) {
      var i = t.get(["label", "position"]), a = t.get("orient"), o = N7e(t, r), s;
      i == null || i === "auto" ? s = a === "horizontal" ? o.y + o.height / 2 < r.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < r.getWidth() / 2 ? "+" : "-" : We(i) ? s = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[a][i] : s = i;
      var l = {
        horizontal: "center",
        vertical: s >= 0 || s === "+" ? "left" : "right"
      }, u = {
        horizontal: s >= 0 || s === "+" ? "top" : "bottom",
        vertical: "middle"
      }, c = {
        horizontal: 0,
        vertical: nT / 2
      }, d = a === "vertical" ? o.height : o.width, f = t.getModel("controlStyle"), p = f.get("show", !0), h = p ? f.get("itemSize") : 0, v = p ? f.get("itemGap") : 0, m = h + v, g = t.get(["label", "rotate"]) || 0;
      g = g * nT / 180;
      var y, b, _, x = f.get("position", !0), w = p && f.get("showPlayBtn", !0), S = p && f.get("showPrevBtn", !0), C = p && f.get("showNextBtn", !0), k = 0, M = d;
      x === "left" || x === "bottom" ? (w && (y = [0, 0], k += m), S && (b = [k, 0], k += m), C && (_ = [M - h, 0], M -= m)) : (w && (y = [M - h, 0], M -= m), S && (b = [0, 0], k += m), C && (_ = [M - h, 0], M -= m));
      var D = [k, M];
      return t.get("inverse") && D.reverse(), {
        viewRect: o,
        mainLength: d,
        orient: a,
        rotation: c[a],
        labelRotation: g,
        labelPosOpt: s,
        labelAlign: t.get(["label", "align"]) || l[a],
        labelBaseline: t.get(["label", "verticalAlign"]) || t.get(["label", "baseline"]) || u[a],
        // Based on mainGroup.
        playPosition: y,
        prevBtnPosition: b,
        nextBtnPosition: _,
        axisExtent: D,
        controlSize: h,
        controlGap: v
      };
    }, e.prototype._position = function(t, r) {
      var i = this._mainGroup, a = this._labelGroup, o = t.viewRect;
      if (t.orient === "vertical") {
        var s = ya(), l = o.x, u = o.y + o.height;
        ws(s, s, [-l, -u]), Zd(s, s, -nT / 2), ws(s, s, [l, u]), o = o.clone(), o.applyTransform(s);
      }
      var c = y(o), d = y(i.getBoundingRect()), f = y(a.getBoundingRect()), p = [i.x, i.y], h = [a.x, a.y];
      h[0] = p[0] = c[0][0];
      var v = t.labelPosOpt;
      if (v == null || We(v)) {
        var m = v === "+" ? 0 : 1;
        b(p, d, c, 1, m), b(h, f, c, 1, 1 - m);
      } else {
        var m = v >= 0 ? 0 : 1;
        b(p, d, c, 1, m), h[1] = p[1] + v;
      }
      i.setPosition(p), a.setPosition(h), i.rotation = a.rotation = t.rotation, g(i), g(a);
      function g(_) {
        _.originX = c[0][0] - _.x, _.originY = c[1][0] - _.y;
      }
      function y(_) {
        return [[_.x, _.x + _.width], [_.y, _.y + _.height]];
      }
      function b(_, x, w, S, C) {
        _[S] += w[S][C] - x[S][C];
      }
    }, e.prototype._createAxis = function(t, r) {
      var i = r.getData(), a = r.get("axisType"), o = L7e(r, a);
      o.getTicks = function() {
        return i.mapArray(["value"], function(u) {
          return {
            value: u
          };
        });
      };
      var s = i.getDataExtent("value");
      o.setExtent(s[0], s[1]), o.calcNiceTicks();
      var l = new O7e("value", o, t.axisExtent, a);
      return l.model = r, l;
    }, e.prototype._createGroup = function(t) {
      var r = this[t] = new mt();
      return this.group.add(r), r;
    }, e.prototype._renderAxisLine = function(t, r, i, a) {
      var o = i.getExtent();
      if (a.get(["lineStyle", "show"])) {
        var s = new Dr({
          shape: {
            x1: o[0],
            y1: 0,
            x2: o[1],
            y2: 0
          },
          style: xe({
            lineCap: "round"
          }, a.getModel("lineStyle").getLineStyle()),
          silent: !0,
          z2: 1
        });
        r.add(s);
        var l = this._progressLine = new Dr({
          shape: {
            x1: o[0],
            x2: this._currentPointer ? this._currentPointer.x : o[0],
            y1: 0,
            y2: 0
          },
          style: dt({
            lineCap: "round",
            lineWidth: s.style.lineWidth
          }, a.getModel(["progress", "lineStyle"]).getLineStyle()),
          silent: !0,
          z2: 1
        });
        r.add(l);
      }
    }, e.prototype._renderAxisTick = function(t, r, i, a) {
      var o = this, s = a.getData(), l = i.scale.getTicks();
      this._tickSymbols = [], $(l, function(u) {
        var c = i.dataToCoord(u.value), d = s.getItemModel(u.value), f = d.getModel("itemStyle"), p = d.getModel(["emphasis", "itemStyle"]), h = d.getModel(["progress", "itemStyle"]), v = {
          x: c,
          y: 0,
          onclick: Ze(o._changeTimeline, o, u.value)
        }, m = bz(d, f, r, v);
        m.ensureState("emphasis").style = p.getItemStyle(), m.ensureState("progress").style = h.getItemStyle(), hd(m);
        var g = yt(m);
        d.get("tooltip") ? (g.dataIndex = u.value, g.dataModel = a) : g.dataIndex = g.dataModel = null, o._tickSymbols.push(m);
      });
    }, e.prototype._renderAxisLabel = function(t, r, i, a) {
      var o = this, s = i.getLabelModel();
      if (s.get("show")) {
        var l = a.getData(), u = i.getViewLabels();
        this._tickLabels = [], $(u, function(c) {
          var d = c.tickValue, f = l.getItemModel(d), p = f.getModel("label"), h = f.getModel(["emphasis", "label"]), v = f.getModel(["progress", "label"]), m = i.dataToCoord(c.tickValue), g = new nn({
            x: m,
            y: 0,
            rotation: t.labelRotation - t.rotation,
            onclick: Ze(o._changeTimeline, o, d),
            silent: !1,
            style: Ln(p, {
              text: c.formattedLabel,
              align: t.labelAlign,
              verticalAlign: t.labelBaseline
            })
          });
          g.ensureState("emphasis").style = Ln(h), g.ensureState("progress").style = Ln(v), r.add(g), hd(g), yz(g).dataIndex = d, o._tickLabels.push(g);
        });
      }
    }, e.prototype._renderControl = function(t, r, i, a) {
      var o = t.controlSize, s = t.rotation, l = a.getModel("controlStyle").getItemStyle(), u = a.getModel(["emphasis", "controlStyle"]).getItemStyle(), c = a.getPlayState(), d = a.get("inverse", !0);
      f(t.nextBtnPosition, "next", Ze(this._changeTimeline, this, d ? "-" : "+")), f(t.prevBtnPosition, "prev", Ze(this._changeTimeline, this, d ? "+" : "-")), f(t.playPosition, c ? "stop" : "play", Ze(this._handlePlayClick, this, !c), !0);
      function f(p, h, v, m) {
        if (p) {
          var g = Mo(bt(a.get(["controlStyle", h + "BtnSize"]), o), o), y = [0, -g / 2, g, g], b = R7e(a, h + "Icon", y, {
            x: p[0],
            y: p[1],
            originX: o / 2,
            originY: 0,
            rotation: m ? -s : 0,
            rectHover: !0,
            style: l,
            onclick: v
          });
          b.ensureState("emphasis").style = u, r.add(b), hd(b);
        }
      }
    }, e.prototype._renderCurrentPointer = function(t, r, i, a) {
      var o = a.getData(), s = a.getCurrentIndex(), l = o.getItemModel(s).getModel("checkpointStyle"), u = this, c = {
        onCreate: function(d) {
          d.draggable = !0, d.drift = Ze(u._handlePointerDrag, u), d.ondragend = Ze(u._handlePointerDragend, u), _z(d, u._progressLine, s, i, a, !0);
        },
        onUpdate: function(d) {
          _z(d, u._progressLine, s, i, a);
        }
      };
      this._currentPointer = bz(l, l, this._mainGroup, {}, this._currentPointer, c);
    }, e.prototype._handlePlayClick = function(t) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: t,
        from: this.uid
      });
    }, e.prototype._handlePointerDrag = function(t, r, i) {
      this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY]);
    }, e.prototype._handlePointerDragend = function(t) {
      this._pointerChangeTimeline([t.offsetX, t.offsetY], !0);
    }, e.prototype._pointerChangeTimeline = function(t, r) {
      var i = this._toAxisCoord(t)[0], a = this._axis, o = Ya(a.getExtent().slice());
      i > o[1] && (i = o[1]), i < o[0] && (i = o[0]), this._currentPointer.x = i, this._currentPointer.markRedraw();
      var s = this._progressLine;
      s && (s.shape.x2 = i, s.dirty());
      var l = this._findNearestTick(i), u = this.model;
      (r || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
    }, e.prototype._doPlayStop = function() {
      var t = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var r = t.model;
        t._changeTimeline(r.getCurrentIndex() + (r.get("rewind", !0) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, e.prototype._toAxisCoord = function(t) {
      var r = this._mainGroup.getLocalTransform();
      return wo(t, r, !0);
    }, e.prototype._findNearestTick = function(t) {
      var r = this.model.getData(), i = 1 / 0, a, o = this._axis;
      return r.each(["value"], function(s, l) {
        var u = o.dataToCoord(s), c = Math.abs(u - t);
        c < i && (i = c, a = l);
      }), a;
    }, e.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, e.prototype._changeTimeline = function(t) {
      var r = this.model.getCurrentIndex();
      t === "+" ? t = r + 1 : t === "-" && (t = r - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: t,
        from: this.uid
      });
    }, e.prototype._updateTicksStatus = function() {
      var t = this.model.getCurrentIndex(), r = this._tickSymbols, i = this._tickLabels;
      if (r)
        for (var a = 0; a < r.length; a++)
          r && r[a] && r[a].toggleState("progress", a < t);
      if (i)
        for (var a = 0; a < i.length; a++)
          i && i[a] && i[a].toggleState("progress", yz(i[a]).dataIndex <= t);
    }, e.type = "timeline.slider", e;
  }(D7e)
);
function L7e(n, e) {
  if (e = e || n.get("type"), e)
    switch (e) {
      case "category":
        return new ww({
          ordinalMeta: n.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new mO({
          locale: n.ecModel.getLocaleModel(),
          useUTC: n.ecModel.get("useUTC")
        });
      default:
        return new El();
    }
}
function N7e(n, e) {
  return Er(n.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  }, n.get("padding"));
}
function R7e(n, e, t, r) {
  var i = r.style, a = qg(n.get(["controlStyle", e]), r || {}, new Ot(t[0], t[1], t[2], t[3]));
  return i && a.setStyle(i), a;
}
function bz(n, e, t, r, i, a) {
  var o = e.get("color");
  if (i)
    i.setColor(o), t.add(i), a && a.onUpdate(i);
  else {
    var s = n.get("symbol");
    i = yr(s, -1, -1, 2, 2, o), i.setStyle("strokeNoScale", !0), t.add(i), a && a.onCreate(i);
  }
  var l = e.getItemStyle(["color"]);
  i.setStyle(l), r = At({
    rectHover: !0,
    z2: 100
  }, r, !0);
  var u = _h(n.get("symbolSize"));
  r.scaleX = u[0] / 2, r.scaleY = u[1] / 2;
  var c = ef(n.get("symbolOffset"), u);
  c && (r.x = (r.x || 0) + c[0], r.y = (r.y || 0) + c[1]);
  var d = n.get("symbolRotate");
  return r.rotation = (d || 0) * Math.PI / 180 || 0, i.attr(r), i.updateTransform(), i;
}
function _z(n, e, t, r, i, a) {
  if (!n.dragging) {
    var o = i.getModel("checkpointStyle"), s = r.dataToCoord(i.getData().get("value", t));
    if (a || !o.get("animation", !0))
      n.attr({
        x: s,
        y: 0
      }), e && e.attr({
        shape: {
          x2: s
        }
      });
    else {
      var l = {
        duration: o.get("animationDuration", !0),
        easing: o.get("animationEasing", !0)
      };
      n.stopAnimation(null, !0), n.animateTo({
        x: s,
        y: 0
      }, l), e && e.animateTo({
        shape: {
          x2: s
        }
      }, l);
    }
  }
}
function P7e(n) {
  n.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(e, t, r) {
    var i = t.getComponent("timeline");
    return i && e.currentIndex != null && (i.setCurrentIndex(e.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.getPlayState() && (i.setPlayState(!1), r.dispatchAction({
      type: "timelinePlayChange",
      playState: !1,
      from: e.from
    }))), t.resetOption("timeline", {
      replaceMerge: i.get("replaceMerge", !0)
    }), dt({
      currentIndex: i.option.currentIndex
    }, e);
  }), n.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(e, t) {
    var r = t.getComponent("timeline");
    r && e.playState != null && r.setPlayState(e.playState);
  });
}
function j7e(n) {
  var e = n && n.timeline;
  Me(e) || (e = e ? [e] : []), $(e, function(t) {
    t && B7e(t);
  });
}
function B7e(n) {
  var e = n.type, t = {
    number: "value",
    time: "time"
  };
  if (t[e] && (n.axisType = t[e], delete n.type), xz(n), jc(n, "controlPosition")) {
    var r = n.controlStyle || (n.controlStyle = {});
    jc(r, "position") || (r.position = n.controlPosition), r.position === "none" && !jc(r, "show") && (r.show = !1, delete r.position), delete n.controlPosition;
  }
  $(n.data || [], function(i) {
    ut(i) && !Me(i) && (!jc(i, "value") && jc(i, "name") && (i.value = i.name), xz(i));
  });
}
function xz(n) {
  var e = n.itemStyle || (n.itemStyle = {}), t = e.emphasis || (e.emphasis = {}), r = n.label || n.label || {}, i = r.normal || (r.normal = {}), a = {
    normal: 1,
    emphasis: 1
  };
  $(r, function(o, s) {
    !a[s] && !jc(i, s) && (i[s] = o);
  }), t.label && !jc(r, "emphasis") && (r.emphasis = t.label, delete t.label);
}
function jc(n, e) {
  return n.hasOwnProperty(e);
}
function $7e(n) {
  n.registerComponentModel(sX), n.registerComponentView(I7e), n.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  }), P7e(n), n.registerPreprocessor(j7e);
}
function _I(n, e) {
  if (!n)
    return !1;
  for (var t = Me(n) ? n : [n], r = 0; r < t.length; r++)
    if (t[r] && t[r][e])
      return !0;
  return !1;
}
function K0(n) {
  Od(n, "label", ["show"]);
}
var X0 = en(), Cl = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.createdBySelf = !1, t;
    }
    return e.prototype.init = function(t, r, i) {
      if (process.env.NODE_ENV !== "production" && this.type === "marker")
        throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
      this.mergeDefaultAndTheme(t, i), this._mergeOption(t, i, !1, !0);
    }, e.prototype.isAnimationEnabled = function() {
      if (Vt.node)
        return !1;
      var t = this.__hostSeries;
      return this.getShallow("animation") && t && t.isAnimationEnabled();
    }, e.prototype.mergeOption = function(t, r) {
      this._mergeOption(t, r, !1, !1);
    }, e.prototype._mergeOption = function(t, r, i, a) {
      var o = this.mainType;
      i || r.eachSeries(function(s) {
        var l = s.get(this.mainType, !0), u = X0(s)[o];
        if (!l || !l.data) {
          X0(s)[o] = null;
          return;
        }
        u ? u._mergeOption(l, r, !0) : (a && K0(l), $(l.data, function(c) {
          c instanceof Array ? (K0(c[0]), K0(c[1])) : K0(c);
        }), u = this.createMarkerModelFromSeries(l, this, r), xe(u, {
          mainType: this.mainType,
          // Use the same series index and name
          seriesIndex: s.seriesIndex,
          name: s.name,
          createdBySelf: !0
        }), u.__hostSeries = s), X0(s)[o] = u;
      }, this);
    }, e.prototype.formatTooltip = function(t, r, i) {
      var a = this.getData(), o = this.getRawValue(t), s = a.getName(t);
      return Rr("section", {
        header: this.name,
        blocks: [Rr("nameValue", {
          name: s,
          value: o,
          noName: !s,
          noValue: o == null
        })]
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.setData = function(t) {
      this._data = t;
    }, e.prototype.getDataParams = function(t, r) {
      var i = mw.prototype.getDataParams.call(this, t, r), a = this.__hostSeries;
      return a && (i.seriesId = a.id, i.seriesName = a.name, i.seriesType = a.subType), i;
    }, e.getMarkerModelFromSeries = function(t, r) {
      return X0(t)[r];
    }, e.type = "marker", e.dependencies = ["series", "grid", "polar", "geo"], e;
  }(Ut)
);
_r(Cl, mw.prototype);
var z7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, r, i) {
      return new e(t, r, i);
    }, e.type = "markPoint", e.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      // symbolRotate: 0,
      // symbolOffset: [0, 0]
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, e;
  }(Cl)
);
function gA(n) {
  return !(isNaN(parseFloat(n.x)) && isNaN(parseFloat(n.y)));
}
function F7e(n) {
  return !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
}
function Z0(n, e, t, r, i, a) {
  var o = [], s = Bu(
    e,
    r
    /* , otherDataDim */
  ), l = s ? e.getCalculationInfo("stackResultDimension") : r, u = xI(e, l, n), c = e.indicesOfNearest(l, u)[0];
  o[i] = e.get(t, c), o[a] = e.get(l, c);
  var d = e.get(r, c), f = ss(e.get(r, c));
  return f = Math.min(f, 20), f >= 0 && (o[a] = +o[a].toFixed(f)), [o, d];
}
var rT = {
  min: Tt(Z0, "min"),
  max: Tt(Z0, "max"),
  average: Tt(Z0, "average"),
  median: Tt(Z0, "median")
};
function bg(n, e) {
  if (e) {
    var t = n.getData(), r = n.coordinateSystem, i = r && r.dimensions;
    if (!F7e(e) && !Me(e.coord) && Me(i)) {
      var a = lX(e, t, r, n);
      if (e = ht(e), e.type && rT[e.type] && a.baseAxis && a.valueAxis) {
        var o = Pt(i, a.baseAxis.dim), s = Pt(i, a.valueAxis.dim), l = rT[e.type](t, a.baseDataDim, a.valueDataDim, o, s);
        e.coord = l[0], e.value = l[1];
      } else
        e.coord = [e.xAxis != null ? e.xAxis : e.radiusAxis, e.yAxis != null ? e.yAxis : e.angleAxis];
    }
    if (e.coord == null || !Me(i))
      e.coord = [];
    else
      for (var u = e.coord, c = 0; c < 2; c++)
        rT[u[c]] && (u[c] = xI(t, t.mapDimension(i[c]), u[c]));
    return e;
  }
}
function lX(n, e, t, r) {
  var i = {};
  return n.valueIndex != null || n.valueDim != null ? (i.valueDataDim = n.valueIndex != null ? e.getDimension(n.valueIndex) : n.valueDim, i.valueAxis = t.getAxis(V7e(r, i.valueDataDim)), i.baseAxis = t.getOtherAxis(i.valueAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim)) : (i.baseAxis = r.getBaseAxis(), i.valueAxis = t.getOtherAxis(i.baseAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim), i.valueDataDim = e.mapDimension(i.valueAxis.dim)), i;
}
function V7e(n, e) {
  var t = n.getData().getDimensionInfo(e);
  return t && t.coordDim;
}
function _g(n, e) {
  return n && n.containData && e.coord && !gA(e) ? n.containData(e.coord) : !0;
}
function H7e(n, e, t) {
  return n && n.containZone && e.coord && t.coord && !gA(e) && !gA(t) ? n.containZone(e.coord, t.coord) : !0;
}
function uX(n, e) {
  return n ? function(t, r, i, a) {
    var o = a < 2 ? t.coord && t.coord[a] : t.value;
    return Cu(o, e[a]);
  } : function(t, r, i, a) {
    return Cu(t.value, e[a]);
  };
}
function xI(n, e, t) {
  if (t === "average") {
    var r = 0, i = 0;
    return n.each(e, function(a, o) {
      isNaN(a) || (r += a, i++);
    }), r / i;
  } else return t === "median" ? n.getMedian(e) : n.getDataExtent(e)[t === "max" ? 1 : 0];
}
var iT = en(), wI = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this.markerGroupMap = tt();
    }, e.prototype.render = function(t, r, i) {
      var a = this, o = this.markerGroupMap;
      o.each(function(s) {
        iT(s).keep = !1;
      }), r.eachSeries(function(s) {
        var l = Cl.getMarkerModelFromSeries(s, a.type);
        l && a.renderSeries(s, l, r, i);
      }), o.each(function(s) {
        !iT(s).keep && a.group.remove(s.group);
      });
    }, e.prototype.markKeep = function(t) {
      iT(t).keep = !0;
    }, e.prototype.toggleBlurSeries = function(t, r) {
      var i = this;
      $(t, function(a) {
        var o = Cl.getMarkerModelFromSeries(a, i.type);
        if (o) {
          var s = o.getData();
          s.eachItemGraphicEl(function(l) {
            l && (r ? tU(l) : zD(l));
          });
        }
      });
    }, e.type = "marker", e;
  }(Yn)
);
function wz(n, e, t) {
  var r = e.coordinateSystem;
  n.each(function(i) {
    var a = n.getItemModel(i), o, s = ze(a.get("x"), t.getWidth()), l = ze(a.get("y"), t.getHeight());
    if (!isNaN(s) && !isNaN(l))
      o = [s, l];
    else if (e.getMarkerPosition)
      o = e.getMarkerPosition(n.getValues(n.dimensions, i));
    else if (r) {
      var u = n.get(r.dimensions[0], i), c = n.get(r.dimensions[1], i);
      o = r.dataToPoint([u, c]);
    }
    isNaN(s) || (o[0] = s), isNaN(l) || (o[1] = l), n.setItemLayout(i, o);
  });
}
var G7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, r, i) {
      r.eachSeries(function(a) {
        var o = Cl.getMarkerModelFromSeries(a, "markPoint");
        o && (wz(o.getData(), a, i), this.markerGroupMap.get(a.id).updateLayout());
      }, this);
    }, e.prototype.renderSeries = function(t, r, i, a) {
      var o = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new Jg()), d = U7e(o, t, r);
      r.setData(d), wz(r.getData(), t, a), d.each(function(f) {
        var p = d.getItemModel(f), h = p.getShallow("symbol"), v = p.getShallow("symbolSize"), m = p.getShallow("symbolRotate"), g = p.getShallow("symbolOffset"), y = p.getShallow("symbolKeepAspect");
        if (at(h) || at(v) || at(m) || at(g)) {
          var b = r.getRawValue(f), _ = r.getDataParams(f);
          at(h) && (h = h(b, _)), at(v) && (v = v(b, _)), at(m) && (m = m(b, _)), at(g) && (g = g(b, _));
        }
        var x = p.getModel("itemStyle").getItemStyle(), w = Yg(l, "color");
        x.fill || (x.fill = w), d.setItemVisual(f, {
          symbol: h,
          symbolSize: v,
          symbolRotate: m,
          symbolOffset: g,
          symbolKeepAspect: y,
          style: x
        });
      }), c.updateData(d), this.group.add(c.group), d.eachItemGraphicEl(function(f) {
        f.traverse(function(p) {
          yt(p).dataModel = r;
        });
      }), this.markKeep(c), c.group.silent = r.get("silent") || t.get("silent");
    }, e.type = "markPoint", e;
  }(wI)
);
function U7e(n, e, t) {
  var r;
  n ? r = De(n && n.dimensions, function(s) {
    var l = e.getData().getDimensionInfo(e.getData().mapDimension(s)) || {};
    return xe(xe({}, l), {
      name: s,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : r = [{
    name: "value",
    type: "float"
  }];
  var i = new Oi(r, t), a = De(t.get("data"), Tt(bg, e));
  n && (a = vn(a, Tt(_g, n)));
  var o = uX(!!n, r);
  return i.initData(a, null, o), i;
}
function W7e(n) {
  n.registerComponentModel(z7e), n.registerComponentView(G7e), n.registerPreprocessor(function(e) {
    _I(e.series, "markPoint") && (e.markPoint = e.markPoint || {});
  });
}
var q7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, r, i) {
      return new e(t, r, i);
    }, e.type = "markLine", e.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: ["circle", "arrow"],
      symbolSize: [8, 16],
      // symbolRotate: 0,
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, e;
  }(Cl)
), J0 = en(), Y7e = function(n, e, t, r) {
  var i = n.getData(), a;
  if (Me(r))
    a = r;
  else {
    var o = r.type;
    if (o === "min" || o === "max" || o === "average" || o === "median" || r.xAxis != null || r.yAxis != null) {
      var s = void 0, l = void 0;
      if (r.yAxis != null || r.xAxis != null)
        s = e.getAxis(r.yAxis != null ? "y" : "x"), l = mr(r.yAxis, r.xAxis);
      else {
        var u = lX(r, i, e, n);
        s = u.valueAxis;
        var c = eq(i, u.valueDataDim);
        l = xI(i, c, o);
      }
      var d = s.dim === "x" ? 0 : 1, f = 1 - d, p = ht(r), h = {
        coord: []
      };
      p.type = null, p.coord = [], p.coord[f] = -1 / 0, h.coord[f] = 1 / 0;
      var v = t.get("precision");
      v >= 0 && sn(l) && (l = +l.toFixed(Math.min(v, 20))), p.coord[d] = h.coord[d] = l, a = [p, h, {
        type: o,
        valueIndex: r.valueIndex,
        // Force to use the value of calculated value.
        value: l
      }];
    } else
      process.env.NODE_ENV !== "production" && _o("Invalid markLine data."), a = [];
  }
  var m = [bg(n, a[0]), bg(n, a[1]), xe({}, a[2])];
  return m[2].type = m[2].type || null, At(m[2], m[0]), At(m[2], m[1]), m;
};
function R_(n) {
  return !isNaN(n) && !isFinite(n);
}
function Sz(n, e, t, r) {
  var i = 1 - n, a = r.dimensions[n];
  return R_(e[i]) && R_(t[i]) && e[n] === t[n] && r.getAxis(a).containData(e[n]);
}
function K7e(n, e) {
  if (n.type === "cartesian2d") {
    var t = e[0].coord, r = e[1].coord;
    if (t && r && (Sz(1, t, r, n) || Sz(0, t, r, n)))
      return !0;
  }
  return _g(n, e[0]) && _g(n, e[1]);
}
function aT(n, e, t, r, i) {
  var a = r.coordinateSystem, o = n.getItemModel(e), s, l = ze(o.get("x"), i.getWidth()), u = ze(o.get("y"), i.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (r.getMarkerPosition)
      s = r.getMarkerPosition(n.getValues(n.dimensions, e));
    else {
      var c = a.dimensions, d = n.get(c[0], e), f = n.get(c[1], e);
      s = a.dataToPoint([d, f]);
    }
    if (nf(a, "cartesian2d")) {
      var p = a.getAxis("x"), h = a.getAxis("y"), c = a.dimensions;
      R_(n.get(c[0], e)) ? s[0] = p.toGlobalCoord(p.getExtent()[t ? 0 : 1]) : R_(n.get(c[1], e)) && (s[1] = h.toGlobalCoord(h.getExtent()[t ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  n.setItemLayout(e, s);
}
var X7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, r, i) {
      r.eachSeries(function(a) {
        var o = Cl.getMarkerModelFromSeries(a, "markLine");
        if (o) {
          var s = o.getData(), l = J0(o).from, u = J0(o).to;
          l.each(function(c) {
            aT(l, c, !0, a, i), aT(u, c, !1, a, i);
          }), s.each(function(c) {
            s.setItemLayout(c, [l.getItemLayout(c), u.getItemLayout(c)]);
          }), this.markerGroupMap.get(a.id).updateLayout();
        }
      }, this);
    }, e.prototype.renderSeries = function(t, r, i, a) {
      var o = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new HO());
      this.group.add(c.group);
      var d = Z7e(o, t, r), f = d.from, p = d.to, h = d.line;
      J0(r).from = f, J0(r).to = p, r.setData(h);
      var v = r.get("symbol"), m = r.get("symbolSize"), g = r.get("symbolRotate"), y = r.get("symbolOffset");
      Me(v) || (v = [v, v]), Me(m) || (m = [m, m]), Me(g) || (g = [g, g]), Me(y) || (y = [y, y]), d.from.each(function(_) {
        b(f, _, !0), b(p, _, !1);
      }), h.each(function(_) {
        var x = h.getItemModel(_).getModel("lineStyle").getLineStyle();
        h.setItemLayout(_, [f.getItemLayout(_), p.getItemLayout(_)]), x.stroke == null && (x.stroke = f.getItemVisual(_, "style").fill), h.setItemVisual(_, {
          fromSymbolKeepAspect: f.getItemVisual(_, "symbolKeepAspect"),
          fromSymbolOffset: f.getItemVisual(_, "symbolOffset"),
          fromSymbolRotate: f.getItemVisual(_, "symbolRotate"),
          fromSymbolSize: f.getItemVisual(_, "symbolSize"),
          fromSymbol: f.getItemVisual(_, "symbol"),
          toSymbolKeepAspect: p.getItemVisual(_, "symbolKeepAspect"),
          toSymbolOffset: p.getItemVisual(_, "symbolOffset"),
          toSymbolRotate: p.getItemVisual(_, "symbolRotate"),
          toSymbolSize: p.getItemVisual(_, "symbolSize"),
          toSymbol: p.getItemVisual(_, "symbol"),
          style: x
        });
      }), c.updateData(h), d.line.eachItemGraphicEl(function(_) {
        yt(_).dataModel = r, _.traverse(function(x) {
          yt(x).dataModel = r;
        });
      });
      function b(_, x, w) {
        var S = _.getItemModel(x);
        aT(_, x, w, t, a);
        var C = S.getModel("itemStyle").getItemStyle();
        C.fill == null && (C.fill = Yg(l, "color")), _.setItemVisual(x, {
          symbolKeepAspect: S.get("symbolKeepAspect"),
          // `0` should be considered as a valid value, so use `retrieve2` instead of `||`
          symbolOffset: bt(S.get("symbolOffset", !0), y[w ? 0 : 1]),
          symbolRotate: bt(S.get("symbolRotate", !0), g[w ? 0 : 1]),
          // TODO: when 2d array is supported, it should ignore parent
          symbolSize: bt(S.get("symbolSize"), m[w ? 0 : 1]),
          symbol: bt(S.get("symbol", !0), v[w ? 0 : 1]),
          style: C
        });
      }
      this.markKeep(c), c.group.silent = r.get("silent") || t.get("silent");
    }, e.type = "markLine", e;
  }(wI)
);
function Z7e(n, e, t) {
  var r;
  n ? r = De(n && n.dimensions, function(u) {
    var c = e.getData().getDimensionInfo(e.getData().mapDimension(u)) || {};
    return xe(xe({}, c), {
      name: u,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : r = [{
    name: "value",
    type: "float"
  }];
  var i = new Oi(r, t), a = new Oi(r, t), o = new Oi([], t), s = De(t.get("data"), Tt(Y7e, e, n, t));
  n && (s = vn(s, Tt(K7e, n)));
  var l = uX(!!n, r);
  return i.initData(De(s, function(u) {
    return u[0];
  }), null, l), a.initData(De(s, function(u) {
    return u[1];
  }), null, l), o.initData(De(s, function(u) {
    return u[2];
  })), o.hasItemOption = !0, {
    from: i,
    to: a,
    line: o
  };
}
function J7e(n) {
  n.registerComponentModel(q7e), n.registerComponentView(X7e), n.registerPreprocessor(function(e) {
    _I(e.series, "markLine") && (e.markLine = e.markLine || {});
  });
}
var Q7e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, r, i) {
      return new e(t, r, i);
    }, e.type = "markArea", e.defaultOption = {
      // zlevel: 0,
      // PENDING
      z: 1,
      tooltip: {
        trigger: "item"
      },
      // markArea should fixed on the coordinate system
      animation: !1,
      label: {
        show: !0,
        position: "top"
      },
      itemStyle: {
        // color and borderColor default to use color from series
        // color: 'auto'
        // borderColor: 'auto'
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: !0,
          position: "top"
        }
      }
    }, e;
  }(Cl)
), Q0 = en(), e9e = function(n, e, t, r) {
  var i = r[0], a = r[1];
  if (!(!i || !a)) {
    var o = bg(n, i), s = bg(n, a), l = o.coord, u = s.coord;
    l[0] = mr(l[0], -1 / 0), l[1] = mr(l[1], -1 / 0), u[0] = mr(u[0], 1 / 0), u[1] = mr(u[1], 1 / 0);
    var c = wD([{}, o, s]);
    return c.coord = [o.coord, s.coord], c.x0 = o.x, c.y0 = o.y, c.x1 = s.x, c.y1 = s.y, c;
  }
};
function P_(n) {
  return !isNaN(n) && !isFinite(n);
}
function Ez(n, e, t, r) {
  var i = 1 - n;
  return P_(e[i]) && P_(t[i]);
}
function t9e(n, e) {
  var t = e.coord[0], r = e.coord[1], i = {
    coord: t,
    x: e.x0,
    y: e.y0
  }, a = {
    coord: r,
    x: e.x1,
    y: e.y1
  };
  return nf(n, "cartesian2d") ? t && r && (Ez(1, t, r) || Ez(0, t, r)) ? !0 : H7e(n, i, a) : _g(n, i) || _g(n, a);
}
function Tz(n, e, t, r, i) {
  var a = r.coordinateSystem, o = n.getItemModel(e), s, l = ze(o.get(t[0]), i.getWidth()), u = ze(o.get(t[1]), i.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (r.getMarkerPosition) {
      var c = n.getValues(["x0", "y0"], e), d = n.getValues(["x1", "y1"], e), f = a.clampData(c), p = a.clampData(d), h = [];
      t[0] === "x0" ? h[0] = f[0] > p[0] ? d[0] : c[0] : h[0] = f[0] > p[0] ? c[0] : d[0], t[1] === "y0" ? h[1] = f[1] > p[1] ? d[1] : c[1] : h[1] = f[1] > p[1] ? c[1] : d[1], s = r.getMarkerPosition(h, t, !0);
    } else {
      var v = n.get(t[0], e), m = n.get(t[1], e), g = [v, m];
      a.clampData && a.clampData(g, g), s = a.dataToPoint(g, !0);
    }
    if (nf(a, "cartesian2d")) {
      var y = a.getAxis("x"), b = a.getAxis("y"), v = n.get(t[0], e), m = n.get(t[1], e);
      P_(v) ? s[0] = y.toGlobalCoord(y.getExtent()[t[0] === "x0" ? 0 : 1]) : P_(m) && (s[1] = b.toGlobalCoord(b.getExtent()[t[1] === "y0" ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  return s;
}
var Cz = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]], n9e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, r, i) {
      r.eachSeries(function(a) {
        var o = Cl.getMarkerModelFromSeries(a, "markArea");
        if (o) {
          var s = o.getData();
          s.each(function(l) {
            var u = De(Cz, function(d) {
              return Tz(s, l, d, a, i);
            });
            s.setItemLayout(l, u);
            var c = s.getItemGraphicEl(l);
            c.setShape("points", u);
          });
        }
      }, this);
    }, e.prototype.renderSeries = function(t, r, i, a) {
      var o = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, {
        group: new mt()
      });
      this.group.add(c.group), this.markKeep(c);
      var d = r9e(o, t, r);
      r.setData(d), d.each(function(f) {
        var p = De(Cz, function(C) {
          return Tz(d, f, C, t, a);
        }), h = o.getAxis("x").scale, v = o.getAxis("y").scale, m = h.getExtent(), g = v.getExtent(), y = [h.parse(d.get("x0", f)), h.parse(d.get("x1", f))], b = [v.parse(d.get("y0", f)), v.parse(d.get("y1", f))];
        Ya(y), Ya(b);
        var _ = !(m[0] > y[1] || m[1] < y[0] || g[0] > b[1] || g[1] < b[0]), x = !_;
        d.setItemLayout(f, {
          points: p,
          allClipped: x
        });
        var w = d.getItemModel(f).getModel("itemStyle").getItemStyle(), S = Yg(l, "color");
        w.fill || (w.fill = S, We(w.fill) && (w.fill = Yb(w.fill, 0.4))), w.stroke || (w.stroke = S), d.setItemVisual(f, "style", w);
      }), d.diff(Q0(c).data).add(function(f) {
        var p = d.getItemLayout(f);
        if (!p.allClipped) {
          var h = new Vi({
            shape: {
              points: p.points
            }
          });
          d.setItemGraphicEl(f, h), c.group.add(h);
        }
      }).update(function(f, p) {
        var h = Q0(c).data.getItemGraphicEl(p), v = d.getItemLayout(f);
        v.allClipped ? h && c.group.remove(h) : (h ? ln(h, {
          shape: {
            points: v.points
          }
        }, r, f) : h = new Vi({
          shape: {
            points: v.points
          }
        }), d.setItemGraphicEl(f, h), c.group.add(h));
      }).remove(function(f) {
        var p = Q0(c).data.getItemGraphicEl(f);
        c.group.remove(p);
      }).execute(), d.eachItemGraphicEl(function(f, p) {
        var h = d.getItemModel(p), v = d.getItemVisual(p, "style");
        f.useStyle(d.getItemVisual(p, "style")), ei(f, Nr(h), {
          labelFetcher: r,
          labelDataIndex: p,
          defaultText: d.getName(p) || "",
          inheritColor: We(v.fill) ? Yb(v.fill, 1) : "#000"
        }), Qr(f, h), er(f, null, null, h.get(["emphasis", "disabled"])), yt(f).dataModel = r;
      }), Q0(c).data = d, c.group.silent = r.get("silent") || t.get("silent");
    }, e.type = "markArea", e;
  }(wI)
);
function r9e(n, e, t) {
  var r, i, a = ["x0", "y0", "x1", "y1"];
  if (n) {
    var o = De(n && n.dimensions, function(u) {
      var c = e.getData(), d = c.getDimensionInfo(c.mapDimension(u)) || {};
      return xe(xe({}, d), {
        name: u,
        // DON'T use ordinalMeta to parse and collect ordinal.
        ordinalMeta: null
      });
    });
    i = De(a, function(u, c) {
      return {
        name: u,
        type: o[c % 2].type
      };
    }), r = new Oi(i, t);
  } else
    i = [{
      name: "value",
      type: "float"
    }], r = new Oi(i, t);
  var s = De(t.get("data"), Tt(e9e, e, n, t));
  n && (s = vn(s, Tt(t9e, n)));
  var l = n ? function(u, c, d, f) {
    var p = u.coord[Math.floor(f / 2)][f % 2];
    return Cu(p, i[f]);
  } : function(u, c, d, f) {
    return Cu(u.value, i[f]);
  };
  return r.initData(s, null, l), r.hasItemOption = !0, r;
}
function i9e(n) {
  n.registerComponentModel(Q7e), n.registerComponentView(n9e), n.registerPreprocessor(function(e) {
    _I(e.series, "markArea") && (e.markArea = e.markArea || {});
  });
}
var a9e = function(n, e) {
  if (e === "all")
    return {
      type: "all",
      title: n.getLocaleModel().get(["legend", "selector", "all"])
    };
  if (e === "inverse")
    return {
      type: "inverse",
      title: n.getLocaleModel().get(["legend", "selector", "inverse"])
    };
}, yA = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        // legend.width/height are maxWidth/maxHeight actually,
        // whereas real width/height is calculated by its content.
        // (Setting {left: 10, right: 10} does not make sense).
        // So consider the case:
        // `setOption({legend: {left: 10});`
        // then `setOption({legend: {right: 10});`
        // The previous `left` should be cleared by setting `ignoreSize`.
        ignoreSize: !0
      }, t;
    }
    return e.prototype.init = function(t, r, i) {
      this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}, this._updateSelector(t);
    }, e.prototype.mergeOption = function(t, r) {
      n.prototype.mergeOption.call(this, t, r), this._updateSelector(t);
    }, e.prototype._updateSelector = function(t) {
      var r = t.selector, i = this.ecModel;
      r === !0 && (r = t.selector = ["all", "inverse"]), Me(r) && $(r, function(a, o) {
        We(a) && (a = {
          type: a
        }), r[o] = At(a, a9e(i, a.type));
      });
    }, e.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var t = this._data;
      if (t[0] && this.get("selectedMode") === "single") {
        for (var r = !1, i = 0; i < t.length; i++) {
          var a = t[i].get("name");
          if (this.isSelected(a)) {
            this.select(a), r = !0;
            break;
          }
        }
        !r && this.select(t[0].get("name"));
      }
    }, e.prototype._updateData = function(t) {
      var r = [], i = [];
      t.eachRawSeries(function(l) {
        var u = l.name;
        i.push(u);
        var c;
        if (l.legendVisualProvider) {
          var d = l.legendVisualProvider, f = d.getAllNames();
          t.isSeriesFiltered(l) || (i = i.concat(f)), f.length ? r = r.concat(f) : c = !0;
        } else
          c = !0;
        c && ID(l) && r.push(l.name);
      }), this._availableNames = i;
      var a = this.get("data") || r, o = tt(), s = De(a, function(l) {
        return (We(l) || sn(l)) && (l = {
          name: l
        }), o.get(l.name) ? null : (o.set(l.name, !0), new yn(l, this, this.ecModel));
      }, this);
      this._data = vn(s, function(l) {
        return !!l;
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.select = function(t) {
      var r = this.option.selected, i = this.get("selectedMode");
      if (i === "single") {
        var a = this._data;
        $(a, function(o) {
          r[o.get("name")] = !1;
        });
      }
      r[t] = !0;
    }, e.prototype.unSelect = function(t) {
      this.get("selectedMode") !== "single" && (this.option.selected[t] = !1);
    }, e.prototype.toggleSelected = function(t) {
      var r = this.option.selected;
      r.hasOwnProperty(t) || (r[t] = !0), this[r[t] ? "unSelect" : "select"](t);
    }, e.prototype.allSelect = function() {
      var t = this._data, r = this.option.selected;
      $(t, function(i) {
        r[i.get("name", !0)] = !0;
      });
    }, e.prototype.inverseSelect = function() {
      var t = this._data, r = this.option.selected;
      $(t, function(i) {
        var a = i.get("name", !0);
        r.hasOwnProperty(a) || (r[a] = !0), r[a] = !r[a];
      });
    }, e.prototype.isSelected = function(t) {
      var r = this.option.selected;
      return !(r.hasOwnProperty(t) && !r[t]) && Pt(this._availableNames, t) >= 0;
    }, e.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, e.type = "legend.plain", e.dependencies = ["series"], e.defaultOption = {
      // zlevel: 0,
      z: 4,
      show: !0,
      orient: "horizontal",
      left: "center",
      // right: 'center',
      top: 0,
      // bottom: null,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: !0,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: !0,
      selector: !1,
      selectorLabel: {
        show: !0,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: !0,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: !1
      }
    }, e;
  }(Ut)
), $f = Tt, bA = $, e1 = mt, cX = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = !1, t;
    }
    return e.prototype.init = function() {
      this.group.add(this._contentGroup = new e1()), this.group.add(this._selectorGroup = new e1()), this._isFirstRender = !0;
    }, e.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, e.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, e.prototype.render = function(t, r, i) {
      var a = this._isFirstRender;
      if (this._isFirstRender = !1, this.resetInner(), !!t.get("show", !0)) {
        var o = t.get("align"), s = t.get("orient");
        (!o || o === "auto") && (o = t.get("left") === "right" && s === "vertical" ? "right" : "left");
        var l = t.get("selector", !0), u = t.get("selectorPosition", !0);
        l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(o, t, r, i, l, s, u);
        var c = t.getBoxLayoutParams(), d = {
          width: i.getWidth(),
          height: i.getHeight()
        }, f = t.get("padding"), p = Er(c, d, f), h = this.layoutInner(t, o, p, a, l, u), v = Er(dt({
          width: h.width,
          height: h.height
        }, c), d, f);
        this.group.x = v.x - h.x, this.group.y = v.y - h.y, this.group.markRedraw(), this.group.add(this._backgroundEl = JK(h, t));
      }
    }, e.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, e.prototype.renderInner = function(t, r, i, a, o, s, l) {
      var u = this.getContentGroup(), c = tt(), d = r.get("selectedMode"), f = [];
      i.eachRawSeries(function(p) {
        !p.get("legendHoverLink") && f.push(p.id);
      }), bA(r.getData(), function(p, h) {
        var v = p.get("name");
        if (!this.newlineDisabled && (v === "" || v === `
`)) {
          var m = new e1();
          m.newline = !0, u.add(m);
          return;
        }
        var g = i.getSeriesByName(v)[0];
        if (!c.get(v)) {
          if (g) {
            var y = g.getData(), b = y.getVisual("legendLineStyle") || {}, _ = y.getVisual("legendIcon"), x = y.getVisual("style"), w = this._createItem(g, v, h, p, r, t, b, x, _, d, a);
            w.on("click", $f(kz, v, null, a, f)).on("mouseover", $f(_A, g.name, null, a, f)).on("mouseout", $f(xA, g.name, null, a, f)), i.ssr && w.eachChild(function(S) {
              var C = yt(S);
              C.seriesIndex = g.seriesIndex, C.dataIndex = h, C.ssrType = "legend";
            }), c.set(v, !0);
          } else
            i.eachRawSeries(function(S) {
              if (!c.get(v) && S.legendVisualProvider) {
                var C = S.legendVisualProvider;
                if (!C.containName(v))
                  return;
                var k = C.indexOfName(v), M = C.getItemVisual(k, "style"), D = C.getItemVisual(k, "legendIcon"), N = ba(M.fill);
                N && N[3] === 0 && (N[3] = 0.2, M = xe(xe({}, M), {
                  fill: dl(N, "rgba")
                }));
                var R = this._createItem(S, v, h, p, r, t, {}, M, D, d, a);
                R.on("click", $f(kz, null, v, a, f)).on("mouseover", $f(_A, null, v, a, f)).on("mouseout", $f(xA, null, v, a, f)), i.ssr && R.eachChild(function(j) {
                  var z = yt(j);
                  z.seriesIndex = S.seriesIndex, z.dataIndex = h, z.ssrType = "legend";
                }), c.set(v, !0);
              }
            }, this);
          process.env.NODE_ENV !== "production" && (c.get(v) || console.warn(v + " series not exists. Legend data should be same with series name or data name."));
        }
      }, this), o && this._createSelector(o, r, a, s, l);
    }, e.prototype._createSelector = function(t, r, i, a, o) {
      var s = this.getSelectorGroup();
      bA(t, function(u) {
        var c = u.type, d = new nn({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            i.dispatchAction({
              type: c === "all" ? "legendAllSelect" : "legendInverseSelect",
              legendId: r.id
            });
          }
        });
        s.add(d);
        var f = r.getModel("selectorLabel"), p = r.getModel(["emphasis", "selectorLabel"]);
        ei(d, {
          normal: f,
          emphasis: p
        }, {
          defaultText: u.title
        }), hd(d);
      });
    }, e.prototype._createItem = function(t, r, i, a, o, s, l, u, c, d, f) {
      var p = t.visualDrawType, h = o.get("itemWidth"), v = o.get("itemHeight"), m = o.isSelected(r), g = a.get("symbolRotate"), y = a.get("symbolKeepAspect"), b = a.get("icon");
      c = b || c || "roundRect";
      var _ = o9e(c, a, l, u, p, m, f), x = new e1(), w = a.getModel("textStyle");
      if (at(t.getLegendIcon) && (!b || b === "inherit"))
        x.add(t.getLegendIcon({
          itemWidth: h,
          itemHeight: v,
          icon: c,
          iconRotate: g,
          itemStyle: _.itemStyle,
          lineStyle: _.lineStyle,
          symbolKeepAspect: y
        }));
      else {
        var S = b === "inherit" && t.getData().getVisual("symbol") ? g === "inherit" ? t.getData().getVisual("symbolRotate") : g : 0;
        x.add(s9e({
          itemWidth: h,
          itemHeight: v,
          icon: c,
          iconRotate: S,
          itemStyle: _.itemStyle,
          symbolKeepAspect: y
        }));
      }
      var C = s === "left" ? h + 5 : -5, k = s, M = o.get("formatter"), D = r;
      We(M) && M ? D = M.replace("{name}", r ?? "") : at(M) && (D = M(r));
      var N = m ? w.getTextColor() : a.get("inactiveColor");
      x.add(new nn({
        style: Ln(w, {
          text: D,
          x: C,
          y: v / 2,
          fill: N,
          align: k,
          verticalAlign: "middle"
        }, {
          inheritColor: N
        })
      }));
      var R = new Qt({
        shape: x.getBoundingRect(),
        style: {
          // Cannot use 'invisible' because SVG SSR will miss the node
          fill: "transparent"
        }
      }), j = a.getModel("tooltip");
      return j.get("show") && Jd({
        el: R,
        componentModel: o,
        itemName: r,
        itemTooltipOption: j.option
      }), x.add(R), x.eachChild(function(z) {
        z.silent = !0;
      }), R.silent = !d, this.getContentGroup().add(x), hd(x), x.__legendDataIndex = i, x;
    }, e.prototype.layoutInner = function(t, r, i, a, o, s) {
      var l = this.getContentGroup(), u = this.getSelectorGroup();
      md(t.get("orient"), l, t.get("itemGap"), i.width, i.height);
      var c = l.getBoundingRect(), d = [-c.x, -c.y];
      if (u.markRedraw(), l.markRedraw(), o) {
        md(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          u,
          t.get("selectorItemGap", !0)
        );
        var f = u.getBoundingRect(), p = [-f.x, -f.y], h = t.get("selectorButtonGap", !0), v = t.getOrient().index, m = v === 0 ? "width" : "height", g = v === 0 ? "height" : "width", y = v === 0 ? "y" : "x";
        s === "end" ? p[v] += c[m] + h : d[v] += f[m] + h, p[1 - v] += c[g] / 2 - f[g] / 2, u.x = p[0], u.y = p[1], l.x = d[0], l.y = d[1];
        var b = {
          x: 0,
          y: 0
        };
        return b[m] = c[m] + h + f[m], b[g] = Math.max(c[g], f[g]), b[y] = Math.min(0, f[y] + p[1 - v]), b;
      } else
        return l.x = d[0], l.y = d[1], this.group.getBoundingRect();
    }, e.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = !0;
    }, e.type = "legend.plain", e;
  }(Yn)
);
function o9e(n, e, t, r, i, a, o) {
  function s(m, g) {
    m.lineWidth === "auto" && (m.lineWidth = g.lineWidth > 0 ? 2 : 0), bA(m, function(y, b) {
      m[b] === "inherit" && (m[b] = g[b]);
    });
  }
  var l = e.getModel("itemStyle"), u = l.getItemStyle(), c = n.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", d = l.getShallow("decal");
  u.decal = !d || d === "inherit" ? r.decal : Hp(d, o), u.fill === "inherit" && (u.fill = r[i]), u.stroke === "inherit" && (u.stroke = r[c]), u.opacity === "inherit" && (u.opacity = (i === "fill" ? r : t).opacity), s(u, r);
  var f = e.getModel("lineStyle"), p = f.getLineStyle();
  if (s(p, t), u.fill === "auto" && (u.fill = r.fill), u.stroke === "auto" && (u.stroke = r.fill), p.stroke === "auto" && (p.stroke = r.fill), !a) {
    var h = e.get("inactiveBorderWidth"), v = u[c];
    u.lineWidth = h === "auto" ? r.lineWidth > 0 && v ? 2 : 0 : u.lineWidth, u.fill = e.get("inactiveColor"), u.stroke = e.get("inactiveBorderColor"), p.stroke = f.get("inactiveColor"), p.lineWidth = f.get("inactiveWidth");
  }
  return {
    itemStyle: u,
    lineStyle: p
  };
}
function s9e(n) {
  var e = n.icon || "roundRect", t = yr(e, 0, 0, n.itemWidth, n.itemHeight, n.itemStyle.fill, n.symbolKeepAspect);
  return t.setStyle(n.itemStyle), t.rotation = (n.iconRotate || 0) * Math.PI / 180, t.setOrigin([n.itemWidth / 2, n.itemHeight / 2]), e.indexOf("empty") > -1 && (t.style.stroke = t.style.fill, t.style.fill = "#fff", t.style.lineWidth = 2), t;
}
function kz(n, e, t, r) {
  xA(n, e, t, r), t.dispatchAction({
    type: "legendToggleSelect",
    name: n ?? e
  }), _A(n, e, t, r);
}
function dX(n) {
  for (var e = n.getZr().storage.getDisplayList(), t, r = 0, i = e.length; r < i && !(t = e[r].states.emphasis); )
    r++;
  return t && t.hoverLayer;
}
function _A(n, e, t, r) {
  dX(t) || t.dispatchAction({
    type: "highlight",
    seriesName: n,
    name: e,
    excludeSeriesId: r
  });
}
function xA(n, e, t, r) {
  dX(t) || t.dispatchAction({
    type: "downplay",
    seriesName: n,
    name: e,
    excludeSeriesId: r
  });
}
function l9e(n) {
  var e = n.findComponents({
    mainType: "legend"
  });
  e && e.length && n.filterSeries(function(t) {
    for (var r = 0; r < e.length; r++)
      if (!e[r].isSelected(t.name))
        return !1;
    return !0;
  });
}
function yv(n, e, t) {
  var r = n === "allSelect" || n === "inverseSelect", i = {}, a = [];
  t.eachComponent({
    mainType: "legend",
    query: e
  }, function(s) {
    r ? s[n]() : s[n](e.name), Az(s, i), a.push(s.componentIndex);
  });
  var o = {};
  return t.eachComponent("legend", function(s) {
    $(i, function(l, u) {
      s[l ? "select" : "unSelect"](u);
    }), Az(s, o);
  }), r ? {
    selected: o,
    // return legendIndex array to tell the developers which legends are allSelect / inverseSelect
    legendIndex: a
  } : {
    name: e.name,
    selected: o
  };
}
function Az(n, e) {
  var t = e || {};
  return $(n.getData(), function(r) {
    var i = r.get("name");
    if (!(i === `
` || i === "")) {
      var a = n.isSelected(i);
      Je(t, i) ? t[i] = t[i] && a : t[i] = a;
    }
  }), t;
}
function u9e(n) {
  n.registerAction("legendToggleSelect", "legendselectchanged", Tt(yv, "toggleSelected")), n.registerAction("legendAllSelect", "legendselectall", Tt(yv, "allSelect")), n.registerAction("legendInverseSelect", "legendinverseselect", Tt(yv, "inverseSelect")), n.registerAction("legendSelect", "legendselected", Tt(yv, "select")), n.registerAction("legendUnSelect", "legendunselected", Tt(yv, "unSelect"));
}
function fX(n) {
  n.registerComponentModel(yA), n.registerComponentView(cX), n.registerProcessor(n.PRIORITY.PROCESSOR.SERIES_FILTER, l9e), n.registerSubTypeDefaulter("legend", function() {
    return "plain";
  }), u9e(n);
}
var c9e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.setScrollDataIndex = function(t) {
      this.option.scrollDataIndex = t;
    }, e.prototype.init = function(t, r, i) {
      var a = vh(t);
      n.prototype.init.call(this, t, r, i), Mz(this, t, a);
    }, e.prototype.mergeOption = function(t, r) {
      n.prototype.mergeOption.call(this, t, r), Mz(this, this.option, t);
    }, e.type = "legend.scroll", e.defaultOption = Ku(yA.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
        vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    }), e;
  }(yA)
);
function Mz(n, e, t) {
  var r = n.getOrient(), i = [1, 1];
  i[r.index] = 0, ju(e, t, {
    type: "box",
    ignoreSize: !!i
  });
}
var Dz = mt, oT = ["width", "height"], sT = ["x", "y"], d9e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = !0, t._currentIndex = 0, t;
    }
    return e.prototype.init = function() {
      n.prototype.init.call(this), this.group.add(this._containerGroup = new Dz()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new Dz());
    }, e.prototype.resetInner = function() {
      n.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, e.prototype.renderInner = function(t, r, i, a, o, s, l) {
      var u = this;
      n.prototype.renderInner.call(this, t, r, i, a, o, s, l);
      var c = this._controllerGroup, d = r.get("pageIconSize", !0), f = Me(d) ? d : [d, d];
      h("pagePrev", 0);
      var p = r.getModel("pageTextStyle");
      c.add(new nn({
        name: "pageText",
        style: {
          // Placeholder to calculate a proper layout.
          text: "xx/xx",
          fill: p.getTextColor(),
          font: p.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: !0
      })), h("pageNext", 1);
      function h(v, m) {
        var g = v + "DataIndex", y = qg(r.get("pageIcons", !0)[r.getOrient().name][m], {
          // Buttons will be created in each render, so we do not need
          // to worry about avoiding using legendModel kept in scope.
          onclick: Ze(u._pageGo, u, g, r, a)
        }, {
          x: -f[0] / 2,
          y: -f[1] / 2,
          width: f[0],
          height: f[1]
        });
        y.name = v, c.add(y);
      }
    }, e.prototype.layoutInner = function(t, r, i, a, o, s) {
      var l = this.getSelectorGroup(), u = t.getOrient().index, c = oT[u], d = sT[u], f = oT[1 - u], p = sT[1 - u];
      o && md(
        // Buttons in selectorGroup always layout horizontally
        "horizontal",
        l,
        t.get("selectorItemGap", !0)
      );
      var h = t.get("selectorButtonGap", !0), v = l.getBoundingRect(), m = [-v.x, -v.y], g = ht(i);
      o && (g[c] = i[c] - v[c] - h);
      var y = this._layoutContentAndController(t, a, g, u, c, f, p, d);
      if (o) {
        if (s === "end")
          m[u] += y[c] + h;
        else {
          var b = v[c] + h;
          m[u] -= b, y[d] -= b;
        }
        y[c] += v[c] + h, m[1 - u] += y[p] + y[f] / 2 - v[f] / 2, y[f] = Math.max(y[f], v[f]), y[p] = Math.min(y[p], v[p] + m[1 - u]), l.x = m[0], l.y = m[1], l.markRedraw();
      }
      return y;
    }, e.prototype._layoutContentAndController = function(t, r, i, a, o, s, l, u) {
      var c = this.getContentGroup(), d = this._containerGroup, f = this._controllerGroup;
      md(t.get("orient"), c, t.get("itemGap"), a ? i.width : null, a ? null : i.height), md(
        // Buttons in controller are layout always horizontally.
        "horizontal",
        f,
        t.get("pageButtonItemGap", !0)
      );
      var p = c.getBoundingRect(), h = f.getBoundingRect(), v = this._showController = p[o] > i[o], m = [-p.x, -p.y];
      r || (m[a] = c[u]);
      var g = [0, 0], y = [-h.x, -h.y], b = bt(t.get("pageButtonGap", !0), t.get("itemGap", !0));
      if (v) {
        var _ = t.get("pageButtonPosition", !0);
        _ === "end" ? y[a] += i[o] - h[o] : g[a] += h[o] + b;
      }
      y[1 - a] += p[s] / 2 - h[s] / 2, c.setPosition(m), d.setPosition(g), f.setPosition(y);
      var x = {
        x: 0,
        y: 0
      };
      if (x[o] = v ? i[o] : p[o], x[s] = Math.max(p[s], h[s]), x[l] = Math.min(0, h[l] + y[1 - a]), d.__rectSize = i[o], v) {
        var w = {
          x: 0,
          y: 0
        };
        w[o] = Math.max(i[o] - h[o] - b, 0), w[s] = x[s], d.setClipPath(new Qt({
          shape: w
        })), d.__rectSize = w[o];
      } else
        f.eachChild(function(C) {
          C.attr({
            invisible: !0,
            silent: !0
          });
        });
      var S = this._getPageInfo(t);
      return S.pageIndex != null && ln(
        c,
        {
          x: S.contentPosition[0],
          y: S.contentPosition[1]
        },
        // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        v ? t : null
      ), this._updatePageInfoView(t, S), x;
    }, e.prototype._pageGo = function(t, r, i) {
      var a = this._getPageInfo(r)[t];
      a != null && i.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: a,
        legendId: r.id
      });
    }, e.prototype._updatePageInfoView = function(t, r) {
      var i = this._controllerGroup;
      $(["pagePrev", "pageNext"], function(c) {
        var d = c + "DataIndex", f = r[d] != null, p = i.childOfName(c);
        p && (p.setStyle("fill", f ? t.get("pageIconColor", !0) : t.get("pageIconInactiveColor", !0)), p.cursor = f ? "pointer" : "default");
      });
      var a = i.childOfName("pageText"), o = t.get("pageFormatter"), s = r.pageIndex, l = s != null ? s + 1 : 0, u = r.pageCount;
      a && o && a.setStyle("text", We(o) ? o.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : o({
        current: l,
        total: u
      }));
    }, e.prototype._getPageInfo = function(t) {
      var r = t.get("scrollDataIndex", !0), i = this.getContentGroup(), a = this._containerGroup.__rectSize, o = t.getOrient().index, s = oT[o], l = sT[o], u = this._findTargetItemIndex(r), c = i.children(), d = c[u], f = c.length, p = f ? 1 : 0, h = {
        contentPosition: [i.x, i.y],
        pageCount: p,
        pageIndex: p - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!d)
        return h;
      var v = _(d);
      h.contentPosition[o] = -v.s;
      for (var m = u + 1, g = v, y = v, b = null; m <= f; ++m)
        b = _(c[m]), // Half of the last item is out of the window.
        (!b && y.e > g.s + a || b && !x(b, g.s)) && (y.i > g.i ? g = y : g = b, g && (h.pageNextDataIndex == null && (h.pageNextDataIndex = g.i), ++h.pageCount)), y = b;
      for (var m = u - 1, g = v, y = v, b = null; m >= -1; --m)
        b = _(c[m]), // If the the end item does not intersect with the window started
        // from the current item, a page can be settled.
        (!b || !x(y, b.s)) && g.i < y.i && (y = g, h.pagePrevDataIndex == null && (h.pagePrevDataIndex = g.i), ++h.pageCount, ++h.pageIndex), g = b;
      return h;
      function _(w) {
        if (w) {
          var S = w.getBoundingRect(), C = S[l] + w[l];
          return {
            s: C,
            e: C + S[s],
            i: w.__legendDataIndex
          };
        }
      }
      function x(w, S) {
        return w.e >= S && w.s <= S + a;
      }
    }, e.prototype._findTargetItemIndex = function(t) {
      if (!this._showController)
        return 0;
      var r, i = this.getContentGroup(), a;
      return i.eachChild(function(o, s) {
        var l = o.__legendDataIndex;
        a == null && l != null && (a = s), l === t && (r = s);
      }), r ?? a;
    }, e.type = "legend.scroll", e;
  }(cX)
);
function f9e(n) {
  n.registerAction("legendScroll", "legendscroll", function(e, t) {
    var r = e.scrollDataIndex;
    r != null && t.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: e
    }, function(i) {
      i.setScrollDataIndex(r);
    });
  });
}
function p9e(n) {
  $t(fX), n.registerComponentModel(c9e), n.registerComponentView(d9e), f9e(n);
}
function h9e(n) {
  $t(fX), $t(p9e);
}
var v9e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.inside", e.defaultOption = Ku(yg.defaultOption, {
      disabled: !1,
      zoomLock: !1,
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !1,
      preventDefaultMouseMove: !0
    }), e;
  }(yg)
), SI = en();
function m9e(n, e, t) {
  SI(n).coordSysRecordMap.each(function(r) {
    var i = r.dataZoomInfoMap.get(e.uid);
    i && (i.getRange = t);
  });
}
function g9e(n, e) {
  for (var t = SI(n).coordSysRecordMap, r = t.keys(), i = 0; i < r.length; i++) {
    var a = r[i], o = t.get(a), s = o.dataZoomInfoMap;
    if (s) {
      var l = e.uid, u = s.get(l);
      u && (s.removeKey(l), s.keys().length || pX(t, o));
    }
  }
}
function pX(n, e) {
  if (e) {
    n.removeKey(e.model.uid);
    var t = e.controller;
    t && t.dispose();
  }
}
function y9e(n, e) {
  var t = {
    model: e,
    containsPoint: Tt(_9e, e),
    dispatchAction: Tt(b9e, n),
    dataZoomInfoMap: null,
    controller: null
  }, r = t.controller = new ry(n.getZr());
  return $(["pan", "zoom", "scrollMove"], function(i) {
    r.on(i, function(a) {
      var o = [];
      t.dataZoomInfoMap.each(function(s) {
        if (a.isAvailableBehavior(s.model.option)) {
          var l = (s.getRange || {})[i], u = l && l(s.dzReferCoordSysInfo, t.model.mainType, t.controller, a);
          !s.model.get("disabled", !0) && u && o.push({
            dataZoomId: s.model.id,
            start: u[0],
            end: u[1]
          });
        }
      }), o.length && t.dispatchAction(o);
    });
  }), t;
}
function b9e(n, e) {
  n.isDisposed() || n.dispatchAction({
    type: "dataZoom",
    animation: {
      easing: "cubicOut",
      duration: 100
    },
    batch: e
  });
}
function _9e(n, e, t, r) {
  return n.coordinateSystem.containPoint([t, r]);
}
function x9e(n) {
  var e, t = "type_", r = {
    type_true: 2,
    type_move: 1,
    type_false: 0,
    type_undefined: -1
  }, i = !0;
  return n.each(function(a) {
    var o = a.model, s = o.get("disabled", !0) ? !1 : o.get("zoomLock", !0) ? "move" : !0;
    r[t + s] > r[t + e] && (e = s), i = i && o.get("preventDefaultMouseMove", !0);
  }), {
    controlType: e,
    opt: {
      // RoamController will enable all of these functionalities,
      // and the final behavior is determined by its event listener
      // provided by each inside zoom.
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !0,
      preventDefaultMouseMove: !!i
    }
  };
}
function w9e(n) {
  n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, function(e, t) {
    var r = SI(t), i = r.coordSysRecordMap || (r.coordSysRecordMap = tt());
    i.each(function(a) {
      a.dataZoomInfoMap = null;
    }), e.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(a) {
      var o = KK(a);
      $(o.infoList, function(s) {
        var l = s.model.uid, u = i.get(l) || i.set(l, y9e(t, s.model)), c = u.dataZoomInfoMap || (u.dataZoomInfoMap = tt());
        c.set(a.uid, {
          dzReferCoordSysInfo: s,
          model: a,
          getRange: null
        });
      });
    }), i.each(function(a) {
      var o = a.controller, s, l = a.dataZoomInfoMap;
      if (l) {
        var u = l.keys()[0];
        u != null && (s = l.get(u));
      }
      if (!s) {
        pX(i, a);
        return;
      }
      var c = x9e(l);
      o.enable(c.controlType, c.opt), o.setPointerChecker(a.containsPoint), bh(a, "dispatchAction", s.model.get("throttle", !0), "fixRate");
    });
  });
}
var S9e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "dataZoom.inside", t;
    }
    return e.prototype.render = function(t, r, i) {
      if (n.prototype.render.apply(this, arguments), t.noTarget()) {
        this._clear();
        return;
      }
      this.range = t.getPercentRange(), m9e(i, t, {
        pan: Ze(lT.pan, this),
        zoom: Ze(lT.zoom, this),
        scrollMove: Ze(lT.scrollMove, this)
      });
    }, e.prototype.dispose = function() {
      this._clear(), n.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      g9e(this.api, this.dataZoomModel), this.range = null;
    }, e.type = "dataZoom.inside", e;
  }(hI)
), lT = {
  zoom: function(n, e, t, r) {
    var i = this.range, a = i.slice(), o = n.axisModels[0];
    if (o) {
      var s = uT[e](null, [r.originX, r.originY], o, t, n), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0], u = Math.max(1 / r.scale, 0);
      a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;
      var c = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      if (af(0, a, [0, 100], 0, c.minSpan, c.maxSpan), this.range = a, i[0] !== a[0] || i[1] !== a[1])
        return a;
    }
  },
  pan: Oz(function(n, e, t, r, i, a) {
    var o = uT[r]([a.oldX, a.oldY], [a.newX, a.newY], e, i, t);
    return o.signal * (n[1] - n[0]) * o.pixel / o.pixelLength;
  }),
  scrollMove: Oz(function(n, e, t, r, i, a) {
    var o = uT[r]([0, 0], [a.scrollDelta, a.scrollDelta], e, i, t);
    return o.signal * (n[1] - n[0]) * a.scrollDelta;
  })
};
function Oz(n) {
  return function(e, t, r, i) {
    var a = this.range, o = a.slice(), s = e.axisModels[0];
    if (s) {
      var l = n(o, s, e, t, r, i);
      if (af(l, o, [0, 100], "all"), this.range = o, a[0] !== o[0] || a[1] !== o[1])
        return o;
    }
  };
}
var uT = {
  grid: function(n, e, t, r, i) {
    var a = t.axis, o = {}, s = i.model.coordinateSystem.getRect();
    return n = n || [0, 0], a.dim === "x" ? (o.pixel = e[0] - n[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - n[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o;
  },
  polar: function(n, e, t, r, i) {
    var a = t.axis, o = {}, s = i.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), u = s.getAngleAxis().getExtent();
    return n = n ? s.pointToCoord(n) : [0, 0], e = s.pointToCoord(e), t.mainType === "radiusAxis" ? (o.pixel = e[0] - n[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - n[1], o.pixelLength = u[1] - u[0], o.pixelStart = u[0], o.signal = a.inverse ? -1 : 1), o;
  },
  singleAxis: function(n, e, t, r, i) {
    var a = t.axis, o = i.model.coordinateSystem.getRect(), s = {};
    return n = n || [0, 0], a.orient === "horizontal" ? (s.pixel = e[0] - n[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = e[1] - n[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s;
  }
};
function hX(n) {
  vI(n), n.registerComponentModel(v9e), n.registerComponentView(S9e), w9e(n);
}
var E9e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.slider", e.layoutMode = "box", e.defaultOption = Ku(yg.defaultOption, {
      show: !0,
      // deault value can only be drived in view stage.
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      // dataBackgroundColor: '#ddd',
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      // Color of selected window.
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      // Percent of the slider height
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: !0,
      showDataShadow: "auto",
      realtime: !0,
      zoomLock: !1,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: !0,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleLabel: {
          show: !0
        },
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    }), e;
  }(yg)
), bv = Qt, Iz = 7, T9e = 1, cT = 30, C9e = 7, _v = "horizontal", Lz = "vertical", k9e = 5, A9e = ["line", "bar", "candlestick", "scatter"], M9e = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
}, D9e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._displayables = {}, t;
    }
    return e.prototype.init = function(t, r) {
      this.api = r, this._onBrush = Ze(this._onBrush, this), this._onBrushEnd = Ze(this._onBrushEnd, this);
    }, e.prototype.render = function(t, r, i, a) {
      if (n.prototype.render.apply(this, arguments), bh(this, "_dispatchZoomAction", t.get("throttle"), "fixRate"), this._orient = t.getOrient(), t.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      if (t.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!a || a.type !== "dataZoom" || a.from !== this.uid) && this._buildView(), this._updateView();
    }, e.prototype.dispose = function() {
      this._clear(), n.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      ag(this, "_dispatchZoomAction");
      var t = this.api.getZr();
      t.off("mousemove", this._onBrush), t.off("mouseup", this._onBrushEnd);
    }, e.prototype._buildView = function() {
      var t = this.group;
      t.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var r = this._displayables.sliderGroup = new mt();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(r), this._positionGroup();
    }, e.prototype._resetLocation = function() {
      var t = this.dataZoomModel, r = this.api, i = t.get("brushSelect"), a = i ? C9e : 0, o = this._findCoordRect(), s = {
        width: r.getWidth(),
        height: r.getHeight()
      }, l = this._orient === _v ? {
        // Why using 'right', because right should be used in vertical,
        // and it is better to be consistent for dealing with position param merge.
        right: s.width - o.x - o.width,
        top: s.height - cT - Iz - a,
        width: o.width,
        height: cT
      } : {
        right: Iz,
        top: o.y,
        width: cT,
        height: o.height
      }, u = vh(t.option);
      $(["right", "top", "width", "height"], function(d) {
        u[d] === "ph" && (u[d] = l[d]);
      });
      var c = Er(u, s);
      this._location = {
        x: c.x,
        y: c.y
      }, this._size = [c.width, c.height], this._orient === Lz && this._size.reverse();
    }, e.prototype._positionGroup = function() {
      var t = this.group, r = this._location, i = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), o = a && a.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
      s.attr(i === _v && !o ? {
        scaleY: l ? 1 : -1,
        scaleX: 1
      } : i === _v && o ? {
        scaleY: l ? 1 : -1,
        scaleX: -1
      } : i === Lz && !o ? {
        scaleY: l ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: l ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var u = t.getBoundingRect([s]);
      t.x = r.x - u.x, t.y = r.y - u.y, t.markRedraw();
    }, e.prototype._getViewExtent = function() {
      return [0, this._size[0]];
    }, e.prototype._renderBackground = function() {
      var t = this.dataZoomModel, r = this._size, i = this._displayables.sliderGroup, a = t.get("brushSelect");
      i.add(new bv({
        silent: !0,
        shape: {
          x: 0,
          y: 0,
          width: r[0],
          height: r[1]
        },
        style: {
          fill: t.get("backgroundColor")
        },
        z2: -40
      }));
      var o = new bv({
        shape: {
          x: 0,
          y: 0,
          width: r[0],
          height: r[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: Ze(this._onClickPanel, this)
      }), s = this.api.getZr();
      a ? (o.on("mousedown", this._onBrushStart, this), o.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), i.add(o);
    }, e.prototype._renderDataShadow = function() {
      var t = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !t)
        return;
      var r = this._size, i = this._shadowSize || [], a = t.series, o = a.getRawData(), s = a.getShadowDim && a.getShadowDim(), l = s && o.getDimensionInfo(s) ? a.getShadowDim() : t.otherDim;
      if (l == null)
        return;
      var u = this._shadowPolygonPts, c = this._shadowPolylinePts;
      if (o !== this._shadowData || l !== this._shadowDim || r[0] !== i[0] || r[1] !== i[1]) {
        var d = o.getDataExtent(l), f = (d[1] - d[0]) * 0.3;
        d = [d[0] - f, d[1] + f];
        var p = [0, r[1]], h = [0, r[0]], v = [[r[0], 0], [0, 0]], m = [], g = h[1] / (o.count() - 1), y = 0, b = Math.round(o.count() / r[0]), _;
        o.each([l], function(k, M) {
          if (b > 0 && M % b) {
            y += g;
            return;
          }
          var D = k == null || isNaN(k) || k === "", N = D ? 0 : mn(k, d, p, !0);
          D && !_ && M ? (v.push([v[v.length - 1][0], 0]), m.push([m[m.length - 1][0], 0])) : !D && _ && (v.push([y, 0]), m.push([y, 0])), v.push([y, N]), m.push([y, N]), y += g, _ = D;
        }), u = this._shadowPolygonPts = v, c = this._shadowPolylinePts = m;
      }
      this._shadowData = o, this._shadowDim = l, this._shadowSize = [r[0], r[1]];
      var x = this.dataZoomModel;
      function w(k) {
        var M = x.getModel(k ? "selectedDataBackground" : "dataBackground"), D = new mt(), N = new Vi({
          shape: {
            points: u
          },
          segmentIgnoreThreshold: 1,
          style: M.getModel("areaStyle").getAreaStyle(),
          silent: !0,
          z2: -20
        }), R = new Hi({
          shape: {
            points: c
          },
          segmentIgnoreThreshold: 1,
          style: M.getModel("lineStyle").getLineStyle(),
          silent: !0,
          z2: -19
        });
        return D.add(N), D.add(R), D;
      }
      for (var S = 0; S < 3; S++) {
        var C = w(S === 1);
        this._displayables.sliderGroup.add(C), this._displayables.dataShadowSegs.push(C);
      }
    }, e.prototype._prepareDataShadowInfo = function() {
      var t = this.dataZoomModel, r = t.get("showDataShadow");
      if (r !== !1) {
        var i, a = this.ecModel;
        return t.eachTargetAxis(function(o, s) {
          var l = t.getAxisProxy(o, s).getTargetSeriesModels();
          $(l, function(u) {
            if (!i && !(r !== !0 && Pt(A9e, u.get("type")) < 0)) {
              var c = a.getComponent(bu(o), s).axis, d = O9e(o), f, p = u.coordinateSystem;
              d != null && p.getOtherAxis && (f = p.getOtherAxis(c).inverse), d = u.getData().mapDimension(d), i = {
                thisAxis: c,
                series: u,
                thisDim: o,
                otherDim: d,
                otherAxisInverse: f
              };
            }
          }, this);
        }, this), i;
      }
    }, e.prototype._renderHandle = function() {
      var t = this.group, r = this._displayables, i = r.handles = [null, null], a = r.handleLabels = [null, null], o = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, u = this.api, c = l.get("borderRadius") || 0, d = l.get("brushSelect"), f = r.filler = new bv({
        silent: d,
        style: {
          fill: l.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      o.add(f), o.add(new bv({
        silent: !0,
        subPixelOptimize: !0,
        shape: {
          x: 0,
          y: 0,
          width: s[0],
          height: s[1],
          r: c
        },
        style: {
          // deprecated option
          stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
          lineWidth: T9e,
          fill: "rgba(0,0,0,0)"
        }
      })), $([0, 1], function(b) {
        var _ = l.get("handleIcon");
        !c_[_] && _.indexOf("path://") < 0 && _.indexOf("image://") < 0 && (_ = "path://" + _, process.env.NODE_ENV !== "production" && Do("handleIcon now needs 'path://' prefix when using a path string"));
        var x = yr(_, -1, 0, 2, 2, null, !0);
        x.attr({
          cursor: Nz(this._orient),
          draggable: !0,
          drift: Ze(this._onDragMove, this, b),
          ondragend: Ze(this._onDragEnd, this),
          onmouseover: Ze(this._showDataInfo, this, !0),
          onmouseout: Ze(this._showDataInfo, this, !1),
          z2: 5
        });
        var w = x.getBoundingRect(), S = l.get("handleSize");
        this._handleHeight = ze(S, this._size[1]), this._handleWidth = w.width / w.height * this._handleHeight, x.setStyle(l.getModel("handleStyle").getItemStyle()), x.style.strokeNoScale = !0, x.rectHover = !0, x.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), hd(x);
        var C = l.get("handleColor");
        C != null && (x.style.fill = C), o.add(i[b] = x);
        var k = l.getModel("textStyle"), M = l.get("handleLabel") || {}, D = M.show || !1;
        t.add(a[b] = new nn({
          silent: !0,
          invisible: !D,
          style: Ln(k, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: k.getTextColor(),
            font: k.getFont()
          }),
          z2: 10
        }));
      }, this);
      var p = f;
      if (d) {
        var h = ze(l.get("moveHandleSize"), s[1]), v = r.moveHandle = new Qt({
          style: l.getModel("moveHandleStyle").getItemStyle(),
          silent: !0,
          shape: {
            r: [0, 0, 2, 2],
            y: s[1] - 0.5,
            height: h
          }
        }), m = h * 0.8, g = r.moveHandleIcon = yr(l.get("moveHandleIcon"), -m / 2, -m / 2, m, m, "#fff", !0);
        g.silent = !0, g.y = s[1] + h / 2 - 0.5, v.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
        var y = Math.min(s[1] / 2, Math.max(h, 10));
        p = r.moveZone = new Qt({
          invisible: !0,
          shape: {
            y: s[1] - y,
            height: h + y
          }
        }), p.on("mouseover", function() {
          u.enterEmphasis(v);
        }).on("mouseout", function() {
          u.leaveEmphasis(v);
        }), o.add(v), o.add(g), o.add(p);
      }
      p.attr({
        draggable: !0,
        cursor: Nz(this._orient),
        drift: Ze(this._onDragMove, this, "all"),
        ondragstart: Ze(this._showDataInfo, this, !0),
        ondragend: Ze(this._onDragEnd, this),
        onmouseover: Ze(this._showDataInfo, this, !0),
        onmouseout: Ze(this._showDataInfo, this, !1)
      });
    }, e.prototype._resetInterval = function() {
      var t = this._range = this.dataZoomModel.getPercentRange(), r = this._getViewExtent();
      this._handleEnds = [mn(t[0], [0, 100], r, !0), mn(t[1], [0, 100], r, !0)];
    }, e.prototype._updateInterval = function(t, r) {
      var i = this.dataZoomModel, a = this._handleEnds, o = this._getViewExtent(), s = i.findRepresentativeAxisProxy().getMinMaxSpan(), l = [0, 100];
      af(r, a, o, i.get("zoomLock") ? "all" : t, s.minSpan != null ? mn(s.minSpan, l, o, !0) : null, s.maxSpan != null ? mn(s.maxSpan, l, o, !0) : null);
      var u = this._range, c = this._range = Ya([mn(a[0], o, l, !0), mn(a[1], o, l, !0)]);
      return !u || u[0] !== c[0] || u[1] !== c[1];
    }, e.prototype._updateView = function(t) {
      var r = this._displayables, i = this._handleEnds, a = Ya(i.slice()), o = this._size;
      $([0, 1], function(p) {
        var h = r.handles[p], v = this._handleHeight;
        h.attr({
          scaleX: v / 2,
          scaleY: v / 2,
          // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
          // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
          x: i[p] + (p ? -1 : 1),
          y: o[1] / 2 - v / 2
        });
      }, this), r.filler.setShape({
        x: a[0],
        y: 0,
        width: a[1] - a[0],
        height: o[1]
      });
      var s = {
        x: a[0],
        width: a[1] - a[0]
      };
      r.moveHandle && (r.moveHandle.setShape(s), r.moveZone.setShape(s), r.moveZone.getBoundingRect(), r.moveHandleIcon && r.moveHandleIcon.attr("x", s.x + s.width / 2));
      for (var l = r.dataShadowSegs, u = [0, a[0], a[1], o[0]], c = 0; c < l.length; c++) {
        var d = l[c], f = d.getClipPath();
        f || (f = new Qt(), d.setClipPath(f)), f.setShape({
          x: u[c],
          y: 0,
          width: u[c + 1] - u[c],
          height: o[1]
        });
      }
      this._updateDataInfo(t);
    }, e.prototype._updateDataInfo = function(t) {
      var r = this.dataZoomModel, i = this._displayables, a = i.handleLabels, o = this._orient, s = ["", ""];
      if (r.get("showDetail")) {
        var l = r.findRepresentativeAxisProxy();
        if (l) {
          var u = l.getAxisModel().axis, c = this._range, d = t ? l.calculateDataWindow({
            start: c[0],
            end: c[1]
          }).valueWindow : l.getDataValueWindow();
          s = [this._formatLabel(d[0], u), this._formatLabel(d[1], u)];
        }
      }
      var f = Ya(this._handleEnds.slice());
      p.call(this, 0), p.call(this, 1);
      function p(h) {
        var v = vd(i.handles[h].parent, this.group), m = sw(h === 0 ? "right" : "left", v), g = this._handleWidth / 2 + k9e, y = wo([f[h] + (h === 0 ? -g : g), this._size[1] / 2], v);
        a[h].setStyle({
          x: y[0],
          y: y[1],
          verticalAlign: o === _v ? "middle" : m,
          align: o === _v ? m : "center",
          text: s[h]
        });
      }
    }, e.prototype._formatLabel = function(t, r) {
      var i = this.dataZoomModel, a = i.get("labelFormatter"), o = i.get("labelPrecision");
      (o == null || o === "auto") && (o = r.getPixelPrecision());
      var s = t == null || isNaN(t) ? "" : r.type === "category" || r.type === "time" ? r.scale.getLabel({
        value: Math.round(t)
      }) : t.toFixed(Math.min(o, 20));
      return at(a) ? a(t, s) : We(a) ? a.replace("{value}", s) : s;
    }, e.prototype._showDataInfo = function(t) {
      var r = this.dataZoomModel.get("handleLabel") || {}, i = r.show || !1, a = this.dataZoomModel.getModel(["emphasis", "handleLabel"]), o = a.get("show") || !1, s = t || this._dragging ? o : i, l = this._displayables, u = l.handleLabels;
      u[0].attr("invisible", !s), u[1].attr("invisible", !s), l.moveHandle && this.api[s ? "enterEmphasis" : "leaveEmphasis"](l.moveHandle, 1);
    }, e.prototype._onDragMove = function(t, r, i, a) {
      this._dragging = !0, bl(a.event);
      var o = this._displayables.sliderGroup.getLocalTransform(), s = wo([r, i], o, !0), l = this._updateInterval(t, s[0]), u = this.dataZoomModel.get("realtime");
      this._updateView(!u), l && u && this._dispatchZoomAction(!0);
    }, e.prototype._onDragEnd = function() {
      this._dragging = !1, this._showDataInfo(!1);
      var t = this.dataZoomModel.get("realtime");
      !t && this._dispatchZoomAction(!1);
    }, e.prototype._onClickPanel = function(t) {
      var r = this._size, i = this._displayables.sliderGroup.transformCoordToLocal(t.offsetX, t.offsetY);
      if (!(i[0] < 0 || i[0] > r[0] || i[1] < 0 || i[1] > r[1])) {
        var a = this._handleEnds, o = (a[0] + a[1]) / 2, s = this._updateInterval("all", i[0] - o);
        this._updateView(), s && this._dispatchZoomAction(!1);
      }
    }, e.prototype._onBrushStart = function(t) {
      var r = t.offsetX, i = t.offsetY;
      this._brushStart = new Mt(r, i), this._brushing = !0, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, e.prototype._onBrushEnd = function(t) {
      if (this._brushing) {
        var r = this._displayables.brushRect;
        if (this._brushing = !1, !!r) {
          r.attr("ignore", !0);
          var i = r.shape, a = +/* @__PURE__ */ new Date();
          if (!(a - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
            var o = this._getViewExtent(), s = [0, 100];
            this._range = Ya([mn(i.x, o, s, !0), mn(i.x + i.width, o, s, !0)]), this._handleEnds = [i.x, i.x + i.width], this._updateView(), this._dispatchZoomAction(!1);
          }
        }
      }
    }, e.prototype._onBrush = function(t) {
      this._brushing && (bl(t.event), this._updateBrushRect(t.offsetX, t.offsetY));
    }, e.prototype._updateBrushRect = function(t, r) {
      var i = this._displayables, a = this.dataZoomModel, o = i.brushRect;
      o || (o = i.brushRect = new bv({
        silent: !0,
        style: a.getModel("brushStyle").getItemStyle()
      }), i.sliderGroup.add(o)), o.attr("ignore", !1);
      var s = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(t, r), c = l.transformCoordToLocal(s.x, s.y), d = this._size;
      u[0] = Math.max(Math.min(d[0], u[0]), 0), o.setShape({
        x: c[0],
        y: 0,
        width: u[0] - c[0],
        height: d[1]
      });
    }, e.prototype._dispatchZoomAction = function(t) {
      var r = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: t ? M9e : null,
        start: r[0],
        end: r[1]
      });
    }, e.prototype._findCoordRect = function() {
      var t, r = KK(this.dataZoomModel).infoList;
      if (!t && r.length) {
        var i = r[0].model.coordinateSystem;
        t = i.getRect && i.getRect();
      }
      if (!t) {
        var a = this.api.getWidth(), o = this.api.getHeight();
        t = {
          x: a * 0.2,
          y: o * 0.2,
          width: a * 0.6,
          height: o * 0.6
        };
      }
      return t;
    }, e.type = "dataZoom.slider", e;
  }(hI)
);
function O9e(n) {
  var e = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return e[n];
}
function Nz(n) {
  return n === "vertical" ? "ns-resize" : "ew-resize";
}
function vX(n) {
  n.registerComponentModel(E9e), n.registerComponentView(D9e), vI(n);
}
function I9e(n) {
  $t(hX), $t(vX);
}
var mX = {
  /**
   * @public
   */
  get: function(n, e, t) {
    var r = ht((L9e[n] || {})[e]);
    return t && Me(r) ? r[r.length - 1] : r;
  }
}, L9e = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: ["rgba(0,0,0,0)"]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
}, Rz = Lr.mapVisual, N9e = Lr.eachVisual, R9e = Me, Pz = $, P9e = Ya, j9e = mn, j_ = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.stateList = ["inRange", "outOfRange"], t.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], t.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, t.dataBound = [-1 / 0, 1 / 0], t.targetVisuals = {}, t.controllerVisuals = {}, t;
    }
    return e.prototype.init = function(t, r, i) {
      this.mergeDefaultAndTheme(t, i);
    }, e.prototype.optionUpdated = function(t, r) {
      var i = this.option;
      !r && aX(i, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, e.prototype.resetVisual = function(t) {
      var r = this.stateList;
      t = Ze(t, this), this.controllerVisuals = vA(this.option.controller, r, t), this.targetVisuals = vA(this.option.target, r, t);
    }, e.prototype.getItemSymbol = function() {
      return null;
    }, e.prototype.getTargetSeriesIndices = function() {
      var t = this.option.seriesIndex, r = [];
      return t == null || t === "all" ? this.ecModel.eachSeries(function(i, a) {
        r.push(a);
      }) : r = wn(t), r;
    }, e.prototype.eachTargetSeries = function(t, r) {
      $(this.getTargetSeriesIndices(), function(i) {
        var a = this.ecModel.getSeriesByIndex(i);
        a && t.call(r, a);
      }, this);
    }, e.prototype.isTargetSeries = function(t) {
      var r = !1;
      return this.eachTargetSeries(function(i) {
        i === t && (r = !0);
      }), r;
    }, e.prototype.formatValueText = function(t, r, i) {
      var a = this.option, o = a.precision, s = this.dataBound, l = a.formatter, u;
      i = i || ["<", ">"], Me(t) && (t = t.slice(), u = !0);
      var c = r ? t : u ? [d(t[0]), d(t[1])] : d(t);
      if (We(l))
        return l.replace("{value}", u ? c[0] : c).replace("{value2}", u ? c[1] : c);
      if (at(l))
        return u ? l(t[0], t[1]) : l(t);
      if (u)
        return t[0] === s[0] ? i[0] + " " + c[1] : t[1] === s[1] ? i[1] + " " + c[0] : c[0] + " - " + c[1];
      return c;
      function d(f) {
        return f === s[0] ? "min" : f === s[1] ? "max" : (+f).toFixed(Math.min(o, 20));
      }
    }, e.prototype.resetExtent = function() {
      var t = this.option, r = P9e([t.min, t.max]);
      this._dataExtent = r;
    }, e.prototype.getDataDimensionIndex = function(t) {
      var r = this.option.dimension;
      if (r != null)
        return t.getDimensionIndex(r);
      for (var i = t.dimensions, a = i.length - 1; a >= 0; a--) {
        var o = i[a], s = t.getDimensionInfo(o);
        if (!s.isCalculationCoord)
          return s.storeDimIndex;
      }
    }, e.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, e.prototype.completeVisualOption = function() {
      var t = this.ecModel, r = this.option, i = {
        inRange: r.inRange,
        outOfRange: r.outOfRange
      }, a = r.target || (r.target = {}), o = r.controller || (r.controller = {});
      At(a, i), At(o, i);
      var s = this.isCategory();
      l.call(this, a), l.call(this, o), u.call(this, a, "inRange", "outOfRange"), c.call(this, o);
      function l(d) {
        R9e(r.color) && !d.inRange && (d.inRange = {
          color: r.color.slice().reverse()
        }), d.inRange = d.inRange || {
          color: t.get("gradientColor")
        };
      }
      function u(d, f, p) {
        var h = d[f], v = d[p];
        h && !v && (v = d[p] = {}, Pz(h, function(m, g) {
          if (Lr.isValidType(g)) {
            var y = mX.get(g, "inactive", s);
            y != null && (v[g] = y, g === "color" && !v.hasOwnProperty("opacity") && !v.hasOwnProperty("colorAlpha") && (v.opacity = [0, 0]));
          }
        }));
      }
      function c(d) {
        var f = (d.inRange || {}).symbol || (d.outOfRange || {}).symbol, p = (d.inRange || {}).symbolSize || (d.outOfRange || {}).symbolSize, h = this.get("inactiveColor"), v = this.getItemSymbol(), m = v || "roundRect";
        Pz(this.stateList, function(g) {
          var y = this.itemSize, b = d[g];
          b || (b = d[g] = {
            color: s ? h : [h]
          }), b.symbol == null && (b.symbol = f && ht(f) || (s ? m : [m])), b.symbolSize == null && (b.symbolSize = p && ht(p) || (s ? y[0] : [y[0], y[0]])), b.symbol = Rz(b.symbol, function(w) {
            return w === "none" ? m : w;
          });
          var _ = b.symbolSize;
          if (_ != null) {
            var x = -1 / 0;
            N9e(_, function(w) {
              w > x && (x = w);
            }), b.symbolSize = Rz(_, function(w) {
              return j9e(w, [0, x], [0, y[0]], !0);
            });
          }
        }, this);
      }
    }, e.prototype.resetItemSize = function() {
      this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
    }, e.prototype.isCategory = function() {
      return !!this.option.categories;
    }, e.prototype.setSelected = function(t) {
    }, e.prototype.getSelected = function() {
      return null;
    }, e.prototype.getValueState = function(t) {
      return null;
    }, e.prototype.getVisualMeta = function(t) {
      return null;
    }, e.type = "visualMap", e.dependencies = ["series"], e.defaultOption = {
      show: !0,
      // zlevel: 0,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: !1,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      // 接受数组分别设定上右下左边距，同css
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
        // 值域文字颜色
      }
    }, e;
  }(Ut)
), jz = [20, 140], B9e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function(t, r) {
      n.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(i) {
        i.mappingMethod = "linear", i.dataExtent = this.getExtent();
      }), this._resetRange();
    }, e.prototype.resetItemSize = function() {
      n.prototype.resetItemSize.apply(this, arguments);
      var t = this.itemSize;
      (t[0] == null || isNaN(t[0])) && (t[0] = jz[0]), (t[1] == null || isNaN(t[1])) && (t[1] = jz[1]);
    }, e.prototype._resetRange = function() {
      var t = this.getExtent(), r = this.option.range;
      !r || r.auto ? (t.auto = 1, this.option.range = t) : Me(r) && (r[0] > r[1] && r.reverse(), r[0] = Math.max(r[0], t[0]), r[1] = Math.min(r[1], t[1]));
    }, e.prototype.completeVisualOption = function() {
      n.prototype.completeVisualOption.apply(this, arguments), $(this.stateList, function(t) {
        var r = this.option.controller[t].symbolSize;
        r && r[0] !== r[1] && (r[0] = r[1] / 3);
      }, this);
    }, e.prototype.setSelected = function(t) {
      this.option.range = t.slice(), this._resetRange();
    }, e.prototype.getSelected = function() {
      var t = this.getExtent(), r = Ya((this.get("range") || []).slice());
      return r[0] > t[1] && (r[0] = t[1]), r[1] > t[1] && (r[1] = t[1]), r[0] < t[0] && (r[0] = t[0]), r[1] < t[0] && (r[1] = t[0]), r;
    }, e.prototype.getValueState = function(t) {
      var r = this.option.range, i = this.getExtent();
      return (r[0] <= i[0] || r[0] <= t) && (r[1] >= i[1] || t <= r[1]) ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var r = [];
      return this.eachTargetSeries(function(i) {
        var a = [], o = i.getData();
        o.each(this.getDataDimensionIndex(o), function(s, l) {
          t[0] <= s && s <= t[1] && a.push(l);
        }, this), r.push({
          seriesId: i.id,
          dataIndex: a
        });
      }, this), r;
    }, e.prototype.getVisualMeta = function(t) {
      var r = Bz(this, "outOfRange", this.getExtent()), i = Bz(this, "inRange", this.option.range.slice()), a = [];
      function o(p, h) {
        a.push({
          value: p,
          color: t(p, h)
        });
      }
      for (var s = 0, l = 0, u = i.length, c = r.length; l < c && (!i.length || r[l] <= i[0]); l++)
        r[l] < i[s] && o(r[l], "outOfRange");
      for (var d = 1; s < u; s++, d = 0)
        d && a.length && o(i[s], "outOfRange"), o(i[s], "inRange");
      for (var d = 1; l < c; l++)
        (!i.length || i[i.length - 1] < r[l]) && (d && (a.length && o(a[a.length - 1].value, "outOfRange"), d = 0), o(r[l], "outOfRange"));
      var f = a.length;
      return {
        stops: a,
        outerColors: [f ? a[0].color : "transparent", f ? a[f - 1].color : "transparent"]
      };
    }, e.type = "visualMap.continuous", e.defaultOption = Ku(j_.defaultOption, {
      align: "auto",
      calculable: !1,
      hoverLink: !0,
      realtime: !0,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
      // emphasis: {
      //     handleStyle: {
      //         shadowBlur: 3,
      //         shadowOffsetX: 1,
      //         shadowOffsetY: 1,
      //         shadowColor: 'rgba(0,0,0,0.2)'
      //     }
      // }
    }), e;
  }(j_)
);
function Bz(n, e, t) {
  if (t[0] === t[1])
    return t.slice();
  for (var r = 200, i = (t[1] - t[0]) / r, a = t[0], o = [], s = 0; s <= r && a < t[1]; s++)
    o.push(a), a += i;
  return o.push(t[1]), o;
}
var gX = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, t;
    }
    return e.prototype.init = function(t, r) {
      this.ecModel = t, this.api = r;
    }, e.prototype.render = function(t, r, i, a) {
      if (this.visualMapModel = t, t.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      this.doRender(t, r, i, a);
    }, e.prototype.renderBackground = function(t) {
      var r = this.visualMapModel, i = hh(r.get("padding") || 0), a = t.getBoundingRect();
      t.add(new Qt({
        z2: -1,
        silent: !0,
        shape: {
          x: a.x - i[3],
          y: a.y - i[0],
          width: a.width + i[3] + i[1],
          height: a.height + i[0] + i[2]
        },
        style: {
          fill: r.get("backgroundColor"),
          stroke: r.get("borderColor"),
          lineWidth: r.get("borderWidth")
        }
      }));
    }, e.prototype.getControllerVisual = function(t, r, i) {
      i = i || {};
      var a = i.forceState, o = this.visualMapModel, s = {};
      if (r === "color") {
        var l = o.get("contentColor");
        s.color = l;
      }
      function u(p) {
        return s[p];
      }
      function c(p, h) {
        s[p] = h;
      }
      var d = o.controllerVisuals[a || o.getValueState(t)], f = Lr.prepareVisualTypes(d);
      return $(f, function(p) {
        var h = d[p];
        i.convertOpacityToAlpha && p === "opacity" && (p = "colorAlpha", h = d.__alphaForOpacity), Lr.dependsOn(p, r) && h && h.applyVisual(t, u, c);
      }), s[r];
    }, e.prototype.positionGroup = function(t) {
      var r = this.visualMapModel, i = this.api;
      hw(t, r.getBoxLayoutParams(), {
        width: i.getWidth(),
        height: i.getHeight()
      });
    }, e.prototype.doRender = function(t, r, i, a) {
    }, e.type = "visualMap", e;
  }(Yn)
), $z = [["left", "right", "width"], ["top", "bottom", "height"]];
function yX(n, e, t) {
  var r = n.option, i = r.align;
  if (i != null && i !== "auto")
    return i;
  for (var a = {
    width: e.getWidth(),
    height: e.getHeight()
  }, o = r.orient === "horizontal" ? 1 : 0, s = $z[o], l = [0, null, 10], u = {}, c = 0; c < 3; c++)
    u[$z[1 - o][c]] = l[c], u[s[c]] = c === 2 ? t[0] : r[s[c]];
  var d = [["x", "width", 3], ["y", "height", 0]][o], f = Er(u, a, r.padding);
  return s[(f.margin[d[2]] || 0) + f[d[0]] + f[d[1]] * 0.5 < a[d[1]] * 0.5 ? 0 : 1];
}
function P1(n, e) {
  return $(n || [], function(t) {
    t.dataIndex != null && (t.dataIndexInside = t.dataIndex, t.dataIndex = null), t.highlightKey = "visualMap" + (e ? e.componentIndex : "");
  }), n;
}
var qo = mn, $9e = $, zz = Math.min, dT = Math.max, z9e = 12, F9e = 6, V9e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._shapes = {}, t._dataInterval = [], t._handleEnds = [], t._hoverLinkDataIndices = [], t;
    }
    return e.prototype.init = function(t, r) {
      n.prototype.init.call(this, t, r), this._hoverLinkFromSeriesMouseOver = Ze(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = Ze(this._hideIndicator, this);
    }, e.prototype.doRender = function(t, r, i, a) {
      (!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView();
    }, e.prototype._buildView = function() {
      this.group.removeAll();
      var t = this.visualMapModel, r = this.group;
      this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(r);
      var i = t.get("text");
      this._renderEndsText(r, i, 0), this._renderEndsText(r, i, 1), this._updateView(!0), this.renderBackground(r), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(r);
    }, e.prototype._renderEndsText = function(t, r, i) {
      if (r) {
        var a = r[1 - i];
        a = a != null ? a + "" : "";
        var o = this.visualMapModel, s = o.get("textGap"), l = o.itemSize, u = this._shapes.mainGroup, c = this._applyTransform([l[0] / 2, i === 0 ? -s : l[1] + s], u), d = this._applyTransform(i === 0 ? "bottom" : "top", u), f = this._orient, p = this.visualMapModel.textStyleModel;
        this.group.add(new nn({
          style: Ln(p, {
            x: c[0],
            y: c[1],
            verticalAlign: f === "horizontal" ? "middle" : d,
            align: f === "horizontal" ? d : "center",
            text: a
          })
        }));
      }
    }, e.prototype._renderBar = function(t) {
      var r = this.visualMapModel, i = this._shapes, a = r.itemSize, o = this._orient, s = this._useHandle, l = yX(r, this.api, a), u = i.mainGroup = this._createBarGroup(l), c = new mt();
      u.add(c), c.add(i.outOfRange = Fz()), c.add(i.inRange = Fz(null, s ? Hz(this._orient) : null, Ze(this._dragHandle, this, "all", !1), Ze(this._dragHandle, this, "all", !0))), c.setClipPath(new Qt({
        shape: {
          x: 0,
          y: 0,
          width: a[0],
          height: a[1],
          r: 3
        }
      }));
      var d = r.textStyleModel.getTextRect("国"), f = dT(d.width, d.height);
      s && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(r, u, 0, a, f, o), this._createHandle(r, u, 1, a, f, o)), this._createIndicator(r, u, a, f, o), t.add(u);
    }, e.prototype._createHandle = function(t, r, i, a, o, s) {
      var l = Ze(this._dragHandle, this, i, !1), u = Ze(this._dragHandle, this, i, !0), c = Mo(t.get("handleSize"), a[0]), d = yr(t.get("handleIcon"), -c / 2, -c / 2, c, c, null, !0), f = Hz(this._orient);
      d.attr({
        cursor: f,
        draggable: !0,
        drift: l,
        ondragend: u,
        onmousemove: function(g) {
          bl(g.event);
        }
      }), d.x = a[0] / 2, d.useStyle(t.getModel("handleStyle").getItemStyle()), d.setStyle({
        strokeNoScale: !0,
        strokeFirst: !0
      }), d.style.lineWidth *= 2, d.ensureState("emphasis").style = t.getModel(["emphasis", "handleStyle"]).getItemStyle(), Uc(d, !0), r.add(d);
      var p = this.visualMapModel.textStyleModel, h = new nn({
        cursor: f,
        draggable: !0,
        drift: l,
        onmousemove: function(g) {
          bl(g.event);
        },
        ondragend: u,
        style: Ln(p, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      h.ensureState("blur").style = {
        opacity: 0.1
      }, h.stateTransition = {
        duration: 200
      }, this.group.add(h);
      var v = [c, 0], m = this._shapes;
      m.handleThumbs[i] = d, m.handleLabelPoints[i] = v, m.handleLabels[i] = h;
    }, e.prototype._createIndicator = function(t, r, i, a, o) {
      var s = Mo(t.get("indicatorSize"), i[0]), l = yr(t.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, !0);
      l.attr({
        cursor: "move",
        invisible: !0,
        silent: !0,
        x: i[0] / 2
      });
      var u = t.getModel("indicatorStyle").getItemStyle();
      if (l instanceof Ur) {
        var c = l.style;
        l.useStyle(xe({
          // TODO other properties like x, y ?
          image: c.image,
          x: c.x,
          y: c.y,
          width: c.width,
          height: c.height
        }, u));
      } else
        l.useStyle(u);
      r.add(l);
      var d = this.visualMapModel.textStyleModel, f = new nn({
        silent: !0,
        invisible: !0,
        style: Ln(d, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(f);
      var p = [(o === "horizontal" ? a / 2 : F9e) + i[0] / 2, 0], h = this._shapes;
      h.indicator = l, h.indicatorLabel = f, h.indicatorLabelPoint = p, this._firstShowIndicator = !0;
    }, e.prototype._dragHandle = function(t, r, i, a) {
      if (this._useHandle) {
        if (this._dragging = !r, !r) {
          var o = this._applyTransform([i, a], this._shapes.mainGroup, !0);
          this._updateInterval(t, o[1]), this._hideIndicator(), this._updateView();
        }
        r === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), r ? !this._hovering && this._clearHoverLinkToSeries() : Vz(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1);
      }
    }, e.prototype._resetInterval = function() {
      var t = this.visualMapModel, r = this._dataInterval = t.getSelected(), i = t.getExtent(), a = [0, t.itemSize[1]];
      this._handleEnds = [qo(r[0], i, a, !0), qo(r[1], i, a, !0)];
    }, e.prototype._updateInterval = function(t, r) {
      r = r || 0;
      var i = this.visualMapModel, a = this._handleEnds, o = [0, i.itemSize[1]];
      af(
        r,
        a,
        o,
        t,
        // cross is forbidden
        0
      );
      var s = i.getExtent();
      this._dataInterval = [qo(a[0], o, s, !0), qo(a[1], o, s, !0)];
    }, e.prototype._updateView = function(t) {
      var r = this.visualMapModel, i = r.getExtent(), a = this._shapes, o = [0, r.itemSize[1]], s = t ? o : this._handleEnds, l = this._createBarVisual(this._dataInterval, i, s, "inRange"), u = this._createBarVisual(i, i, o, "outOfRange");
      a.inRange.setStyle({
        fill: l.barColor
        // opacity: visualInRange.opacity
      }).setShape("points", l.barPoints), a.outOfRange.setStyle({
        fill: u.barColor
        // opacity: visualOutOfRange.opacity
      }).setShape("points", u.barPoints), this._updateHandle(s, l);
    }, e.prototype._createBarVisual = function(t, r, i, a) {
      var o = {
        forceState: a,
        convertOpacityToAlpha: !0
      }, s = this._makeColorGradient(t, o), l = [this.getControllerVisual(t[0], "symbolSize", o), this.getControllerVisual(t[1], "symbolSize", o)], u = this._createBarPoints(i, l);
      return {
        barColor: new Ug(0, 0, 0, 1, s),
        barPoints: u,
        handlesColor: [s[0].color, s[s.length - 1].color]
      };
    }, e.prototype._makeColorGradient = function(t, r) {
      var i = 100, a = [], o = (t[1] - t[0]) / i;
      a.push({
        color: this.getControllerVisual(t[0], "color", r),
        offset: 0
      });
      for (var s = 1; s < i; s++) {
        var l = t[0] + o * s;
        if (l > t[1])
          break;
        a.push({
          color: this.getControllerVisual(l, "color", r),
          offset: s / i
        });
      }
      return a.push({
        color: this.getControllerVisual(t[1], "color", r),
        offset: 1
      }), a;
    }, e.prototype._createBarPoints = function(t, r) {
      var i = this.visualMapModel.itemSize;
      return [[i[0] - r[0], t[0]], [i[0], t[0]], [i[0], t[1]], [i[0] - r[1], t[1]]];
    }, e.prototype._createBarGroup = function(t) {
      var r = this._orient, i = this.visualMapModel.get("inverse");
      return new mt(r === "horizontal" && !i ? {
        scaleX: t === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : r === "horizontal" && i ? {
        scaleX: t === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : r === "vertical" && !i ? {
        scaleX: t === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: t === "left" ? 1 : -1
      });
    }, e.prototype._updateHandle = function(t, r) {
      if (this._useHandle) {
        var i = this._shapes, a = this.visualMapModel, o = i.handleThumbs, s = i.handleLabels, l = a.itemSize, u = a.getExtent(), c = this._applyTransform("left", i.mainGroup);
        $9e([0, 1], function(d) {
          var f = o[d];
          f.setStyle("fill", r.handlesColor[d]), f.y = t[d];
          var p = qo(t[d], [0, l[1]], u, !0), h = this.getControllerVisual(p, "symbolSize");
          f.scaleX = f.scaleY = h / l[0], f.x = l[0] - h / 2;
          var v = wo(i.handleLabelPoints[d], vd(f, this.group));
          if (this._orient === "horizontal") {
            var m = c === "left" || c === "top" ? (l[0] - h) / 2 : (l[0] - h) / -2;
            v[1] += m;
          }
          s[d].setStyle({
            x: v[0],
            y: v[1],
            text: a.formatValueText(this._dataInterval[d]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", i.mainGroup) : "center"
          });
        }, this);
      }
    }, e.prototype._showIndicator = function(t, r, i, a) {
      var o = this.visualMapModel, s = o.getExtent(), l = o.itemSize, u = [0, l[1]], c = this._shapes, d = c.indicator;
      if (d) {
        d.attr("invisible", !1);
        var f = {
          convertOpacityToAlpha: !0
        }, p = this.getControllerVisual(t, "color", f), h = this.getControllerVisual(t, "symbolSize"), v = qo(t, s, u, !0), m = l[0] - h / 2, g = {
          x: d.x,
          y: d.y
        };
        d.y = v, d.x = m;
        var y = wo(c.indicatorLabelPoint, vd(d, this.group)), b = c.indicatorLabel;
        b.attr("invisible", !1);
        var _ = this._applyTransform("left", c.mainGroup), x = this._orient, w = x === "horizontal";
        b.setStyle({
          text: (i || "") + o.formatValueText(r),
          verticalAlign: w ? _ : "middle",
          align: w ? "center" : _
        });
        var S = {
          x: m,
          y: v,
          style: {
            fill: p
          }
        }, C = {
          style: {
            x: y[0],
            y: y[1]
          }
        };
        if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var k = {
            duration: 100,
            easing: "cubicInOut",
            additive: !0
          };
          d.x = g.x, d.y = g.y, d.animateTo(S, k), b.animateTo(C, k);
        } else
          d.attr(S), b.attr(C);
        this._firstShowIndicator = !1;
        var M = this._shapes.handleLabels;
        if (M)
          for (var D = 0; D < M.length; D++)
            this.api.enterBlur(M[D]);
      }
    }, e.prototype._enableHoverLinkToSeries = function() {
      var t = this;
      this._shapes.mainGroup.on("mousemove", function(r) {
        if (t._hovering = !0, !t._dragging) {
          var i = t.visualMapModel.itemSize, a = t._applyTransform([r.offsetX, r.offsetY], t._shapes.mainGroup, !0, !0);
          a[1] = zz(dT(0, a[1]), i[1]), t._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= i[0]);
        }
      }).on("mouseout", function() {
        t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries();
      });
    }, e.prototype._enableHoverLinkFromSeries = function() {
      var t = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, e.prototype._doHoverLinkToSeries = function(t, r) {
      var i = this.visualMapModel, a = i.itemSize;
      if (i.option.hoverLink) {
        var o = [0, a[1]], s = i.getExtent();
        t = zz(dT(o[0], t), o[1]);
        var l = H9e(i, s, o), u = [t - l, t + l], c = qo(t, o, s, !0), d = [qo(u[0], o, s, !0), qo(u[1], o, s, !0)];
        u[0] < o[0] && (d[0] = -1 / 0), u[1] > o[1] && (d[1] = 1 / 0), r && (d[0] === -1 / 0 ? this._showIndicator(c, d[1], "< ", l) : d[1] === 1 / 0 ? this._showIndicator(c, d[0], "> ", l) : this._showIndicator(c, c, "≈ ", l));
        var f = this._hoverLinkDataIndices, p = [];
        (r || Vz(i)) && (p = this._hoverLinkDataIndices = i.findTargetDataIndices(d));
        var h = qOe(f, p);
        this._dispatchHighDown("downplay", P1(h[0], i)), this._dispatchHighDown("highlight", P1(h[1], i));
      }
    }, e.prototype._hoverLinkFromSeriesMouseOver = function(t) {
      var r;
      if (qc(t.target, function(l) {
        var u = yt(l);
        if (u.dataIndex != null)
          return r = u, !0;
      }, !0), !!r) {
        var i = this.ecModel.getSeriesByIndex(r.seriesIndex), a = this.visualMapModel;
        if (a.isTargetSeries(i)) {
          var o = i.getData(r.dataType), s = o.getStore().get(a.getDataDimensionIndex(o), r.dataIndex);
          isNaN(s) || this._showIndicator(s, s);
        }
      }
    }, e.prototype._hideIndicator = function() {
      var t = this._shapes;
      t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0);
      var r = this._shapes.handleLabels;
      if (r)
        for (var i = 0; i < r.length; i++)
          this.api.leaveBlur(r[i]);
    }, e.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var t = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", P1(t, this.visualMapModel)), t.length = 0;
    }, e.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var t = this.api.getZr();
      t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator);
    }, e.prototype._applyTransform = function(t, r, i, a) {
      var o = vd(r, a ? null : this.group);
      return Me(t) ? wo(t, o, i) : sw(t, o, i);
    }, e.prototype._dispatchHighDown = function(t, r) {
      r && r.length && this.api.dispatchAction({
        type: t,
        batch: r
      });
    }, e.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, e.type = "visualMap.continuous", e;
  }(gX)
);
function Fz(n, e, t, r) {
  return new Vi({
    shape: {
      points: n
    },
    draggable: !!t,
    cursor: e,
    drift: t,
    onmousemove: function(i) {
      bl(i.event);
    },
    ondragend: r
  });
}
function H9e(n, e, t) {
  var r = z9e / 2, i = n.get("hoverLinkDataSize");
  return i && (r = qo(i, e, t, !0) / 2), r;
}
function Vz(n) {
  var e = n.get("hoverLinkOnHandle");
  return !!(e ?? n.get("realtime"));
}
function Hz(n) {
  return n === "vertical" ? "ns-resize" : "ew-resize";
}
var G9e = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  // FIXME use updateView appears wrong
  update: "update"
}, U9e = function(n, e) {
  e.eachComponent({
    mainType: "visualMap",
    query: n
  }, function(t) {
    t.setSelected(n.selected);
  });
}, W9e = [
  {
    createOnAllSeries: !0,
    reset: function(n, e) {
      var t = [];
      return e.eachComponent("visualMap", function(r) {
        var i = n.pipelineContext;
        !r.isTargetSeries(n) || i && i.large || t.push(h7e(r.stateList, r.targetVisuals, Ze(r.getValueState, r), r.getDataDimensionIndex(n.getData())));
      }), t;
    }
  },
  // Only support color.
  {
    createOnAllSeries: !0,
    reset: function(n, e) {
      var t = n.getData(), r = [];
      e.eachComponent("visualMap", function(i) {
        if (i.isTargetSeries(n)) {
          var a = i.getVisualMeta(Ze(q9e, null, n, i)) || {
            stops: [],
            outerColors: []
          }, o = i.getDataDimensionIndex(t);
          o >= 0 && (a.dimension = o, r.push(a));
        }
      }), n.getData().setVisual("visualMeta", r);
    }
  }
];
function q9e(n, e, t, r) {
  for (var i = e.targetVisuals[r], a = Lr.prepareVisualTypes(i), o = {
    color: Yg(n.getData(), "color")
    // default color.
  }, s = 0, l = a.length; s < l; s++) {
    var u = a[s], c = i[u === "opacity" ? "__alphaForOpacity" : u];
    c && c.applyVisual(t, d, f);
  }
  return o.color;
  function d(p) {
    return o[p];
  }
  function f(p, h) {
    o[p] = h;
  }
}
var Gz = $;
function Y9e(n) {
  var e = n && n.visualMap;
  Me(e) || (e = e ? [e] : []), Gz(e, function(t) {
    if (t) {
      zf(t, "splitList") && !zf(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
      var r = t.pieces;
      r && Me(r) && Gz(r, function(i) {
        ut(i) && (zf(i, "start") && !zf(i, "min") && (i.min = i.start), zf(i, "end") && !zf(i, "max") && (i.max = i.end));
      });
    }
  });
}
function zf(n, e) {
  return n && n.hasOwnProperty && n.hasOwnProperty(e);
}
var Uz = !1;
function bX(n) {
  Uz || (Uz = !0, n.registerSubTypeDefaulter("visualMap", function(e) {
    return !e.categories && (!(e.pieces ? e.pieces.length > 0 : e.splitNumber > 0) || e.calculable) ? "continuous" : "piecewise";
  }), n.registerAction(G9e, U9e), $(W9e, function(e) {
    n.registerVisual(n.PRIORITY.VISUAL.COMPONENT, e);
  }), n.registerPreprocessor(Y9e));
}
function _X(n) {
  n.registerComponentModel(B9e), n.registerComponentView(V9e), bX(n);
}
var K9e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._pieceList = [], t;
    }
    return e.prototype.optionUpdated = function(t, r) {
      n.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var i = this._mode = this._determineMode();
      this._pieceList = [], X9e[this._mode].call(this, this._pieceList), this._resetSelected(t, r);
      var a = this.option.categories;
      this.resetVisual(function(o, s) {
        i === "categories" ? (o.mappingMethod = "category", o.categories = ht(a)) : (o.dataExtent = this.getExtent(), o.mappingMethod = "piecewise", o.pieceList = De(this._pieceList, function(l) {
          return l = ht(l), s !== "inRange" && (l.visual = null), l;
        }));
      });
    }, e.prototype.completeVisualOption = function() {
      var t = this.option, r = {}, i = Lr.listVisualTypes(), a = this.isCategory();
      $(t.pieces, function(s) {
        $(i, function(l) {
          s.hasOwnProperty(l) && (r[l] = 1);
        });
      }), $(r, function(s, l) {
        var u = !1;
        $(this.stateList, function(c) {
          u = u || o(t, c, l) || o(t.target, c, l);
        }, this), !u && $(this.stateList, function(c) {
          (t[c] || (t[c] = {}))[l] = mX.get(l, c === "inRange" ? "active" : "inactive", a);
        });
      }, this);
      function o(s, l, u) {
        return s && s[l] && s[l].hasOwnProperty(u);
      }
      n.prototype.completeVisualOption.apply(this, arguments);
    }, e.prototype._resetSelected = function(t, r) {
      var i = this.option, a = this._pieceList, o = (r ? i : t).selected || {};
      if (i.selected = o, $(a, function(l, u) {
        var c = this.getSelectedMapKey(l);
        o.hasOwnProperty(c) || (o[c] = !0);
      }, this), i.selectedMode === "single") {
        var s = !1;
        $(a, function(l, u) {
          var c = this.getSelectedMapKey(l);
          o[c] && (s ? o[c] = !1 : s = !0);
        }, this);
      }
    }, e.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, e.prototype.getSelectedMapKey = function(t) {
      return this._mode === "categories" ? t.value + "" : t.index + "";
    }, e.prototype.getPieceList = function() {
      return this._pieceList;
    }, e.prototype._determineMode = function() {
      var t = this.option;
      return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, e.prototype.setSelected = function(t) {
      this.option.selected = ht(t);
    }, e.prototype.getValueState = function(t) {
      var r = Lr.findPieceIndex(t, this._pieceList);
      return r != null && this.option.selected[this.getSelectedMapKey(this._pieceList[r])] ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var r = [], i = this._pieceList;
      return this.eachTargetSeries(function(a) {
        var o = [], s = a.getData();
        s.each(this.getDataDimensionIndex(s), function(l, u) {
          var c = Lr.findPieceIndex(l, i);
          c === t && o.push(u);
        }, this), r.push({
          seriesId: a.id,
          dataIndex: o
        });
      }, this), r;
    }, e.prototype.getRepresentValue = function(t) {
      var r;
      if (this.isCategory())
        r = t.value;
      else if (t.value != null)
        r = t.value;
      else {
        var i = t.interval || [];
        r = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
      }
      return r;
    }, e.prototype.getVisualMeta = function(t) {
      if (this.isCategory())
        return;
      var r = [], i = ["", ""], a = this;
      function o(c, d) {
        var f = a.getRepresentValue({
          interval: c
        });
        d || (d = a.getValueState(f));
        var p = t(f, d);
        c[0] === -1 / 0 ? i[0] = p : c[1] === 1 / 0 ? i[1] = p : r.push({
          value: c[0],
          color: p
        }, {
          value: c[1],
          color: p
        });
      }
      var s = this._pieceList.slice();
      if (!s.length)
        s.push({
          interval: [-1 / 0, 1 / 0]
        });
      else {
        var l = s[0].interval[0];
        l !== -1 / 0 && s.unshift({
          interval: [-1 / 0, l]
        }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({
          interval: [l, 1 / 0]
        });
      }
      var u = -1 / 0;
      return $(s, function(c) {
        var d = c.interval;
        d && (d[0] > u && o([u, d[0]], "outOfRange"), o(d.slice()), u = d[1]);
      }, this), {
        stops: r,
        outerColors: i
      };
    }, e.type = "visualMap.piecewise", e.defaultOption = Ku(j_.defaultOption, {
      selected: null,
      minOpen: !1,
      maxOpen: !1,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: !0
      // Enable hover highlight.
    }), e;
  }(j_)
), X9e = {
  splitNumber: function(n) {
    var e = this.option, t = Math.min(e.precision, 20), r = this.getExtent(), i = e.splitNumber;
    i = Math.max(parseInt(i, 10), 1), e.splitNumber = i;
    for (var a = (r[1] - r[0]) / i; +a.toFixed(t) !== a && t < 5; )
      t++;
    e.precision = t, a = +a.toFixed(t), e.minOpen && n.push({
      interval: [-1 / 0, r[0]],
      close: [0, 0]
    });
    for (var o = 0, s = r[0]; o < i; s += a, o++) {
      var l = o === i - 1 ? r[1] : s + a;
      n.push({
        interval: [s, l],
        close: [1, 1]
      });
    }
    e.maxOpen && n.push({
      interval: [r[1], 1 / 0],
      close: [0, 0]
    }), L3(n), $(n, function(u, c) {
      u.index = c, u.text = this.formatValueText(u.interval);
    }, this);
  },
  categories: function(n) {
    var e = this.option;
    $(e.categories, function(t) {
      n.push({
        text: this.formatValueText(t, !0),
        value: t
      });
    }, this), Wz(e, n);
  },
  pieces: function(n) {
    var e = this.option;
    $(e.pieces, function(t, r) {
      ut(t) || (t = {
        value: t
      });
      var i = {
        text: "",
        index: r
      };
      if (t.label != null && (i.text = t.label), t.hasOwnProperty("value")) {
        var a = i.value = t.value;
        i.interval = [a, a], i.close = [1, 1];
      } else {
        for (var o = i.interval = [], s = i.close = [0, 0], l = [1, 0, 1], u = [-1 / 0, 1 / 0], c = [], d = 0; d < 2; d++) {
          for (var f = [["gte", "gt", "min"], ["lte", "lt", "max"]][d], p = 0; p < 3 && o[d] == null; p++)
            o[d] = t[f[p]], s[d] = l[p], c[d] = p === 2;
          o[d] == null && (o[d] = u[d]);
        }
        c[0] && o[1] === 1 / 0 && (s[0] = 0), c[1] && o[0] === -1 / 0 && (s[1] = 0), process.env.NODE_ENV !== "production" && o[0] > o[1] && console.warn("Piece " + r + "is illegal: " + o + " lower bound should not greater then uppper bound."), o[0] === o[1] && s[0] && s[1] && (i.value = o[0]);
      }
      i.visual = Lr.retrieveVisuals(t), n.push(i);
    }, this), Wz(e, n), L3(n), $(n, function(t) {
      var r = t.close, i = [["<", "≤"][r[1]], [">", "≥"][r[0]]];
      t.text = t.text || this.formatValueText(t.value != null ? t.value : t.interval, !1, i);
    }, this);
  }
};
function Wz(n, e) {
  var t = n.inverse;
  (n.orient === "vertical" ? !t : t) && e.reverse();
}
var Z9e = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.doRender = function() {
      var t = this.group;
      t.removeAll();
      var r = this.visualMapModel, i = r.get("textGap"), a = r.textStyleModel, o = a.getFont(), s = a.getTextColor(), l = this._getItemAlign(), u = r.itemSize, c = this._getViewData(), d = c.endsText, f = mr(r.get("showLabel", !0), !d), p = !r.get("selectedMode");
      d && this._renderEndsText(t, d[0], u, f, l), $(c.viewPieceList, function(h) {
        var v = h.piece, m = new mt();
        m.onclick = Ze(this._onItemClick, this, v), this._enableHoverLink(m, h.indexInModelPieceList);
        var g = r.getRepresentValue(v);
        if (this._createItemSymbol(m, g, [0, 0, u[0], u[1]], p), f) {
          var y = this.visualMapModel.getValueState(g);
          m.add(new nn({
            style: {
              x: l === "right" ? -i : u[0] + i,
              y: u[1] / 2,
              text: v.text,
              verticalAlign: "middle",
              align: l,
              font: o,
              fill: s,
              opacity: y === "outOfRange" ? 0.5 : 1
            },
            silent: p
          }));
        }
        t.add(m);
      }, this), d && this._renderEndsText(t, d[1], u, f, l), md(r.get("orient"), t, r.get("itemGap")), this.renderBackground(t), this.positionGroup(t);
    }, e.prototype._enableHoverLink = function(t, r) {
      var i = this;
      t.on("mouseover", function() {
        return a("highlight");
      }).on("mouseout", function() {
        return a("downplay");
      });
      var a = function(o) {
        var s = i.visualMapModel;
        s.option.hoverLink && i.api.dispatchAction({
          type: o,
          batch: P1(s.findTargetDataIndices(r), s)
        });
      };
    }, e.prototype._getItemAlign = function() {
      var t = this.visualMapModel, r = t.option;
      if (r.orient === "vertical")
        return yX(t, this.api, t.itemSize);
      var i = r.align;
      return (!i || i === "auto") && (i = "left"), i;
    }, e.prototype._renderEndsText = function(t, r, i, a, o) {
      if (r) {
        var s = new mt(), l = this.visualMapModel.textStyleModel;
        s.add(new nn({
          style: Ln(l, {
            x: a ? o === "right" ? i[0] : 0 : i[0] / 2,
            y: i[1] / 2,
            verticalAlign: "middle",
            align: a ? o : "center",
            text: r
          })
        })), t.add(s);
      }
    }, e.prototype._getViewData = function() {
      var t = this.visualMapModel, r = De(t.getPieceList(), function(s, l) {
        return {
          piece: s,
          indexInModelPieceList: l
        };
      }), i = t.get("text"), a = t.get("orient"), o = t.get("inverse");
      return (a === "horizontal" ? o : !o) ? r.reverse() : i && (i = i.slice().reverse()), {
        viewPieceList: r,
        endsText: i
      };
    }, e.prototype._createItemSymbol = function(t, r, i, a) {
      var o = yr(
        // symbol will be string
        this.getControllerVisual(r, "symbol"),
        i[0],
        i[1],
        i[2],
        i[3],
        // color will be string
        this.getControllerVisual(r, "color")
      );
      o.silent = a, t.add(o);
    }, e.prototype._onItemClick = function(t) {
      var r = this.visualMapModel, i = r.option, a = i.selectedMode;
      if (a) {
        var o = ht(i.selected), s = r.getSelectedMapKey(t);
        a === "single" || a === !0 ? (o[s] = !0, $(o, function(l, u) {
          o[u] = u === s;
        })) : o[s] = !o[s], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: o
        });
      }
    }, e.type = "visualMap.piecewise", e;
  }(gX)
);
function xX(n) {
  n.registerComponentModel(K9e), n.registerComponentView(Z9e), bX(n);
}
function J9e(n) {
  $t(_X), $t(xX);
}
var Q9e = {
  label: {
    enabled: !0
  },
  decal: {
    show: !1
  }
}, qz = en(), eGe = {};
function tGe(n, e) {
  var t = n.getModel("aria");
  if (!t.get("enabled"))
    return;
  var r = ht(Q9e);
  At(r.label, n.getLocaleModel().get("aria"), !1), At(t.option, r, !1), i(), a();
  function i() {
    var u = t.getModel("decal"), c = u.get("show");
    if (c) {
      var d = tt();
      n.eachSeries(function(f) {
        if (!f.isColorBySeries()) {
          var p = d.get(f.type);
          p || (p = {}, d.set(f.type, p)), qz(f).scope = p;
        }
      }), n.eachRawSeries(function(f) {
        if (n.isSeriesFiltered(f))
          return;
        if (at(f.enableAriaDecal)) {
          f.enableAriaDecal();
          return;
        }
        var p = f.getData();
        if (f.isColorBySeries()) {
          var y = wk(f.ecModel, f.name, eGe, n.getSeriesCount()), b = p.getVisual("decal");
          p.setVisual("decal", _(b, y));
        } else {
          var h = f.getRawData(), v = {}, m = qz(f).scope;
          p.each(function(x) {
            var w = p.getRawIndex(x);
            v[w] = x;
          });
          var g = h.count();
          h.each(function(x) {
            var w = v[x], S = h.getName(x) || x + "", C = wk(f.ecModel, S, m, g), k = p.getItemVisual(w, "decal");
            p.setItemVisual(w, "decal", _(k, C));
          });
        }
        function _(x, w) {
          var S = x ? xe(xe({}, w), x) : w;
          return S.dirty = !0, S;
        }
      });
    }
  }
  function a() {
    var u = e.getZr().dom;
    if (u) {
      var c = n.getLocaleModel().get("aria"), d = t.getModel("label");
      if (d.option = dt(d.option, c), !!d.get("enabled")) {
        if (u.setAttribute("role", "img"), d.get("description")) {
          u.setAttribute("aria-label", d.get("description"));
          return;
        }
        var f = n.getSeriesCount(), p = d.get(["data", "maxCount"]) || 10, h = d.get(["series", "maxCount"]) || 10, v = Math.min(f, h), m;
        if (!(f < 1)) {
          var g = s();
          if (g) {
            var y = d.get(["general", "withTitle"]);
            m = o(y, {
              title: g
            });
          } else
            m = d.get(["general", "withoutTitle"]);
          var b = [], _ = f > 1 ? d.get(["series", "multiple", "prefix"]) : d.get(["series", "single", "prefix"]);
          m += o(_, {
            seriesCount: f
          }), n.eachSeries(function(C, k) {
            if (k < v) {
              var M = void 0, D = C.get("name"), N = D ? "withName" : "withoutName";
              M = f > 1 ? d.get(["series", "multiple", N]) : d.get(["series", "single", N]), M = o(M, {
                seriesId: C.seriesIndex,
                seriesName: C.get("name"),
                seriesType: l(C.subType)
              });
              var R = C.getData();
              if (R.count() > p) {
                var j = d.get(["data", "partialData"]);
                M += o(j, {
                  displayCnt: p
                });
              } else
                M += d.get(["data", "allData"]);
              for (var z = d.get(["data", "separator", "middle"]), F = d.get(["data", "separator", "end"]), B = d.get(["data", "excludeDimensionId"]), H = [], Y = 0; Y < R.count(); Y++)
                if (Y < p) {
                  var ne = R.getName(Y), J = B ? vn(R.getValues(Y), function(ie, ye) {
                    return Pt(B, ye) === -1;
                  }) : R.getValues(Y), X = d.get(["data", ne ? "withName" : "withoutName"]);
                  H.push(o(X, {
                    name: ne,
                    value: J.join(z)
                  }));
                }
              M += H.join(z) + F, b.push(M);
            }
          });
          var x = d.getModel(["series", "multiple", "separator"]), w = x.get("middle"), S = x.get("end");
          m += b.join(w) + S, u.setAttribute("aria-label", m);
        }
      }
    }
  }
  function o(u, c) {
    if (!We(u))
      return u;
    var d = u;
    return $(c, function(f, p) {
      d = d.replace(new RegExp("\\{\\s*" + p + "\\s*\\}", "g"), f);
    }), d;
  }
  function s() {
    var u = n.get("title");
    return u && u.length && (u = u[0]), u && u.text;
  }
  function l(u) {
    var c = n.getLocaleModel().get(["series", "typeNames"]);
    return c[u] || c.chart;
  }
}
function nGe(n) {
  if (!(!n || !n.aria)) {
    var e = n.aria;
    e.show != null && (e.enabled = e.show), e.label = e.label || {}, $(["description", "general", "series", "data"], function(t) {
      e[t] != null && (e.label[t] = e[t]);
    });
  }
}
function rGe(n) {
  n.registerPreprocessor(nGe), n.registerVisual(n.PRIORITY.VISUAL.ARIA, tGe);
}
var Yz = {
  value: "eq",
  // PENDING: not good for literal semantic?
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
  // Might be misleading for sake of the difference between '==' and '===',
  // so don't support them.
  // '==': 'eq',
  // '===': 'seq',
  // '!==': 'sne'
  // PENDING: Whether support some common alias "ge", "le", "neq"?
  // ge: 'gte',
  // le: 'lte',
  // neq: 'ne',
}, iGe = (
  /** @class */
  function() {
    function n(e) {
      var t = this._condVal = We(e) ? new RegExp(e) : Q9(e) ? e : null;
      if (t == null) {
        var r = "";
        process.env.NODE_ENV !== "production" && (r = $i("Illegal regexp", e, "in")), hn(r);
      }
    }
    return n.prototype.evaluate = function(e) {
      var t = typeof e;
      return We(t) ? this._condVal.test(e) : sn(t) ? this._condVal.test(e + "") : !1;
    }, n;
  }()
), aGe = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      return this.value;
    }, n;
  }()
), oGe = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++)
        if (!e[t].evaluate())
          return !1;
      return !0;
    }, n;
  }()
), sGe = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++)
        if (e[t].evaluate())
          return !0;
      return !1;
    }, n;
  }()
), lGe = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, n;
  }()
), uGe = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      for (var e = !!this.valueParser, t = this.getValue, r = t(this.valueGetterParam), i = e ? this.valueParser(r) : null, a = 0; a < this.subCondList.length; a++)
        if (!this.subCondList[a].evaluate(e ? i : r))
          return !1;
      return !0;
    }, n;
  }()
);
function EI(n, e) {
  if (n === !0 || n === !1) {
    var t = new aGe();
    return t.value = n, t;
  }
  var r = "";
  return wX(n) || (process.env.NODE_ENV !== "production" && (r = $i("Illegal config. Expect a plain object but actually", n)), hn(r)), n.and ? Kz("and", n, e) : n.or ? Kz("or", n, e) : n.not ? cGe(n, e) : dGe(n, e);
}
function Kz(n, e, t) {
  var r = e[n], i = "";
  process.env.NODE_ENV !== "production" && (i = $i('"and"/"or" condition should only be `' + n + ": [...]` and must not be empty array.", "Illegal condition:", e)), Me(r) || hn(i), r.length || hn(i);
  var a = n === "and" ? new oGe() : new sGe();
  return a.children = De(r, function(o) {
    return EI(o, t);
  }), a.children.length || hn(i), a;
}
function cGe(n, e) {
  var t = n.not, r = "";
  process.env.NODE_ENV !== "production" && (r = $i('"not" condition should only be `not: {}`.', "Illegal condition:", n)), wX(t) || hn(r);
  var i = new lGe();
  return i.child = EI(t, e), i.child || hn(r), i;
}
function dGe(n, e) {
  for (var t = "", r = e.prepareGetValue(n), i = [], a = Yt(n), o = n.parser, s = o ? rW(o) : null, l = 0; l < a.length; l++) {
    var u = a[l];
    if (!(u === "parser" || e.valueGetterAttrMap.get(u))) {
      var c = Je(Yz, u) ? Yz[u] : u, d = n[u], f = s ? s(d) : d, p = JNe(c, f) || c === "reg" && new iGe(f);
      p || (process.env.NODE_ENV !== "production" && (t = $i('Illegal relational operation: "' + u + '" in condition:', n)), hn(t)), i.push(p);
    }
  }
  i.length || (process.env.NODE_ENV !== "production" && (t = $i("Relational condition must have at least one operator.", "Illegal condition:", n)), hn(t));
  var h = new uGe();
  return h.valueGetterParam = r, h.valueParser = s, h.getValue = e.getValue, h.subCondList = i, h;
}
function wX(n) {
  return ut(n) && !hi(n);
}
var fGe = (
  /** @class */
  function() {
    function n(e, t) {
      this._cond = EI(e, t);
    }
    return n.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, n;
  }()
);
function pGe(n, e) {
  return new fGe(n, e);
}
var hGe = {
  type: "echarts:filter",
  // PENDING: enhance to filter by index rather than create new data
  transform: function(n) {
    for (var e = n.upstream, t, r = pGe(n.config, {
      valueGetterAttrMap: tt({
        dimension: !0
      }),
      prepareGetValue: function(s) {
        var l = "", u = s.dimension;
        Je(s, "dimension") || (process.env.NODE_ENV !== "production" && (l = $i('Relation condition must has prop "dimension" specified.', "Illegal condition:", s)), hn(l));
        var c = e.getDimensionInfo(u);
        return c || (process.env.NODE_ENV !== "production" && (l = $i("Can not find dimension info via: " + u + `.
`, "Existing dimensions: ", e.cloneAllDimensionInfo(), `.
`, "Illegal condition:", s, `.
`)), hn(l)), {
          dimIdx: c.index
        };
      },
      getValue: function(s) {
        return e.retrieveValueFromItem(t, s.dimIdx);
      }
    }), i = [], a = 0, o = e.count(); a < o; a++)
      t = e.getRawDataItem(a), r.evaluate() && i.push(t);
    return {
      data: i
    };
  }
}, wA = "";
process.env.NODE_ENV !== "production" && (wA = ["Valid config is like:", '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(" "));
var vGe = {
  type: "echarts:sort",
  transform: function(n) {
    var e = n.upstream, t = n.config, r = "", i = wn(t);
    i.length || (process.env.NODE_ENV !== "production" && (r = "Empty `config` in sort transform."), hn(r));
    var a = [];
    $(i, function(c) {
      var d = c.dimension, f = c.order, p = c.parser, h = c.incomparable;
      if (d == null && (process.env.NODE_ENV !== "production" && (r = 'Sort transform config must has "dimension" specified.' + wA), hn(r)), f !== "asc" && f !== "desc" && (process.env.NODE_ENV !== "production" && (r = 'Sort transform config must has "order" specified.' + wA), hn(r)), h && h !== "min" && h !== "max") {
        var v = "";
        process.env.NODE_ENV !== "production" && (v = 'incomparable must be "min" or "max" rather than "' + h + '".'), hn(v);
      }
      if (f !== "asc" && f !== "desc") {
        var m = "";
        process.env.NODE_ENV !== "production" && (m = 'order must be "asc" or "desc" rather than "' + f + '".'), hn(m);
      }
      var g = e.getDimensionInfo(d);
      g || (process.env.NODE_ENV !== "production" && (r = $i("Can not find dimension info via: " + d + `.
`, "Existing dimensions: ", e.cloneAllDimensionInfo(), `.
`, "Illegal config:", c, `.
`)), hn(r));
      var y = p ? rW(p) : null;
      p && !y && (process.env.NODE_ENV !== "production" && (r = $i("Invalid parser name " + p + `.
`, "Illegal config:", c, `.
`)), hn(r)), a.push({
        dimIdx: g.index,
        parser: y,
        comparator: new aW(f, h)
      });
    });
    var o = e.sourceFormat;
    o !== vi && o !== oo && (process.env.NODE_ENV !== "production" && (r = 'sourceFormat "' + o + '" is not supported yet'), hn(r));
    for (var s = [], l = 0, u = e.count(); l < u; l++)
      s.push(e.getRawDataItem(l));
    return s.sort(function(c, d) {
      for (var f = 0; f < a.length; f++) {
        var p = a[f], h = e.retrieveValueFromItem(c, p.dimIdx), v = e.retrieveValueFromItem(d, p.dimIdx);
        p.parser && (h = p.parser(h), v = p.parser(v));
        var m = p.comparator.evaluate(h, v);
        if (m !== 0)
          return m;
      }
      return 0;
    }), {
      data: s
    };
  }
};
function mGe(n) {
  n.registerTransform(hGe), n.registerTransform(vGe);
}
var gGe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.prototype.init = function(t, r, i) {
      n.prototype.init.call(this, t, r, i), this._sourceManager = new uW(this), Yj(this);
    }, e.prototype.mergeOption = function(t, r) {
      n.prototype.mergeOption.call(this, t, r), Yj(this);
    }, e.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, e.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, e.type = "dataset", e.defaultOption = {
      seriesLayoutBy: ps
    }, e;
  }(Ut)
), yGe = (
  /** @class */
  function(n) {
    le(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.type = "dataset", e;
  }(Yn)
);
function bGe(n) {
  n.registerComponentModel(gGe), n.registerComponentView(yGe);
}
var Ho = Ts.CMD;
function dp(n, e) {
  return Math.abs(n - e) < 1e-5;
}
function SA(n) {
  var e = n.data, t = n.len(), r = [], i, a = 0, o = 0, s = 0, l = 0;
  function u(R, j) {
    i && i.length > 2 && r.push(i), i = [R, j];
  }
  function c(R, j, z, F) {
    dp(R, z) && dp(j, F) || i.push(R, j, z, F, z, F);
  }
  function d(R, j, z, F, B, H) {
    var Y = Math.abs(j - R), ne = Math.tan(Y / 4) * 4 / 3, J = j < R ? -1 : 1, X = Math.cos(R), ie = Math.sin(R), ye = Math.cos(j), pe = Math.sin(j), Be = X * B + z, Ce = ie * H + F, Ee = ye * B + z, ce = pe * H + F, Pe = B * ne * J, Ae = H * ne * J;
    i.push(Be - Pe * ie, Ce + Ae * X, Ee + Pe * pe, ce - Ae * ye, Ee, ce);
  }
  for (var f, p, h, v, m = 0; m < t; ) {
    var g = e[m++], y = m === 1;
    switch (y && (a = e[m], o = e[m + 1], s = a, l = o, (g === Ho.L || g === Ho.C || g === Ho.Q) && (i = [s, l])), g) {
      case Ho.M:
        a = s = e[m++], o = l = e[m++], u(s, l);
        break;
      case Ho.L:
        f = e[m++], p = e[m++], c(a, o, f, p), a = f, o = p;
        break;
      case Ho.C:
        i.push(e[m++], e[m++], e[m++], e[m++], a = e[m++], o = e[m++]);
        break;
      case Ho.Q:
        f = e[m++], p = e[m++], h = e[m++], v = e[m++], i.push(a + 2 / 3 * (f - a), o + 2 / 3 * (p - o), h + 2 / 3 * (f - h), v + 2 / 3 * (p - v), h, v), a = h, o = v;
        break;
      case Ho.A:
        var b = e[m++], _ = e[m++], x = e[m++], w = e[m++], S = e[m++], C = e[m++] + S;
        m += 1;
        var k = !e[m++];
        f = Math.cos(S) * x + b, p = Math.sin(S) * w + _, y ? (s = f, l = p, u(s, l)) : c(a, o, f, p), a = Math.cos(C) * x + b, o = Math.sin(C) * w + _;
        for (var M = (k ? -1 : 1) * Math.PI / 2, D = S; k ? D > C : D < C; D += M) {
          var N = k ? Math.max(D + M, C) : Math.min(D + M, C);
          d(D, N, b, _, x, w);
        }
        break;
      case Ho.R:
        s = a = e[m++], l = o = e[m++], f = s + e[m++], p = l + e[m++], u(f, l), c(f, l, f, p), c(f, p, s, p), c(s, p, s, l), c(s, l, f, l);
        break;
      case Ho.Z:
        i && c(a, o, s, l), a = s, o = l;
        break;
    }
  }
  return i && i.length > 2 && r.push(i), r;
}
function EA(n, e, t, r, i, a, o, s, l, u) {
  if (dp(n, t) && dp(e, r) && dp(i, o) && dp(a, s)) {
    l.push(o, s);
    return;
  }
  var c = 2 / u, d = c * c, f = o - n, p = s - e, h = Math.sqrt(f * f + p * p);
  f /= h, p /= h;
  var v = t - n, m = r - e, g = i - o, y = a - s, b = v * v + m * m, _ = g * g + y * y;
  if (b < d && _ < d) {
    l.push(o, s);
    return;
  }
  var x = f * v + p * m, w = -f * g - p * y, S = b - x * x, C = _ - w * w;
  if (S < d && x >= 0 && C < d && w >= 0) {
    l.push(o, s);
    return;
  }
  var k = [], M = [];
  Nu(n, t, i, o, 0.5, k), Nu(e, r, a, s, 0.5, M), EA(k[0], M[0], k[1], M[1], k[2], M[2], k[3], M[3], l, u), EA(k[4], M[4], k[5], M[5], k[6], M[6], k[7], M[7], l, u);
}
function _Ge(n, e) {
  var t = SA(n), r = [];
  e = e || 1;
  for (var i = 0; i < t.length; i++) {
    var a = t[i], o = [], s = a[0], l = a[1];
    o.push(s, l);
    for (var u = 2; u < a.length; ) {
      var c = a[u++], d = a[u++], f = a[u++], p = a[u++], h = a[u++], v = a[u++];
      EA(s, l, c, d, f, p, h, v, o, e), s = h, l = v;
    }
    r.push(o);
  }
  return r;
}
function SX(n, e, t) {
  var r = n[e], i = n[1 - e], a = Math.abs(r / i), o = Math.ceil(Math.sqrt(a * t)), s = Math.floor(t / o);
  s === 0 && (s = 1, o = t);
  for (var l = [], u = 0; u < o; u++)
    l.push(s);
  var c = o * s, d = t - c;
  if (d > 0)
    for (var u = 0; u < d; u++)
      l[u % o] += 1;
  return l;
}
function Xz(n, e, t) {
  for (var r = n.r0, i = n.r, a = n.startAngle, o = n.endAngle, s = Math.abs(o - a), l = s * i, u = i - r, c = l > Math.abs(u), d = SX([l, u], c ? 0 : 1, e), f = (c ? s : u) / d.length, p = 0; p < d.length; p++)
    for (var h = (c ? u : s) / d[p], v = 0; v < d[p]; v++) {
      var m = {};
      c ? (m.startAngle = a + f * p, m.endAngle = a + f * (p + 1), m.r0 = r + h * v, m.r = r + h * (v + 1)) : (m.startAngle = a + h * v, m.endAngle = a + h * (v + 1), m.r0 = r + f * p, m.r = r + f * (p + 1)), m.clockwise = n.clockwise, m.cx = n.cx, m.cy = n.cy, t.push(m);
    }
}
function xGe(n, e, t) {
  for (var r = n.width, i = n.height, a = r > i, o = SX([r, i], a ? 0 : 1, e), s = a ? "width" : "height", l = a ? "height" : "width", u = a ? "x" : "y", c = a ? "y" : "x", d = n[s] / o.length, f = 0; f < o.length; f++)
    for (var p = n[l] / o[f], h = 0; h < o[f]; h++) {
      var v = {};
      v[u] = f * d, v[c] = h * p, v[s] = d, v[l] = p, v.x += n.x, v.y += n.y, t.push(v);
    }
}
function Zz(n, e, t, r) {
  return n * r - t * e;
}
function wGe(n, e, t, r, i, a, o, s) {
  var l = t - n, u = r - e, c = o - i, d = s - a, f = Zz(c, d, l, u);
  if (Math.abs(f) < 1e-6)
    return null;
  var p = n - i, h = e - a, v = Zz(p, h, c, d) / f;
  return v < 0 || v > 1 ? null : new Mt(v * l + n, v * u + e);
}
function SGe(n, e, t) {
  var r = new Mt();
  Mt.sub(r, t, e), r.normalize();
  var i = new Mt();
  Mt.sub(i, n, e);
  var a = i.dot(r);
  return a;
}
function Ff(n, e) {
  var t = n[n.length - 1];
  t && t[0] === e[0] && t[1] === e[1] || n.push(e);
}
function EGe(n, e, t) {
  for (var r = n.length, i = [], a = 0; a < r; a++) {
    var o = n[a], s = n[(a + 1) % r], l = wGe(o[0], o[1], s[0], s[1], e.x, e.y, t.x, t.y);
    l && i.push({
      projPt: SGe(l, e, t),
      pt: l,
      idx: a
    });
  }
  if (i.length < 2)
    return [{ points: n }, { points: n }];
  i.sort(function(m, g) {
    return m.projPt - g.projPt;
  });
  var u = i[0], c = i[i.length - 1];
  if (c.idx < u.idx) {
    var d = u;
    u = c, c = d;
  }
  for (var f = [u.pt.x, u.pt.y], p = [c.pt.x, c.pt.y], h = [f], v = [p], a = u.idx + 1; a <= c.idx; a++)
    Ff(h, n[a].slice());
  Ff(h, p), Ff(h, f);
  for (var a = c.idx + 1; a <= u.idx + r; a++)
    Ff(v, n[a % r].slice());
  return Ff(v, f), Ff(v, p), [{
    points: h
  }, {
    points: v
  }];
}
function Jz(n) {
  var e = n.points, t = [], r = [];
  tw(e, t, r);
  var i = new Ot(t[0], t[1], r[0] - t[0], r[1] - t[1]), a = i.width, o = i.height, s = i.x, l = i.y, u = new Mt(), c = new Mt();
  return a > o ? (u.x = c.x = s + a / 2, u.y = l, c.y = l + o) : (u.y = c.y = l + o / 2, u.x = s, c.x = s + a), EGe(e, u, c);
}
function B_(n, e, t, r) {
  if (t === 1)
    r.push(e);
  else {
    var i = Math.floor(t / 2), a = n(e);
    B_(n, a[0], i, r), B_(n, a[1], t - i, r);
  }
  return r;
}
function TGe(n, e) {
  for (var t = [], r = 0; r < e; r++)
    t.push(VD(n));
  return t;
}
function CGe(n, e) {
  e.setStyle(n.style), e.z = n.z, e.z2 = n.z2, e.zlevel = n.zlevel;
}
function kGe(n) {
  for (var e = [], t = 0; t < n.length; )
    e.push([n[t++], n[t++]]);
  return e;
}
function AGe(n, e) {
  var t = [], r = n.shape, i;
  switch (n.type) {
    case "rect":
      xGe(r, e, t), i = Qt;
      break;
    case "sector":
      Xz(r, e, t), i = Fi;
      break;
    case "circle":
      Xz({
        r0: 0,
        r: r.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: r.cx,
        cy: r.cy
      }, e, t), i = Fi;
      break;
    default:
      var a = n.getComputedTransform(), o = a ? Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3])) : 1, s = De(_Ge(n.getUpdatedPathProxy(), o), function(g) {
        return kGe(g);
      }), l = s.length;
      if (l === 0)
        B_(Jz, {
          points: s[0]
        }, e, t);
      else if (l === e)
        for (var u = 0; u < l; u++)
          t.push({
            points: s[u]
          });
      else {
        var c = 0, d = De(s, function(g) {
          var y = [], b = [];
          tw(g, y, b);
          var _ = (b[1] - y[1]) * (b[0] - y[0]);
          return c += _, { poly: g, area: _ };
        });
        d.sort(function(g, y) {
          return y.area - g.area;
        });
        for (var f = e, u = 0; u < l; u++) {
          var p = d[u];
          if (f <= 0)
            break;
          var h = u === l - 1 ? f : Math.ceil(p.area / c * e);
          h < 0 || (B_(Jz, {
            points: p.poly
          }, h, t), f -= h);
        }
      }
      i = Vi;
      break;
  }
  if (!i)
    return TGe(n, e);
  for (var v = [], u = 0; u < t.length; u++) {
    var m = new i();
    m.setShape(t[u]), CGe(n, m), v.push(m);
  }
  return v;
}
function MGe(n, e) {
  var t = n.length, r = e.length;
  if (t === r)
    return [n, e];
  for (var i = [], a = [], o = t < r ? n : e, s = Math.min(t, r), l = Math.abs(r - t) / 6, u = (s - 2) / 6, c = Math.ceil(l / u) + 1, d = [o[0], o[1]], f = l, p = 2; p < s; ) {
    var h = o[p - 2], v = o[p - 1], m = o[p++], g = o[p++], y = o[p++], b = o[p++], _ = o[p++], x = o[p++];
    if (f <= 0) {
      d.push(m, g, y, b, _, x);
      continue;
    }
    for (var w = Math.min(f, c - 1) + 1, S = 1; S <= w; S++) {
      var C = S / w;
      Nu(h, m, y, _, C, i), Nu(v, g, b, x, C, a), h = i[3], v = a[3], d.push(i[1], a[1], i[2], a[2], h, v), m = i[5], g = a[5], y = i[6], b = a[6];
    }
    f -= w - 1;
  }
  return o === n ? [d, e] : [n, d];
}
function Qz(n, e) {
  for (var t = n.length, r = n[t - 2], i = n[t - 1], a = [], o = 0; o < e.length; )
    a[o++] = r, a[o++] = i;
  return a;
}
function DGe(n, e) {
  for (var t, r, i, a = [], o = [], s = 0; s < Math.max(n.length, e.length); s++) {
    var l = n[s], u = e[s], c = void 0, d = void 0;
    l ? u ? (t = MGe(l, u), c = t[0], d = t[1], r = c, i = d) : (d = Qz(i || l, l), c = l) : (c = Qz(r || u, u), d = u), a.push(c), o.push(d);
  }
  return [a, o];
}
function eF(n) {
  for (var e = 0, t = 0, r = 0, i = n.length, a = 0, o = i - 2; a < i; o = a, a += 2) {
    var s = n[o], l = n[o + 1], u = n[a], c = n[a + 1], d = s * c - u * l;
    e += d, t += (s + u) * d, r += (l + c) * d;
  }
  return e === 0 ? [n[0] || 0, n[1] || 0] : [t / e / 3, r / e / 3, e];
}
function OGe(n, e, t, r) {
  for (var i = (n.length - 2) / 6, a = 1 / 0, o = 0, s = n.length, l = s - 2, u = 0; u < i; u++) {
    for (var c = u * 6, d = 0, f = 0; f < s; f += 2) {
      var p = f === 0 ? c : (c + f - 2) % l + 2, h = n[p] - t[0], v = n[p + 1] - t[1], m = e[f] - r[0], g = e[f + 1] - r[1], y = m - h, b = g - v;
      d += y * y + b * b;
    }
    d < a && (a = d, o = u);
  }
  return o;
}
function IGe(n) {
  for (var e = [], t = n.length, r = 0; r < t; r += 2)
    e[r] = n[t - r - 2], e[r + 1] = n[t - r - 1];
  return e;
}
function LGe(n, e, t, r) {
  for (var i = [], a, o = 0; o < n.length; o++) {
    var s = n[o], l = e[o], u = eF(s), c = eF(l);
    a == null && (a = u[2] < 0 != c[2] < 0);
    var d = [], f = [], p = 0, h = 1 / 0, v = [], m = s.length;
    a && (s = IGe(s));
    for (var g = OGe(s, l, u, c) * 6, y = m - 2, b = 0; b < y; b += 2) {
      var _ = (g + b) % y + 2;
      d[b + 2] = s[_] - u[0], d[b + 3] = s[_ + 1] - u[1];
    }
    d[0] = s[g] - u[0], d[1] = s[g + 1] - u[1];
    for (var x = r / t, w = -r / 2; w <= r / 2; w += x) {
      for (var S = Math.sin(w), C = Math.cos(w), k = 0, b = 0; b < s.length; b += 2) {
        var M = d[b], D = d[b + 1], N = l[b] - c[0], R = l[b + 1] - c[1], j = N * C - R * S, z = N * S + R * C;
        v[b] = j, v[b + 1] = z;
        var F = j - M, B = z - D;
        k += F * F + B * B;
      }
      if (k < h) {
        h = k, p = w;
        for (var H = 0; H < v.length; H++)
          f[H] = v[H];
      }
    }
    i.push({
      from: d,
      to: f,
      fromCp: u,
      toCp: c,
      rotation: -p
    });
  }
  return i;
}
function $_(n) {
  return n.__isCombineMorphing;
}
var EX = "__mOriginal_";
function z_(n, e, t) {
  var r = EX + e, i = n[r] || n[e];
  n[r] || (n[r] = n[e]);
  var a = t.replace, o = t.after, s = t.before;
  n[e] = function() {
    var l = arguments, u;
    return s && s.apply(this, l), a ? u = a.apply(this, l) : u = i.apply(this, l), o && o.apply(this, l), u;
  };
}
function _m(n, e) {
  var t = EX + e;
  n[t] && (n[e] = n[t], n[t] = null);
}
function tF(n, e) {
  for (var t = 0; t < n.length; t++)
    for (var r = n[t], i = 0; i < r.length; ) {
      var a = r[i], o = r[i + 1];
      r[i++] = e[0] * a + e[2] * o + e[4], r[i++] = e[1] * a + e[3] * o + e[5];
    }
}
function TX(n, e) {
  var t = n.getUpdatedPathProxy(), r = e.getUpdatedPathProxy(), i = DGe(SA(t), SA(r)), a = i[0], o = i[1], s = n.getComputedTransform(), l = e.getComputedTransform();
  function u() {
    this.transform = null;
  }
  s && tF(a, s), l && tF(o, l), z_(e, "updateTransform", { replace: u }), e.transform = null;
  var c = LGe(a, o, 10, Math.PI), d = [];
  z_(e, "buildPath", { replace: function(f) {
    for (var p = e.__morphT, h = 1 - p, v = [], m = 0; m < c.length; m++) {
      var g = c[m], y = g.from, b = g.to, _ = g.rotation * p, x = g.fromCp, w = g.toCp, S = Math.sin(_), C = Math.cos(_);
      b1(v, x, w, p);
      for (var k = 0; k < y.length; k += 2) {
        var M = y[k], D = y[k + 1], N = b[k], R = b[k + 1], j = M * h + N * p, z = D * h + R * p;
        d[k] = j * C - z * S + v[0], d[k + 1] = j * S + z * C + v[1];
      }
      var F = d[0], B = d[1];
      f.moveTo(F, B);
      for (var k = 2; k < y.length; ) {
        var N = d[k++], R = d[k++], H = d[k++], Y = d[k++], ne = d[k++], J = d[k++];
        F === N && B === R && H === ne && Y === J ? f.lineTo(ne, J) : f.bezierCurveTo(N, R, H, Y, ne, J), F = ne, B = J;
      }
    }
  } });
}
function TI(n, e, t) {
  if (!n || !e)
    return e;
  var r = t.done, i = t.during;
  TX(n, e), e.__morphT = 0;
  function a() {
    _m(e, "buildPath"), _m(e, "updateTransform"), e.__morphT = -1, e.createPathProxy(), e.dirtyShape();
  }
  return e.animateTo({
    __morphT: 1
  }, dt({
    during: function(o) {
      e.dirtyShape(), i && i(o);
    },
    done: function() {
      a(), r && r();
    }
  }, t)), e;
}
function NGe(n, e, t, r, i, a) {
  var o = 16;
  n = i === t ? 0 : Math.round(32767 * (n - t) / (i - t)), e = a === r ? 0 : Math.round(32767 * (e - r) / (a - r));
  for (var s = 0, l, u = (1 << o) / 2; u > 0; u /= 2) {
    var c = 0, d = 0;
    (n & u) > 0 && (c = 1), (e & u) > 0 && (d = 1), s += u * u * (3 * c ^ d), d === 0 && (c === 1 && (n = u - 1 - n, e = u - 1 - e), l = n, n = e, e = l);
  }
  return s;
}
function F_(n) {
  var e = 1 / 0, t = 1 / 0, r = -1 / 0, i = -1 / 0, a = De(n, function(s) {
    var l = s.getBoundingRect(), u = s.getComputedTransform(), c = l.x + l.width / 2 + (u ? u[4] : 0), d = l.y + l.height / 2 + (u ? u[5] : 0);
    return e = Math.min(c, e), t = Math.min(d, t), r = Math.max(c, r), i = Math.max(d, i), [c, d];
  }), o = De(a, function(s, l) {
    return {
      cp: s,
      z: NGe(s[0], s[1], e, t, r, i),
      path: n[l]
    };
  });
  return o.sort(function(s, l) {
    return s.z - l.z;
  }).map(function(s) {
    return s.path;
  });
}
function CX(n) {
  return AGe(n.path, n.count);
}
function TA() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function RGe(n, e, t) {
  var r = [];
  function i(x) {
    for (var w = 0; w < x.length; w++) {
      var S = x[w];
      $_(S) ? i(S.childrenRef()) : S instanceof Ht && r.push(S);
    }
  }
  i(n);
  var a = r.length;
  if (!a)
    return TA();
  var o = t.dividePath || CX, s = o({
    path: e,
    count: a
  });
  if (s.length !== a)
    return console.error("Invalid morphing: unmatched splitted path"), TA();
  r = F_(r), s = F_(s);
  for (var l = t.done, u = t.during, c = t.individualDelay, d = new rl(), f = 0; f < a; f++) {
    var p = r[f], h = s[f];
    h.parent = e, h.copyTransform(d), c || TX(p, h);
  }
  e.__isCombineMorphing = !0, e.childrenRef = function() {
    return s;
  };
  function v(x) {
    for (var w = 0; w < s.length; w++)
      s[w].addSelfToZr(x);
  }
  z_(e, "addSelfToZr", {
    after: function(x) {
      v(x);
    }
  }), z_(e, "removeSelfFromZr", {
    after: function(x) {
      for (var w = 0; w < s.length; w++)
        s[w].removeSelfFromZr(x);
    }
  });
  function m() {
    e.__isCombineMorphing = !1, e.__morphT = -1, e.childrenRef = null, _m(e, "addSelfToZr"), _m(e, "removeSelfFromZr");
  }
  var g = s.length;
  if (c)
    for (var y = g, b = function() {
      y--, y === 0 && (m(), l && l());
    }, f = 0; f < g; f++) {
      var _ = c ? dt({
        delay: (t.delay || 0) + c(f, g, r[f], s[f]),
        done: b
      }, t) : t;
      TI(r[f], s[f], _);
    }
  else
    e.__morphT = 0, e.animateTo({
      __morphT: 1
    }, dt({
      during: function(x) {
        for (var w = 0; w < g; w++) {
          var S = s[w];
          S.__morphT = e.__morphT, S.dirtyShape();
        }
        u && u(x);
      },
      done: function() {
        m();
        for (var x = 0; x < n.length; x++)
          _m(n[x], "updateTransform");
        l && l();
      }
    }, t));
  return e.__zr && v(e.__zr), {
    fromIndividuals: r,
    toIndividuals: s,
    count: g
  };
}
function PGe(n, e, t) {
  var r = e.length, i = [], a = t.dividePath || CX;
  function o(p) {
    for (var h = 0; h < p.length; h++) {
      var v = p[h];
      $_(v) ? o(v.childrenRef()) : v instanceof Ht && i.push(v);
    }
  }
  if ($_(n)) {
    o(n.childrenRef());
    var s = i.length;
    if (s < r)
      for (var l = 0, u = s; u < r; u++)
        i.push(VD(i[l++ % s]));
    i.length = r;
  } else {
    i = a({ path: n, count: r });
    for (var c = n.getComputedTransform(), u = 0; u < i.length; u++)
      i[u].setLocalTransform(c);
    if (i.length !== r)
      return console.error("Invalid morphing: unmatched splitted path"), TA();
  }
  i = F_(i), e = F_(e);
  for (var d = t.individualDelay, u = 0; u < r; u++) {
    var f = d ? dt({
      delay: (t.delay || 0) + d(u, r, i[u], e[u])
    }, t) : t;
    TI(i[u], e[u], f);
  }
  return {
    fromIndividuals: i,
    toIndividuals: e,
    count: e.length
  };
}
function nF(n) {
  return Me(n[0]);
}
function rF(n, e) {
  for (var t = [], r = n.length, i = 0; i < r; i++)
    t.push({
      one: n[i],
      many: []
    });
  for (var i = 0; i < e.length; i++) {
    var a = e[i].length, o = void 0;
    for (o = 0; o < a; o++)
      t[o % r].many.push(e[i][o]);
  }
  for (var s = 0, i = r - 1; i >= 0; i--)
    if (!t[i].many.length) {
      var l = t[s].many;
      if (l.length <= 1)
        if (s)
          s = 0;
        else
          return t;
      var a = l.length, u = Math.ceil(a / 2);
      t[i].many = l.slice(u, a), t[s].many = l.slice(0, u), s++;
    }
  return t;
}
var jGe = {
  clone: function(n) {
    for (var e = [], t = 1 - Math.pow(1 - n.path.style.opacity, 1 / n.count), r = 0; r < n.count; r++) {
      var i = VD(n.path);
      i.setStyle("opacity", t), e.push(i);
    }
    return e;
  },
  // Use the default divider
  split: null
};
function fT(n, e, t, r, i, a) {
  if (!n.length || !e.length)
    return;
  var o = dh("update", r, i);
  if (!(o && o.duration > 0))
    return;
  var s = r.getModel("universalTransition").get("delay"), l = Object.assign({
    // Need to setToFinal so the further calculation based on the style can be correct.
    // Like emphasis color.
    setToFinal: !0
  }, o), u, c;
  nF(n) && (u = n, c = e), nF(e) && (u = e, c = n);
  function d(g, y, b, _, x) {
    var w = g.many, S = g.one;
    if (w.length === 1 && !x) {
      var C = y ? w[0] : S, k = y ? S : w[0];
      if ($_(C))
        d({
          many: [C],
          one: k
        }, !0, b, _, !0);
      else {
        var M = s ? dt({
          delay: s(b, _)
        }, l) : l;
        TI(C, k, M), a(C, k, C, k, M);
      }
    } else
      for (var D = dt({
        dividePath: jGe[t],
        individualDelay: s && function(B, H, Y, ne) {
          return s(B + b, _);
        }
      }, l), N = y ? RGe(w, S, D) : PGe(S, w, D), R = N.fromIndividuals, j = N.toIndividuals, z = R.length, F = 0; F < z; F++) {
        var M = s ? dt({
          delay: s(F, z)
        }, l) : l;
        a(R[F], j[F], y ? w[F] : g.one, y ? g.one : w[F], M);
      }
  }
  for (var f = u ? u === n : n.length > e.length, p = u ? rF(c, u) : rF(f ? e : n, [f ? n : e]), h = 0, v = 0; v < p.length; v++)
    h += p[v].many.length;
  for (var m = 0, v = 0; v < p.length; v++)
    d(p[v], f, m, h), m += p[v].many.length;
}
function Mc(n) {
  if (!n)
    return [];
  if (Me(n)) {
    for (var e = [], t = 0; t < n.length; t++)
      e.push(Mc(n[t]));
    return e;
  }
  var r = [];
  return n.traverse(function(i) {
    i instanceof Ht && !i.disableMorphing && !i.invisible && !i.ignore && r.push(i);
  }), r;
}
var kX = 1e4, BGe = 0, iF = 1, aF = 2, $Ge = en();
function zGe(n, e) {
  for (var t = n.dimensions, r = 0; r < t.length; r++) {
    var i = n.getDimensionInfo(t[r]);
    if (i && i.otherDims[e] === 0)
      return t[r];
  }
}
function FGe(n, e, t) {
  var r = n.getDimensionInfo(t), i = r && r.ordinalMeta;
  if (r) {
    var a = n.get(r.name, e);
    return i && i.categories[a] || a + "";
  }
}
function oF(n, e, t, r) {
  var i = r ? "itemChildGroupId" : "itemGroupId", a = zGe(n, i);
  if (a) {
    var o = FGe(n, e, a);
    return o;
  }
  var s = n.getRawDataItem(e), l = r ? "childGroupId" : "groupId";
  if (s && s[l])
    return s[l] + "";
  if (!r)
    return t || n.getId(e);
}
function sF(n) {
  var e = [];
  return $(n, function(t) {
    var r = t.data, i = t.dataGroupId;
    if (r.count() > kX) {
      process.env.NODE_ENV !== "production" && Jn("Universal transition is disabled on large data > 10k.");
      return;
    }
    for (var a = r.getIndices(), o = 0; o < a.length; o++)
      e.push({
        data: r,
        groupId: oF(r, o, i, !1),
        childGroupId: oF(r, o, i, !0),
        divide: t.divide,
        dataIndex: o
      });
  }), e;
}
function pT(n, e, t) {
  n.traverse(function(r) {
    r instanceof Ht && Gn(r, {
      style: {
        opacity: 0
      }
    }, e, {
      dataIndex: t,
      isFrom: !0
    });
  });
}
function hT(n) {
  if (n.parent) {
    var e = n.getComputedTransform();
    n.setLocalTransform(e), n.parent.remove(n);
  }
}
function Vf(n) {
  n.stopAnimation(), n.isGroup && n.traverse(function(e) {
    e.stopAnimation();
  });
}
function VGe(n, e, t) {
  var r = dh("update", t, e);
  r && n.traverse(function(i) {
    if (i instanceof no) {
      var a = LLe(i);
      a && i.animateFrom({
        style: a
      }, r);
    }
  });
}
function HGe(n, e) {
  var t = n.length;
  if (t !== e.length)
    return !1;
  for (var r = 0; r < t; r++) {
    var i = n[r], a = e[r];
    if (i.data.getId(i.dataIndex) !== a.data.getId(a.dataIndex))
      return !1;
  }
  return !0;
}
function AX(n, e, t) {
  var r = sF(n), i = sF(e);
  function a(b, _, x, w, S) {
    (x || b) && _.animateFrom({
      style: x && x !== b ? xe(xe({}, x.style), b.style) : b.style
    }, S);
  }
  var o = !1, s = BGe, l = tt(), u = tt();
  r.forEach(function(b) {
    b.groupId && l.set(b.groupId, !0), b.childGroupId && u.set(b.childGroupId, !0);
  });
  for (var c = 0; c < i.length; c++) {
    var d = i[c].groupId;
    if (u.get(d)) {
      s = iF;
      break;
    }
    var f = i[c].childGroupId;
    if (f && l.get(f)) {
      s = aF;
      break;
    }
  }
  function p(b, _) {
    return function(x) {
      var w = x.data, S = x.dataIndex;
      return _ ? w.getId(S) : b ? s === iF ? x.childGroupId : x.groupId : s === aF ? x.childGroupId : x.groupId;
    };
  }
  var h = HGe(r, i), v = {};
  if (!h)
    for (var c = 0; c < i.length; c++) {
      var m = i[c], g = m.data.getItemGraphicEl(m.dataIndex);
      g && (v[g.id] = !0);
    }
  function y(b, _) {
    var x = r[_], w = i[b], S = w.data.hostModel, C = x.data.getItemGraphicEl(x.dataIndex), k = w.data.getItemGraphicEl(w.dataIndex);
    if (C === k) {
      k && VGe(k, w.dataIndex, S);
      return;
    }
    // We can't use the elements that already being morphed
    C && v[C.id] || k && (Vf(k), C ? (Vf(C), hT(C), o = !0, fT(Mc(C), Mc(k), w.divide, S, b, a)) : pT(k, S, b));
  }
  new Sl(r, i, p(!0, h), p(!1, h), null, "multiple").update(y).updateManyToOne(function(b, _) {
    var x = i[b], w = x.data, S = w.hostModel, C = w.getItemGraphicEl(x.dataIndex), k = vn(De(_, function(M) {
      return r[M].data.getItemGraphicEl(r[M].dataIndex);
    }), function(M) {
      return M && M !== C && !v[M.id];
    });
    C && (Vf(C), k.length ? ($(k, function(M) {
      Vf(M), hT(M);
    }), o = !0, fT(Mc(k), Mc(C), x.divide, S, b, a)) : pT(C, S, x.dataIndex));
  }).updateOneToMany(function(b, _) {
    var x = r[_], w = x.data.getItemGraphicEl(x.dataIndex);
    if (!(w && v[w.id])) {
      var S = vn(De(b, function(k) {
        return i[k].data.getItemGraphicEl(i[k].dataIndex);
      }), function(k) {
        return k && k !== w;
      }), C = i[b[0]].data.hostModel;
      S.length && ($(S, function(k) {
        return Vf(k);
      }), w ? (Vf(w), hT(w), o = !0, fT(
        Mc(w),
        Mc(S),
        x.divide,
        // Use divide on old.
        C,
        b[0],
        a
      )) : $(S, function(k) {
        return pT(k, C, b[0]);
      }));
    }
  }).updateManyToMany(function(b, _) {
    new Sl(_, b, function(x) {
      return r[x].data.getId(r[x].dataIndex);
    }, function(x) {
      return i[x].data.getId(i[x].dataIndex);
    }).update(function(x, w) {
      y(b[x], _[w]);
    }).execute();
  }).execute(), o && $(e, function(b) {
    var _ = b.data, x = _.hostModel, w = x && t.getViewOfSeriesModel(x), S = dh("update", x, 0);
    w && x.isAnimationEnabled() && S && S.duration > 0 && w.group.traverse(function(C) {
      C instanceof Ht && !C.animators.length && C.animateFrom({
        style: {
          opacity: 0
        }
      }, S);
    });
  });
}
function lF(n) {
  var e = n.getModel("universalTransition").get("seriesKey");
  return e || n.id;
}
function uF(n) {
  return Me(n) ? n.sort().join(",") : n;
}
function tu(n) {
  if (n.hostModel)
    return n.hostModel.getModel("universalTransition").get("divideShape");
}
function GGe(n, e) {
  var t = tt(), r = tt(), i = tt();
  $(n.oldSeries, function(o, s) {
    var l = n.oldDataGroupIds[s], u = n.oldData[s], c = lF(o), d = uF(c);
    r.set(d, {
      dataGroupId: l,
      data: u
    }), Me(c) && $(c, function(f) {
      i.set(f, {
        key: d,
        dataGroupId: l,
        data: u
      });
    });
  });
  function a(o) {
    t.get(o) && Jn("Duplicated seriesKey in universalTransition " + o);
  }
  return $(e.updatedSeries, function(o) {
    if (o.isUniversalTransitionEnabled() && o.isAnimationEnabled()) {
      var s = o.get("dataGroupId"), l = o.getData(), u = lF(o), c = uF(u), d = r.get(c);
      if (d)
        process.env.NODE_ENV !== "production" && a(c), t.set(c, {
          oldSeries: [{
            dataGroupId: d.dataGroupId,
            divide: tu(d.data),
            data: d.data
          }],
          newSeries: [{
            dataGroupId: s,
            divide: tu(l),
            data: l
          }]
        });
      else if (Me(u)) {
        process.env.NODE_ENV !== "production" && a(c);
        var f = [];
        $(u, function(v) {
          var m = r.get(v);
          m.data && f.push({
            dataGroupId: m.dataGroupId,
            divide: tu(m.data),
            data: m.data
          });
        }), f.length && t.set(c, {
          oldSeries: f,
          newSeries: [{
            dataGroupId: s,
            data: l,
            divide: tu(l)
          }]
        });
      } else {
        var p = i.get(u);
        if (p) {
          var h = t.get(p.key);
          h || (h = {
            oldSeries: [{
              dataGroupId: p.dataGroupId,
              data: p.data,
              divide: tu(p.data)
            }],
            newSeries: []
          }, t.set(p.key, h)), h.newSeries.push({
            dataGroupId: s,
            data: l,
            divide: tu(l)
          });
        }
      }
    }
  }), t;
}
function cF(n, e) {
  for (var t = 0; t < n.length; t++) {
    var r = e.seriesIndex != null && e.seriesIndex === n[t].seriesIndex || e.seriesId != null && e.seriesId === n[t].id;
    if (r)
      return t;
  }
}
function UGe(n, e, t, r) {
  var i = [], a = [];
  $(wn(n.from), function(o) {
    var s = cF(e.oldSeries, o);
    s >= 0 && i.push({
      dataGroupId: e.oldDataGroupIds[s],
      data: e.oldData[s],
      // TODO can specify divideShape in transition.
      divide: tu(e.oldData[s]),
      groupIdDim: o.dimension
    });
  }), $(wn(n.to), function(o) {
    var s = cF(t.updatedSeries, o);
    if (s >= 0) {
      var l = t.updatedSeries[s].getData();
      a.push({
        dataGroupId: e.oldDataGroupIds[s],
        data: l,
        divide: tu(l),
        groupIdDim: o.dimension
      });
    }
  }), i.length > 0 && a.length > 0 && AX(i, a, r);
}
function WGe(n) {
  n.registerUpdateLifecycle("series:beforeupdate", function(e, t, r) {
    $(wn(r.seriesTransition), function(i) {
      $(wn(i.to), function(a) {
        for (var o = r.updatedSeries, s = 0; s < o.length; s++)
          (a.seriesIndex != null && a.seriesIndex === o[s].seriesIndex || a.seriesId != null && a.seriesId === o[s].id) && (o[s][M1] = !0);
      });
    });
  }), n.registerUpdateLifecycle("series:transition", function(e, t, r) {
    var i = $Ge(t);
    if (i.oldSeries && r.updatedSeries && r.optionChanged) {
      var a = r.seriesTransition;
      if (a)
        $(wn(a), function(p) {
          UGe(p, i, r, t);
        });
      else {
        var o = GGe(i, r);
        $(o.keys(), function(p) {
          var h = o.get(p);
          AX(h.oldSeries, h.newSeries, t);
        });
      }
      $(r.updatedSeries, function(p) {
        p[M1] && (p[M1] = !1);
      });
    }
    for (var s = e.getSeries(), l = i.oldSeries = [], u = i.oldDataGroupIds = [], c = i.oldData = [], d = 0; d < s.length; d++) {
      var f = s[d].getData();
      f.count() < kX && (l.push(s[d]), u.push(s[d].get("dataGroupId")), c.push(f));
    }
  });
}
$t([r5e]);
$t([Jje]);
$t([S5e, B5e, Y5e, kBe, BBe, E4e, J4e, R$e, rze, uze, yze, fFe, jFe, YFe, cVe, hVe, EVe, OVe, VVe, YVe, i6e, z6e]);
$t(a8e);
$t(O8e);
$t(TY);
$t(G8e);
$t(cK);
$t(Y8e);
$t(rHe);
$t(GHe);
$t(u7e);
$t(ay);
$t(C7e);
$t(M7e);
$t($7e);
$t(W7e);
$t(J7e);
$t(i9e);
$t(h9e);
$t(I9e);
$t(hX);
$t(vX);
$t(J9e);
$t(_X);
$t(xX);
$t(rGe);
$t(mGe);
$t(bGe);
$t(WGe);
$t(yje);
const CI = /* @__PURE__ */ ve({
  __name: "ECharts",
  props: {
    options: {},
    events: {},
    error: {}
  },
  setup(n) {
    const e = n;
    let t;
    const r = Z();
    return kt(() => {
      var o;
      if (!r.value) return;
      t = zPe(r.value, "light", { renderer: "svg" }), t.setOption({ ...e.options }, !0), (o = e.events) != null && o.click && t.on("click", e.events.click);
      const i = cx(() => {
        t.resize({
          animation: {
            duration: 300
          }
        });
      }, 250);
      let a = new ResizeObserver(i);
      setTimeout(() => a.observe(r.value), 500), Io(() => a.unobserve(r.value));
    }), et(
      () => e.options,
      (i) => {
        t && t.setOption(i, !0);
      },
      { deep: !0 }
    ), (i, a) => (L(), W(Ke, null, [
      ta(G("div", {
        ref_key: "chartDiv",
        ref: r,
        class: "h-full w-full min-w-[300px] md:min-w-[400px] min-h-[300px] px-4 py-2"
      }, null, 512), [
        [hs, !i.error]
      ]),
      ta(G("div", { class: "flex h-full w-full items-center justify-center text-center text-ink-red-3" }, " Error: " + ke(i.error), 513), [
        [hs, i.error]
      ])
    ], 64));
  }
}), KUe = /* @__PURE__ */ ve({
  __name: "AxisChart",
  props: {
    config: {}
  },
  setup(n) {
    const e = n, t = Z(""), r = K(() => {
      try {
        return WMe(e.config);
      } catch (i) {
        return t.value = i.message, {};
      }
    });
    return (i, a) => (L(), re(CI, {
      options: r.value,
      error: t.value
    }, null, 8, ["options", "error"]));
  }
}), qGe = { class: "flex w-full flex-col" }, YGe = { class: "truncate text-sm font-medium text-ink-gray-5" }, KGe = { class: "flex-1 flex-shrink-0 truncate text-[24px] text-ink-gray-6 font-semibold leading-10" }, XGe = { class: "" }, XUe = /* @__PURE__ */ ve({
  __name: "NumberChart",
  props: {
    config: {}
  },
  setup(n) {
    return (e, t) => (L(), W("div", {
      class: _e(["flex max-h-[140px] items-center gap-2 overflow-hidden bg-surface-white text-ink-gray-8 px-6 pt-5", e.config.delta ? "pb-6" : "pb-3"])
    }, [
      ue(e.$slots, "body", {}, () => [
        G("div", qGe, [
          ue(e.$slots, "title", {}, () => [
            G("span", YGe, ke(e.config.title), 1)
          ]),
          ue(e.$slots, "subtitle", Bt(Jt({ formatValue: O(Xi) })), () => [
            G("div", KGe, ke(e.config.prefix) + ke(O(Xi)(e.config.value, 1, !0)) + ke(e.config.suffix), 1)
          ]),
          ue(e.$slots, "delta", Bt(Jt({ formatValue: O(Xi) })), () => [
            e.config.delta ? (L(), W("div", {
              key: 0,
              class: _e(["flex items-center gap-0.5 text-xs font-medium", [
                e.config.negativeIsBetter ? e.config.delta >= 0 ? "text-ink-red-4" : "text-ink-green-3" : e.config.delta >= 0 ? "text-ink-green-3" : "text-ink-red-4"
              ]])
            }, [
              G("span", XGe, ke(e.config.delta >= 0 ? "↑" : "↓"), 1),
              G("span", null, ke(e.config.deltaPrefix) + ke(O(Xi)(e.config.delta, 1, !0)) + ke(e.config.deltaSuffix), 1)
            ], 2)) : ge("", !0)
          ])
        ])
      ])
    ], 2));
  }
});
function ZGe(n) {
  let e = n.data || [];
  e = e.sort((d, f) => {
    const p = d[n.valueColumn], h = f[n.valueColumn];
    return p === h ? 0 : p > h ? -1 : 1;
  });
  const t = e.map((d) => d[n.categoryColumn]), r = e.map((d) => d[n.valueColumn]), i = r.reduce((d, f) => isNaN(f) ? d : d + f, 0);
  let a = ["40%", "70%"], o = ["50%", "48%"];
  n.subtitle && (a = ["40%", "70%"], o = ["50%", "50%"]), n.showInlineLabels && (o = ["50%", "50%"]);
  let s = "horizontal", l = 0, u = "center", c = [0, 10, 10, 10];
  return {
    animation: !0,
    animationDuration: 700,
    color: n.colors,
    textStyle: { fontFamily: ["InterVar", "sans-serif"] },
    title: yD(n.title, n.subtitle),
    dataset: {
      source: [
        [n.categoryColumn, n.valueColumn],
        ...e.map((d) => [d[n.categoryColumn], d[n.valueColumn]])
      ]
    },
    series: [
      {
        type: "pie",
        name: n.categoryColumn,
        center: o,
        radius: a,
        labelLine: {
          show: n.showInlineLabels,
          lineStyle: {
            width: 2
          },
          length: 10,
          length2: 20,
          smooth: !0
        },
        label: {
          show: n.showInlineLabels,
          formatter: ({ value: d, name: f }) => {
            const p = i > 0 ? d[1] / i * 100 : 0;
            return `${f} (${p.toFixed(0)}%)`;
          }
        },
        emphasis: { scaleSize: 5 }
      }
    ],
    legend: n.showInlineLabels ? null : {
      // top,
      left: u,
      bottom: l,
      padding: c,
      orient: s,
      show: !0,
      type: "scroll",
      itemGap: 12,
      formatter: function(d) {
        const f = t.indexOf(d), p = i > 0 ? r[f] / i * 100 : 0;
        return `${d} (${p.toFixed(0)}%)`;
      },
      textStyle: {
        padding: [0, 0, 0, -5],
        color: "var(--ink-gray-8)"
      },
      icon: "circle",
      pageIcons: {
        horizontal: [
          "M 17 3 h 2 c 0.386 0 0.738 0.223 0.904 0.572 s 0.115 0.762 -0.13 1.062 L 11.292 15 l 8.482 10.367 c 0.245 0.299 0.295 0.712 0.13 1.062 S 19.386 27 19 27 h -2 c -0.3 0 -0.584 -0.135 -0.774 -0.367 l -9 -11 c -0.301 -0.369 -0.301 -0.898 0 -1.267 l 9 -11 C 16.416 3.135 16.7 3 17 3 Z",
          "M 12 27 h -2 c -0.386 0 -0.738 -0.223 -0.904 -0.572 s -0.115 -0.762 0.13 -1.062 L 17.708 15 L 9.226 4.633 c -0.245 -0.299 -0.295 -0.712 -0.13 -1.062 S 9.614 3 10 3 h 2 c 0.3 0 0.584 0.135 0.774 0.367 l 9 11 c 0.301 0.369 0.301 0.898 0 1.267 l -9 11 C 12.584 26.865 12.3 27 12 27 Z"
        ]
      },
      pageIconColor: "var(--ink-gray-6)",
      pageInactiveColor: "var(--ink-gray-4)",
      pageIconSize: 10,
      pageTextStyle: {
        color: "var(--ink-gray-6)"
      },
      animationDurationUpdate: 300
    },
    tooltip: {
      trigger: "item",
      confine: !0,
      appendToBody: !1,
      formatter: function(d) {
        const f = d, p = f.value[1], h = i > 0 ? p / i * 100 : 0, v = isNaN(p) ? p : Xi(p, 1, !0), m = h.toFixed(0);
        return `
          <div class="flex items-center justify-between gap-5">
            <div>${f.name}</div>
            <div class="font-bold">
              ${v} (${m}%)
            </div>
          </div>
        `;
      }
    }
  };
}
const ZUe = /* @__PURE__ */ ve({
  __name: "DonutChart",
  props: {
    config: {}
  },
  setup(n) {
    const e = n, t = Z(""), r = K(() => {
      try {
        return ZGe(e.config);
      } catch (i) {
        return t.value = i.message, {};
      }
    });
    return (i, a) => (L(), re(CI, {
      options: r.value,
      error: t.value
    }, null, 8, ["options", "error"]));
  }
});
function JGe(n) {
  let e = n.data || [];
  const t = n.subtitle ? 1 : 0, r = e.map((l) => l[n.categoryColumn]), i = e.map((l) => l[n.valueColumn]), a = i[0], s = [
    "#2d87d6",
    "#4393da",
    "#589fdf",
    "#6dace3",
    "#83b8e7",
    "#98c4eb",
    "#c3dcf3",
    "#d8e9f7",
    "#edf5fc",
    "#ffffff"
  ];
  return {
    animation: !0,
    animationDuration: 700,
    color: s,
    textStyle: { fontFamily: ["InterVar", "sans-serif"] },
    title: yD(n.title, n.subtitle),
    series: [
      {
        name: "Funnel",
        type: "funnel",
        orient: "vertical",
        funnelAlign: "center",
        top: U9 + W9 + q9 * t + Y9,
        left: "center",
        width: "60%",
        height: "75%",
        minSize: "10px",
        maxSize: "100%",
        sort: "descending",
        label: {
          show: !0,
          position: "inside",
          lineHeight: 16,
          formatter: (l) => {
            const u = r.indexOf(l.name), c = Xi(i[u], 1, !0);
            if (!n.showPercentages)
              return c;
            const d = Number(i[u] / a * 100).toFixed(0);
            return `${c} (${d}%)`;
          }
        },
        labelLine: { show: !1 },
        gap: 6,
        data: i.map((l, u) => ({
          name: r[u],
          value: l,
          itemStyle: {
            color: s[u],
            borderColor: s[u],
            borderWidth: 4,
            borderCap: "round",
            borderJoin: "round"
          },
          emphasis: {
            itemStyle: {
              color: s[u],
              borderColor: s[u],
              borderWidth: 6,
              borderCap: "round",
              borderJoin: "round"
            }
          }
        }))
      }
    ],
    tooltip: {
      trigger: "item",
      confine: !0,
      appendToBody: !1,
      formatter: function(l) {
        const u = l, c = u.value, d = a > 0 ? c / a * 100 : 0, f = isNaN(c) ? c : Xi(c, 1, !0), p = d.toFixed(0);
        return `
          <div class="flex items-center justify-between gap-5">
            <div>${u.name}</div>
            <div class="font-bold">
              ${f} (${p}%)
            </div>
          </div>
        `;
      }
    }
  };
}
const JUe = /* @__PURE__ */ ve({
  __name: "FunnelChart",
  props: {
    config: {}
  },
  setup(n) {
    const e = n, t = Z(""), r = K(() => {
      try {
        return JGe(e.config);
      } catch (i) {
        return t.value = i.message, {};
      }
    });
    return (i, a) => (L(), re(CI, {
      options: r.value,
      error: t.value
    }, null, 8, ["options", "error"]));
  }
}), CA = /* @__PURE__ */ new Map();
function QGe(n, e, t) {
  const r = n.target;
  e !== r && !e.contains(r) && (t == null || t(n));
}
const QUe = {
  beforeMount(n, e, t) {
    const r = e.value, i = function(a) {
      QGe(a, n, r);
    };
    dF(n), CA.set(n, i), document.addEventListener("click", i);
  },
  unmounted(n) {
    dF(n);
  }
};
function dF(n) {
  const e = CA.get(n);
  e && (CA.delete(n), document.removeEventListener("click", e));
}
const eWe = {
  beforeMount(n, e, t) {
    const r = e.value;
    if (!r) return;
    const i = new IntersectionObserver(
      (a) => {
        const o = a[0], s = o.isIntersecting && o.intersectionRatio > 0;
        r(s, o);
      }
    );
    Wt(() => {
      i.observe(n);
    }), n._visibility_observer = i;
  },
  unmounted(n) {
    n._visibility_observer && (n._visibility_observer.disconnect(), delete n._visibility_observer);
  }
}, eUe = (n) => new Promise((e, t) => {
  const r = new FileReader();
  r.onloadend = () => {
    r.result == null ? t(new Error("FileReader result is null")) : typeof r.result == "string" && e(r.result);
  }, r.readAsDataURL(n);
});
function tWe(n) {
  let e = Object.assign({}, n);
  if (!e.url)
    throw new Error("[request] options.url is required");
  e.transformRequest && (e = e.transformRequest(n)), e.responseType || (e.responseType = "json"), e.method || (e.method = "GET");
  let t = e.url, r;
  if (e.params)
    if (e.method === "GET") {
      let i = new URLSearchParams();
      for (let a in e.params)
        i.append(a, e.params[a]);
      t = e.url + "?" + i.toString();
    } else
      r = JSON.stringify(e.params);
  return fetch(t, {
    method: e.method || "GET",
    headers: e.headers,
    body: r
  }).then((i) => {
    if (e.transformResponse)
      return e.transformResponse(i, e);
    if (i.status >= 200 && i.status < 300)
      return e.responseType === "json" ? i.json() : i;
    {
      let a = new Error(i.statusText);
      throw a.response = i, a;
    }
  }).catch((i) => {
    if (e.transformError)
      return e.transformError(i);
    throw i;
  });
}
export {
  rUe as $,
  zUe as A,
  bCe as B,
  pUe as C,
  mUe as D,
  Lc as E,
  FUe as F,
  xUe as G,
  VUe as H,
  wUe as I,
  HUe as J,
  GUe as K,
  SUe as L,
  Wle as M,
  qUe as N,
  YUe as O,
  KUe as P,
  XUe as Q,
  ZUe as R,
  JUe as S,
  CI as T,
  QUe as U,
  eWe as V,
  cx as W,
  eUe as X,
  tWe as Y,
  yUe as Z,
  zt as _,
  Ei as a,
  hae as a0,
  cUe as a1,
  dUe as a2,
  fUe as a3,
  fn as a4,
  hUe as a5,
  ux as a6,
  hx as a7,
  _Ue as a8,
  KV as a9,
  f6 as aa,
  Fs as ab,
  TUe as ac,
  CUe as ad,
  oM as ae,
  AUe as af,
  MUe as ag,
  DUe as ah,
  p6 as ai,
  Ga as aj,
  Wse as ak,
  BUe as al,
  r2e as am,
  e2e as an,
  l2e as ao,
  Nve as ap,
  UUe as aq,
  WUe as ar,
  th as b,
  pTe as c,
  vUe as d,
  gUe as e,
  bUe as f,
  En as g,
  Yse as h,
  EUe as i,
  nh as j,
  XV as k,
  kUe as l,
  OUe as m,
  tue as n,
  nue as o,
  $Ue as p,
  ITe as q,
  OTe as r,
  MTe as s,
  PTe as t,
  d9 as u,
  NTe as v,
  YTe as w,
  GTe as x,
  WTe as y,
  eCe as z
};
